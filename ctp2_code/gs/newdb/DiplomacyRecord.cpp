
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "DiplomacyRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "DiplomacyProposalRecord.h"

CTPDatabase<DiplomacyRecord> *g_theDiplomacyDB = NULL;

void DiplomacyRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    memset(m_Inherit, 0, sizeof(m_Inherit));
    m_numInherit = 0;
    memset(&m_ScenarioEventValue, 0, sizeof(m_ScenarioEventValue));
    memset(&m_MilitaryPowerEventValue, 0, sizeof(m_MilitaryPowerEventValue));
    memset(&m_MilitarySafetyEventValue, 0, sizeof(m_MilitarySafetyEventValue));
    memset(&m_DiplomacyEventValue, 0, sizeof(m_DiplomacyEventValue));
    memset(&m_GoldEventValue, 0, sizeof(m_GoldEventValue));
    memset(&m_KnowledgeEventValue, 0, sizeof(m_KnowledgeEventValue));
    memset(&m_ProductionEventValue, 0, sizeof(m_ProductionEventValue));
    m_ThreatenValue = 0;
    m_IncursionRegardCostValue = 0;
    m_IncursionOfAllieRegardCostValue = 0;
    m_InvaderMovementRegardCostValue = 0;
    m_PerRoutePiracyRegardCostValue = 0;
    m_ShareContinentRegardCostValue = 0;
    m_AttackCivilianRegardCostValue = 0;
    m_PreemptiveAttackRegardCostValue = 0;
    m_EmbargoTradeRegardCostValue = 0;
    m_TakeCityRegardCostValue = 0;
    m_InciteRevolutionRegardCostValue = 0;
    m_AssassinateRulerRegardCostValue = 0;
    m_FranchiseCityRegardCostValue = 0;
    m_PlantNukeRegardCostValue = 0;
    m_SlaveRaidRegardCostValue = 0;
    m_LawsuitRegardCostValue = 0;
    m_ExpelUnitsRegardCostValue = 0;
    m_NukeCityRegardCostValue = 0;
    m_ConvertCityRegardCostValue = 0;
    m_EnslaveSettlerRegardCostValue = 0;
    m_UndergroundRailwayRegardCostValue = 0;
    m_InciteUprisingRegardCostValue = 0;
    m_BioInfectedCityRegardCostValue = 0;
    m_PlagueCityRegardCostValue = 0;
    m_NanoInfectCityRegardCostValue = 0;
    m_CreateParkRegardCostValue = 0;
    m_InjoinCityRegardCostValue = 0;
    m_PillageRegardCostValue = 0;
    m_HoldReceptionRegardBonusValue = 0;
    m_HasPactTrustBonusValue = 0;
    m_NoWarTrustBonusValue = 0;
    m_AttackCivilianTrustCostValue = 0;
    m_PreemptiveAttackTrustCostValue = 0;
    m_FollowThroughTrustBonusValue = 0;
    m_UsedNukesTrustCostValue = 0;
    m_WantMapTurnsValue = 0;
    m_ProposalElement = NULL;
    m_numProposalElement = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void DiplomacyRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_flags1;
        archive << m_numInherit;
        archive.Store((uint8*)&m_Inherit, sizeof(m_Inherit));
        m_ScenarioEventValue.Serialize(archive);
        m_MilitaryPowerEventValue.Serialize(archive);
        m_MilitarySafetyEventValue.Serialize(archive);
        m_DiplomacyEventValue.Serialize(archive);
        m_GoldEventValue.Serialize(archive);
        m_KnowledgeEventValue.Serialize(archive);
        m_ProductionEventValue.Serialize(archive);
        archive << m_ThreatenValue;
        archive << m_IncursionRegardCostValue;
        archive << m_IncursionOfAllieRegardCostValue;
        archive << m_InvaderMovementRegardCostValue;
        archive << m_PerRoutePiracyRegardCostValue;
        archive << m_ShareContinentRegardCostValue;
        archive << m_AttackCivilianRegardCostValue;
        archive << m_PreemptiveAttackRegardCostValue;
        archive << m_EmbargoTradeRegardCostValue;
        archive << m_TakeCityRegardCostValue;
        archive << m_InciteRevolutionRegardCostValue;
        archive << m_AssassinateRulerRegardCostValue;
        archive << m_FranchiseCityRegardCostValue;
        archive << m_PlantNukeRegardCostValue;
        archive << m_SlaveRaidRegardCostValue;
        archive << m_LawsuitRegardCostValue;
        archive << m_ExpelUnitsRegardCostValue;
        archive << m_NukeCityRegardCostValue;
        archive << m_ConvertCityRegardCostValue;
        archive << m_EnslaveSettlerRegardCostValue;
        archive << m_UndergroundRailwayRegardCostValue;
        archive << m_InciteUprisingRegardCostValue;
        archive << m_BioInfectedCityRegardCostValue;
        archive << m_PlagueCityRegardCostValue;
        archive << m_NanoInfectCityRegardCostValue;
        archive << m_CreateParkRegardCostValue;
        archive << m_InjoinCityRegardCostValue;
        archive << m_PillageRegardCostValue;
        archive << m_HoldReceptionRegardBonusValue;
        archive << m_HasPactTrustBonusValue;
        archive << m_NoWarTrustBonusValue;
        archive << m_AttackCivilianTrustCostValue;
        archive << m_PreemptiveAttackTrustCostValue;
        archive << m_FollowThroughTrustBonusValue;
        archive << m_UsedNukesTrustCostValue;
        archive << m_WantMapTurnsValue;

        {
            archive << m_numProposalElement;
            for(sint32 i = 0; i < m_numProposalElement; ++i){
                m_ProposalElement[i].Serialize(archive);
            }
        }

    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_numInherit;
        archive.Load((uint8*)&m_Inherit, sizeof(m_Inherit));
        memset((uint8*)&m_ScenarioEventValue, 0, sizeof(m_ScenarioEventValue));
        m_ScenarioEventValue.Serialize(archive);
        memset((uint8*)&m_MilitaryPowerEventValue, 0, sizeof(m_MilitaryPowerEventValue));
        m_MilitaryPowerEventValue.Serialize(archive);
        memset((uint8*)&m_MilitarySafetyEventValue, 0, sizeof(m_MilitarySafetyEventValue));
        m_MilitarySafetyEventValue.Serialize(archive);
        memset((uint8*)&m_DiplomacyEventValue, 0, sizeof(m_DiplomacyEventValue));
        m_DiplomacyEventValue.Serialize(archive);
        memset((uint8*)&m_GoldEventValue, 0, sizeof(m_GoldEventValue));
        m_GoldEventValue.Serialize(archive);
        memset((uint8*)&m_KnowledgeEventValue, 0, sizeof(m_KnowledgeEventValue));
        m_KnowledgeEventValue.Serialize(archive);
        memset((uint8*)&m_ProductionEventValue, 0, sizeof(m_ProductionEventValue));
        m_ProductionEventValue.Serialize(archive);
        archive >> m_ThreatenValue;
        archive >> m_IncursionRegardCostValue;
        archive >> m_IncursionOfAllieRegardCostValue;
        archive >> m_InvaderMovementRegardCostValue;
        archive >> m_PerRoutePiracyRegardCostValue;
        archive >> m_ShareContinentRegardCostValue;
        archive >> m_AttackCivilianRegardCostValue;
        archive >> m_PreemptiveAttackRegardCostValue;
        archive >> m_EmbargoTradeRegardCostValue;
        archive >> m_TakeCityRegardCostValue;
        archive >> m_InciteRevolutionRegardCostValue;
        archive >> m_AssassinateRulerRegardCostValue;
        archive >> m_FranchiseCityRegardCostValue;
        archive >> m_PlantNukeRegardCostValue;
        archive >> m_SlaveRaidRegardCostValue;
        archive >> m_LawsuitRegardCostValue;
        archive >> m_ExpelUnitsRegardCostValue;
        archive >> m_NukeCityRegardCostValue;
        archive >> m_ConvertCityRegardCostValue;
        archive >> m_EnslaveSettlerRegardCostValue;
        archive >> m_UndergroundRailwayRegardCostValue;
        archive >> m_InciteUprisingRegardCostValue;
        archive >> m_BioInfectedCityRegardCostValue;
        archive >> m_PlagueCityRegardCostValue;
        archive >> m_NanoInfectCityRegardCostValue;
        archive >> m_CreateParkRegardCostValue;
        archive >> m_InjoinCityRegardCostValue;
        archive >> m_PillageRegardCostValue;
        archive >> m_HoldReceptionRegardBonusValue;
        archive >> m_HasPactTrustBonusValue;
        archive >> m_NoWarTrustBonusValue;
        archive >> m_AttackCivilianTrustCostValue;
        archive >> m_PreemptiveAttackTrustCostValue;
        archive >> m_FollowThroughTrustBonusValue;
        archive >> m_UsedNukesTrustCostValue;
        archive >> m_WantMapTurnsValue;

        {
            archive >> m_numProposalElement;
            m_ProposalElement = new ProposalElement[m_numProposalElement];
            for(sint32 i = 0; i < m_numProposalElement; ++i){
                m_ProposalElement[i].Serialize(archive);
            }
        }

    }
}

DiplomacyRecord::~DiplomacyRecord()
{
    delete [] m_ProposalElement;
}

DiplomacyRecord const & DiplomacyRecord::operator = (DiplomacyRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        std::copy(rval.m_Inherit, rval.m_Inherit + rval.m_numInherit, m_Inherit);

        m_ScenarioEventValue = rval.m_ScenarioEventValue;

        m_MilitaryPowerEventValue = rval.m_MilitaryPowerEventValue;

        m_MilitarySafetyEventValue = rval.m_MilitarySafetyEventValue;

        m_DiplomacyEventValue = rval.m_DiplomacyEventValue;

        m_GoldEventValue = rval.m_GoldEventValue;

        m_KnowledgeEventValue = rval.m_KnowledgeEventValue;

        m_ProductionEventValue = rval.m_ProductionEventValue;

        m_ThreatenValue = rval.m_ThreatenValue;

        m_IncursionRegardCostValue = rval.m_IncursionRegardCostValue;

        m_IncursionOfAllieRegardCostValue = rval.m_IncursionOfAllieRegardCostValue;

        m_InvaderMovementRegardCostValue = rval.m_InvaderMovementRegardCostValue;

        m_PerRoutePiracyRegardCostValue = rval.m_PerRoutePiracyRegardCostValue;

        m_ShareContinentRegardCostValue = rval.m_ShareContinentRegardCostValue;

        m_AttackCivilianRegardCostValue = rval.m_AttackCivilianRegardCostValue;

        m_PreemptiveAttackRegardCostValue = rval.m_PreemptiveAttackRegardCostValue;

        m_EmbargoTradeRegardCostValue = rval.m_EmbargoTradeRegardCostValue;

        m_TakeCityRegardCostValue = rval.m_TakeCityRegardCostValue;

        m_InciteRevolutionRegardCostValue = rval.m_InciteRevolutionRegardCostValue;

        m_AssassinateRulerRegardCostValue = rval.m_AssassinateRulerRegardCostValue;

        m_FranchiseCityRegardCostValue = rval.m_FranchiseCityRegardCostValue;

        m_PlantNukeRegardCostValue = rval.m_PlantNukeRegardCostValue;

        m_SlaveRaidRegardCostValue = rval.m_SlaveRaidRegardCostValue;

        m_LawsuitRegardCostValue = rval.m_LawsuitRegardCostValue;

        m_ExpelUnitsRegardCostValue = rval.m_ExpelUnitsRegardCostValue;

        m_NukeCityRegardCostValue = rval.m_NukeCityRegardCostValue;

        m_ConvertCityRegardCostValue = rval.m_ConvertCityRegardCostValue;

        m_EnslaveSettlerRegardCostValue = rval.m_EnslaveSettlerRegardCostValue;

        m_UndergroundRailwayRegardCostValue = rval.m_UndergroundRailwayRegardCostValue;

        m_InciteUprisingRegardCostValue = rval.m_InciteUprisingRegardCostValue;

        m_BioInfectedCityRegardCostValue = rval.m_BioInfectedCityRegardCostValue;

        m_PlagueCityRegardCostValue = rval.m_PlagueCityRegardCostValue;

        m_NanoInfectCityRegardCostValue = rval.m_NanoInfectCityRegardCostValue;

        m_CreateParkRegardCostValue = rval.m_CreateParkRegardCostValue;

        m_InjoinCityRegardCostValue = rval.m_InjoinCityRegardCostValue;

        m_PillageRegardCostValue = rval.m_PillageRegardCostValue;

        m_HoldReceptionRegardBonusValue = rval.m_HoldReceptionRegardBonusValue;

        m_HasPactTrustBonusValue = rval.m_HasPactTrustBonusValue;

        m_NoWarTrustBonusValue = rval.m_NoWarTrustBonusValue;

        m_AttackCivilianTrustCostValue = rval.m_AttackCivilianTrustCostValue;

        m_PreemptiveAttackTrustCostValue = rval.m_PreemptiveAttackTrustCostValue;

        m_FollowThroughTrustBonusValue = rval.m_FollowThroughTrustBonusValue;

        m_UsedNukesTrustCostValue = rval.m_UsedNukesTrustCostValue;

        m_WantMapTurnsValue = rval.m_WantMapTurnsValue;

        delete [] m_ProposalElement;
        m_ProposalElement = NULL;
        if (rval.m_numProposalElement > 0)
        {
            m_ProposalElement = new ProposalElement [rval.m_numProposalElement];
            std::copy(rval.m_ProposalElement, rval.m_ProposalElement + rval.m_numProposalElement, m_ProposalElement);
        }
        m_numProposalElement = rval.m_numProposalElement;

    }

    return *this;
}

const char *g_Diplomacy_Tokens[] =
{
    "Inherit",
    "ScenarioEvent",
    "ScenarioEventValue",
    "MilitaryPowerEvent",
    "MilitaryPowerEventValue",
    "MilitarySafetyEvent",
    "MilitarySafetyEventValue",
    "DiplomacyEvent",
    "DiplomacyEventValue",
    "GoldEvent",
    "GoldEventValue",
    "KnowledgeEvent",
    "KnowledgeEventValue",
    "ProductionEvent",
    "ProductionEventValue",
    "Threaten",
    "ThreatenValue",
    "IncursionRegardCost",
    "IncursionRegardCostValue",
    "IncursionOfAllieRegardCost",
    "IncursionOfAllieRegardCostValue",
    "InvaderMovementRegardCost",
    "InvaderMovementRegardCostValue",
    "PerRoutePiracyRegardCost",
    "PerRoutePiracyRegardCostValue",
    "ShareContinentRegardCost",
    "ShareContinentRegardCostValue",
    "AttackCivilianRegardCost",
    "AttackCivilianRegardCostValue",
    "PreemptiveAttackRegardCost",
    "PreemptiveAttackRegardCostValue",
    "EmbargoTradeRegardCost",
    "EmbargoTradeRegardCostValue",
    "TakeCityRegardCost",
    "TakeCityRegardCostValue",
    "InciteRevolutionRegardCost",
    "InciteRevolutionRegardCostValue",
    "AssassinateRulerRegardCost",
    "AssassinateRulerRegardCostValue",
    "FranchiseCityRegardCost",
    "FranchiseCityRegardCostValue",
    "PlantNukeRegardCost",
    "PlantNukeRegardCostValue",
    "SlaveRaidRegardCost",
    "SlaveRaidRegardCostValue",
    "LawsuitRegardCost",
    "LawsuitRegardCostValue",
    "ExpelUnitsRegardCost",
    "ExpelUnitsRegardCostValue",
    "NukeCityRegardCost",
    "NukeCityRegardCostValue",
    "ConvertCityRegardCost",
    "ConvertCityRegardCostValue",
    "EnslaveSettlerRegardCost",
    "EnslaveSettlerRegardCostValue",
    "UndergroundRailwayRegardCost",
    "UndergroundRailwayRegardCostValue",
    "InciteUprisingRegardCost",
    "InciteUprisingRegardCostValue",
    "BioInfectedCityRegardCost",
    "BioInfectedCityRegardCostValue",
    "PlagueCityRegardCost",
    "PlagueCityRegardCostValue",
    "NanoInfectCityRegardCost",
    "NanoInfectCityRegardCostValue",
    "CreateParkRegardCost",
    "CreateParkRegardCostValue",
    "InjoinCityRegardCost",
    "InjoinCityRegardCostValue",
    "PillageRegardCost",
    "PillageRegardCostValue",
    "HoldReceptionRegardBonus",
    "HoldReceptionRegardBonusValue",
    "HasPactTrustBonus",
    "HasPactTrustBonusValue",
    "NoWarTrustBonus",
    "NoWarTrustBonusValue",
    "AttackCivilianTrustCost",
    "AttackCivilianTrustCostValue",
    "PreemptiveAttackTrustCost",
    "PreemptiveAttackTrustCostValue",
    "FollowThroughTrustBonus",
    "FollowThroughTrustBonusValue",
    "UsedNukesTrustCost",
    "UsedNukesTrustCostValue",
    "WantMapTurns",
    "WantMapTurnsValue",
    "ProposalElement",
};

DiplomacyRecordAccessorInfo g_DiplomacyRecord_Accessors[] =
{
    { &DiplomacyRecord::GetNumInherit, NULL, NULL, NULL, NULL, &DiplomacyRecord::GetInheritIndex, NULL}, /* Inherit (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ScenarioEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ScenarioEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MilitaryPowerEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MilitaryPowerEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MilitarySafetyEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MilitarySafetyEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DiplomacyEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DiplomacyEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* KnowledgeEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* KnowledgeEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProductionEvent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProductionEvent */
    { NULL, NULL, NULL, &DiplomacyRecord::GetThreaten, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Threaten */
    { NULL, NULL, NULL, &DiplomacyRecord::GetIncursionRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncursionRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetIncursionOfAllieRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncursionOfAllieRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetInvaderMovementRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvaderMovementRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetPerRoutePiracyRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PerRoutePiracyRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetShareContinentRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShareContinentRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetAttackCivilianRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackCivilianRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetPreemptiveAttackRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PreemptiveAttackRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetEmbargoTradeRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EmbargoTradeRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetTakeCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TakeCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetInciteRevolutionRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InciteRevolutionRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetAssassinateRulerRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AssassinateRulerRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetFranchiseCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FranchiseCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetPlantNukeRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PlantNukeRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetSlaveRaidRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveRaidRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetLawsuitRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LawsuitRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetExpelUnitsRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ExpelUnitsRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetNukeCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NukeCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetConvertCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConvertCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetEnslaveSettlerRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EnslaveSettlerRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetUndergroundRailwayRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UndergroundRailwayRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetInciteUprisingRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InciteUprisingRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetBioInfectedCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BioInfectedCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetPlagueCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PlagueCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetNanoInfectCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NanoInfectCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetCreateParkRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateParkRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetInjoinCityRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InjoinCityRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetPillageRegardCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PillageRegardCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetHoldReceptionRegardBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* HoldReceptionRegardBonus */
    { NULL, NULL, NULL, &DiplomacyRecord::GetHasPactTrustBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* HasPactTrustBonus */
    { NULL, NULL, NULL, &DiplomacyRecord::GetNoWarTrustBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NoWarTrustBonus */
    { NULL, NULL, NULL, &DiplomacyRecord::GetAttackCivilianTrustCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackCivilianTrustCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetPreemptiveAttackTrustCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PreemptiveAttackTrustCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetFollowThroughTrustBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FollowThroughTrustBonus */
    { NULL, NULL, NULL, &DiplomacyRecord::GetUsedNukesTrustCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UsedNukesTrustCost */
    { NULL, NULL, NULL, &DiplomacyRecord::GetWantMapTurns, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* WantMapTurns */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProposalElement */
};

#define k_Token_Diplomacy_Inherit                ((k_Token_Custom_Base) + 0)
#define k_Token_Diplomacy_ScenarioEvent          ((k_Token_Custom_Base) + 1)
#define k_Token_Diplomacy_ScenarioEvent_Value    ((k_Token_Custom_Base) + 2)
#define k_Token_Diplomacy_MilitaryPowerEvent     ((k_Token_Custom_Base) + 3)
#define k_Token_Diplomacy_MilitaryPowerEvent_Value ((k_Token_Custom_Base) + 4)
#define k_Token_Diplomacy_MilitarySafetyEvent    ((k_Token_Custom_Base) + 5)
#define k_Token_Diplomacy_MilitarySafetyEvent_Value ((k_Token_Custom_Base) + 6)
#define k_Token_Diplomacy_DiplomacyEvent         ((k_Token_Custom_Base) + 7)
#define k_Token_Diplomacy_DiplomacyEvent_Value   ((k_Token_Custom_Base) + 8)
#define k_Token_Diplomacy_GoldEvent              ((k_Token_Custom_Base) + 9)
#define k_Token_Diplomacy_GoldEvent_Value        ((k_Token_Custom_Base) + 10)
#define k_Token_Diplomacy_KnowledgeEvent         ((k_Token_Custom_Base) + 11)
#define k_Token_Diplomacy_KnowledgeEvent_Value   ((k_Token_Custom_Base) + 12)
#define k_Token_Diplomacy_ProductionEvent        ((k_Token_Custom_Base) + 13)
#define k_Token_Diplomacy_ProductionEvent_Value  ((k_Token_Custom_Base) + 14)
#define k_Token_Diplomacy_Threaten               ((k_Token_Custom_Base) + 15)
#define k_Token_Diplomacy_Threaten_Value         ((k_Token_Custom_Base) + 16)
#define k_Token_Diplomacy_IncursionRegardCost    ((k_Token_Custom_Base) + 17)
#define k_Token_Diplomacy_IncursionRegardCost_Value ((k_Token_Custom_Base) + 18)
#define k_Token_Diplomacy_IncursionOfAllieRegardCost ((k_Token_Custom_Base) + 19)
#define k_Token_Diplomacy_IncursionOfAllieRegardCost_Value ((k_Token_Custom_Base) + 20)
#define k_Token_Diplomacy_InvaderMovementRegardCost ((k_Token_Custom_Base) + 21)
#define k_Token_Diplomacy_InvaderMovementRegardCost_Value ((k_Token_Custom_Base) + 22)
#define k_Token_Diplomacy_PerRoutePiracyRegardCost ((k_Token_Custom_Base) + 23)
#define k_Token_Diplomacy_PerRoutePiracyRegardCost_Value ((k_Token_Custom_Base) + 24)
#define k_Token_Diplomacy_ShareContinentRegardCost ((k_Token_Custom_Base) + 25)
#define k_Token_Diplomacy_ShareContinentRegardCost_Value ((k_Token_Custom_Base) + 26)
#define k_Token_Diplomacy_AttackCivilianRegardCost ((k_Token_Custom_Base) + 27)
#define k_Token_Diplomacy_AttackCivilianRegardCost_Value ((k_Token_Custom_Base) + 28)
#define k_Token_Diplomacy_PreemptiveAttackRegardCost ((k_Token_Custom_Base) + 29)
#define k_Token_Diplomacy_PreemptiveAttackRegardCost_Value ((k_Token_Custom_Base) + 30)
#define k_Token_Diplomacy_EmbargoTradeRegardCost ((k_Token_Custom_Base) + 31)
#define k_Token_Diplomacy_EmbargoTradeRegardCost_Value ((k_Token_Custom_Base) + 32)
#define k_Token_Diplomacy_TakeCityRegardCost     ((k_Token_Custom_Base) + 33)
#define k_Token_Diplomacy_TakeCityRegardCost_Value ((k_Token_Custom_Base) + 34)
#define k_Token_Diplomacy_InciteRevolutionRegardCost ((k_Token_Custom_Base) + 35)
#define k_Token_Diplomacy_InciteRevolutionRegardCost_Value ((k_Token_Custom_Base) + 36)
#define k_Token_Diplomacy_AssassinateRulerRegardCost ((k_Token_Custom_Base) + 37)
#define k_Token_Diplomacy_AssassinateRulerRegardCost_Value ((k_Token_Custom_Base) + 38)
#define k_Token_Diplomacy_FranchiseCityRegardCost ((k_Token_Custom_Base) + 39)
#define k_Token_Diplomacy_FranchiseCityRegardCost_Value ((k_Token_Custom_Base) + 40)
#define k_Token_Diplomacy_PlantNukeRegardCost    ((k_Token_Custom_Base) + 41)
#define k_Token_Diplomacy_PlantNukeRegardCost_Value ((k_Token_Custom_Base) + 42)
#define k_Token_Diplomacy_SlaveRaidRegardCost    ((k_Token_Custom_Base) + 43)
#define k_Token_Diplomacy_SlaveRaidRegardCost_Value ((k_Token_Custom_Base) + 44)
#define k_Token_Diplomacy_LawsuitRegardCost      ((k_Token_Custom_Base) + 45)
#define k_Token_Diplomacy_LawsuitRegardCost_Value ((k_Token_Custom_Base) + 46)
#define k_Token_Diplomacy_ExpelUnitsRegardCost   ((k_Token_Custom_Base) + 47)
#define k_Token_Diplomacy_ExpelUnitsRegardCost_Value ((k_Token_Custom_Base) + 48)
#define k_Token_Diplomacy_NukeCityRegardCost     ((k_Token_Custom_Base) + 49)
#define k_Token_Diplomacy_NukeCityRegardCost_Value ((k_Token_Custom_Base) + 50)
#define k_Token_Diplomacy_ConvertCityRegardCost  ((k_Token_Custom_Base) + 51)
#define k_Token_Diplomacy_ConvertCityRegardCost_Value ((k_Token_Custom_Base) + 52)
#define k_Token_Diplomacy_EnslaveSettlerRegardCost ((k_Token_Custom_Base) + 53)
#define k_Token_Diplomacy_EnslaveSettlerRegardCost_Value ((k_Token_Custom_Base) + 54)
#define k_Token_Diplomacy_UndergroundRailwayRegardCost ((k_Token_Custom_Base) + 55)
#define k_Token_Diplomacy_UndergroundRailwayRegardCost_Value ((k_Token_Custom_Base) + 56)
#define k_Token_Diplomacy_InciteUprisingRegardCost ((k_Token_Custom_Base) + 57)
#define k_Token_Diplomacy_InciteUprisingRegardCost_Value ((k_Token_Custom_Base) + 58)
#define k_Token_Diplomacy_BioInfectedCityRegardCost ((k_Token_Custom_Base) + 59)
#define k_Token_Diplomacy_BioInfectedCityRegardCost_Value ((k_Token_Custom_Base) + 60)
#define k_Token_Diplomacy_PlagueCityRegardCost   ((k_Token_Custom_Base) + 61)
#define k_Token_Diplomacy_PlagueCityRegardCost_Value ((k_Token_Custom_Base) + 62)
#define k_Token_Diplomacy_NanoInfectCityRegardCost ((k_Token_Custom_Base) + 63)
#define k_Token_Diplomacy_NanoInfectCityRegardCost_Value ((k_Token_Custom_Base) + 64)
#define k_Token_Diplomacy_CreateParkRegardCost   ((k_Token_Custom_Base) + 65)
#define k_Token_Diplomacy_CreateParkRegardCost_Value ((k_Token_Custom_Base) + 66)
#define k_Token_Diplomacy_InjoinCityRegardCost   ((k_Token_Custom_Base) + 67)
#define k_Token_Diplomacy_InjoinCityRegardCost_Value ((k_Token_Custom_Base) + 68)
#define k_Token_Diplomacy_PillageRegardCost      ((k_Token_Custom_Base) + 69)
#define k_Token_Diplomacy_PillageRegardCost_Value ((k_Token_Custom_Base) + 70)
#define k_Token_Diplomacy_HoldReceptionRegardBonus ((k_Token_Custom_Base) + 71)
#define k_Token_Diplomacy_HoldReceptionRegardBonus_Value ((k_Token_Custom_Base) + 72)
#define k_Token_Diplomacy_HasPactTrustBonus      ((k_Token_Custom_Base) + 73)
#define k_Token_Diplomacy_HasPactTrustBonus_Value ((k_Token_Custom_Base) + 74)
#define k_Token_Diplomacy_NoWarTrustBonus        ((k_Token_Custom_Base) + 75)
#define k_Token_Diplomacy_NoWarTrustBonus_Value  ((k_Token_Custom_Base) + 76)
#define k_Token_Diplomacy_AttackCivilianTrustCost ((k_Token_Custom_Base) + 77)
#define k_Token_Diplomacy_AttackCivilianTrustCost_Value ((k_Token_Custom_Base) + 78)
#define k_Token_Diplomacy_PreemptiveAttackTrustCost ((k_Token_Custom_Base) + 79)
#define k_Token_Diplomacy_PreemptiveAttackTrustCost_Value ((k_Token_Custom_Base) + 80)
#define k_Token_Diplomacy_FollowThroughTrustBonus ((k_Token_Custom_Base) + 81)
#define k_Token_Diplomacy_FollowThroughTrustBonus_Value ((k_Token_Custom_Base) + 82)
#define k_Token_Diplomacy_UsedNukesTrustCost     ((k_Token_Custom_Base) + 83)
#define k_Token_Diplomacy_UsedNukesTrustCost_Value ((k_Token_Custom_Base) + 84)
#define k_Token_Diplomacy_WantMapTurns           ((k_Token_Custom_Base) + 85)
#define k_Token_Diplomacy_WantMapTurns_Value     ((k_Token_Custom_Base) + 86)
#define k_Token_Diplomacy_ProposalElement        ((k_Token_Custom_Base) + 87)
#define k_Token_Diplomacy_Max                    ((k_Token_Custom_Base) + 88)


static BitArray s_ParsedTokens(88);
void DiplomacyRecord::CheckRequiredFields(DBLexer *lex)
{
}

sint32 DiplomacyRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Diplomacy_Tokens, k_Token_Diplomacy_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "DIPLOMACY_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Diplomacy_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Diplomacy_Inherit:
                if(!g_theDiplomacyDB->ParseRecordInArray(lex, (sint32 *)m_Inherit, &m_numInherit, k_MAX_Inherit)) {
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ScenarioEvent:
                m_flags0 |= k_Diplomacy_ScenarioEvent_Bit;
                if(!m_ScenarioEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_MilitaryPowerEvent:
                m_flags0 |= k_Diplomacy_MilitaryPowerEvent_Bit;
                if(!m_MilitaryPowerEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_MilitarySafetyEvent:
                m_flags0 |= k_Diplomacy_MilitarySafetyEvent_Bit;
                if(!m_MilitarySafetyEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_DiplomacyEvent:
                m_flags0 |= k_Diplomacy_DiplomacyEvent_Bit;
                if(!m_DiplomacyEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_GoldEvent:
                m_flags0 |= k_Diplomacy_GoldEvent_Bit;
                if(!m_GoldEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_KnowledgeEvent:
                m_flags0 |= k_Diplomacy_KnowledgeEvent_Bit;
                if(!m_KnowledgeEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProductionEvent:
                m_flags0 |= k_Diplomacy_ProductionEvent_Bit;
                if(!m_ProductionEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_Threaten:
                m_flags0 |= k_Diplomacy_Threaten_Bit;
                if(!lex->GetIntAssignment(m_ThreatenValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_IncursionRegardCost:
                m_flags0 |= k_Diplomacy_IncursionRegardCost_Bit;
                if(!lex->GetIntAssignment(m_IncursionRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_IncursionOfAllieRegardCost:
                m_flags0 |= k_Diplomacy_IncursionOfAllieRegardCost_Bit;
                if(!lex->GetIntAssignment(m_IncursionOfAllieRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InvaderMovementRegardCost:
                m_flags0 |= k_Diplomacy_InvaderMovementRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InvaderMovementRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PerRoutePiracyRegardCost:
                m_flags0 |= k_Diplomacy_PerRoutePiracyRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PerRoutePiracyRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ShareContinentRegardCost:
                m_flags0 |= k_Diplomacy_ShareContinentRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ShareContinentRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_AttackCivilianRegardCost:
                m_flags0 |= k_Diplomacy_AttackCivilianRegardCost_Bit;
                if(!lex->GetIntAssignment(m_AttackCivilianRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PreemptiveAttackRegardCost:
                m_flags0 |= k_Diplomacy_PreemptiveAttackRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PreemptiveAttackRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_EmbargoTradeRegardCost:
                m_flags0 |= k_Diplomacy_EmbargoTradeRegardCost_Bit;
                if(!lex->GetIntAssignment(m_EmbargoTradeRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_TakeCityRegardCost:
                m_flags0 |= k_Diplomacy_TakeCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_TakeCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InciteRevolutionRegardCost:
                m_flags0 |= k_Diplomacy_InciteRevolutionRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InciteRevolutionRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_AssassinateRulerRegardCost:
                m_flags0 |= k_Diplomacy_AssassinateRulerRegardCost_Bit;
                if(!lex->GetIntAssignment(m_AssassinateRulerRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_FranchiseCityRegardCost:
                m_flags0 |= k_Diplomacy_FranchiseCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_FranchiseCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PlantNukeRegardCost:
                m_flags0 |= k_Diplomacy_PlantNukeRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PlantNukeRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_SlaveRaidRegardCost:
                m_flags0 |= k_Diplomacy_SlaveRaidRegardCost_Bit;
                if(!lex->GetIntAssignment(m_SlaveRaidRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_LawsuitRegardCost:
                m_flags0 |= k_Diplomacy_LawsuitRegardCost_Bit;
                if(!lex->GetIntAssignment(m_LawsuitRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ExpelUnitsRegardCost:
                m_flags0 |= k_Diplomacy_ExpelUnitsRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ExpelUnitsRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_NukeCityRegardCost:
                m_flags0 |= k_Diplomacy_NukeCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_NukeCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ConvertCityRegardCost:
                m_flags0 |= k_Diplomacy_ConvertCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ConvertCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_EnslaveSettlerRegardCost:
                m_flags0 |= k_Diplomacy_EnslaveSettlerRegardCost_Bit;
                if(!lex->GetIntAssignment(m_EnslaveSettlerRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_UndergroundRailwayRegardCost:
                m_flags0 |= k_Diplomacy_UndergroundRailwayRegardCost_Bit;
                if(!lex->GetIntAssignment(m_UndergroundRailwayRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InciteUprisingRegardCost:
                m_flags0 |= k_Diplomacy_InciteUprisingRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InciteUprisingRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_BioInfectedCityRegardCost:
                m_flags0 |= k_Diplomacy_BioInfectedCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_BioInfectedCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PlagueCityRegardCost:
                m_flags0 |= k_Diplomacy_PlagueCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PlagueCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_NanoInfectCityRegardCost:
                m_flags0 |= k_Diplomacy_NanoInfectCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_NanoInfectCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_CreateParkRegardCost:
                m_flags1 |= k_Diplomacy_CreateParkRegardCost_Bit;
                if(!lex->GetIntAssignment(m_CreateParkRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InjoinCityRegardCost:
                m_flags1 |= k_Diplomacy_InjoinCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InjoinCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PillageRegardCost:
                m_flags1 |= k_Diplomacy_PillageRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PillageRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_HoldReceptionRegardBonus:
                m_flags1 |= k_Diplomacy_HoldReceptionRegardBonus_Bit;
                if(!lex->GetIntAssignment(m_HoldReceptionRegardBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_HasPactTrustBonus:
                m_flags1 |= k_Diplomacy_HasPactTrustBonus_Bit;
                if(!lex->GetIntAssignment(m_HasPactTrustBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_NoWarTrustBonus:
                m_flags1 |= k_Diplomacy_NoWarTrustBonus_Bit;
                if(!lex->GetIntAssignment(m_NoWarTrustBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_AttackCivilianTrustCost:
                m_flags1 |= k_Diplomacy_AttackCivilianTrustCost_Bit;
                if(!lex->GetIntAssignment(m_AttackCivilianTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PreemptiveAttackTrustCost:
                m_flags1 |= k_Diplomacy_PreemptiveAttackTrustCost_Bit;
                if(!lex->GetIntAssignment(m_PreemptiveAttackTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_FollowThroughTrustBonus:
                m_flags1 |= k_Diplomacy_FollowThroughTrustBonus_Bit;
                if(!lex->GetIntAssignment(m_FollowThroughTrustBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_UsedNukesTrustCost:
                m_flags1 |= k_Diplomacy_UsedNukesTrustCost_Bit;
                if(!lex->GetIntAssignment(m_UsedNukesTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_WantMapTurns:
                m_flags1 |= k_Diplomacy_WantMapTurns_Bit;
                if(!lex->GetIntAssignment(m_WantMapTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement:
                if(!DiplomacyRecord::ProposalElement::ParseInArray(lex, &m_ProposalElement, &m_numProposalElement))
                {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(false)
                if(!g_theDiplomacyDB->ParseRecordInArray(lex, (sint32 *)m_Inherit, &m_numInherit, k_MAX_Inherit)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void DiplomacyRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numInherit; i++) {
            if(m_Inherit[i] & 0x80000000) {
                sint32 id = m_Inherit[i] & 0x7fffffff;
                if(!g_theDiplomacyDB->GetNamedItem(id, m_Inherit[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Diplomacy database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Inherit[i] == 0x7fffffff){
                m_Inherit[i] = -1;
            }
        }
    }
    m_ScenarioEventValue.ResolveDBReferences();
    m_MilitaryPowerEventValue.ResolveDBReferences();
    m_MilitarySafetyEventValue.ResolveDBReferences();
    m_DiplomacyEventValue.ResolveDBReferences();
    m_GoldEventValue.ResolveDBReferences();
    m_KnowledgeEventValue.ResolveDBReferences();
    m_ProductionEventValue.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numProposalElement; i++) {
            m_ProposalElement[i].ResolveDBReferences();
        }
    }
}

DiplomacyRecord::RegardDecay::RegardDecay()
{
    m_PositiveDecay = 0.000000;
    m_NegativeDecay = 0.000000;
}

DiplomacyRecord::RegardDecay::~RegardDecay()
{
}

DiplomacyRecord::RegardDecay const & DiplomacyRecord::RegardDecay::operator = (RegardDecay const & rval)
{
    if (this != &rval)
    {

        m_PositiveDecay = rval.m_PositiveDecay;

        m_NegativeDecay = rval.m_NegativeDecay;

    }

    return *this;
}

void DiplomacyRecord::RegardDecay::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_PositiveDecay;
        archive << m_NegativeDecay;
    } else {
        archive >> m_PositiveDecay;
        archive >> m_NegativeDecay;
    }
}

static const char *s_Diplomacy_RegardDecay_Tokens[] = {
    "PositiveDecay",
    "NegativeDecay",
};
#define k_Token_Diplomacy_RegardDecay_PositiveDecay ((k_Token_Custom_Base) + 0)
#define k_Token_Diplomacy_RegardDecay_NegativeDecay ((k_Token_Custom_Base) + 1)
#define k_Token_Diplomacy_RegardDecay_Max ((k_Token_Custom_Base) + 2)
sint32 DiplomacyRecord::RegardDecay::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_PositiveDecay)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_NegativeDecay)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 DiplomacyRecord::RegardDecay::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_PositiveDecay)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_NegativeDecay)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 DiplomacyRecord::RegardDecay::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for RegardDecay"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Diplomacy_RegardDecay_Tokens, k_Token_Diplomacy_RegardDecay_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Diplomacy_RegardDecay_PositiveDecay:
                if(!lex->GetFloatAssignment(m_PositiveDecay)) {
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_RegardDecay_NegativeDecay:
                if(!lex->GetFloatAssignment(m_NegativeDecay)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_PositiveDecay)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DiplomacyRecord::RegardDecay::ParseInArray(DBLexer *lex, RegardDecay **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RegardDecay *oldArray = *array;
        *array = new RegardDecay[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RegardDecay[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DiplomacyRecord::RegardDecay::ParseInArray(DBLexer *lex, RegardDecay *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DiplomacyRecord::RegardDecay::ParseInArraySequential(DBLexer *lex, RegardDecay **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RegardDecay *oldArray = *array;
        *array = new RegardDecay[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RegardDecay[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 DiplomacyRecord::RegardDecay::ParseInArraySequential(DBLexer *lex, RegardDecay *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void DiplomacyRecord::RegardDecay::ResolveDBReferences()
{
}

DiplomacyRecord::ProposalElement::ProposalElement()
{
    m_flags0 = 0;
    m_Proposal = 0x7fffffff;
    m_SendPriorityValue = 0;
    m_AcceptPriorityValue = 0;
    m_RejectPriorityValue = 0;
    m_SenderRegardResultValue = 0;
    m_ReceiverRegardResultValue = 0;
    m_ViolationRegardCostValue = 0;
    m_ViolationTrustCostValue = 0;
}

DiplomacyRecord::ProposalElement::~ProposalElement()
{
}

DiplomacyRecord::ProposalElement const & DiplomacyRecord::ProposalElement::operator = (ProposalElement const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Proposal = rval.m_Proposal;

        m_SendPriorityValue = rval.m_SendPriorityValue;

        m_AcceptPriorityValue = rval.m_AcceptPriorityValue;

        m_RejectPriorityValue = rval.m_RejectPriorityValue;

        m_SenderRegardResultValue = rval.m_SenderRegardResultValue;

        m_ReceiverRegardResultValue = rval.m_ReceiverRegardResultValue;

        m_ViolationRegardCostValue = rval.m_ViolationRegardCostValue;

        m_ViolationTrustCostValue = rval.m_ViolationTrustCostValue;

    }

    return *this;
}

void DiplomacyRecord::ProposalElement::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Proposal;
        archive << m_SendPriorityValue;
        archive << m_AcceptPriorityValue;
        archive << m_RejectPriorityValue;
        archive << m_SenderRegardResultValue;
        archive << m_ReceiverRegardResultValue;
        archive << m_ViolationRegardCostValue;
        archive << m_ViolationTrustCostValue;
    } else {
        archive >> m_flags0;
        archive >> m_Proposal;
        archive >> m_SendPriorityValue;
        archive >> m_AcceptPriorityValue;
        archive >> m_RejectPriorityValue;
        archive >> m_SenderRegardResultValue;
        archive >> m_ReceiverRegardResultValue;
        archive >> m_ViolationRegardCostValue;
        archive >> m_ViolationTrustCostValue;
    }
}

static const char *s_Diplomacy_ProposalElement_Tokens[] = {
    "Proposal",
    "SendPriority",
    "AcceptPriority",
    "RejectPriority",
    "SenderRegardResult",
    "ReceiverRegardResult",
    "ViolationRegardCost",
    "ViolationTrustCost",
};
#define k_Token_Diplomacy_ProposalElement_Proposal ((k_Token_Custom_Base) + 0)
#define k_Token_Diplomacy_ProposalElement_SendPriority ((k_Token_Custom_Base) + 1)
#define k_Token_Diplomacy_ProposalElement_AcceptPriority ((k_Token_Custom_Base) + 2)
#define k_Token_Diplomacy_ProposalElement_RejectPriority ((k_Token_Custom_Base) + 3)
#define k_Token_Diplomacy_ProposalElement_SenderRegardResult ((k_Token_Custom_Base) + 4)
#define k_Token_Diplomacy_ProposalElement_ReceiverRegardResult ((k_Token_Custom_Base) + 5)
#define k_Token_Diplomacy_ProposalElement_ViolationRegardCost ((k_Token_Custom_Base) + 6)
#define k_Token_Diplomacy_ProposalElement_ViolationTrustCost ((k_Token_Custom_Base) + 7)
#define k_Token_Diplomacy_ProposalElement_Max ((k_Token_Custom_Base) + 8)
sint32 DiplomacyRecord::ProposalElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for ProposalElement"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Diplomacy_ProposalElement_Tokens, k_Token_Diplomacy_ProposalElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Diplomacy_ProposalElement_Proposal:
                if (!g_theDiplomacyProposalDB->GetRecordFromLexer(lex, m_Proposal)) {
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_SendPriority:
                m_flags0 |= k_ProposalElement_SendPriority_Bit;
                if(!lex->GetIntAssignment(m_SendPriorityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_AcceptPriority:
                m_flags0 |= k_ProposalElement_AcceptPriority_Bit;
                if(!lex->GetIntAssignment(m_AcceptPriorityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_RejectPriority:
                m_flags0 |= k_ProposalElement_RejectPriority_Bit;
                if(!lex->GetIntAssignment(m_RejectPriorityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_SenderRegardResult:
                m_flags0 |= k_ProposalElement_SenderRegardResult_Bit;
                if(!lex->GetIntAssignment(m_SenderRegardResultValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_ReceiverRegardResult:
                m_flags0 |= k_ProposalElement_ReceiverRegardResult_Bit;
                if(!lex->GetIntAssignment(m_ReceiverRegardResultValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_ViolationRegardCost:
                m_flags0 |= k_ProposalElement_ViolationRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ViolationRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_ViolationTrustCost:
                m_flags0 |= k_ProposalElement_ViolationTrustCost_Bit;
                if(!lex->GetIntAssignment(m_ViolationTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theDiplomacyProposalDB->GetCurrentRecordFromLexer(lex, m_Proposal)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DiplomacyRecord::ProposalElement::ParseInArray(DBLexer *lex, ProposalElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ProposalElement *oldArray = *array;
        *array = new ProposalElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ProposalElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DiplomacyRecord::ProposalElement::ParseInArray(DBLexer *lex, ProposalElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void DiplomacyRecord::ProposalElement::ResolveDBReferences()
{
    if(m_Proposal & 0x80000000) {
        sint32 id = m_Proposal & 0x7fffffff;
        if(!g_theDiplomacyProposalDB->GetNamedItem(id, m_Proposal)) {
            c3errors_ErrorDialog("DB", "%s not found in DiplomacyProposal database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Proposal == 0x7fffffff) {
        m_Proposal = -1;
    }
}

void DiplomacyRecord::Merge(const DiplomacyRecord & rval){
    if (rval.m_numInherit > 0)
        std::copy(rval.m_Inherit, rval.m_Inherit + rval.m_numInherit, m_Inherit);

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_ScenarioEvent_Bit)
    {
        m_ScenarioEventValue = rval.m_ScenarioEventValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_MilitaryPowerEvent_Bit)
    {
        m_MilitaryPowerEventValue = rval.m_MilitaryPowerEventValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_MilitarySafetyEvent_Bit)
    {
        m_MilitarySafetyEventValue = rval.m_MilitarySafetyEventValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_DiplomacyEvent_Bit)
    {
        m_DiplomacyEventValue = rval.m_DiplomacyEventValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_GoldEvent_Bit)
    {
        m_GoldEventValue = rval.m_GoldEventValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_KnowledgeEvent_Bit)
    {
        m_KnowledgeEventValue = rval.m_KnowledgeEventValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_ProductionEvent_Bit)
    {
        m_ProductionEventValue = rval.m_ProductionEventValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_Threaten_Bit)
    {
        m_ThreatenValue = rval.m_ThreatenValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_IncursionRegardCost_Bit)
    {
        m_IncursionRegardCostValue = rval.m_IncursionRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_IncursionOfAllieRegardCost_Bit)
    {
        m_IncursionOfAllieRegardCostValue = rval.m_IncursionOfAllieRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_InvaderMovementRegardCost_Bit)
    {
        m_InvaderMovementRegardCostValue = rval.m_InvaderMovementRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_PerRoutePiracyRegardCost_Bit)
    {
        m_PerRoutePiracyRegardCostValue = rval.m_PerRoutePiracyRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_ShareContinentRegardCost_Bit)
    {
        m_ShareContinentRegardCostValue = rval.m_ShareContinentRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_AttackCivilianRegardCost_Bit)
    {
        m_AttackCivilianRegardCostValue = rval.m_AttackCivilianRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_PreemptiveAttackRegardCost_Bit)
    {
        m_PreemptiveAttackRegardCostValue = rval.m_PreemptiveAttackRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_EmbargoTradeRegardCost_Bit)
    {
        m_EmbargoTradeRegardCostValue = rval.m_EmbargoTradeRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_TakeCityRegardCost_Bit)
    {
        m_TakeCityRegardCostValue = rval.m_TakeCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_InciteRevolutionRegardCost_Bit)
    {
        m_InciteRevolutionRegardCostValue = rval.m_InciteRevolutionRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_AssassinateRulerRegardCost_Bit)
    {
        m_AssassinateRulerRegardCostValue = rval.m_AssassinateRulerRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_FranchiseCityRegardCost_Bit)
    {
        m_FranchiseCityRegardCostValue = rval.m_FranchiseCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_PlantNukeRegardCost_Bit)
    {
        m_PlantNukeRegardCostValue = rval.m_PlantNukeRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_SlaveRaidRegardCost_Bit)
    {
        m_SlaveRaidRegardCostValue = rval.m_SlaveRaidRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_LawsuitRegardCost_Bit)
    {
        m_LawsuitRegardCostValue = rval.m_LawsuitRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_ExpelUnitsRegardCost_Bit)
    {
        m_ExpelUnitsRegardCostValue = rval.m_ExpelUnitsRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_NukeCityRegardCost_Bit)
    {
        m_NukeCityRegardCostValue = rval.m_NukeCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_ConvertCityRegardCost_Bit)
    {
        m_ConvertCityRegardCostValue = rval.m_ConvertCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_EnslaveSettlerRegardCost_Bit)
    {
        m_EnslaveSettlerRegardCostValue = rval.m_EnslaveSettlerRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_UndergroundRailwayRegardCost_Bit)
    {
        m_UndergroundRailwayRegardCostValue = rval.m_UndergroundRailwayRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_InciteUprisingRegardCost_Bit)
    {
        m_InciteUprisingRegardCostValue = rval.m_InciteUprisingRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_BioInfectedCityRegardCost_Bit)
    {
        m_BioInfectedCityRegardCostValue = rval.m_BioInfectedCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_PlagueCityRegardCost_Bit)
    {
        m_PlagueCityRegardCostValue = rval.m_PlagueCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Diplomacy_NanoInfectCityRegardCost_Bit)
    {
        m_NanoInfectCityRegardCostValue = rval.m_NanoInfectCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_CreateParkRegardCost_Bit)
    {
        m_CreateParkRegardCostValue = rval.m_CreateParkRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_InjoinCityRegardCost_Bit)
    {
        m_InjoinCityRegardCostValue = rval.m_InjoinCityRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_PillageRegardCost_Bit)
    {
        m_PillageRegardCostValue = rval.m_PillageRegardCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_HoldReceptionRegardBonus_Bit)
    {
        m_HoldReceptionRegardBonusValue = rval.m_HoldReceptionRegardBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_HasPactTrustBonus_Bit)
    {
        m_HasPactTrustBonusValue = rval.m_HasPactTrustBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_NoWarTrustBonus_Bit)
    {
        m_NoWarTrustBonusValue = rval.m_NoWarTrustBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_AttackCivilianTrustCost_Bit)
    {
        m_AttackCivilianTrustCostValue = rval.m_AttackCivilianTrustCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_PreemptiveAttackTrustCost_Bit)
    {
        m_PreemptiveAttackTrustCostValue = rval.m_PreemptiveAttackTrustCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_FollowThroughTrustBonus_Bit)
    {
        m_FollowThroughTrustBonusValue = rval.m_FollowThroughTrustBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_UsedNukesTrustCost_Bit)
    {
        m_UsedNukesTrustCostValue = rval.m_UsedNukesTrustCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Diplomacy_WantMapTurns_Bit)
    {
        m_WantMapTurnsValue = rval.m_WantMapTurnsValue;
    }

    // replace struct elements of m_ProposalElement
    for (sint32 index_ProposalElement = 0; index_ProposalElement < m_numProposalElement; ++index_ProposalElement)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numProposalElement; ++obj_index)
            if (m_ProposalElement[index_ProposalElement] == rval.m_ProposalElement[obj_index]){
                m_ProposalElement[index_ProposalElement] = rval.m_ProposalElement[obj_index];
            }
    }
}

sint32 DiplomacyRecord::GetInheritIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return m_Inherit[index];
}

DiplomacyRecord const * DiplomacyRecord::GetInherit(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return g_theDiplomacyDB->Get(m_Inherit[index]);
}

DiplomacyRecord::ProposalElement const * DiplomacyRecord::GetProposalElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numProposalElement);
    if((index < 0) || (index >= m_numProposalElement)) {
        return 0;
    }
    return &m_ProposalElement[index];
}

const DiplomacyProposalRecord *DiplomacyRecord::ProposalElement::GetProposal() const
{
    return g_theDiplomacyProposalDB->Get(m_Proposal);
}

