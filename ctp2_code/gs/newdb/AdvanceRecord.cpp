
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "AdvanceRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "IconRecord.h"
#include "AdvanceBranchRecord.h"
#include "AgeRecord.h"
#include "CityStyleRecord.h"
#include "GovernmentRecord.h"
#include "ResourceRecord.h"
#include "FeatRecord.h"

CTPDatabase<AdvanceRecord> *g_theAdvanceDB = NULL;

void AdvanceRecord::Init()
{
    m_flags0 = 0;
    m_Cost = 0;
    memset(m_Prerequisites, 0, sizeof(m_Prerequisites));
    m_numPrerequisites = 0;
    m_Dependencies = NULL;
    m_numDependencies = 0;
    m_LeadsTo = NULL;
    m_numLeadsTo = 0;
    m_ExcludesAdvance = NULL;
    m_numExcludesAdvance = 0;
    m_Icon = 0x7fffffff;
    m_Branch = 0x7fffffff;
    m_Age = 0x7fffffff;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    m_NeedsCityGoodAnyCity = NULL;
    m_numNeedsCityGoodAnyCity = 0;
    memset(m_EitherPrerequisites, 0, sizeof(m_EitherPrerequisites));
    m_numEitherPrerequisites = 0;
    m_BonusHappy = 0;
    m_BonusGold = 0;
    m_BonusFood = 0;
    m_BonusProduction = 0;
    m_BonusScience = 0;
    m_ProductionPercentValue = 0.000000;
    m_FoodPercentValue = 0.000000;
    m_CommercePercentValue = 0.000000;
    m_SciencePercentValue = 0.000000;
    m_PowerPoints = 0;
    m_PollutionSizeModifierValue = 0.000000;
    m_PollutionProductionModifierValue = 0.000000;
    m_TriggerFeatValue = 0;
    m_KeyAdvanceAdviceValue = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void AdvanceRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_Cost;
        archive << m_numPrerequisites;
        archive.Store((uint8*)&m_Prerequisites, sizeof(m_Prerequisites));
        archive << m_numDependencies;
        archive.Store((uint8*)m_Dependencies, m_numDependencies * sizeof(sint32));

        archive << m_numLeadsTo;
        archive.Store((uint8*)m_LeadsTo, m_numLeadsTo * sizeof(sint32));

        archive << m_numExcludesAdvance;
        archive.Store((uint8*)m_ExcludesAdvance, m_numExcludesAdvance * sizeof(sint32));

        archive << m_Icon;
        archive << m_Branch;
        archive << m_Age;
        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_numGovernmentType;
        archive.Store((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive << m_numNeedsCityGoodAnyCity;
        archive.Store((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive << m_numEitherPrerequisites;
        archive.Store((uint8*)&m_EitherPrerequisites, sizeof(m_EitherPrerequisites));
        archive << m_BonusHappy;
        archive << m_BonusGold;
        archive << m_BonusFood;
        archive << m_BonusProduction;
        archive << m_BonusScience;
        archive << m_ProductionPercentValue;
        archive << m_FoodPercentValue;
        archive << m_CommercePercentValue;
        archive << m_SciencePercentValue;
        archive << m_PowerPoints;
        archive << m_PollutionSizeModifierValue;
        archive << m_PollutionProductionModifierValue;
        archive << m_TriggerFeatValue;
        if (HasKeyAdvanceAdvice()){
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_KeyAdvanceAdviceValue);
            archive << tmpString;
        }

    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_Cost;
        archive >> m_numPrerequisites;
        archive.Load((uint8*)&m_Prerequisites, sizeof(m_Prerequisites));
        archive >> m_numDependencies;
        archive.Load((uint8*)m_Dependencies, m_numDependencies * sizeof(sint32));

        archive >> m_numLeadsTo;
        archive.Load((uint8*)m_LeadsTo, m_numLeadsTo * sizeof(sint32));

        archive >> m_numExcludesAdvance;
        archive.Load((uint8*)m_ExcludesAdvance, m_numExcludesAdvance * sizeof(sint32));

        archive >> m_Icon;
        archive >> m_Branch;
        archive >> m_Age;
        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_numGovernmentType;
        archive.Load((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive >> m_numNeedsCityGoodAnyCity;
        archive.Load((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive >> m_numEitherPrerequisites;
        archive.Load((uint8*)&m_EitherPrerequisites, sizeof(m_EitherPrerequisites));
        archive >> m_BonusHappy;
        archive >> m_BonusGold;
        archive >> m_BonusFood;
        archive >> m_BonusProduction;
        archive >> m_BonusScience;
        archive >> m_ProductionPercentValue;
        archive >> m_FoodPercentValue;
        archive >> m_CommercePercentValue;
        archive >> m_SciencePercentValue;
        archive >> m_PowerPoints;
        archive >> m_PollutionSizeModifierValue;
        archive >> m_PollutionProductionModifierValue;
        archive >> m_TriggerFeatValue;
        {
            if (HasKeyAdvanceAdvice()){
                MBCHAR* tmpString = NULL;
                archive >> tmpString;
                g_theStringDB->GetStringID(tmpString, m_KeyAdvanceAdviceValue);
                delete[] tmpString;
            }
        }

    }
}

AdvanceRecord::~AdvanceRecord()
{
    delete [] m_Dependencies;
    delete [] m_LeadsTo;
    delete [] m_ExcludesAdvance;
    delete [] m_CultureOnly;
    delete [] m_GovernmentType;
    delete [] m_NeedsCityGoodAnyCity;
}

AdvanceRecord const & AdvanceRecord::operator = (AdvanceRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_Cost = rval.m_Cost;

        std::copy(rval.m_Prerequisites, rval.m_Prerequisites + rval.m_numPrerequisites, m_Prerequisites);

        delete [] m_Dependencies;
        m_Dependencies = NULL;
        if (rval.m_numDependencies > 0)
        {
            m_Dependencies = new sint32 [rval.m_numDependencies];
            std::copy(rval.m_Dependencies, rval.m_Dependencies + rval.m_numDependencies, m_Dependencies);
        }
        m_numDependencies = rval.m_numDependencies;

        delete [] m_LeadsTo;
        m_LeadsTo = NULL;
        if (rval.m_numLeadsTo > 0)
        {
            m_LeadsTo = new sint32 [rval.m_numLeadsTo];
            std::copy(rval.m_LeadsTo, rval.m_LeadsTo + rval.m_numLeadsTo, m_LeadsTo);
        }
        m_numLeadsTo = rval.m_numLeadsTo;

        delete [] m_ExcludesAdvance;
        m_ExcludesAdvance = NULL;
        if (rval.m_numExcludesAdvance > 0)
        {
            m_ExcludesAdvance = new sint32 [rval.m_numExcludesAdvance];
            std::copy(rval.m_ExcludesAdvance, rval.m_ExcludesAdvance + rval.m_numExcludesAdvance, m_ExcludesAdvance);
        }
        m_numExcludesAdvance = rval.m_numExcludesAdvance;

        m_Icon = rval.m_Icon;

        m_Branch = rval.m_Branch;

        m_Age = rval.m_Age;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
        {
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
            std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);
        }
        m_numGovernmentType = rval.m_numGovernmentType;

        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
        {
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
            std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);
        }
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;

        std::copy(rval.m_EitherPrerequisites, rval.m_EitherPrerequisites + rval.m_numEitherPrerequisites, m_EitherPrerequisites);

        m_BonusHappy = rval.m_BonusHappy;

        m_BonusGold = rval.m_BonusGold;

        m_BonusFood = rval.m_BonusFood;

        m_BonusProduction = rval.m_BonusProduction;

        m_BonusScience = rval.m_BonusScience;

        m_ProductionPercentValue = rval.m_ProductionPercentValue;

        m_FoodPercentValue = rval.m_FoodPercentValue;

        m_CommercePercentValue = rval.m_CommercePercentValue;

        m_SciencePercentValue = rval.m_SciencePercentValue;

        m_PowerPoints = rval.m_PowerPoints;

        m_PollutionSizeModifierValue = rval.m_PollutionSizeModifierValue;

        m_PollutionProductionModifierValue = rval.m_PollutionProductionModifierValue;

        m_TriggerFeatValue = rval.m_TriggerFeatValue;

        m_KeyAdvanceAdviceValue = rval.m_KeyAdvanceAdviceValue;

    }

    return *this;
}

const char *g_Advance_Tokens[] =
{
    "Cost",
    "Prerequisites",
    "Dependencies",
    "LeadsTo",
    "ExcludesAdvance",
    "Icon",
    "Branch",
    "Age",
    "CultureOnly",
    "GovernmentType",
    "NeedsCityGoodAnyCity",
    "EitherPrerequisites",
    "DeepOcean",
    "Capitalization",
    "Infrastructure",
    "Transform",
    "RequiresProbeRecovery",
    "Genetic",
    "PlantNuke",
    "NoIndex",
    "Roads",
    "Railroads",
    "AlienLife",
    "MagLev",
    "Tunnels",
    "BonusHappy",
    "BonusGold",
    "BonusFood",
    "BonusProduction",
    "BonusScience",
    "ProductionPercent",
    "ProductionPercentValue",
    "FoodPercent",
    "FoodPercentValue",
    "CommercePercent",
    "CommercePercentValue",
    "SciencePercent",
    "SciencePercentValue",
    "GLHidden",
    "GoodyHutExcluded",
    "PowerPoints",
    "PollutionSizeModifier",
    "PollutionSizeModifierValue",
    "PollutionProductionModifier",
    "PollutionProductionModifierValue",
    "TriggerFeat",
    "TriggerFeatValue",
    "IsMassMedia",
    "EnablesGuerrillas",
    "KeyAdvanceAdvice",
    "KeyAdvanceAdviceValue",
};

AdvanceRecordAccessorInfo g_AdvanceRecord_Accessors[] =
{
    { &AdvanceRecord::GetCost, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetNumPrerequisites, NULL, NULL, NULL, NULL, &AdvanceRecord::GetPrerequisitesIndex, NULL}, /* Prerequisites (array) */
    { &AdvanceRecord::GetNumDependencies, NULL, NULL, NULL, NULL, &AdvanceRecord::GetDependenciesIndex, NULL}, /* Dependencies (array) */
    { &AdvanceRecord::GetNumLeadsTo, NULL, NULL, NULL, NULL, &AdvanceRecord::GetLeadsToIndex, NULL}, /* LeadsTo (array) */
    { &AdvanceRecord::GetNumExcludesAdvance, NULL, NULL, NULL, NULL, &AdvanceRecord::GetExcludesAdvanceIndex, NULL}, /* ExcludesAdvance (array) */
    { &AdvanceRecord::GetIconIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetBranchIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetAgeIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetNumCultureOnly, NULL, NULL, NULL, NULL, &AdvanceRecord::GetCultureOnlyIndex, NULL}, /* CultureOnly (array) */
    { &AdvanceRecord::GetNumGovernmentType, NULL, NULL, NULL, NULL, &AdvanceRecord::GetGovernmentTypeIndex, NULL}, /* GovernmentType (array) */
    { &AdvanceRecord::GetNumNeedsCityGoodAnyCity, NULL, NULL, NULL, NULL, &AdvanceRecord::GetNeedsCityGoodAnyCityIndex, NULL}, /* NeedsCityGoodAnyCity (array) */
    { &AdvanceRecord::GetNumEitherPrerequisites, NULL, NULL, NULL, NULL, &AdvanceRecord::GetEitherPrerequisitesIndex, NULL}, /* EitherPrerequisites (array) */
    { NULL, &AdvanceRecord::GetDeepOcean, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetCapitalization, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetInfrastructure, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetTransform, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetRequiresProbeRecovery, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetGenetic, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetPlantNuke, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetNoIndex, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetRoads, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetRailroads, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetAlienLife, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetMagLev, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetTunnels, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetBonusHappy, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetBonusGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetBonusFood, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetBonusProduction, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetBonusScience, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &AdvanceRecord::GetProductionPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProductionPercent */
    { NULL, NULL, NULL, NULL, &AdvanceRecord::GetFoodPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FoodPercent */
    { NULL, NULL, NULL, NULL, &AdvanceRecord::GetCommercePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CommercePercent */
    { NULL, NULL, NULL, NULL, &AdvanceRecord::GetSciencePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SciencePercent */
    { NULL, &AdvanceRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetGoodyHutExcluded, NULL, NULL, NULL, NULL, NULL },
    { &AdvanceRecord::GetPowerPoints, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &AdvanceRecord::GetPollutionSizeModifier, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutionSizeModifier */
    { NULL, NULL, NULL, NULL, &AdvanceRecord::GetPollutionProductionModifier, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutionProductionModifier */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TriggerFeat */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TriggerFeat */
    { NULL, &AdvanceRecord::GetIsMassMedia, NULL, NULL, NULL, NULL, NULL },
    { NULL, &AdvanceRecord::GetEnablesGuerrillas, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* KeyAdvanceAdvice */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* KeyAdvanceAdvice */
};

#define k_Token_Advance_Cost                     ((k_Token_Custom_Base) + 0)
#define k_Token_Advance_Prerequisites            ((k_Token_Custom_Base) + 1)
#define k_Token_Advance_Dependencies             ((k_Token_Custom_Base) + 2)
#define k_Token_Advance_LeadsTo                  ((k_Token_Custom_Base) + 3)
#define k_Token_Advance_ExcludesAdvance          ((k_Token_Custom_Base) + 4)
#define k_Token_Advance_Icon                     ((k_Token_Custom_Base) + 5)
#define k_Token_Advance_Branch                   ((k_Token_Custom_Base) + 6)
#define k_Token_Advance_Age                      ((k_Token_Custom_Base) + 7)
#define k_Token_Advance_CultureOnly              ((k_Token_Custom_Base) + 8)
#define k_Token_Advance_GovernmentType           ((k_Token_Custom_Base) + 9)
#define k_Token_Advance_NeedsCityGoodAnyCity     ((k_Token_Custom_Base) + 10)
#define k_Token_Advance_EitherPrerequisites      ((k_Token_Custom_Base) + 11)
#define k_Token_Advance_DeepOcean                ((k_Token_Custom_Base) + 12)
#define k_Token_Advance_Capitalization           ((k_Token_Custom_Base) + 13)
#define k_Token_Advance_Infrastructure           ((k_Token_Custom_Base) + 14)
#define k_Token_Advance_Transform                ((k_Token_Custom_Base) + 15)
#define k_Token_Advance_RequiresProbeRecovery    ((k_Token_Custom_Base) + 16)
#define k_Token_Advance_Genetic                  ((k_Token_Custom_Base) + 17)
#define k_Token_Advance_PlantNuke                ((k_Token_Custom_Base) + 18)
#define k_Token_Advance_NoIndex                  ((k_Token_Custom_Base) + 19)
#define k_Token_Advance_Roads                    ((k_Token_Custom_Base) + 20)
#define k_Token_Advance_Railroads                ((k_Token_Custom_Base) + 21)
#define k_Token_Advance_AlienLife                ((k_Token_Custom_Base) + 22)
#define k_Token_Advance_MagLev                   ((k_Token_Custom_Base) + 23)
#define k_Token_Advance_Tunnels                  ((k_Token_Custom_Base) + 24)
#define k_Token_Advance_BonusHappy               ((k_Token_Custom_Base) + 25)
#define k_Token_Advance_BonusGold                ((k_Token_Custom_Base) + 26)
#define k_Token_Advance_BonusFood                ((k_Token_Custom_Base) + 27)
#define k_Token_Advance_BonusProduction          ((k_Token_Custom_Base) + 28)
#define k_Token_Advance_BonusScience             ((k_Token_Custom_Base) + 29)
#define k_Token_Advance_ProductionPercent        ((k_Token_Custom_Base) + 30)
#define k_Token_Advance_ProductionPercent_Value  ((k_Token_Custom_Base) + 31)
#define k_Token_Advance_FoodPercent              ((k_Token_Custom_Base) + 32)
#define k_Token_Advance_FoodPercent_Value        ((k_Token_Custom_Base) + 33)
#define k_Token_Advance_CommercePercent          ((k_Token_Custom_Base) + 34)
#define k_Token_Advance_CommercePercent_Value    ((k_Token_Custom_Base) + 35)
#define k_Token_Advance_SciencePercent           ((k_Token_Custom_Base) + 36)
#define k_Token_Advance_SciencePercent_Value     ((k_Token_Custom_Base) + 37)
#define k_Token_Advance_GLHidden                 ((k_Token_Custom_Base) + 38)
#define k_Token_Advance_GoodyHutExcluded         ((k_Token_Custom_Base) + 39)
#define k_Token_Advance_PowerPoints              ((k_Token_Custom_Base) + 40)
#define k_Token_Advance_PollutionSizeModifier    ((k_Token_Custom_Base) + 41)
#define k_Token_Advance_PollutionSizeModifier_Value ((k_Token_Custom_Base) + 42)
#define k_Token_Advance_PollutionProductionModifier ((k_Token_Custom_Base) + 43)
#define k_Token_Advance_PollutionProductionModifier_Value ((k_Token_Custom_Base) + 44)
#define k_Token_Advance_TriggerFeat              ((k_Token_Custom_Base) + 45)
#define k_Token_Advance_TriggerFeat_Value        ((k_Token_Custom_Base) + 46)
#define k_Token_Advance_IsMassMedia              ((k_Token_Custom_Base) + 47)
#define k_Token_Advance_EnablesGuerrillas        ((k_Token_Custom_Base) + 48)
#define k_Token_Advance_KeyAdvanceAdvice         ((k_Token_Custom_Base) + 49)
#define k_Token_Advance_KeyAdvanceAdvice_Value   ((k_Token_Custom_Base) + 50)
#define k_Token_Advance_Max                      ((k_Token_Custom_Base) + 51)


static BitArray s_ParsedTokens(51);
void AdvanceRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Advance_Cost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Cost missing"));
    }
}

sint32 AdvanceRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Advance_Tokens, k_Token_Advance_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "ADVANCE_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Advance_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Advance_Cost:
                if(!lex->GetIntAssignment(m_Cost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_Prerequisites:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_Prerequisites, &m_numPrerequisites, k_MAX_Prerequisites)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Dependencies:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_Dependencies, &m_numDependencies))
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_LeadsTo:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_LeadsTo, &m_numLeadsTo))
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_ExcludesAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludesAdvance, &m_numExcludesAdvance))
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Icon:
                if (!g_theIconDB->GetRecordFromLexer(lex, m_Icon)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Branch:
                if (!g_theAdvanceBranchDB->GetRecordFromLexer(lex, m_Branch)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Age:
                if (!g_theAgeDB->GetRecordFromLexer(lex, m_Age)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CultureOnly, &m_numCultureOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_NeedsCityGoodAnyCity:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAnyCity, &m_numNeedsCityGoodAnyCity))
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_EitherPrerequisites:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_EitherPrerequisites, &m_numEitherPrerequisites, k_MAX_EitherPrerequisites)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_DeepOcean:
                m_flags0 |= k_Advance_DeepOcean_Bit;
                break;
            case k_Token_Advance_Capitalization:
                m_flags0 |= k_Advance_Capitalization_Bit;
                break;
            case k_Token_Advance_Infrastructure:
                m_flags0 |= k_Advance_Infrastructure_Bit;
                break;
            case k_Token_Advance_Transform:
                m_flags0 |= k_Advance_Transform_Bit;
                break;
            case k_Token_Advance_RequiresProbeRecovery:
                m_flags0 |= k_Advance_RequiresProbeRecovery_Bit;
                break;
            case k_Token_Advance_Genetic:
                m_flags0 |= k_Advance_Genetic_Bit;
                break;
            case k_Token_Advance_PlantNuke:
                m_flags0 |= k_Advance_PlantNuke_Bit;
                break;
            case k_Token_Advance_NoIndex:
                m_flags0 |= k_Advance_NoIndex_Bit;
                break;
            case k_Token_Advance_Roads:
                m_flags0 |= k_Advance_Roads_Bit;
                break;
            case k_Token_Advance_Railroads:
                m_flags0 |= k_Advance_Railroads_Bit;
                break;
            case k_Token_Advance_AlienLife:
                m_flags0 |= k_Advance_AlienLife_Bit;
                break;
            case k_Token_Advance_MagLev:
                m_flags0 |= k_Advance_MagLev_Bit;
                break;
            case k_Token_Advance_Tunnels:
                m_flags0 |= k_Advance_Tunnels_Bit;
                break;
            case k_Token_Advance_BonusHappy:
                if(!lex->GetIntAssignment(m_BonusHappy)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_BonusGold:
                if(!lex->GetIntAssignment(m_BonusGold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_BonusFood:
                if(!lex->GetIntAssignment(m_BonusFood)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_BonusProduction:
                if(!lex->GetIntAssignment(m_BonusProduction)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_BonusScience:
                if(!lex->GetIntAssignment(m_BonusScience)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_ProductionPercent:
                m_flags0 |= k_Advance_ProductionPercent_Bit;
                if(!lex->GetFloatAssignment(m_ProductionPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_FoodPercent:
                m_flags0 |= k_Advance_FoodPercent_Bit;
                if(!lex->GetFloatAssignment(m_FoodPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_CommercePercent:
                m_flags0 |= k_Advance_CommercePercent_Bit;
                if(!lex->GetFloatAssignment(m_CommercePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_SciencePercent:
                m_flags0 |= k_Advance_SciencePercent_Bit;
                if(!lex->GetFloatAssignment(m_SciencePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_GLHidden:
                m_flags0 |= k_Advance_GLHidden_Bit;
                break;
            case k_Token_Advance_GoodyHutExcluded:
                m_flags0 |= k_Advance_GoodyHutExcluded_Bit;
                break;
            case k_Token_Advance_PowerPoints:
                if(!lex->GetIntAssignment(m_PowerPoints)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_PollutionSizeModifier:
                m_flags0 |= k_Advance_PollutionSizeModifier_Bit;
                if(!lex->GetFloatAssignment(m_PollutionSizeModifierValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_PollutionProductionModifier:
                m_flags0 |= k_Advance_PollutionProductionModifier_Bit;
                if(!lex->GetFloatAssignment(m_PollutionProductionModifierValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_TriggerFeat:
                m_flags0 |= k_Advance_TriggerFeat_Bit;
                if(!g_theFeatDB->GetRecordFromLexer(lex, m_TriggerFeatValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_IsMassMedia:
                m_flags0 |= k_Advance_IsMassMedia_Bit;
                break;
            case k_Token_Advance_EnablesGuerrillas:
                m_flags0 |= k_Advance_EnablesGuerrillas_Bit;
                break;
            case k_Token_Advance_KeyAdvanceAdvice:
                m_flags0 |= k_Advance_KeyAdvanceAdvice_Bit;
                if(!lex->GetStringIdAssignment(m_KeyAdvanceAdviceValue)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Cost)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void AdvanceRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisites; i++) {
            if(m_Prerequisites[i] & 0x80000000) {
                sint32 id = m_Prerequisites[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_Prerequisites[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Prerequisites[i] == 0x7fffffff){
                m_Prerequisites[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numDependencies; i++) {
            if(m_Dependencies[i] & 0x80000000) {
                sint32 id = m_Dependencies[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_Dependencies[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Dependencies[i] == 0x7fffffff){
                m_Dependencies[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numLeadsTo; i++) {
            if(m_LeadsTo[i] & 0x80000000) {
                sint32 id = m_LeadsTo[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_LeadsTo[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_LeadsTo[i] == 0x7fffffff){
                m_LeadsTo[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludesAdvance; i++) {
            if(m_ExcludesAdvance[i] & 0x80000000) {
                sint32 id = m_ExcludesAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ExcludesAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludesAdvance[i] == 0x7fffffff){
                m_ExcludesAdvance[i] = -1;
            }
        }
    }
    if(m_Icon & 0x80000000) {
        sint32 id = m_Icon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_Icon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Icon == 0x7fffffff) {
        m_Icon = -1;
    }
    if(m_Branch & 0x80000000) {
        sint32 id = m_Branch & 0x7fffffff;
        if(!g_theAdvanceBranchDB->GetNamedItem(id, m_Branch)) {
            c3errors_ErrorDialog("DB", "%s not found in AdvanceBranch database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Branch == 0x7fffffff) {
        m_Branch = -1;
    }
    if(m_Age & 0x80000000) {
        sint32 id = m_Age & 0x7fffffff;
        if(!g_theAgeDB->GetNamedItem(id, m_Age)) {
            c3errors_ErrorDialog("DB", "%s not found in Age database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Age == 0x7fffffff) {
        m_Age = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAnyCity; i++) {
            if(m_NeedsCityGoodAnyCity[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAnyCity[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAnyCity[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAnyCity[i] == 0x7fffffff){
                m_NeedsCityGoodAnyCity[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numEitherPrerequisites; i++) {
            if(m_EitherPrerequisites[i] & 0x80000000) {
                sint32 id = m_EitherPrerequisites[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_EitherPrerequisites[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_EitherPrerequisites[i] == 0x7fffffff){
                m_EitherPrerequisites[i] = -1;
            }
        }
    }
    if(m_TriggerFeatValue & 0x80000000) {
        sint32 id = m_TriggerFeatValue & 0x7fffffff;
        if(!g_theFeatDB->GetNamedItem(id, m_TriggerFeatValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_TriggerFeatValue == 0x7fffffff) {
        m_TriggerFeatValue = -1;
    }
}

void AdvanceRecord::Merge(const AdvanceRecord & rval){
    if (rval.m_numPrerequisites > 0)
        std::copy(rval.m_Prerequisites, rval.m_Prerequisites + rval.m_numPrerequisites, m_Prerequisites);

    // resize m_Dependencies if necessary
    if (rval.m_numDependencies > m_numDependencies)
    {
        delete [] m_Dependencies;
        m_Dependencies = NULL;
        if (rval.m_numDependencies > 0)
            m_Dependencies = new sint32 [rval.m_numDependencies];
        m_numDependencies = rval.m_numDependencies;
    }
    if (rval.m_numDependencies > 0)
        std::copy(rval.m_Dependencies, rval.m_Dependencies + rval.m_numDependencies, m_Dependencies);

    // resize m_LeadsTo if necessary
    if (rval.m_numLeadsTo > m_numLeadsTo)
    {
        delete [] m_LeadsTo;
        m_LeadsTo = NULL;
        if (rval.m_numLeadsTo > 0)
            m_LeadsTo = new sint32 [rval.m_numLeadsTo];
        m_numLeadsTo = rval.m_numLeadsTo;
    }
    if (rval.m_numLeadsTo > 0)
        std::copy(rval.m_LeadsTo, rval.m_LeadsTo + rval.m_numLeadsTo, m_LeadsTo);

    // resize m_ExcludesAdvance if necessary
    if (rval.m_numExcludesAdvance > m_numExcludesAdvance)
    {
        delete [] m_ExcludesAdvance;
        m_ExcludesAdvance = NULL;
        if (rval.m_numExcludesAdvance > 0)
            m_ExcludesAdvance = new sint32 [rval.m_numExcludesAdvance];
        m_numExcludesAdvance = rval.m_numExcludesAdvance;
    }
    if (rval.m_numExcludesAdvance > 0)
        std::copy(rval.m_ExcludesAdvance, rval.m_ExcludesAdvance + rval.m_numExcludesAdvance, m_ExcludesAdvance);

    // resize m_CultureOnly if necessary
    if (rval.m_numCultureOnly > m_numCultureOnly)
    {
        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
        m_numCultureOnly = rval.m_numCultureOnly;
    }
    if (rval.m_numCultureOnly > 0)
        std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);

    // resize m_GovernmentType if necessary
    if (rval.m_numGovernmentType > m_numGovernmentType)
    {
        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
        m_numGovernmentType = rval.m_numGovernmentType;
    }
    if (rval.m_numGovernmentType > 0)
        std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);

    // resize m_NeedsCityGoodAnyCity if necessary
    if (rval.m_numNeedsCityGoodAnyCity > m_numNeedsCityGoodAnyCity)
    {
        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;
    }
    if (rval.m_numNeedsCityGoodAnyCity > 0)
        std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);

    if (rval.m_numEitherPrerequisites > 0)
        std::copy(rval.m_EitherPrerequisites, rval.m_EitherPrerequisites + rval.m_numEitherPrerequisites, m_EitherPrerequisites);

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_ProductionPercent_Bit)
    {
        m_ProductionPercentValue = rval.m_ProductionPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_FoodPercent_Bit)
    {
        m_FoodPercentValue = rval.m_FoodPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_CommercePercent_Bit)
    {
        m_CommercePercentValue = rval.m_CommercePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_SciencePercent_Bit)
    {
        m_SciencePercentValue = rval.m_SciencePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_PollutionSizeModifier_Bit)
    {
        m_PollutionSizeModifierValue = rval.m_PollutionSizeModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_PollutionProductionModifier_Bit)
    {
        m_PollutionProductionModifierValue = rval.m_PollutionProductionModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_TriggerFeat_Bit)
    {
        m_TriggerFeatValue = rval.m_TriggerFeatValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Advance_KeyAdvanceAdvice_Bit)
    {
        m_KeyAdvanceAdviceValue = rval.m_KeyAdvanceAdviceValue;
    }

}

sint32 AdvanceRecord::GetPrerequisitesIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisites);
    if((index < 0) || (index >= m_numPrerequisites)) {
        return 0;
    }
    return m_Prerequisites[index];
}

AdvanceRecord const * AdvanceRecord::GetPrerequisites(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisites);
    if((index < 0) || (index >= m_numPrerequisites)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_Prerequisites[index]);
}

sint32 AdvanceRecord::GetDependenciesIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numDependencies);
    if((index < 0) || (index >= m_numDependencies)) {
        return 0;
    }
    return m_Dependencies[index];
}

AdvanceRecord const * AdvanceRecord::GetDependencies(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numDependencies);
    if((index < 0) || (index >= m_numDependencies)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_Dependencies[index]);
}

sint32 AdvanceRecord::GetLeadsToIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numLeadsTo);
    if((index < 0) || (index >= m_numLeadsTo)) {
        return 0;
    }
    return m_LeadsTo[index];
}

AdvanceRecord const * AdvanceRecord::GetLeadsTo(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numLeadsTo);
    if((index < 0) || (index >= m_numLeadsTo)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_LeadsTo[index]);
}

sint32 AdvanceRecord::GetExcludesAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludesAdvance);
    if((index < 0) || (index >= m_numExcludesAdvance)) {
        return 0;
    }
    return m_ExcludesAdvance[index];
}

AdvanceRecord const * AdvanceRecord::GetExcludesAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludesAdvance);
    if((index < 0) || (index >= m_numExcludesAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ExcludesAdvance[index]);
}

IconRecord const * AdvanceRecord::GetIcon() const
{
    return g_theIconDB->Get(m_Icon);
}

AdvanceBranchRecord const * AdvanceRecord::GetBranch() const
{
    return g_theAdvanceBranchDB->Get(m_Branch);
}

AgeRecord const * AdvanceRecord::GetAge() const
{
    return g_theAgeDB->Get(m_Age);
}

sint32 AdvanceRecord::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

CityStyleRecord const * AdvanceRecord::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

sint32 AdvanceRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

GovernmentRecord const * AdvanceRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

sint32 AdvanceRecord::GetNeedsCityGoodAnyCityIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return m_NeedsCityGoodAnyCity[index];
}

ResourceRecord const * AdvanceRecord::GetNeedsCityGoodAnyCity(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAnyCity[index]);
}

sint32 AdvanceRecord::GetEitherPrerequisitesIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEitherPrerequisites);
    if((index < 0) || (index >= m_numEitherPrerequisites)) {
        return 0;
    }
    return m_EitherPrerequisites[index];
}

AdvanceRecord const * AdvanceRecord::GetEitherPrerequisites(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEitherPrerequisites);
    if((index < 0) || (index >= m_numEitherPrerequisites)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_EitherPrerequisites[index]);
}

FeatRecord const * AdvanceRecord::GetTriggerFeatPtr() const
{
    return g_theFeatDB->Get(m_TriggerFeatValue);
}

