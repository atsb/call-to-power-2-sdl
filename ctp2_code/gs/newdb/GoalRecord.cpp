
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "GoalRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "OrderRecord.h"
#include "WonderRecord.h"

CTPDatabase<GoalRecord> *g_theGoalDB = NULL;

void GoalRecord::Init()
{
    m_flags0 = 0;
    m_SquadClass = 0;
    m_TargetType = 0;
    m_TargetOwner = 0;
    m_Execute = 0x7fffffff;
    m_ThreatBonus = 0;
    m_EnemyValueBonus = 0;
    m_AlliedValueBonus = 0;
    m_PowerBonus = 0;
    m_DistanceToHomeBonus = 0;
    m_DistanceToEnemyBonus = 0;
    m_InHomeTerritoryBonus = 0;
    m_NoOwnerTerritoryBonus = 0;
    m_InEnemyTerritoryBonus = 0;
    m_WoundedArmyBonus = 0;
    m_NotVisibleBonus = 0;
    m_InVisionRangeBonus = 0;
    m_NoBarbarianBonus = 0;
    m_CanAttackBonus = 0;
    m_SlaveryProtectionBonus = 0;
    m_SmallCitySizeBonus = 0;
    m_GarrisonBonus = 0;
    memset(&m_ConnectionBoniValue, 0, sizeof(m_ConnectionBoniValue));
    m_ChokePointBonus = 0;
    m_UnexploredBonus = 0;
    m_ObsoleteArmyBonus = 0;
    m_TreaspassingArmyBonus = 0;
    m_ThreatenType = 0;
    m_ThreatenBonus = 0;
    m_ForceMatch = 0;
    m_TargetProtectionWonderValue = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void GoalRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_SquadClass;
        archive << m_TargetType;
        archive << m_TargetOwner;
        archive << m_Execute;
        archive << m_ThreatBonus;
        archive << m_EnemyValueBonus;
        archive << m_AlliedValueBonus;
        archive << m_PowerBonus;
        archive << m_DistanceToHomeBonus;
        archive << m_DistanceToEnemyBonus;
        archive << m_InHomeTerritoryBonus;
        archive << m_NoOwnerTerritoryBonus;
        archive << m_InEnemyTerritoryBonus;
        archive << m_WoundedArmyBonus;
        archive << m_NotVisibleBonus;
        archive << m_InVisionRangeBonus;
        archive << m_NoBarbarianBonus;
        archive << m_CanAttackBonus;
        archive << m_SlaveryProtectionBonus;
        archive << m_SmallCitySizeBonus;
        archive << m_GarrisonBonus;
        m_ConnectionBoniValue.Serialize(archive);
        archive << m_ChokePointBonus;
        archive << m_UnexploredBonus;
        archive << m_ObsoleteArmyBonus;
        archive << m_TreaspassingArmyBonus;
        archive << m_ThreatenType;
        archive << m_ThreatenBonus;
        archive << m_ForceMatch;
        archive << m_TargetProtectionWonderValue;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_SquadClass;
        archive >> m_TargetType;
        archive >> m_TargetOwner;
        archive >> m_Execute;
        archive >> m_ThreatBonus;
        archive >> m_EnemyValueBonus;
        archive >> m_AlliedValueBonus;
        archive >> m_PowerBonus;
        archive >> m_DistanceToHomeBonus;
        archive >> m_DistanceToEnemyBonus;
        archive >> m_InHomeTerritoryBonus;
        archive >> m_NoOwnerTerritoryBonus;
        archive >> m_InEnemyTerritoryBonus;
        archive >> m_WoundedArmyBonus;
        archive >> m_NotVisibleBonus;
        archive >> m_InVisionRangeBonus;
        archive >> m_NoBarbarianBonus;
        archive >> m_CanAttackBonus;
        archive >> m_SlaveryProtectionBonus;
        archive >> m_SmallCitySizeBonus;
        archive >> m_GarrisonBonus;
        memset((uint8*)&m_ConnectionBoniValue, 0, sizeof(m_ConnectionBoniValue));
        m_ConnectionBoniValue.Serialize(archive);
        archive >> m_ChokePointBonus;
        archive >> m_UnexploredBonus;
        archive >> m_ObsoleteArmyBonus;
        archive >> m_TreaspassingArmyBonus;
        archive >> m_ThreatenType;
        archive >> m_ThreatenBonus;
        archive >> m_ForceMatch;
        archive >> m_TargetProtectionWonderValue;
    }
}

GoalRecord::~GoalRecord()
{
}

GoalRecord const & GoalRecord::operator = (GoalRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_SquadClass = rval.m_SquadClass;

        m_TargetType = rval.m_TargetType;

        m_TargetOwner = rval.m_TargetOwner;

        m_Execute = rval.m_Execute;

        m_ThreatBonus = rval.m_ThreatBonus;

        m_EnemyValueBonus = rval.m_EnemyValueBonus;

        m_AlliedValueBonus = rval.m_AlliedValueBonus;

        m_PowerBonus = rval.m_PowerBonus;

        m_DistanceToHomeBonus = rval.m_DistanceToHomeBonus;

        m_DistanceToEnemyBonus = rval.m_DistanceToEnemyBonus;

        m_InHomeTerritoryBonus = rval.m_InHomeTerritoryBonus;

        m_NoOwnerTerritoryBonus = rval.m_NoOwnerTerritoryBonus;

        m_InEnemyTerritoryBonus = rval.m_InEnemyTerritoryBonus;

        m_WoundedArmyBonus = rval.m_WoundedArmyBonus;

        m_NotVisibleBonus = rval.m_NotVisibleBonus;

        m_InVisionRangeBonus = rval.m_InVisionRangeBonus;

        m_NoBarbarianBonus = rval.m_NoBarbarianBonus;

        m_CanAttackBonus = rval.m_CanAttackBonus;

        m_SlaveryProtectionBonus = rval.m_SlaveryProtectionBonus;

        m_SmallCitySizeBonus = rval.m_SmallCitySizeBonus;

        m_GarrisonBonus = rval.m_GarrisonBonus;

        m_ConnectionBoniValue = rval.m_ConnectionBoniValue;

        m_ChokePointBonus = rval.m_ChokePointBonus;

        m_UnexploredBonus = rval.m_UnexploredBonus;

        m_ObsoleteArmyBonus = rval.m_ObsoleteArmyBonus;

        m_TreaspassingArmyBonus = rval.m_TreaspassingArmyBonus;

        m_ThreatenType = rval.m_ThreatenType;

        m_ThreatenBonus = rval.m_ThreatenBonus;

        m_ForceMatch = rval.m_ForceMatch;

        m_TargetProtectionWonderValue = rval.m_TargetProtectionWonderValue;

    }

    return *this;
}

const char *g_Goal_Tokens[] =
{
    "NeedsEscort",
    "IsSally",
    "AvoidWatchfulCity",
    "ExecuteIncrementally",
    "NeverSatisfied",
    "RemoveWhenComplete",
    "RallyFirst",
    "NoTransport",
    "UnGroupFirst",
    "NoRollback",
    "HasTransportersOrNoCoastalCities",
    "IsGlobalGoal",
    "NeedsRoom",
    "InField",
    "SquadClass",
    "TargetType",
    "TargetOwner",
    "Execute",
    "ThreatBonus",
    "EnemyValueBonus",
    "AlliedValueBonus",
    "PowerBonus",
    "DistanceToHomeBonus",
    "DistanceToEnemyBonus",
    "InHomeTerritoryBonus",
    "NoOwnerTerritoryBonus",
    "InEnemyTerritoryBonus",
    "WoundedArmyBonus",
    "NotVisibleBonus",
    "InVisionRangeBonus",
    "NoBarbarianBonus",
    "CanAttackBonus",
    "SlaveryProtectionBonus",
    "SmallCitySizeBonus",
    "GarrisonBonus",
    "ConnectionBoni",
    "ConnectionBoniValue",
    "ChokePointBonus",
    "UnexploredBonus",
    "ObsoleteArmyBonus",
    "TreaspassingArmyBonus",
    "ThreatenType",
    "ThreatenBonus",
    "ForceMatch",
    "TargetProtectionWonder",
    "TargetProtectionWonderValue",
};

GoalRecordAccessorInfo g_GoalRecord_Accessors[] =
{
    { NULL, &GoalRecord::GetNeedsEscort, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetIsSally, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetAvoidWatchfulCity, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetExecuteIncrementally, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetNeverSatisfied, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetRemoveWhenComplete, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetRallyFirst, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetNoTransport, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetUnGroupFirst, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetNoRollback, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetHasTransportersOrNoCoastalCities, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetIsGlobalGoal, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetNeedsRoom, NULL, NULL, NULL, NULL, NULL },
    { NULL, &GoalRecord::GetInField, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SquadClass */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TargetType */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TargetOwner */
    { &GoalRecord::GetExecuteIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetThreatBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetEnemyValueBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetAlliedValueBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetPowerBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetDistanceToHomeBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetDistanceToEnemyBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetInHomeTerritoryBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetNoOwnerTerritoryBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetInEnemyTerritoryBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetWoundedArmyBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetNotVisibleBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetInVisionRangeBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetNoBarbarianBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetCanAttackBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetSlaveryProtectionBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetSmallCitySizeBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetGarrisonBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConnectionBoni */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConnectionBoni */
    { &GoalRecord::GetChokePointBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetUnexploredBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetObsoleteArmyBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &GoalRecord::GetTreaspassingArmyBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ThreatenType */
    { &GoalRecord::GetThreatenBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ForceMatch */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TargetProtectionWonder */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TargetProtectionWonder */
};

#define k_Token_Goal_NeedsEscort                 ((k_Token_Custom_Base) + 0)
#define k_Token_Goal_IsSally                     ((k_Token_Custom_Base) + 1)
#define k_Token_Goal_AvoidWatchfulCity           ((k_Token_Custom_Base) + 2)
#define k_Token_Goal_ExecuteIncrementally        ((k_Token_Custom_Base) + 3)
#define k_Token_Goal_NeverSatisfied              ((k_Token_Custom_Base) + 4)
#define k_Token_Goal_RemoveWhenComplete          ((k_Token_Custom_Base) + 5)
#define k_Token_Goal_RallyFirst                  ((k_Token_Custom_Base) + 6)
#define k_Token_Goal_NoTransport                 ((k_Token_Custom_Base) + 7)
#define k_Token_Goal_UnGroupFirst                ((k_Token_Custom_Base) + 8)
#define k_Token_Goal_NoRollback                  ((k_Token_Custom_Base) + 9)
#define k_Token_Goal_HasTransportersOrNoCoastalCities ((k_Token_Custom_Base) + 10)
#define k_Token_Goal_IsGlobalGoal                ((k_Token_Custom_Base) + 11)
#define k_Token_Goal_NeedsRoom                   ((k_Token_Custom_Base) + 12)
#define k_Token_Goal_InField                     ((k_Token_Custom_Base) + 13)
#define k_Token_Goal_SquadClass                  ((k_Token_Custom_Base) + 14)
#define k_Token_Goal_TargetType                  ((k_Token_Custom_Base) + 15)
#define k_Token_Goal_TargetOwner                 ((k_Token_Custom_Base) + 16)
#define k_Token_Goal_Execute                     ((k_Token_Custom_Base) + 17)
#define k_Token_Goal_ThreatBonus                 ((k_Token_Custom_Base) + 18)
#define k_Token_Goal_EnemyValueBonus             ((k_Token_Custom_Base) + 19)
#define k_Token_Goal_AlliedValueBonus            ((k_Token_Custom_Base) + 20)
#define k_Token_Goal_PowerBonus                  ((k_Token_Custom_Base) + 21)
#define k_Token_Goal_DistanceToHomeBonus         ((k_Token_Custom_Base) + 22)
#define k_Token_Goal_DistanceToEnemyBonus        ((k_Token_Custom_Base) + 23)
#define k_Token_Goal_InHomeTerritoryBonus        ((k_Token_Custom_Base) + 24)
#define k_Token_Goal_NoOwnerTerritoryBonus       ((k_Token_Custom_Base) + 25)
#define k_Token_Goal_InEnemyTerritoryBonus       ((k_Token_Custom_Base) + 26)
#define k_Token_Goal_WoundedArmyBonus            ((k_Token_Custom_Base) + 27)
#define k_Token_Goal_NotVisibleBonus             ((k_Token_Custom_Base) + 28)
#define k_Token_Goal_InVisionRangeBonus          ((k_Token_Custom_Base) + 29)
#define k_Token_Goal_NoBarbarianBonus            ((k_Token_Custom_Base) + 30)
#define k_Token_Goal_CanAttackBonus              ((k_Token_Custom_Base) + 31)
#define k_Token_Goal_SlaveryProtectionBonus      ((k_Token_Custom_Base) + 32)
#define k_Token_Goal_SmallCitySizeBonus          ((k_Token_Custom_Base) + 33)
#define k_Token_Goal_GarrisonBonus               ((k_Token_Custom_Base) + 34)
#define k_Token_Goal_ConnectionBoni              ((k_Token_Custom_Base) + 35)
#define k_Token_Goal_ConnectionBoni_Value        ((k_Token_Custom_Base) + 36)
#define k_Token_Goal_ChokePointBonus             ((k_Token_Custom_Base) + 37)
#define k_Token_Goal_UnexploredBonus             ((k_Token_Custom_Base) + 38)
#define k_Token_Goal_ObsoleteArmyBonus           ((k_Token_Custom_Base) + 39)
#define k_Token_Goal_TreaspassingArmyBonus       ((k_Token_Custom_Base) + 40)
#define k_Token_Goal_ThreatenType                ((k_Token_Custom_Base) + 41)
#define k_Token_Goal_ThreatenBonus               ((k_Token_Custom_Base) + 42)
#define k_Token_Goal_ForceMatch                  ((k_Token_Custom_Base) + 43)
#define k_Token_Goal_TargetProtectionWonder      ((k_Token_Custom_Base) + 44)
#define k_Token_Goal_TargetProtectionWonder_Value ((k_Token_Custom_Base) + 45)
#define k_Token_Goal_Max                         ((k_Token_Custom_Base) + 46)


static BitArray s_ParsedTokens(46);
void GoalRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Goal_ThreatBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ThreatBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_EnemyValueBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field EnemyValueBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_AlliedValueBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field AlliedValueBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_PowerBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field PowerBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_DistanceToHomeBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field DistanceToHomeBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_DistanceToEnemyBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field DistanceToEnemyBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_ChokePointBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ChokePointBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_UnexploredBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field UnexploredBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_ObsoleteArmyBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ObsoleteArmyBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_TreaspassingArmyBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field TreaspassingArmyBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Goal_ThreatenBonus - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ThreatenBonus missing"));
    }
}

sint32 GoalRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Goal_Tokens, k_Token_Goal_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "GOAL_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Goal_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Goal_NeedsEscort:
                m_flags0 |= k_Goal_NeedsEscort_Bit;
                break;
            case k_Token_Goal_IsSally:
                m_flags0 |= k_Goal_IsSally_Bit;
                break;
            case k_Token_Goal_AvoidWatchfulCity:
                m_flags0 |= k_Goal_AvoidWatchfulCity_Bit;
                break;
            case k_Token_Goal_ExecuteIncrementally:
                m_flags0 |= k_Goal_ExecuteIncrementally_Bit;
                break;
            case k_Token_Goal_NeverSatisfied:
                m_flags0 |= k_Goal_NeverSatisfied_Bit;
                break;
            case k_Token_Goal_RemoveWhenComplete:
                m_flags0 |= k_Goal_RemoveWhenComplete_Bit;
                break;
            case k_Token_Goal_RallyFirst:
                m_flags0 |= k_Goal_RallyFirst_Bit;
                break;
            case k_Token_Goal_NoTransport:
                m_flags0 |= k_Goal_NoTransport_Bit;
                break;
            case k_Token_Goal_UnGroupFirst:
                m_flags0 |= k_Goal_UnGroupFirst_Bit;
                break;
            case k_Token_Goal_NoRollback:
                m_flags0 |= k_Goal_NoRollback_Bit;
                break;
            case k_Token_Goal_HasTransportersOrNoCoastalCities:
                m_flags0 |= k_Goal_HasTransportersOrNoCoastalCities_Bit;
                break;
            case k_Token_Goal_IsGlobalGoal:
                m_flags0 |= k_Goal_IsGlobalGoal_Bit;
                break;
            case k_Token_Goal_NeedsRoom:
                m_flags0 |= k_Goal_NeedsRoom_Bit;
                break;
            case k_Token_Goal_InField:
                m_flags0 |= k_Goal_InField_Bit;
                break;
            case k_Token_Goal_SquadClass:
                if(!ParseSquadClassBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_TargetType:
                if(!ParseTargetTypeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_TargetOwner:
                if(!ParseTargetOwnerBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_Execute:
                if (!g_theOrderDB->GetRecordFromLexer(lex, m_Execute)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_ThreatBonus:
                if(!lex->GetIntAssignment(m_ThreatBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_EnemyValueBonus:
                if(!lex->GetIntAssignment(m_EnemyValueBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_AlliedValueBonus:
                if(!lex->GetIntAssignment(m_AlliedValueBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_PowerBonus:
                if(!lex->GetIntAssignment(m_PowerBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_DistanceToHomeBonus:
                if(!lex->GetIntAssignment(m_DistanceToHomeBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_DistanceToEnemyBonus:
                if(!lex->GetIntAssignment(m_DistanceToEnemyBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_InHomeTerritoryBonus:
                if(!lex->GetIntAssignment(m_InHomeTerritoryBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_NoOwnerTerritoryBonus:
                if(!lex->GetIntAssignment(m_NoOwnerTerritoryBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_InEnemyTerritoryBonus:
                if(!lex->GetIntAssignment(m_InEnemyTerritoryBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_WoundedArmyBonus:
                if(!lex->GetIntAssignment(m_WoundedArmyBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_NotVisibleBonus:
                if(!lex->GetIntAssignment(m_NotVisibleBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_InVisionRangeBonus:
                if(!lex->GetIntAssignment(m_InVisionRangeBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_NoBarbarianBonus:
                if(!lex->GetIntAssignment(m_NoBarbarianBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_CanAttackBonus:
                if(!lex->GetIntAssignment(m_CanAttackBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_SlaveryProtectionBonus:
                if(!lex->GetIntAssignment(m_SlaveryProtectionBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_SmallCitySizeBonus:
                if(!lex->GetIntAssignment(m_SmallCitySizeBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_GarrisonBonus:
                if(!lex->GetIntAssignment(m_GarrisonBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_ConnectionBoni:
                m_flags0 |= k_Goal_ConnectionBoni_Bit;
                if(!m_ConnectionBoniValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_ChokePointBonus:
                if(!lex->GetIntAssignment(m_ChokePointBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_UnexploredBonus:
                if(!lex->GetIntAssignment(m_UnexploredBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_ObsoleteArmyBonus:
                if(!lex->GetIntAssignment(m_ObsoleteArmyBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_TreaspassingArmyBonus:
                if(!lex->GetIntAssignment(m_TreaspassingArmyBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_ThreatenType:
                if(!ParseThreatenTypeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_ThreatenBonus:
                if(!lex->GetIntAssignment(m_ThreatenBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Goal_ForceMatch:
                if(!ParseForceMatchBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_TargetProtectionWonder:
                m_flags0 |= k_Goal_TargetProtectionWonder_Bit;
                if(!g_theWonderDB->GetRecordFromLexer(lex, m_TargetProtectionWonderValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                m_flags0 |= k_Goal_NeedsEscort_Bit;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void GoalRecord::ResolveDBReferences()
{
    if(m_Execute & 0x80000000) {
        sint32 id = m_Execute & 0x7fffffff;
        if(!g_theOrderDB->GetNamedItem(id, m_Execute)) {
            c3errors_ErrorDialog("DB", "%s not found in Order database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Execute == 0x7fffffff) {
        m_Execute = -1;
    }
    m_ConnectionBoniValue.ResolveDBReferences();
    if(m_TargetProtectionWonderValue & 0x80000000) {
        sint32 id = m_TargetProtectionWonderValue & 0x7fffffff;
        if(!g_theWonderDB->GetNamedItem(id, m_TargetProtectionWonderValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_TargetProtectionWonderValue == 0x7fffffff) {
        m_TargetProtectionWonderValue = -1;
    }
}

GoalRecord::ConnectionBoni::ConnectionBoni()
{
    m_LandToCloseCityConnectionBonus = 0;
    m_CloseCityConnectionBonus = 0;
    m_SmallTargetEmpireBonus = 0;
    m_SmallTargetEmpireSize = 0;
    m_WeakestEnemyBonus = 0;
}

GoalRecord::ConnectionBoni::~ConnectionBoni()
{
}

GoalRecord::ConnectionBoni const & GoalRecord::ConnectionBoni::operator = (ConnectionBoni const & rval)
{
    if (this != &rval)
    {

        m_LandToCloseCityConnectionBonus = rval.m_LandToCloseCityConnectionBonus;

        m_CloseCityConnectionBonus = rval.m_CloseCityConnectionBonus;

        m_SmallTargetEmpireBonus = rval.m_SmallTargetEmpireBonus;

        m_SmallTargetEmpireSize = rval.m_SmallTargetEmpireSize;

        m_WeakestEnemyBonus = rval.m_WeakestEnemyBonus;

    }

    return *this;
}

void GoalRecord::ConnectionBoni::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_LandToCloseCityConnectionBonus;
        archive << m_CloseCityConnectionBonus;
        archive << m_SmallTargetEmpireBonus;
        archive << m_SmallTargetEmpireSize;
        archive << m_WeakestEnemyBonus;
    } else {
        archive >> m_LandToCloseCityConnectionBonus;
        archive >> m_CloseCityConnectionBonus;
        archive >> m_SmallTargetEmpireBonus;
        archive >> m_SmallTargetEmpireSize;
        archive >> m_WeakestEnemyBonus;
    }
}

static const char *s_Goal_ConnectionBoni_Tokens[] = {
    "LandToCloseCityConnectionBonus",
    "CloseCityConnectionBonus",
    "SmallTargetEmpireBonus",
    "SmallTargetEmpireSize",
    "WeakestEnemyBonus",
};
#define k_Token_Goal_ConnectionBoni_LandToCloseCityConnectionBonus ((k_Token_Custom_Base) + 0)
#define k_Token_Goal_ConnectionBoni_CloseCityConnectionBonus ((k_Token_Custom_Base) + 1)
#define k_Token_Goal_ConnectionBoni_SmallTargetEmpireBonus ((k_Token_Custom_Base) + 2)
#define k_Token_Goal_ConnectionBoni_SmallTargetEmpireSize ((k_Token_Custom_Base) + 3)
#define k_Token_Goal_ConnectionBoni_WeakestEnemyBonus ((k_Token_Custom_Base) + 4)
#define k_Token_Goal_ConnectionBoni_Max ((k_Token_Custom_Base) + 5)
sint32 GoalRecord::ConnectionBoni::ParseSequential(DBLexer *lex)
{
    if(!lex->GetIntAssignment(m_LandToCloseCityConnectionBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_CloseCityConnectionBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_SmallTargetEmpireBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_SmallTargetEmpireSize)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_WeakestEnemyBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 GoalRecord::ConnectionBoni::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetInt(m_LandToCloseCityConnectionBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_CloseCityConnectionBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_SmallTargetEmpireBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_SmallTargetEmpireSize)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_WeakestEnemyBonus)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 GoalRecord::ConnectionBoni::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for ConnectionBoni"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Goal_ConnectionBoni_Tokens, k_Token_Goal_ConnectionBoni_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Goal_ConnectionBoni_LandToCloseCityConnectionBonus:
                if(!lex->GetIntAssignment(m_LandToCloseCityConnectionBonus)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_ConnectionBoni_CloseCityConnectionBonus:
                if(!lex->GetIntAssignment(m_CloseCityConnectionBonus)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_ConnectionBoni_SmallTargetEmpireBonus:
                if(!lex->GetIntAssignment(m_SmallTargetEmpireBonus)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_ConnectionBoni_SmallTargetEmpireSize:
                if(!lex->GetIntAssignment(m_SmallTargetEmpireSize)) {
                    done = true; break;
                }
                break;
            case k_Token_Goal_ConnectionBoni_WeakestEnemyBonus:
                if(!lex->GetIntAssignment(m_WeakestEnemyBonus)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_LandToCloseCityConnectionBonus)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 GoalRecord::ConnectionBoni::ParseInArray(DBLexer *lex, ConnectionBoni **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ConnectionBoni *oldArray = *array;
        *array = new ConnectionBoni[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ConnectionBoni[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 GoalRecord::ConnectionBoni::ParseInArray(DBLexer *lex, ConnectionBoni *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 GoalRecord::ConnectionBoni::ParseInArraySequential(DBLexer *lex, ConnectionBoni **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ConnectionBoni *oldArray = *array;
        *array = new ConnectionBoni[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ConnectionBoni[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 GoalRecord::ConnectionBoni::ParseInArraySequential(DBLexer *lex, ConnectionBoni *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void GoalRecord::ConnectionBoni::ResolveDBReferences()
{
}

static const char *s_Goal_SquadClass_BitNames[] = {
    "CanExplore",
    "CanAttack",
    "CanDefend",
    "HasZoc",
    "CanCaptureCity",
    "CanBombard",
    "Special",
    "Stealth",
    "CanTransport",
};
#define k_Goal_SquadClass_Num_BitNames 9

sint32 GoalRecord::ParseSquadClassBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Goal_SquadClass_BitNames, k_Goal_SquadClass_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of SquadClass", lex->GetTokenText()));
        return 0;
    }
    m_SquadClass |= (1 << bitindex);
    return 1;
}

static const char *s_Goal_TargetType_BitNames[] = {
    "AttackUnit",
    "SpecialUnit",
    "SettleLand",
    "SettleSea",
    "City",
    "ChokePoint",
    "GoodyHut",
    "TradeRoute",
    "Improvement",
    "Unexplored",
    "Border",
    "Endgame",
    "PetrolStation",
    "Random",
};
#define k_Goal_TargetType_Num_BitNames 14

sint32 GoalRecord::ParseTargetTypeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Goal_TargetType_BitNames, k_Goal_TargetType_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of TargetType", lex->GetTokenText()));
        return 0;
    }
    m_TargetType |= (1 << bitindex);
    return 1;
}

static const char *s_Goal_TargetOwner_BitNames[] = {
    "Self",
    "Ally",
    "Neutral",
    "ColdEnemy",
    "HotEnemy",
    "NoContact",
};
#define k_Goal_TargetOwner_Num_BitNames 6

sint32 GoalRecord::ParseTargetOwnerBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Goal_TargetOwner_BitNames, k_Goal_TargetOwner_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of TargetOwner", lex->GetTokenText()));
        return 0;
    }
    m_TargetOwner |= (1 << bitindex);
    return 1;
}

static const char *s_Goal_ThreatenType_BitNames[] = {
    "AttackCity",
    "Pirate",
    "SpecialAttackCity",
    "DestroyCity",
    "None",
};
#define k_Goal_ThreatenType_Num_BitNames 5

sint32 GoalRecord::ParseThreatenTypeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Goal_ThreatenType_BitNames, k_Goal_ThreatenType_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of ThreatenType", lex->GetTokenText()));
        return 0;
    }
    m_ThreatenType |= (1 << bitindex);
    return 1;
}

static const char *s_Goal_ForceMatch_BitNames[] = {
    "Offensive",
    "Defensive",
    "StealthAttack",
    "Bombard",
    "Special",
    "Harass",
};
#define k_Goal_ForceMatch_Num_BitNames 6

sint32 GoalRecord::ParseForceMatchBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Goal_ForceMatch_BitNames, k_Goal_ForceMatch_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of ForceMatch", lex->GetTokenText()));
        return 0;
    }
    m_ForceMatch |= (1 << bitindex);
    return 1;
}

void GoalRecord::Merge(const GoalRecord & rval){
    // only replace values that have been set
    if (rval.m_SquadClass)
    {
        m_SquadClass = rval.m_SquadClass;
    }

    // only replace values that have been set
    if (rval.m_TargetType)
    {
        m_TargetType = rval.m_TargetType;
    }

    // only replace values that have been set
    if (rval.m_TargetOwner)
    {
        m_TargetOwner = rval.m_TargetOwner;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Goal_ConnectionBoni_Bit)
    {
        m_ConnectionBoniValue = rval.m_ConnectionBoniValue;
    }

    // only replace values that have been set
    if (rval.m_ThreatenType)
    {
        m_ThreatenType = rval.m_ThreatenType;
    }

    // only replace values that have been set
    if (rval.m_ForceMatch)
    {
        m_ForceMatch = rval.m_ForceMatch;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Goal_TargetProtectionWonder_Bit)
    {
        m_TargetProtectionWonderValue = rval.m_TargetProtectionWonderValue;
    }

}

OrderRecord const * GoalRecord::GetExecute() const
{
    return g_theOrderDB->Get(m_Execute);
}

WonderRecord const * GoalRecord::GetTargetProtectionWonderPtr() const
{
    return g_theWonderDB->Get(m_TargetProtectionWonderValue);
}

