
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "CultureRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "BuildingRecord.h"
#include "CityStyleRecord.h"
#include "GovernmentRecord.h"
#include "GovernmentRecord.h"
#include "CityStyleRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "CivilisationRecord.h"
#include "FeatRecord.h"
#include "FeatRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "WonderRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"

CTPDatabase<CultureRecord> *g_theCultureDB = NULL;

void CultureRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    m_CultureCost = 0;
    m_Description = 0;
    m_EnableAdvance = 0x7fffffff;
    memset(m_ObsoleteAdvance, 0, sizeof(m_ObsoleteAdvance));
    m_numObsoleteAdvance = 0;
    m_PrerequisiteBuilding = NULL;
    m_numPrerequisiteBuilding = 0;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    m_ObsoleteGovernmentType = NULL;
    m_numObsoleteGovernmentType = 0;
    m_CityStyleOnly = NULL;
    m_numCityStyleOnly = 0;
    m_NeedsCityGood = NULL;
    m_numNeedsCityGood = 0;
    m_NeedsCityGoodAll = NULL;
    m_numNeedsCityGoodAll = 0;
    m_NeedsCityGoodAnyCity = NULL;
    m_numNeedsCityGoodAnyCity = 0;
    m_EnablesGood = NULL;
    m_numEnablesGood = 0;
    m_CivilisationOnly = NULL;
    m_numCivilisationOnly = 0;
    m_NeedsFeatToBuild = NULL;
    m_numNeedsFeatToBuild = 0;
    m_NeedsAnyPlayerFeatToBuild = NULL;
    m_numNeedsAnyPlayerFeatToBuild = 0;
    m_SquaredBorderRadiusValue = 0;
    m_IntBorderRadiusValue = 0;
    m_ReduceReadinessCostValue = 0;
    m_DecCrimePercentValue = 0;
    m_IncKnowledgePercentValue = 0;
    m_DecEmpireSizeValue = 0;
    m_IncHappinessEmpireValue = 0;
    m_IncConvertedCitiesFeePercentValue = 0;
    m_GoldPerWaterTradeRouteValue = 0;
    m_GoldPerTelevisionValue = 0;
    m_GoldPerInternationalTradeRouteValue = 0;
    m_PollutersToParksValue = 0;
    m_ReduceWorldPollutionValue = 0;
    m_IncreaseBoatMovementValue = 0;
    m_DecreaseMaintenanceValue = 0;
    m_RandomAdvanceChanceValue = 0;
    m_IncreaseHpValue = 0;
    m_MultiplyTradeRoutesValue = 0;
    m_IncreaseScientistsValue = 0;
    m_OtherCivRandomAdvanceChanceValue = 0;
    m_IncreaseProductionValue = 0;
    m_BonusGoldValue = 0;
    m_IncreaseFoodAllCitiesValue = 0;
    m_TemporaryFullHappinessValue = 0;
    m_IncreaseSpecialistsValue = 0;
    m_IncreaseCathedralsValue = 0;
    m_IncreaseBrokeragesValue = 0;
    m_IncreaseRegardValue = 0;
    memset(&m_BuildingFeatValue, 0, sizeof(m_BuildingFeatValue));
    memset(&m_BuildingGoldValue, 0, sizeof(m_BuildingGoldValue));
    m_BuildingEverywhereValue = 0;
    m_ActualBuildingEverywhereValue = 0;
    m_BuildingEffectEverywhereValue = 0;
    m_ConflictsWithBuildingValue = 0;
    m_BuildingAnywhere = NULL;
    m_numBuildingAnywhere = 0;
    m_GoldPerBuildingAnywhereValue = 0;
    m_PollutionPercentValue = 0.000000;
    m_PollutionAmountValue = 0.000000;
    m_ExcludedByBuilding = NULL;
    m_numExcludedByBuilding = 0;
    m_ExcludedByWonder = NULL;
    m_numExcludedByWonder = 0;
    m_EnergyHungerValue = 0;
    m_ProducesEnergyValue = 0;
    m_EnergyHungerPerPopValue = 0;
    m_ProducesEnergyPerPopValue = 0;
    m_TooManyCitiesThresholdModifierValue = 0;
    m_TooManyCitiesCoefficientModifierValue = 0.000000;
    m_RiotLevelModifierValue = 0;
    m_OtherPlayerRiotLevelModifierValue = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void CultureRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_flags1;
        archive << m_flags2;
        archive << m_CultureCost;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Description);
            archive << tmpString;
        }

        archive << m_EnableAdvance;
        archive << m_numObsoleteAdvance;
        archive.Store((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive << m_numPrerequisiteBuilding;
        archive.Store((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_numGovernmentType;
        archive.Store((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive << m_numObsoleteGovernmentType;
        archive.Store((uint8*)m_ObsoleteGovernmentType, m_numObsoleteGovernmentType * sizeof(sint32));

        archive << m_numCityStyleOnly;
        archive.Store((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive << m_numNeedsCityGood;
        archive.Store((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive << m_numNeedsCityGoodAll;
        archive.Store((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive << m_numNeedsCityGoodAnyCity;
        archive.Store((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive << m_numEnablesGood;
        archive.Store((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive << m_numCivilisationOnly;
        archive.Store((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive << m_numNeedsFeatToBuild;
        archive.Store((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive << m_numNeedsAnyPlayerFeatToBuild;
        archive.Store((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive << m_SquaredBorderRadiusValue;
        archive << m_IntBorderRadiusValue;
        archive << m_ReduceReadinessCostValue;
        archive << m_DecCrimePercentValue;
        archive << m_IncKnowledgePercentValue;
        archive << m_DecEmpireSizeValue;
        archive << m_IncHappinessEmpireValue;
        archive << m_IncConvertedCitiesFeePercentValue;
        archive << m_GoldPerWaterTradeRouteValue;
        archive << m_GoldPerTelevisionValue;
        archive << m_GoldPerInternationalTradeRouteValue;
        archive << m_PollutersToParksValue;
        archive << m_ReduceWorldPollutionValue;
        archive << m_IncreaseBoatMovementValue;
        archive << m_DecreaseMaintenanceValue;
        archive << m_RandomAdvanceChanceValue;
        archive << m_IncreaseHpValue;
        archive << m_MultiplyTradeRoutesValue;
        archive << m_IncreaseScientistsValue;
        archive << m_OtherCivRandomAdvanceChanceValue;
        archive << m_IncreaseProductionValue;
        archive << m_BonusGoldValue;
        archive << m_IncreaseFoodAllCitiesValue;
        archive << m_TemporaryFullHappinessValue;
        archive << m_IncreaseSpecialistsValue;
        archive << m_IncreaseCathedralsValue;
        archive << m_IncreaseBrokeragesValue;
        archive << m_IncreaseRegardValue;
        m_BuildingFeatValue.Serialize(archive);
        m_BuildingGoldValue.Serialize(archive);
        archive << m_BuildingEverywhereValue;
        archive << m_ActualBuildingEverywhereValue;
        archive << m_BuildingEffectEverywhereValue;
        archive << m_ConflictsWithBuildingValue;
        archive << m_numBuildingAnywhere;
        archive.Store((uint8*)m_BuildingAnywhere, m_numBuildingAnywhere * sizeof(sint32));

        archive << m_GoldPerBuildingAnywhereValue;
        archive << m_PollutionPercentValue;
        archive << m_PollutionAmountValue;
        archive << m_numExcludedByBuilding;
        archive.Store((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive << m_numExcludedByWonder;
        archive.Store((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive << m_EnergyHungerValue;
        archive << m_ProducesEnergyValue;
        archive << m_EnergyHungerPerPopValue;
        archive << m_ProducesEnergyPerPopValue;
        archive << m_TooManyCitiesThresholdModifierValue;
        archive << m_TooManyCitiesCoefficientModifierValue;
        archive << m_RiotLevelModifierValue;
        archive << m_OtherPlayerRiotLevelModifierValue;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_flags2;
        archive >> m_CultureCost;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Description);
            delete[] tmpString;
        }

        archive >> m_EnableAdvance;
        archive >> m_numObsoleteAdvance;
        archive.Load((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive >> m_numPrerequisiteBuilding;
        archive.Load((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_numGovernmentType;
        archive.Load((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive >> m_numObsoleteGovernmentType;
        archive.Load((uint8*)m_ObsoleteGovernmentType, m_numObsoleteGovernmentType * sizeof(sint32));

        archive >> m_numCityStyleOnly;
        archive.Load((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive >> m_numNeedsCityGood;
        archive.Load((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive >> m_numNeedsCityGoodAll;
        archive.Load((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive >> m_numNeedsCityGoodAnyCity;
        archive.Load((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive >> m_numEnablesGood;
        archive.Load((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive >> m_numCivilisationOnly;
        archive.Load((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive >> m_numNeedsFeatToBuild;
        archive.Load((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive >> m_numNeedsAnyPlayerFeatToBuild;
        archive.Load((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive >> m_SquaredBorderRadiusValue;
        archive >> m_IntBorderRadiusValue;
        archive >> m_ReduceReadinessCostValue;
        archive >> m_DecCrimePercentValue;
        archive >> m_IncKnowledgePercentValue;
        archive >> m_DecEmpireSizeValue;
        archive >> m_IncHappinessEmpireValue;
        archive >> m_IncConvertedCitiesFeePercentValue;
        archive >> m_GoldPerWaterTradeRouteValue;
        archive >> m_GoldPerTelevisionValue;
        archive >> m_GoldPerInternationalTradeRouteValue;
        archive >> m_PollutersToParksValue;
        archive >> m_ReduceWorldPollutionValue;
        archive >> m_IncreaseBoatMovementValue;
        archive >> m_DecreaseMaintenanceValue;
        archive >> m_RandomAdvanceChanceValue;
        archive >> m_IncreaseHpValue;
        archive >> m_MultiplyTradeRoutesValue;
        archive >> m_IncreaseScientistsValue;
        archive >> m_OtherCivRandomAdvanceChanceValue;
        archive >> m_IncreaseProductionValue;
        archive >> m_BonusGoldValue;
        archive >> m_IncreaseFoodAllCitiesValue;
        archive >> m_TemporaryFullHappinessValue;
        archive >> m_IncreaseSpecialistsValue;
        archive >> m_IncreaseCathedralsValue;
        archive >> m_IncreaseBrokeragesValue;
        archive >> m_IncreaseRegardValue;
        memset((uint8*)&m_BuildingFeatValue, 0, sizeof(m_BuildingFeatValue));
        m_BuildingFeatValue.Serialize(archive);
        memset((uint8*)&m_BuildingGoldValue, 0, sizeof(m_BuildingGoldValue));
        m_BuildingGoldValue.Serialize(archive);
        archive >> m_BuildingEverywhereValue;
        archive >> m_ActualBuildingEverywhereValue;
        archive >> m_BuildingEffectEverywhereValue;
        archive >> m_ConflictsWithBuildingValue;
        archive >> m_numBuildingAnywhere;
        archive.Load((uint8*)m_BuildingAnywhere, m_numBuildingAnywhere * sizeof(sint32));

        archive >> m_GoldPerBuildingAnywhereValue;
        archive >> m_PollutionPercentValue;
        archive >> m_PollutionAmountValue;
        archive >> m_numExcludedByBuilding;
        archive.Load((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive >> m_numExcludedByWonder;
        archive.Load((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive >> m_EnergyHungerValue;
        archive >> m_ProducesEnergyValue;
        archive >> m_EnergyHungerPerPopValue;
        archive >> m_ProducesEnergyPerPopValue;
        archive >> m_TooManyCitiesThresholdModifierValue;
        archive >> m_TooManyCitiesCoefficientModifierValue;
        archive >> m_RiotLevelModifierValue;
        archive >> m_OtherPlayerRiotLevelModifierValue;
    }
}

CultureRecord::~CultureRecord()
{
    delete [] m_PrerequisiteBuilding;
    delete [] m_CultureOnly;
    delete [] m_GovernmentType;
    delete [] m_ObsoleteGovernmentType;
    delete [] m_CityStyleOnly;
    delete [] m_NeedsCityGood;
    delete [] m_NeedsCityGoodAll;
    delete [] m_NeedsCityGoodAnyCity;
    delete [] m_EnablesGood;
    delete [] m_CivilisationOnly;
    delete [] m_NeedsFeatToBuild;
    delete [] m_NeedsAnyPlayerFeatToBuild;
    delete [] m_BuildingAnywhere;
    delete [] m_ExcludedByBuilding;
    delete [] m_ExcludedByWonder;
}

CultureRecord const & CultureRecord::operator = (CultureRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;
        m_flags2 = rval.m_flags2;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_CultureCost = rval.m_CultureCost;

        m_Description = rval.m_Description;

        m_EnableAdvance = rval.m_EnableAdvance;

        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
        {
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
            std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);
        }
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
        {
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
            std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);
        }
        m_numGovernmentType = rval.m_numGovernmentType;

        delete [] m_ObsoleteGovernmentType;
        m_ObsoleteGovernmentType = NULL;
        if (rval.m_numObsoleteGovernmentType > 0)
        {
            m_ObsoleteGovernmentType = new sint32 [rval.m_numObsoleteGovernmentType];
            std::copy(rval.m_ObsoleteGovernmentType, rval.m_ObsoleteGovernmentType + rval.m_numObsoleteGovernmentType, m_ObsoleteGovernmentType);
        }
        m_numObsoleteGovernmentType = rval.m_numObsoleteGovernmentType;

        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
        {
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
            std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);
        }
        m_numCityStyleOnly = rval.m_numCityStyleOnly;

        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
        {
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
            std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);
        }
        m_numNeedsCityGood = rval.m_numNeedsCityGood;

        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
        {
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
            std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);
        }
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;

        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
        {
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
            std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);
        }
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;

        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
        {
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
            std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);
        }
        m_numEnablesGood = rval.m_numEnablesGood;

        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
        {
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
            std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);
        }
        m_numCivilisationOnly = rval.m_numCivilisationOnly;

        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
        {
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
            std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);
        }
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;

        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        {
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
            std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);
        }
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;

        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;

        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;

        m_ReduceReadinessCostValue = rval.m_ReduceReadinessCostValue;

        m_DecCrimePercentValue = rval.m_DecCrimePercentValue;

        m_IncKnowledgePercentValue = rval.m_IncKnowledgePercentValue;

        m_DecEmpireSizeValue = rval.m_DecEmpireSizeValue;

        m_IncHappinessEmpireValue = rval.m_IncHappinessEmpireValue;

        m_IncConvertedCitiesFeePercentValue = rval.m_IncConvertedCitiesFeePercentValue;

        m_GoldPerWaterTradeRouteValue = rval.m_GoldPerWaterTradeRouteValue;

        m_GoldPerTelevisionValue = rval.m_GoldPerTelevisionValue;

        m_GoldPerInternationalTradeRouteValue = rval.m_GoldPerInternationalTradeRouteValue;

        m_PollutersToParksValue = rval.m_PollutersToParksValue;

        m_ReduceWorldPollutionValue = rval.m_ReduceWorldPollutionValue;

        m_IncreaseBoatMovementValue = rval.m_IncreaseBoatMovementValue;

        m_DecreaseMaintenanceValue = rval.m_DecreaseMaintenanceValue;

        m_RandomAdvanceChanceValue = rval.m_RandomAdvanceChanceValue;

        m_IncreaseHpValue = rval.m_IncreaseHpValue;

        m_MultiplyTradeRoutesValue = rval.m_MultiplyTradeRoutesValue;

        m_IncreaseScientistsValue = rval.m_IncreaseScientistsValue;

        m_OtherCivRandomAdvanceChanceValue = rval.m_OtherCivRandomAdvanceChanceValue;

        m_IncreaseProductionValue = rval.m_IncreaseProductionValue;

        m_BonusGoldValue = rval.m_BonusGoldValue;

        m_IncreaseFoodAllCitiesValue = rval.m_IncreaseFoodAllCitiesValue;

        m_TemporaryFullHappinessValue = rval.m_TemporaryFullHappinessValue;

        m_IncreaseSpecialistsValue = rval.m_IncreaseSpecialistsValue;

        m_IncreaseCathedralsValue = rval.m_IncreaseCathedralsValue;

        m_IncreaseBrokeragesValue = rval.m_IncreaseBrokeragesValue;

        m_IncreaseRegardValue = rval.m_IncreaseRegardValue;

        m_BuildingFeatValue = rval.m_BuildingFeatValue;

        m_BuildingGoldValue = rval.m_BuildingGoldValue;

        m_BuildingEverywhereValue = rval.m_BuildingEverywhereValue;

        m_ActualBuildingEverywhereValue = rval.m_ActualBuildingEverywhereValue;

        m_BuildingEffectEverywhereValue = rval.m_BuildingEffectEverywhereValue;

        m_ConflictsWithBuildingValue = rval.m_ConflictsWithBuildingValue;

        delete [] m_BuildingAnywhere;
        m_BuildingAnywhere = NULL;
        if (rval.m_numBuildingAnywhere > 0)
        {
            m_BuildingAnywhere = new sint32 [rval.m_numBuildingAnywhere];
            std::copy(rval.m_BuildingAnywhere, rval.m_BuildingAnywhere + rval.m_numBuildingAnywhere, m_BuildingAnywhere);
        }
        m_numBuildingAnywhere = rval.m_numBuildingAnywhere;

        m_GoldPerBuildingAnywhereValue = rval.m_GoldPerBuildingAnywhereValue;

        m_PollutionPercentValue = rval.m_PollutionPercentValue;

        m_PollutionAmountValue = rval.m_PollutionAmountValue;

        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
        {
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
            std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);
        }
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;

        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
        {
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
            std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);
        }
        m_numExcludedByWonder = rval.m_numExcludedByWonder;

        m_EnergyHungerValue = rval.m_EnergyHungerValue;

        m_ProducesEnergyValue = rval.m_ProducesEnergyValue;

        m_EnergyHungerPerPopValue = rval.m_EnergyHungerPerPopValue;

        m_ProducesEnergyPerPopValue = rval.m_ProducesEnergyPerPopValue;

        m_TooManyCitiesThresholdModifierValue = rval.m_TooManyCitiesThresholdModifierValue;

        m_TooManyCitiesCoefficientModifierValue = rval.m_TooManyCitiesCoefficientModifierValue;

        m_RiotLevelModifierValue = rval.m_RiotLevelModifierValue;

        m_OtherPlayerRiotLevelModifierValue = rval.m_OtherPlayerRiotLevelModifierValue;

    }

    return *this;
}

const char *g_Culture_Tokens[] =
{
    "CultureCost",
    "Description",
    "IsCityBonus",
    "IsCivilizationBonus",
    "EnableAdvance",
    "ObsoleteAdvance",
    "PrerequisiteBuilding",
    "CultureOnly",
    "GovernmentType",
    "ObsoleteGovernmentType",
    "CityStyleOnly",
    "NeedsCityGood",
    "NeedsCityGoodAll",
    "NeedsCityGoodAnyCity",
    "EnablesGood",
    "CivilisationOnly",
    "NeedsFeatToBuild",
    "NeedsAnyPlayerFeatToBuild",
    "SquaredBorderRadius",
    "SquaredBorderRadiusValue",
    "IntBorderRadius",
    "IntBorderRadiusValue",
    "ReduceReadinessCost",
    "ReduceReadinessCostValue",
    "EmbassiesEverywhere",
    "DecCrimePercent",
    "DecCrimePercentValue",
    "IncKnowledgePercent",
    "IncKnowledgePercentValue",
    "DecEmpireSize",
    "DecEmpireSizeValue",
    "IncHappinessEmpire",
    "IncHappinessEmpireValue",
    "CloseEmbassies",
    "ReformCities",
    "FreeSlaves",
    "ProhibitSlavers",
    "IncConvertedCitiesFeePercent",
    "IncConvertedCitiesFeePercentValue",
    "GoldPerWaterTradeRoute",
    "GoldPerWaterTradeRouteValue",
    "GoldPerTelevision",
    "GoldPerTelevisionValue",
    "GlobalRadar",
    "SpiesEverywhere",
    "GoldPerInternationalTradeRoute",
    "GoldPerInternationalTradeRouteValue",
    "ProtectFromBiologicalWarfare",
    "PollutersToParks",
    "PollutersToParksValue",
    "EnableParkRangers",
    "ReduceWorldPollution",
    "ReduceWorldPollutionValue",
    "AllCitizensContent",
    "EliminateNukes",
    "AllBoatsDeepWater",
    "IncreaseBoatMovement",
    "IncreaseBoatMovementValue",
    "FreeTradeRoutes",
    "DecreaseMaintenance",
    "DecreaseMaintenanceValue",
    "RandomAdvanceChance",
    "RandomAdvanceChanceValue",
    "IncreaseHp",
    "IncreaseHpValue",
    "MultiplyTradeRoutes",
    "MultiplyTradeRoutesValue",
    "ForcefieldEverywhere",
    "IncreaseScientists",
    "IncreaseScientistsValue",
    "OtherCivRandomAdvanceChance",
    "OtherCivRandomAdvanceChanceValue",
    "IncreaseProduction",
    "IncreaseProductionValue",
    "BonusGold",
    "BonusGoldValue",
    "CantBuildInSea",
    "CantBuildOnLand",
    "CoastalBuilding",
    "EnablesPunativeAirstrikes",
    "IncreaseFoodAllCities",
    "IncreaseFoodAllCitiesValue",
    "TemporaryFullHappiness",
    "TemporaryFullHappinessValue",
    "RevoltingCitiesJoinPlayer",
    "NoPollutionUnhappiness",
    "EmbassiesEverywhereEvenAtWar",
    "IncreaseSpecialists",
    "IncreaseSpecialistsValue",
    "IncreaseCathedrals",
    "IncreaseCathedralsValue",
    "IncreaseBrokerages",
    "IncreaseBrokeragesValue",
    "IncreaseRegard",
    "IncreaseRegardValue",
    "PreventConversion",
    "ProtectFromBarbarians",
    "StartGaiaController",
    "GLHidden",
    "BuildingFeat",
    "BuildingFeatValue",
    "BuildingGold",
    "BuildingGoldValue",
    "BuildingEverywhere",
    "BuildingEverywhereValue",
    "ActualBuildingEverywhere",
    "ActualBuildingEverywhereValue",
    "BuildingEffectEverywhere",
    "BuildingEffectEverywhereValue",
    "ConflictsWithBuilding",
    "ConflictsWithBuildingValue",
    "BuildingAnywhere",
    "GoldPerBuildingAnywhere",
    "GoldPerBuildingAnywhereValue",
    "PollutionPercent",
    "PollutionPercentValue",
    "PollutionAmount",
    "PollutionAmountValue",
    "ExcludedByBuilding",
    "ExcludedByWonder",
    "EnergyHunger",
    "EnergyHungerValue",
    "ProducesEnergy",
    "ProducesEnergyValue",
    "EnergyHungerPerPop",
    "EnergyHungerPerPopValue",
    "ProducesEnergyPerPop",
    "ProducesEnergyPerPopValue",
    "TooManyCitiesThresholdModifier",
    "TooManyCitiesThresholdModifierValue",
    "TooManyCitiesCoefficientModifier",
    "TooManyCitiesCoefficientModifierValue",
    "RiotLevelModifier",
    "RiotLevelModifierValue",
    "OtherPlayerRiotLevelModifier",
    "OtherPlayerRiotLevelModifierValue",
};

CultureRecordAccessorInfo g_CultureRecord_Accessors[] =
{
    { &CultureRecord::GetCultureCost, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Description */
    { NULL, &CultureRecord::GetIsCityBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetIsCivilizationBonus, NULL, NULL, NULL, NULL, NULL },
    { &CultureRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CultureRecord::GetNumObsoleteAdvance, NULL, NULL, NULL, NULL, &CultureRecord::GetObsoleteAdvanceIndex, NULL}, /* ObsoleteAdvance (array) */
    { &CultureRecord::GetNumPrerequisiteBuilding, NULL, NULL, NULL, NULL, &CultureRecord::GetPrerequisiteBuildingIndex, NULL}, /* PrerequisiteBuilding (array) */
    { &CultureRecord::GetNumCultureOnly, NULL, NULL, NULL, NULL, &CultureRecord::GetCultureOnlyIndex, NULL}, /* CultureOnly (array) */
    { &CultureRecord::GetNumGovernmentType, NULL, NULL, NULL, NULL, &CultureRecord::GetGovernmentTypeIndex, NULL}, /* GovernmentType (array) */
    { &CultureRecord::GetNumObsoleteGovernmentType, NULL, NULL, NULL, NULL, &CultureRecord::GetObsoleteGovernmentTypeIndex, NULL}, /* ObsoleteGovernmentType (array) */
    { &CultureRecord::GetNumCityStyleOnly, NULL, NULL, NULL, NULL, &CultureRecord::GetCityStyleOnlyIndex, NULL}, /* CityStyleOnly (array) */
    { &CultureRecord::GetNumNeedsCityGood, NULL, NULL, NULL, NULL, &CultureRecord::GetNeedsCityGoodIndex, NULL}, /* NeedsCityGood (array) */
    { &CultureRecord::GetNumNeedsCityGoodAll, NULL, NULL, NULL, NULL, &CultureRecord::GetNeedsCityGoodAllIndex, NULL}, /* NeedsCityGoodAll (array) */
    { &CultureRecord::GetNumNeedsCityGoodAnyCity, NULL, NULL, NULL, NULL, &CultureRecord::GetNeedsCityGoodAnyCityIndex, NULL}, /* NeedsCityGoodAnyCity (array) */
    { &CultureRecord::GetNumEnablesGood, NULL, NULL, NULL, NULL, &CultureRecord::GetEnablesGoodIndex, NULL}, /* EnablesGood (array) */
    { &CultureRecord::GetNumCivilisationOnly, NULL, NULL, NULL, NULL, &CultureRecord::GetCivilisationOnlyIndex, NULL}, /* CivilisationOnly (array) */
    { &CultureRecord::GetNumNeedsFeatToBuild, NULL, NULL, NULL, NULL, &CultureRecord::GetNeedsFeatToBuildIndex, NULL}, /* NeedsFeatToBuild (array) */
    { &CultureRecord::GetNumNeedsAnyPlayerFeatToBuild, NULL, NULL, NULL, NULL, &CultureRecord::GetNeedsAnyPlayerFeatToBuildIndex, NULL}, /* NeedsAnyPlayerFeatToBuild (array) */
    { NULL, NULL, NULL, &CultureRecord::GetSquaredBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SquaredBorderRadius */
    { NULL, NULL, NULL, &CultureRecord::GetIntBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IntBorderRadius */
    { NULL, NULL, NULL, &CultureRecord::GetReduceReadinessCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ReduceReadinessCost */
    { NULL, &CultureRecord::GetEmbassiesEverywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetDecCrimePercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DecCrimePercent */
    { NULL, NULL, NULL, &CultureRecord::GetIncKnowledgePercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncKnowledgePercent */
    { NULL, NULL, NULL, &CultureRecord::GetDecEmpireSize, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DecEmpireSize */
    { NULL, NULL, NULL, &CultureRecord::GetIncHappinessEmpire, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncHappinessEmpire */
    { NULL, &CultureRecord::GetCloseEmbassies, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetReformCities, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetFreeSlaves, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetProhibitSlavers, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetIncConvertedCitiesFeePercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncConvertedCitiesFeePercent */
    { NULL, NULL, NULL, &CultureRecord::GetGoldPerWaterTradeRoute, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerWaterTradeRoute */
    { NULL, NULL, NULL, &CultureRecord::GetGoldPerTelevision, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerTelevision */
    { NULL, &CultureRecord::GetGlobalRadar, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetSpiesEverywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetGoldPerInternationalTradeRoute, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerInternationalTradeRoute */
    { NULL, &CultureRecord::GetProtectFromBiologicalWarfare, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetPollutersToParks, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutersToParks */
    { NULL, &CultureRecord::GetEnableParkRangers, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetReduceWorldPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ReduceWorldPollution */
    { NULL, &CultureRecord::GetAllCitizensContent, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetEliminateNukes, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetAllBoatsDeepWater, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseBoatMovement, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseBoatMovement */
    { NULL, &CultureRecord::GetFreeTradeRoutes, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetDecreaseMaintenance, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DecreaseMaintenance */
    { NULL, NULL, NULL, &CultureRecord::GetRandomAdvanceChance, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RandomAdvanceChance */
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseHp, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseHp */
    { NULL, NULL, NULL, &CultureRecord::GetMultiplyTradeRoutes, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MultiplyTradeRoutes */
    { NULL, &CultureRecord::GetForcefieldEverywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseScientists, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseScientists */
    { NULL, NULL, NULL, &CultureRecord::GetOtherCivRandomAdvanceChance, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OtherCivRandomAdvanceChance */
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseProduction, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseProduction */
    { NULL, NULL, NULL, &CultureRecord::GetBonusGold, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BonusGold */
    { NULL, &CultureRecord::GetCantBuildInSea, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetCantBuildOnLand, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetCoastalBuilding, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetEnablesPunativeAirstrikes, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseFoodAllCities, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseFoodAllCities */
    { NULL, NULL, NULL, &CultureRecord::GetTemporaryFullHappiness, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TemporaryFullHappiness */
    { NULL, &CultureRecord::GetRevoltingCitiesJoinPlayer, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetNoPollutionUnhappiness, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetEmbassiesEverywhereEvenAtWar, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseSpecialists, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseSpecialists */
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseCathedrals, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseCathedrals */
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseBrokerages, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseBrokerages */
    { NULL, NULL, NULL, &CultureRecord::GetIncreaseRegard, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseRegard */
    { NULL, &CultureRecord::GetPreventConversion, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetProtectFromBarbarians, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetStartGaiaController, NULL, NULL, NULL, NULL, NULL },
    { NULL, &CultureRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingFeat */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingFeat */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingGold */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingGold */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ActualBuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ActualBuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEffectEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEffectEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConflictsWithBuilding */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConflictsWithBuilding */
    { &CultureRecord::GetNumBuildingAnywhere, NULL, NULL, NULL, NULL, &CultureRecord::GetBuildingAnywhereIndex, NULL}, /* BuildingAnywhere (array) */
    { NULL, NULL, NULL, &CultureRecord::GetGoldPerBuildingAnywhere, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerBuildingAnywhere */
    { NULL, NULL, NULL, NULL, &CultureRecord::GetPollutionPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutionPercent */
    { NULL, NULL, NULL, NULL, &CultureRecord::GetPollutionAmount, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutionAmount */
    { &CultureRecord::GetNumExcludedByBuilding, NULL, NULL, NULL, NULL, &CultureRecord::GetExcludedByBuildingIndex, NULL}, /* ExcludedByBuilding (array) */
    { &CultureRecord::GetNumExcludedByWonder, NULL, NULL, NULL, NULL, &CultureRecord::GetExcludedByWonderIndex, NULL}, /* ExcludedByWonder (array) */
    { NULL, NULL, NULL, &CultureRecord::GetEnergyHunger, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EnergyHunger */
    { NULL, NULL, NULL, &CultureRecord::GetProducesEnergy, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProducesEnergy */
    { NULL, NULL, NULL, &CultureRecord::GetEnergyHungerPerPop, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EnergyHungerPerPop */
    { NULL, NULL, NULL, &CultureRecord::GetProducesEnergyPerPop, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProducesEnergyPerPop */
    { NULL, NULL, NULL, &CultureRecord::GetTooManyCitiesThresholdModifier, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TooManyCitiesThresholdModifier */
    { NULL, NULL, NULL, NULL, &CultureRecord::GetTooManyCitiesCoefficientModifier, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TooManyCitiesCoefficientModifier */
    { NULL, NULL, NULL, &CultureRecord::GetRiotLevelModifier, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RiotLevelModifier */
    { NULL, NULL, NULL, &CultureRecord::GetOtherPlayerRiotLevelModifier, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OtherPlayerRiotLevelModifier */
};

#define k_Token_Culture_CultureCost              ((k_Token_Custom_Base) + 0)
#define k_Token_Culture_Description              ((k_Token_Custom_Base) + 1)
#define k_Token_Culture_IsCityBonus              ((k_Token_Custom_Base) + 2)
#define k_Token_Culture_IsCivilizationBonus      ((k_Token_Custom_Base) + 3)
#define k_Token_Culture_EnableAdvance            ((k_Token_Custom_Base) + 4)
#define k_Token_Culture_ObsoleteAdvance          ((k_Token_Custom_Base) + 5)
#define k_Token_Culture_PrerequisiteBuilding     ((k_Token_Custom_Base) + 6)
#define k_Token_Culture_CultureOnly              ((k_Token_Custom_Base) + 7)
#define k_Token_Culture_GovernmentType           ((k_Token_Custom_Base) + 8)
#define k_Token_Culture_ObsoleteGovernmentType   ((k_Token_Custom_Base) + 9)
#define k_Token_Culture_CityStyleOnly            ((k_Token_Custom_Base) + 10)
#define k_Token_Culture_NeedsCityGood            ((k_Token_Custom_Base) + 11)
#define k_Token_Culture_NeedsCityGoodAll         ((k_Token_Custom_Base) + 12)
#define k_Token_Culture_NeedsCityGoodAnyCity     ((k_Token_Custom_Base) + 13)
#define k_Token_Culture_EnablesGood              ((k_Token_Custom_Base) + 14)
#define k_Token_Culture_CivilisationOnly         ((k_Token_Custom_Base) + 15)
#define k_Token_Culture_NeedsFeatToBuild         ((k_Token_Custom_Base) + 16)
#define k_Token_Culture_NeedsAnyPlayerFeatToBuild ((k_Token_Custom_Base) + 17)
#define k_Token_Culture_SquaredBorderRadius      ((k_Token_Custom_Base) + 18)
#define k_Token_Culture_SquaredBorderRadius_Value ((k_Token_Custom_Base) + 19)
#define k_Token_Culture_IntBorderRadius          ((k_Token_Custom_Base) + 20)
#define k_Token_Culture_IntBorderRadius_Value    ((k_Token_Custom_Base) + 21)
#define k_Token_Culture_ReduceReadinessCost      ((k_Token_Custom_Base) + 22)
#define k_Token_Culture_ReduceReadinessCost_Value ((k_Token_Custom_Base) + 23)
#define k_Token_Culture_EmbassiesEverywhere      ((k_Token_Custom_Base) + 24)
#define k_Token_Culture_DecCrimePercent          ((k_Token_Custom_Base) + 25)
#define k_Token_Culture_DecCrimePercent_Value    ((k_Token_Custom_Base) + 26)
#define k_Token_Culture_IncKnowledgePercent      ((k_Token_Custom_Base) + 27)
#define k_Token_Culture_IncKnowledgePercent_Value ((k_Token_Custom_Base) + 28)
#define k_Token_Culture_DecEmpireSize            ((k_Token_Custom_Base) + 29)
#define k_Token_Culture_DecEmpireSize_Value      ((k_Token_Custom_Base) + 30)
#define k_Token_Culture_IncHappinessEmpire       ((k_Token_Custom_Base) + 31)
#define k_Token_Culture_IncHappinessEmpire_Value ((k_Token_Custom_Base) + 32)
#define k_Token_Culture_CloseEmbassies           ((k_Token_Custom_Base) + 33)
#define k_Token_Culture_ReformCities             ((k_Token_Custom_Base) + 34)
#define k_Token_Culture_FreeSlaves               ((k_Token_Custom_Base) + 35)
#define k_Token_Culture_ProhibitSlavers          ((k_Token_Custom_Base) + 36)
#define k_Token_Culture_IncConvertedCitiesFeePercent ((k_Token_Custom_Base) + 37)
#define k_Token_Culture_IncConvertedCitiesFeePercent_Value ((k_Token_Custom_Base) + 38)
#define k_Token_Culture_GoldPerWaterTradeRoute   ((k_Token_Custom_Base) + 39)
#define k_Token_Culture_GoldPerWaterTradeRoute_Value ((k_Token_Custom_Base) + 40)
#define k_Token_Culture_GoldPerTelevision        ((k_Token_Custom_Base) + 41)
#define k_Token_Culture_GoldPerTelevision_Value  ((k_Token_Custom_Base) + 42)
#define k_Token_Culture_GlobalRadar              ((k_Token_Custom_Base) + 43)
#define k_Token_Culture_SpiesEverywhere          ((k_Token_Custom_Base) + 44)
#define k_Token_Culture_GoldPerInternationalTradeRoute ((k_Token_Custom_Base) + 45)
#define k_Token_Culture_GoldPerInternationalTradeRoute_Value ((k_Token_Custom_Base) + 46)
#define k_Token_Culture_ProtectFromBiologicalWarfare ((k_Token_Custom_Base) + 47)
#define k_Token_Culture_PollutersToParks         ((k_Token_Custom_Base) + 48)
#define k_Token_Culture_PollutersToParks_Value   ((k_Token_Custom_Base) + 49)
#define k_Token_Culture_EnableParkRangers        ((k_Token_Custom_Base) + 50)
#define k_Token_Culture_ReduceWorldPollution     ((k_Token_Custom_Base) + 51)
#define k_Token_Culture_ReduceWorldPollution_Value ((k_Token_Custom_Base) + 52)
#define k_Token_Culture_AllCitizensContent       ((k_Token_Custom_Base) + 53)
#define k_Token_Culture_EliminateNukes           ((k_Token_Custom_Base) + 54)
#define k_Token_Culture_AllBoatsDeepWater        ((k_Token_Custom_Base) + 55)
#define k_Token_Culture_IncreaseBoatMovement     ((k_Token_Custom_Base) + 56)
#define k_Token_Culture_IncreaseBoatMovement_Value ((k_Token_Custom_Base) + 57)
#define k_Token_Culture_FreeTradeRoutes          ((k_Token_Custom_Base) + 58)
#define k_Token_Culture_DecreaseMaintenance      ((k_Token_Custom_Base) + 59)
#define k_Token_Culture_DecreaseMaintenance_Value ((k_Token_Custom_Base) + 60)
#define k_Token_Culture_RandomAdvanceChance      ((k_Token_Custom_Base) + 61)
#define k_Token_Culture_RandomAdvanceChance_Value ((k_Token_Custom_Base) + 62)
#define k_Token_Culture_IncreaseHp               ((k_Token_Custom_Base) + 63)
#define k_Token_Culture_IncreaseHp_Value         ((k_Token_Custom_Base) + 64)
#define k_Token_Culture_MultiplyTradeRoutes      ((k_Token_Custom_Base) + 65)
#define k_Token_Culture_MultiplyTradeRoutes_Value ((k_Token_Custom_Base) + 66)
#define k_Token_Culture_ForcefieldEverywhere     ((k_Token_Custom_Base) + 67)
#define k_Token_Culture_IncreaseScientists       ((k_Token_Custom_Base) + 68)
#define k_Token_Culture_IncreaseScientists_Value ((k_Token_Custom_Base) + 69)
#define k_Token_Culture_OtherCivRandomAdvanceChance ((k_Token_Custom_Base) + 70)
#define k_Token_Culture_OtherCivRandomAdvanceChance_Value ((k_Token_Custom_Base) + 71)
#define k_Token_Culture_IncreaseProduction       ((k_Token_Custom_Base) + 72)
#define k_Token_Culture_IncreaseProduction_Value ((k_Token_Custom_Base) + 73)
#define k_Token_Culture_BonusGold                ((k_Token_Custom_Base) + 74)
#define k_Token_Culture_BonusGold_Value          ((k_Token_Custom_Base) + 75)
#define k_Token_Culture_CantBuildInSea           ((k_Token_Custom_Base) + 76)
#define k_Token_Culture_CantBuildOnLand          ((k_Token_Custom_Base) + 77)
#define k_Token_Culture_CoastalBuilding          ((k_Token_Custom_Base) + 78)
#define k_Token_Culture_EnablesPunativeAirstrikes ((k_Token_Custom_Base) + 79)
#define k_Token_Culture_IncreaseFoodAllCities    ((k_Token_Custom_Base) + 80)
#define k_Token_Culture_IncreaseFoodAllCities_Value ((k_Token_Custom_Base) + 81)
#define k_Token_Culture_TemporaryFullHappiness   ((k_Token_Custom_Base) + 82)
#define k_Token_Culture_TemporaryFullHappiness_Value ((k_Token_Custom_Base) + 83)
#define k_Token_Culture_RevoltingCitiesJoinPlayer ((k_Token_Custom_Base) + 84)
#define k_Token_Culture_NoPollutionUnhappiness   ((k_Token_Custom_Base) + 85)
#define k_Token_Culture_EmbassiesEverywhereEvenAtWar ((k_Token_Custom_Base) + 86)
#define k_Token_Culture_IncreaseSpecialists      ((k_Token_Custom_Base) + 87)
#define k_Token_Culture_IncreaseSpecialists_Value ((k_Token_Custom_Base) + 88)
#define k_Token_Culture_IncreaseCathedrals       ((k_Token_Custom_Base) + 89)
#define k_Token_Culture_IncreaseCathedrals_Value ((k_Token_Custom_Base) + 90)
#define k_Token_Culture_IncreaseBrokerages       ((k_Token_Custom_Base) + 91)
#define k_Token_Culture_IncreaseBrokerages_Value ((k_Token_Custom_Base) + 92)
#define k_Token_Culture_IncreaseRegard           ((k_Token_Custom_Base) + 93)
#define k_Token_Culture_IncreaseRegard_Value     ((k_Token_Custom_Base) + 94)
#define k_Token_Culture_PreventConversion        ((k_Token_Custom_Base) + 95)
#define k_Token_Culture_ProtectFromBarbarians    ((k_Token_Custom_Base) + 96)
#define k_Token_Culture_StartGaiaController      ((k_Token_Custom_Base) + 97)
#define k_Token_Culture_GLHidden                 ((k_Token_Custom_Base) + 98)
#define k_Token_Culture_BuildingFeat             ((k_Token_Custom_Base) + 99)
#define k_Token_Culture_BuildingFeat_Value       ((k_Token_Custom_Base) + 100)
#define k_Token_Culture_BuildingGold             ((k_Token_Custom_Base) + 101)
#define k_Token_Culture_BuildingGold_Value       ((k_Token_Custom_Base) + 102)
#define k_Token_Culture_BuildingEverywhere       ((k_Token_Custom_Base) + 103)
#define k_Token_Culture_BuildingEverywhere_Value ((k_Token_Custom_Base) + 104)
#define k_Token_Culture_ActualBuildingEverywhere ((k_Token_Custom_Base) + 105)
#define k_Token_Culture_ActualBuildingEverywhere_Value ((k_Token_Custom_Base) + 106)
#define k_Token_Culture_BuildingEffectEverywhere ((k_Token_Custom_Base) + 107)
#define k_Token_Culture_BuildingEffectEverywhere_Value ((k_Token_Custom_Base) + 108)
#define k_Token_Culture_ConflictsWithBuilding    ((k_Token_Custom_Base) + 109)
#define k_Token_Culture_ConflictsWithBuilding_Value ((k_Token_Custom_Base) + 110)
#define k_Token_Culture_BuildingAnywhere         ((k_Token_Custom_Base) + 111)
#define k_Token_Culture_GoldPerBuildingAnywhere  ((k_Token_Custom_Base) + 112)
#define k_Token_Culture_GoldPerBuildingAnywhere_Value ((k_Token_Custom_Base) + 113)
#define k_Token_Culture_PollutionPercent         ((k_Token_Custom_Base) + 114)
#define k_Token_Culture_PollutionPercent_Value   ((k_Token_Custom_Base) + 115)
#define k_Token_Culture_PollutionAmount          ((k_Token_Custom_Base) + 116)
#define k_Token_Culture_PollutionAmount_Value    ((k_Token_Custom_Base) + 117)
#define k_Token_Culture_ExcludedByBuilding       ((k_Token_Custom_Base) + 118)
#define k_Token_Culture_ExcludedByWonder         ((k_Token_Custom_Base) + 119)
#define k_Token_Culture_EnergyHunger             ((k_Token_Custom_Base) + 120)
#define k_Token_Culture_EnergyHunger_Value       ((k_Token_Custom_Base) + 121)
#define k_Token_Culture_ProducesEnergy           ((k_Token_Custom_Base) + 122)
#define k_Token_Culture_ProducesEnergy_Value     ((k_Token_Custom_Base) + 123)
#define k_Token_Culture_EnergyHungerPerPop       ((k_Token_Custom_Base) + 124)
#define k_Token_Culture_EnergyHungerPerPop_Value ((k_Token_Custom_Base) + 125)
#define k_Token_Culture_ProducesEnergyPerPop     ((k_Token_Custom_Base) + 126)
#define k_Token_Culture_ProducesEnergyPerPop_Value ((k_Token_Custom_Base) + 127)
#define k_Token_Culture_TooManyCitiesThresholdModifier ((k_Token_Custom_Base) + 128)
#define k_Token_Culture_TooManyCitiesThresholdModifier_Value ((k_Token_Custom_Base) + 129)
#define k_Token_Culture_TooManyCitiesCoefficientModifier ((k_Token_Custom_Base) + 130)
#define k_Token_Culture_TooManyCitiesCoefficientModifier_Value ((k_Token_Custom_Base) + 131)
#define k_Token_Culture_RiotLevelModifier        ((k_Token_Custom_Base) + 132)
#define k_Token_Culture_RiotLevelModifier_Value  ((k_Token_Custom_Base) + 133)
#define k_Token_Culture_OtherPlayerRiotLevelModifier ((k_Token_Custom_Base) + 134)
#define k_Token_Culture_OtherPlayerRiotLevelModifier_Value ((k_Token_Custom_Base) + 135)
#define k_Token_Culture_Max                      ((k_Token_Custom_Base) + 136)


static BitArray s_ParsedTokens(136);
void CultureRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Culture_CultureCost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field CultureCost missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Culture_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
}

sint32 CultureRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Culture_Tokens, k_Token_Culture_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "CULTURE_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Culture_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Culture_CultureCost:
                if(!lex->GetIntAssignment(m_CultureCost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IsCityBonus:
                m_flags0 |= k_Culture_IsCityBonus_Bit;
                break;
            case k_Token_Culture_IsCivilizationBonus:
                m_flags0 |= k_Culture_IsCivilizationBonus_Bit;
                break;
            case k_Token_Culture_EnableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Culture_ObsoleteAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_ObsoleteAdvance, &m_numObsoleteAdvance, k_MAX_ObsoleteAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Culture_PrerequisiteBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteBuilding, &m_numPrerequisiteBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CultureOnly, &m_numCultureOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_ObsoleteGovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_ObsoleteGovernmentType, &m_numObsoleteGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_CityStyleOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CityStyleOnly, &m_numCityStyleOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_NeedsCityGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGood, &m_numNeedsCityGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_NeedsCityGoodAll:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAll, &m_numNeedsCityGoodAll))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_NeedsCityGoodAnyCity:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAnyCity, &m_numNeedsCityGoodAnyCity))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_EnablesGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_EnablesGood, &m_numEnablesGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_CivilisationOnly:
                if(!g_theCivilisationDB->ParseRecordInArray(lex, (sint32 **)&m_CivilisationOnly, &m_numCivilisationOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_NeedsFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsFeatToBuild, &m_numNeedsFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_NeedsAnyPlayerFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsAnyPlayerFeatToBuild, &m_numNeedsAnyPlayerFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_SquaredBorderRadius:
                m_flags0 |= k_Culture_SquaredBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_SquaredBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IntBorderRadius:
                m_flags0 |= k_Culture_IntBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_IntBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ReduceReadinessCost:
                m_flags0 |= k_Culture_ReduceReadinessCost_Bit;
                if(!lex->GetIntAssignment(m_ReduceReadinessCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_EmbassiesEverywhere:
                m_flags0 |= k_Culture_EmbassiesEverywhere_Bit;
                break;
            case k_Token_Culture_DecCrimePercent:
                m_flags0 |= k_Culture_DecCrimePercent_Bit;
                if(!lex->GetIntAssignment(m_DecCrimePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IncKnowledgePercent:
                m_flags0 |= k_Culture_IncKnowledgePercent_Bit;
                if(!lex->GetIntAssignment(m_IncKnowledgePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_DecEmpireSize:
                m_flags0 |= k_Culture_DecEmpireSize_Bit;
                if(!lex->GetIntAssignment(m_DecEmpireSizeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IncHappinessEmpire:
                m_flags0 |= k_Culture_IncHappinessEmpire_Bit;
                if(!lex->GetIntAssignment(m_IncHappinessEmpireValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_CloseEmbassies:
                m_flags0 |= k_Culture_CloseEmbassies_Bit;
                break;
            case k_Token_Culture_ReformCities:
                m_flags0 |= k_Culture_ReformCities_Bit;
                break;
            case k_Token_Culture_FreeSlaves:
                m_flags0 |= k_Culture_FreeSlaves_Bit;
                break;
            case k_Token_Culture_ProhibitSlavers:
                m_flags0 |= k_Culture_ProhibitSlavers_Bit;
                break;
            case k_Token_Culture_IncConvertedCitiesFeePercent:
                m_flags0 |= k_Culture_IncConvertedCitiesFeePercent_Bit;
                if(!lex->GetIntAssignment(m_IncConvertedCitiesFeePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_GoldPerWaterTradeRoute:
                m_flags0 |= k_Culture_GoldPerWaterTradeRoute_Bit;
                if(!lex->GetIntAssignment(m_GoldPerWaterTradeRouteValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_GoldPerTelevision:
                m_flags0 |= k_Culture_GoldPerTelevision_Bit;
                if(!lex->GetIntAssignment(m_GoldPerTelevisionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_GlobalRadar:
                m_flags0 |= k_Culture_GlobalRadar_Bit;
                break;
            case k_Token_Culture_SpiesEverywhere:
                m_flags0 |= k_Culture_SpiesEverywhere_Bit;
                break;
            case k_Token_Culture_GoldPerInternationalTradeRoute:
                m_flags0 |= k_Culture_GoldPerInternationalTradeRoute_Bit;
                if(!lex->GetIntAssignment(m_GoldPerInternationalTradeRouteValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ProtectFromBiologicalWarfare:
                m_flags0 |= k_Culture_ProtectFromBiologicalWarfare_Bit;
                break;
            case k_Token_Culture_PollutersToParks:
                m_flags0 |= k_Culture_PollutersToParks_Bit;
                if(!lex->GetIntAssignment(m_PollutersToParksValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_EnableParkRangers:
                m_flags0 |= k_Culture_EnableParkRangers_Bit;
                break;
            case k_Token_Culture_ReduceWorldPollution:
                m_flags0 |= k_Culture_ReduceWorldPollution_Bit;
                if(!lex->GetIntAssignment(m_ReduceWorldPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_AllCitizensContent:
                m_flags0 |= k_Culture_AllCitizensContent_Bit;
                break;
            case k_Token_Culture_EliminateNukes:
                m_flags0 |= k_Culture_EliminateNukes_Bit;
                break;
            case k_Token_Culture_AllBoatsDeepWater:
                m_flags0 |= k_Culture_AllBoatsDeepWater_Bit;
                break;
            case k_Token_Culture_IncreaseBoatMovement:
                m_flags0 |= k_Culture_IncreaseBoatMovement_Bit;
                if(!lex->GetIntAssignment(m_IncreaseBoatMovementValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_FreeTradeRoutes:
                m_flags0 |= k_Culture_FreeTradeRoutes_Bit;
                break;
            case k_Token_Culture_DecreaseMaintenance:
                m_flags0 |= k_Culture_DecreaseMaintenance_Bit;
                if(!lex->GetIntAssignment(m_DecreaseMaintenanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_RandomAdvanceChance:
                m_flags0 |= k_Culture_RandomAdvanceChance_Bit;
                if(!lex->GetIntAssignment(m_RandomAdvanceChanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IncreaseHp:
                m_flags0 |= k_Culture_IncreaseHp_Bit;
                if(!lex->GetIntAssignment(m_IncreaseHpValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_MultiplyTradeRoutes:
                m_flags1 |= k_Culture_MultiplyTradeRoutes_Bit;
                if(!lex->GetIntAssignment(m_MultiplyTradeRoutesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ForcefieldEverywhere:
                m_flags1 |= k_Culture_ForcefieldEverywhere_Bit;
                break;
            case k_Token_Culture_IncreaseScientists:
                m_flags1 |= k_Culture_IncreaseScientists_Bit;
                if(!lex->GetIntAssignment(m_IncreaseScientistsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_OtherCivRandomAdvanceChance:
                m_flags1 |= k_Culture_OtherCivRandomAdvanceChance_Bit;
                if(!lex->GetIntAssignment(m_OtherCivRandomAdvanceChanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IncreaseProduction:
                m_flags1 |= k_Culture_IncreaseProduction_Bit;
                if(!lex->GetIntAssignment(m_IncreaseProductionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_BonusGold:
                m_flags1 |= k_Culture_BonusGold_Bit;
                if(!lex->GetIntAssignment(m_BonusGoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_CantBuildInSea:
                m_flags1 |= k_Culture_CantBuildInSea_Bit;
                break;
            case k_Token_Culture_CantBuildOnLand:
                m_flags1 |= k_Culture_CantBuildOnLand_Bit;
                break;
            case k_Token_Culture_CoastalBuilding:
                m_flags1 |= k_Culture_CoastalBuilding_Bit;
                break;
            case k_Token_Culture_EnablesPunativeAirstrikes:
                m_flags1 |= k_Culture_EnablesPunativeAirstrikes_Bit;
                break;
            case k_Token_Culture_IncreaseFoodAllCities:
                m_flags1 |= k_Culture_IncreaseFoodAllCities_Bit;
                if(!lex->GetIntAssignment(m_IncreaseFoodAllCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_TemporaryFullHappiness:
                m_flags1 |= k_Culture_TemporaryFullHappiness_Bit;
                if(!lex->GetIntAssignment(m_TemporaryFullHappinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_RevoltingCitiesJoinPlayer:
                m_flags1 |= k_Culture_RevoltingCitiesJoinPlayer_Bit;
                break;
            case k_Token_Culture_NoPollutionUnhappiness:
                m_flags1 |= k_Culture_NoPollutionUnhappiness_Bit;
                break;
            case k_Token_Culture_EmbassiesEverywhereEvenAtWar:
                m_flags1 |= k_Culture_EmbassiesEverywhereEvenAtWar_Bit;
                break;
            case k_Token_Culture_IncreaseSpecialists:
                m_flags1 |= k_Culture_IncreaseSpecialists_Bit;
                if(!lex->GetIntAssignment(m_IncreaseSpecialistsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IncreaseCathedrals:
                m_flags1 |= k_Culture_IncreaseCathedrals_Bit;
                if(!lex->GetIntAssignment(m_IncreaseCathedralsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IncreaseBrokerages:
                m_flags1 |= k_Culture_IncreaseBrokerages_Bit;
                if(!lex->GetIntAssignment(m_IncreaseBrokeragesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_IncreaseRegard:
                m_flags1 |= k_Culture_IncreaseRegard_Bit;
                if(!lex->GetIntAssignment(m_IncreaseRegardValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_PreventConversion:
                m_flags1 |= k_Culture_PreventConversion_Bit;
                break;
            case k_Token_Culture_ProtectFromBarbarians:
                m_flags1 |= k_Culture_ProtectFromBarbarians_Bit;
                break;
            case k_Token_Culture_StartGaiaController:
                m_flags1 |= k_Culture_StartGaiaController_Bit;
                break;
            case k_Token_Culture_GLHidden:
                m_flags1 |= k_Culture_GLHidden_Bit;
                break;
            case k_Token_Culture_BuildingFeat:
                m_flags1 |= k_Culture_BuildingFeat_Bit;
                if(!m_BuildingFeatValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_BuildingGold:
                m_flags1 |= k_Culture_BuildingGold_Bit;
                if(!m_BuildingGoldValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_BuildingEverywhere:
                m_flags1 |= k_Culture_BuildingEverywhere_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_BuildingEverywhereValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ActualBuildingEverywhere:
                m_flags1 |= k_Culture_ActualBuildingEverywhere_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_ActualBuildingEverywhereValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_BuildingEffectEverywhere:
                m_flags1 |= k_Culture_BuildingEffectEverywhere_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_BuildingEffectEverywhereValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ConflictsWithBuilding:
                m_flags1 |= k_Culture_ConflictsWithBuilding_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_ConflictsWithBuildingValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_BuildingAnywhere:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_BuildingAnywhere, &m_numBuildingAnywhere))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_GoldPerBuildingAnywhere:
                m_flags1 |= k_Culture_GoldPerBuildingAnywhere_Bit;
                if(!lex->GetIntAssignment(m_GoldPerBuildingAnywhereValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_PollutionPercent:
                m_flags1 |= k_Culture_PollutionPercent_Bit;
                if(!lex->GetFloatAssignment(m_PollutionPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_PollutionAmount:
                m_flags1 |= k_Culture_PollutionAmount_Bit;
                if(!lex->GetFloatAssignment(m_PollutionAmountValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ExcludedByBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByBuilding, &m_numExcludedByBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_ExcludedByWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByWonder, &m_numExcludedByWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Culture_EnergyHunger:
                m_flags2 |= k_Culture_EnergyHunger_Bit;
                if(!lex->GetIntAssignment(m_EnergyHungerValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ProducesEnergy:
                m_flags2 |= k_Culture_ProducesEnergy_Bit;
                if(!lex->GetIntAssignment(m_ProducesEnergyValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_EnergyHungerPerPop:
                m_flags2 |= k_Culture_EnergyHungerPerPop_Bit;
                if(!lex->GetIntAssignment(m_EnergyHungerPerPopValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_ProducesEnergyPerPop:
                m_flags2 |= k_Culture_ProducesEnergyPerPop_Bit;
                if(!lex->GetIntAssignment(m_ProducesEnergyPerPopValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_TooManyCitiesThresholdModifier:
                m_flags2 |= k_Culture_TooManyCitiesThresholdModifier_Bit;
                if(!lex->GetIntAssignment(m_TooManyCitiesThresholdModifierValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_TooManyCitiesCoefficientModifier:
                m_flags2 |= k_Culture_TooManyCitiesCoefficientModifier_Bit;
                if(!lex->GetFloatAssignment(m_TooManyCitiesCoefficientModifierValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_RiotLevelModifier:
                m_flags2 |= k_Culture_RiotLevelModifier_Bit;
                if(!lex->GetIntAssignment(m_RiotLevelModifierValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_OtherPlayerRiotLevelModifier:
                m_flags2 |= k_Culture_OtherPlayerRiotLevelModifier_Bit;
                if(!lex->GetIntAssignment(m_OtherPlayerRiotLevelModifierValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_CultureCost)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void CultureRecord::ResolveDBReferences()
{
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteAdvance; i++) {
            if(m_ObsoleteAdvance[i] & 0x80000000) {
                sint32 id = m_ObsoleteAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ObsoleteAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteAdvance[i] == 0x7fffffff){
                m_ObsoleteAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteBuilding; i++) {
            if(m_PrerequisiteBuilding[i] & 0x80000000) {
                sint32 id = m_PrerequisiteBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_PrerequisiteBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteBuilding[i] == 0x7fffffff){
                m_PrerequisiteBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteGovernmentType; i++) {
            if(m_ObsoleteGovernmentType[i] & 0x80000000) {
                sint32 id = m_ObsoleteGovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_ObsoleteGovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteGovernmentType[i] == 0x7fffffff){
                m_ObsoleteGovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCityStyleOnly; i++) {
            if(m_CityStyleOnly[i] & 0x80000000) {
                sint32 id = m_CityStyleOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CityStyleOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CityStyleOnly[i] == 0x7fffffff){
                m_CityStyleOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGood; i++) {
            if(m_NeedsCityGood[i] & 0x80000000) {
                sint32 id = m_NeedsCityGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGood[i] == 0x7fffffff){
                m_NeedsCityGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAll; i++) {
            if(m_NeedsCityGoodAll[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAll[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAll[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAll[i] == 0x7fffffff){
                m_NeedsCityGoodAll[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAnyCity; i++) {
            if(m_NeedsCityGoodAnyCity[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAnyCity[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAnyCity[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAnyCity[i] == 0x7fffffff){
                m_NeedsCityGoodAnyCity[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numEnablesGood; i++) {
            if(m_EnablesGood[i] & 0x80000000) {
                sint32 id = m_EnablesGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_EnablesGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_EnablesGood[i] == 0x7fffffff){
                m_EnablesGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCivilisationOnly; i++) {
            if(m_CivilisationOnly[i] & 0x80000000) {
                sint32 id = m_CivilisationOnly[i] & 0x7fffffff;
                if(!g_theCivilisationDB->GetNamedItem(id, m_CivilisationOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Civilisation database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CivilisationOnly[i] == 0x7fffffff){
                m_CivilisationOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsFeatToBuild; i++) {
            if(m_NeedsFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsFeatToBuild[i] == 0x7fffffff){
                m_NeedsFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsAnyPlayerFeatToBuild; i++) {
            if(m_NeedsAnyPlayerFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsAnyPlayerFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsAnyPlayerFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsAnyPlayerFeatToBuild[i] == 0x7fffffff){
                m_NeedsAnyPlayerFeatToBuild[i] = -1;
            }
        }
    }
    m_BuildingFeatValue.ResolveDBReferences();
    m_BuildingGoldValue.ResolveDBReferences();
    if(m_BuildingEverywhereValue & 0x80000000) {
        sint32 id = m_BuildingEverywhereValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_BuildingEverywhereValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_BuildingEverywhereValue == 0x7fffffff) {
        m_BuildingEverywhereValue = -1;
    }
    if(m_ActualBuildingEverywhereValue & 0x80000000) {
        sint32 id = m_ActualBuildingEverywhereValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_ActualBuildingEverywhereValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ActualBuildingEverywhereValue == 0x7fffffff) {
        m_ActualBuildingEverywhereValue = -1;
    }
    if(m_BuildingEffectEverywhereValue & 0x80000000) {
        sint32 id = m_BuildingEffectEverywhereValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_BuildingEffectEverywhereValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_BuildingEffectEverywhereValue == 0x7fffffff) {
        m_BuildingEffectEverywhereValue = -1;
    }
    if(m_ConflictsWithBuildingValue & 0x80000000) {
        sint32 id = m_ConflictsWithBuildingValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_ConflictsWithBuildingValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ConflictsWithBuildingValue == 0x7fffffff) {
        m_ConflictsWithBuildingValue = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numBuildingAnywhere; i++) {
            if(m_BuildingAnywhere[i] & 0x80000000) {
                sint32 id = m_BuildingAnywhere[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_BuildingAnywhere[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_BuildingAnywhere[i] == 0x7fffffff){
                m_BuildingAnywhere[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByBuilding; i++) {
            if(m_ExcludedByBuilding[i] & 0x80000000) {
                sint32 id = m_ExcludedByBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_ExcludedByBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByBuilding[i] == 0x7fffffff){
                m_ExcludedByBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByWonder; i++) {
            if(m_ExcludedByWonder[i] & 0x80000000) {
                sint32 id = m_ExcludedByWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_ExcludedByWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByWonder[i] == 0x7fffffff){
                m_ExcludedByWonder[i] = -1;
            }
        }
    }
}

CultureRecord::BuildingFeat::BuildingFeat()
{
    m_flags0 = 0;
    m_Building = 0x7fffffff;
    m_NumValue = 0;
    m_PercentCitiesValue = 0;
}

CultureRecord::BuildingFeat::~BuildingFeat()
{
}

CultureRecord::BuildingFeat const & CultureRecord::BuildingFeat::operator = (BuildingFeat const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Building = rval.m_Building;

        m_NumValue = rval.m_NumValue;

        m_PercentCitiesValue = rval.m_PercentCitiesValue;

    }

    return *this;
}

void CultureRecord::BuildingFeat::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Building;
        archive << m_NumValue;
        archive << m_PercentCitiesValue;
    } else {
        archive >> m_flags0;
        archive >> m_Building;
        archive >> m_NumValue;
        archive >> m_PercentCitiesValue;
    }
}

static const char *s_Culture_BuildingFeat_Tokens[] = {
    "Building",
    "Num",
    "PercentCities",
};
#define k_Token_Culture_BuildingFeat_Building    ((k_Token_Custom_Base) + 0)
#define k_Token_Culture_BuildingFeat_Num         ((k_Token_Custom_Base) + 1)
#define k_Token_Culture_BuildingFeat_PercentCities ((k_Token_Custom_Base) + 2)
#define k_Token_Culture_BuildingFeat_Max ((k_Token_Custom_Base) + 3)
sint32 CultureRecord::BuildingFeat::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildingFeat"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Culture_BuildingFeat_Tokens, k_Token_Culture_BuildingFeat_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Culture_BuildingFeat_Building:
                if (!g_theBuildingDB->GetRecordFromLexer(lex, m_Building)) {
                    done = true; break;
                }
                break;
            case k_Token_Culture_BuildingFeat_Num:
                m_flags0 |= k_BuildingFeat_Num_Bit;
                if(!lex->GetIntAssignment(m_NumValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Culture_BuildingFeat_PercentCities:
                m_flags0 |= k_BuildingFeat_PercentCities_Bit;
                if(!lex->GetIntAssignment(m_PercentCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theBuildingDB->GetCurrentRecordFromLexer(lex, m_Building)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 CultureRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildingFeat *oldArray = *array;
        *array = new BuildingFeat[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildingFeat[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 CultureRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void CultureRecord::BuildingFeat::ResolveDBReferences()
{
    if(m_Building & 0x80000000) {
        sint32 id = m_Building & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_Building)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Building == 0x7fffffff) {
        m_Building = -1;
    }
}

CultureRecord::BuildingGold::BuildingGold()
{
    m_flags0 = 0;
    m_Building = 0x7fffffff;
    m_GoldValue = 0;
}

CultureRecord::BuildingGold::~BuildingGold()
{
}

CultureRecord::BuildingGold const & CultureRecord::BuildingGold::operator = (BuildingGold const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Building = rval.m_Building;

        m_GoldValue = rval.m_GoldValue;

    }

    return *this;
}

void CultureRecord::BuildingGold::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Building;
        archive << m_GoldValue;
    } else {
        archive >> m_flags0;
        archive >> m_Building;
        archive >> m_GoldValue;
    }
}

static const char *s_Culture_BuildingGold_Tokens[] = {
    "Building",
    "Gold",
};
#define k_Token_Culture_BuildingGold_Building    ((k_Token_Custom_Base) + 0)
#define k_Token_Culture_BuildingGold_Gold        ((k_Token_Custom_Base) + 1)
#define k_Token_Culture_BuildingGold_Max ((k_Token_Custom_Base) + 2)
sint32 CultureRecord::BuildingGold::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildingGold"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Culture_BuildingGold_Tokens, k_Token_Culture_BuildingGold_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Culture_BuildingGold_Building:
                if (!g_theBuildingDB->GetRecordFromLexer(lex, m_Building)) {
                    done = true; break;
                }
                break;
            case k_Token_Culture_BuildingGold_Gold:
                m_flags0 |= k_BuildingGold_Gold_Bit;
                if(!lex->GetIntAssignment(m_GoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theBuildingDB->GetCurrentRecordFromLexer(lex, m_Building)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 CultureRecord::BuildingGold::ParseInArray(DBLexer *lex, BuildingGold **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildingGold *oldArray = *array;
        *array = new BuildingGold[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildingGold[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 CultureRecord::BuildingGold::ParseInArray(DBLexer *lex, BuildingGold *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void CultureRecord::BuildingGold::ResolveDBReferences()
{
    if(m_Building & 0x80000000) {
        sint32 id = m_Building & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_Building)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Building == 0x7fffffff) {
        m_Building = -1;
    }
}

void CultureRecord::Merge(const CultureRecord & rval){
    if (rval.m_numObsoleteAdvance > 0)
        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

    // resize m_PrerequisiteBuilding if necessary
    if (rval.m_numPrerequisiteBuilding > m_numPrerequisiteBuilding)
    {
        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;
    }
    if (rval.m_numPrerequisiteBuilding > 0)
        std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);

    // resize m_CultureOnly if necessary
    if (rval.m_numCultureOnly > m_numCultureOnly)
    {
        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
        m_numCultureOnly = rval.m_numCultureOnly;
    }
    if (rval.m_numCultureOnly > 0)
        std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);

    // resize m_GovernmentType if necessary
    if (rval.m_numGovernmentType > m_numGovernmentType)
    {
        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
        m_numGovernmentType = rval.m_numGovernmentType;
    }
    if (rval.m_numGovernmentType > 0)
        std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);

    // resize m_ObsoleteGovernmentType if necessary
    if (rval.m_numObsoleteGovernmentType > m_numObsoleteGovernmentType)
    {
        delete [] m_ObsoleteGovernmentType;
        m_ObsoleteGovernmentType = NULL;
        if (rval.m_numObsoleteGovernmentType > 0)
            m_ObsoleteGovernmentType = new sint32 [rval.m_numObsoleteGovernmentType];
        m_numObsoleteGovernmentType = rval.m_numObsoleteGovernmentType;
    }
    if (rval.m_numObsoleteGovernmentType > 0)
        std::copy(rval.m_ObsoleteGovernmentType, rval.m_ObsoleteGovernmentType + rval.m_numObsoleteGovernmentType, m_ObsoleteGovernmentType);

    // resize m_CityStyleOnly if necessary
    if (rval.m_numCityStyleOnly > m_numCityStyleOnly)
    {
        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
        m_numCityStyleOnly = rval.m_numCityStyleOnly;
    }
    if (rval.m_numCityStyleOnly > 0)
        std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);

    // resize m_NeedsCityGood if necessary
    if (rval.m_numNeedsCityGood > m_numNeedsCityGood)
    {
        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
        m_numNeedsCityGood = rval.m_numNeedsCityGood;
    }
    if (rval.m_numNeedsCityGood > 0)
        std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);

    // resize m_NeedsCityGoodAll if necessary
    if (rval.m_numNeedsCityGoodAll > m_numNeedsCityGoodAll)
    {
        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;
    }
    if (rval.m_numNeedsCityGoodAll > 0)
        std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);

    // resize m_NeedsCityGoodAnyCity if necessary
    if (rval.m_numNeedsCityGoodAnyCity > m_numNeedsCityGoodAnyCity)
    {
        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;
    }
    if (rval.m_numNeedsCityGoodAnyCity > 0)
        std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);

    // resize m_EnablesGood if necessary
    if (rval.m_numEnablesGood > m_numEnablesGood)
    {
        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
        m_numEnablesGood = rval.m_numEnablesGood;
    }
    if (rval.m_numEnablesGood > 0)
        std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);

    // resize m_CivilisationOnly if necessary
    if (rval.m_numCivilisationOnly > m_numCivilisationOnly)
    {
        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
        m_numCivilisationOnly = rval.m_numCivilisationOnly;
    }
    if (rval.m_numCivilisationOnly > 0)
        std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);

    // resize m_NeedsFeatToBuild if necessary
    if (rval.m_numNeedsFeatToBuild > m_numNeedsFeatToBuild)
    {
        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;
    }
    if (rval.m_numNeedsFeatToBuild > 0)
        std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);

    // resize m_NeedsAnyPlayerFeatToBuild if necessary
    if (rval.m_numNeedsAnyPlayerFeatToBuild > m_numNeedsAnyPlayerFeatToBuild)
    {
        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;
    }
    if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_SquaredBorderRadius_Bit)
    {
        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_IntBorderRadius_Bit)
    {
        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_ReduceReadinessCost_Bit)
    {
        m_ReduceReadinessCostValue = rval.m_ReduceReadinessCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_DecCrimePercent_Bit)
    {
        m_DecCrimePercentValue = rval.m_DecCrimePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_IncKnowledgePercent_Bit)
    {
        m_IncKnowledgePercentValue = rval.m_IncKnowledgePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_DecEmpireSize_Bit)
    {
        m_DecEmpireSizeValue = rval.m_DecEmpireSizeValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_IncHappinessEmpire_Bit)
    {
        m_IncHappinessEmpireValue = rval.m_IncHappinessEmpireValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_IncConvertedCitiesFeePercent_Bit)
    {
        m_IncConvertedCitiesFeePercentValue = rval.m_IncConvertedCitiesFeePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_GoldPerWaterTradeRoute_Bit)
    {
        m_GoldPerWaterTradeRouteValue = rval.m_GoldPerWaterTradeRouteValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_GoldPerTelevision_Bit)
    {
        m_GoldPerTelevisionValue = rval.m_GoldPerTelevisionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_GoldPerInternationalTradeRoute_Bit)
    {
        m_GoldPerInternationalTradeRouteValue = rval.m_GoldPerInternationalTradeRouteValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_PollutersToParks_Bit)
    {
        m_PollutersToParksValue = rval.m_PollutersToParksValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_ReduceWorldPollution_Bit)
    {
        m_ReduceWorldPollutionValue = rval.m_ReduceWorldPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_IncreaseBoatMovement_Bit)
    {
        m_IncreaseBoatMovementValue = rval.m_IncreaseBoatMovementValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_DecreaseMaintenance_Bit)
    {
        m_DecreaseMaintenanceValue = rval.m_DecreaseMaintenanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_RandomAdvanceChance_Bit)
    {
        m_RandomAdvanceChanceValue = rval.m_RandomAdvanceChanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Culture_IncreaseHp_Bit)
    {
        m_IncreaseHpValue = rval.m_IncreaseHpValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_MultiplyTradeRoutes_Bit)
    {
        m_MultiplyTradeRoutesValue = rval.m_MultiplyTradeRoutesValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_IncreaseScientists_Bit)
    {
        m_IncreaseScientistsValue = rval.m_IncreaseScientistsValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_OtherCivRandomAdvanceChance_Bit)
    {
        m_OtherCivRandomAdvanceChanceValue = rval.m_OtherCivRandomAdvanceChanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_IncreaseProduction_Bit)
    {
        m_IncreaseProductionValue = rval.m_IncreaseProductionValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_BonusGold_Bit)
    {
        m_BonusGoldValue = rval.m_BonusGoldValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_IncreaseFoodAllCities_Bit)
    {
        m_IncreaseFoodAllCitiesValue = rval.m_IncreaseFoodAllCitiesValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_TemporaryFullHappiness_Bit)
    {
        m_TemporaryFullHappinessValue = rval.m_TemporaryFullHappinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_IncreaseSpecialists_Bit)
    {
        m_IncreaseSpecialistsValue = rval.m_IncreaseSpecialistsValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_IncreaseCathedrals_Bit)
    {
        m_IncreaseCathedralsValue = rval.m_IncreaseCathedralsValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_IncreaseBrokerages_Bit)
    {
        m_IncreaseBrokeragesValue = rval.m_IncreaseBrokeragesValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_IncreaseRegard_Bit)
    {
        m_IncreaseRegardValue = rval.m_IncreaseRegardValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_BuildingFeat_Bit)
    {
        m_BuildingFeatValue = rval.m_BuildingFeatValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_BuildingGold_Bit)
    {
        m_BuildingGoldValue = rval.m_BuildingGoldValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_BuildingEverywhere_Bit)
    {
        m_BuildingEverywhereValue = rval.m_BuildingEverywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_ActualBuildingEverywhere_Bit)
    {
        m_ActualBuildingEverywhereValue = rval.m_ActualBuildingEverywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_BuildingEffectEverywhere_Bit)
    {
        m_BuildingEffectEverywhereValue = rval.m_BuildingEffectEverywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_ConflictsWithBuilding_Bit)
    {
        m_ConflictsWithBuildingValue = rval.m_ConflictsWithBuildingValue;
    }

    // resize m_BuildingAnywhere if necessary
    if (rval.m_numBuildingAnywhere > m_numBuildingAnywhere)
    {
        delete [] m_BuildingAnywhere;
        m_BuildingAnywhere = NULL;
        if (rval.m_numBuildingAnywhere > 0)
            m_BuildingAnywhere = new sint32 [rval.m_numBuildingAnywhere];
        m_numBuildingAnywhere = rval.m_numBuildingAnywhere;
    }
    if (rval.m_numBuildingAnywhere > 0)
        std::copy(rval.m_BuildingAnywhere, rval.m_BuildingAnywhere + rval.m_numBuildingAnywhere, m_BuildingAnywhere);

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_GoldPerBuildingAnywhere_Bit)
    {
        m_GoldPerBuildingAnywhereValue = rval.m_GoldPerBuildingAnywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_PollutionPercent_Bit)
    {
        m_PollutionPercentValue = rval.m_PollutionPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Culture_PollutionAmount_Bit)
    {
        m_PollutionAmountValue = rval.m_PollutionAmountValue;
    }

    // resize m_ExcludedByBuilding if necessary
    if (rval.m_numExcludedByBuilding > m_numExcludedByBuilding)
    {
        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;
    }
    if (rval.m_numExcludedByBuilding > 0)
        std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);

    // resize m_ExcludedByWonder if necessary
    if (rval.m_numExcludedByWonder > m_numExcludedByWonder)
    {
        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
        m_numExcludedByWonder = rval.m_numExcludedByWonder;
    }
    if (rval.m_numExcludedByWonder > 0)
        std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_EnergyHunger_Bit)
    {
        m_EnergyHungerValue = rval.m_EnergyHungerValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_ProducesEnergy_Bit)
    {
        m_ProducesEnergyValue = rval.m_ProducesEnergyValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_EnergyHungerPerPop_Bit)
    {
        m_EnergyHungerPerPopValue = rval.m_EnergyHungerPerPopValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_ProducesEnergyPerPop_Bit)
    {
        m_ProducesEnergyPerPopValue = rval.m_ProducesEnergyPerPopValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_TooManyCitiesThresholdModifier_Bit)
    {
        m_TooManyCitiesThresholdModifierValue = rval.m_TooManyCitiesThresholdModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_TooManyCitiesCoefficientModifier_Bit)
    {
        m_TooManyCitiesCoefficientModifierValue = rval.m_TooManyCitiesCoefficientModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_RiotLevelModifier_Bit)
    {
        m_RiotLevelModifierValue = rval.m_RiotLevelModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Culture_OtherPlayerRiotLevelModifier_Bit)
    {
        m_OtherPlayerRiotLevelModifierValue = rval.m_OtherPlayerRiotLevelModifierValue;
    }

}

AdvanceRecord const * CultureRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 CultureRecord::GetObsoleteAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return m_ObsoleteAdvance[index];
}

AdvanceRecord const * CultureRecord::GetObsoleteAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ObsoleteAdvance[index]);
}

sint32 CultureRecord::GetPrerequisiteBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return m_PrerequisiteBuilding[index];
}

BuildingRecord const * CultureRecord::GetPrerequisiteBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_PrerequisiteBuilding[index]);
}

sint32 CultureRecord::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

CityStyleRecord const * CultureRecord::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

sint32 CultureRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

GovernmentRecord const * CultureRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

sint32 CultureRecord::GetObsoleteGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteGovernmentType);
    if((index < 0) || (index >= m_numObsoleteGovernmentType)) {
        return 0;
    }
    return m_ObsoleteGovernmentType[index];
}

GovernmentRecord const * CultureRecord::GetObsoleteGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteGovernmentType);
    if((index < 0) || (index >= m_numObsoleteGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_ObsoleteGovernmentType[index]);
}

sint32 CultureRecord::GetCityStyleOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return m_CityStyleOnly[index];
}

CityStyleRecord const * CultureRecord::GetCityStyleOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CityStyleOnly[index]);
}

sint32 CultureRecord::GetNeedsCityGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return m_NeedsCityGood[index];
}

ResourceRecord const * CultureRecord::GetNeedsCityGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGood[index]);
}

sint32 CultureRecord::GetNeedsCityGoodAllIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return m_NeedsCityGoodAll[index];
}

ResourceRecord const * CultureRecord::GetNeedsCityGoodAll(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAll[index]);
}

sint32 CultureRecord::GetNeedsCityGoodAnyCityIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return m_NeedsCityGoodAnyCity[index];
}

ResourceRecord const * CultureRecord::GetNeedsCityGoodAnyCity(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAnyCity[index]);
}

sint32 CultureRecord::GetEnablesGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return m_EnablesGood[index];
}

ResourceRecord const * CultureRecord::GetEnablesGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_EnablesGood[index]);
}

sint32 CultureRecord::GetCivilisationOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return m_CivilisationOnly[index];
}

CivilisationRecord const * CultureRecord::GetCivilisationOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return g_theCivilisationDB->Get(m_CivilisationOnly[index]);
}

sint32 CultureRecord::GetNeedsFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return m_NeedsFeatToBuild[index];
}

FeatRecord const * CultureRecord::GetNeedsFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsFeatToBuild[index]);
}

sint32 CultureRecord::GetNeedsAnyPlayerFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return m_NeedsAnyPlayerFeatToBuild[index];
}

FeatRecord const * CultureRecord::GetNeedsAnyPlayerFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsAnyPlayerFeatToBuild[index]);
}

BuildingRecord const * CultureRecord::GetBuildingEverywherePtr() const
{
    return g_theBuildingDB->Get(m_BuildingEverywhereValue);
}

BuildingRecord const * CultureRecord::GetActualBuildingEverywherePtr() const
{
    return g_theBuildingDB->Get(m_ActualBuildingEverywhereValue);
}

BuildingRecord const * CultureRecord::GetBuildingEffectEverywherePtr() const
{
    return g_theBuildingDB->Get(m_BuildingEffectEverywhereValue);
}

BuildingRecord const * CultureRecord::GetConflictsWithBuildingPtr() const
{
    return g_theBuildingDB->Get(m_ConflictsWithBuildingValue);
}

sint32 CultureRecord::GetBuildingAnywhereIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildingAnywhere);
    if((index < 0) || (index >= m_numBuildingAnywhere)) {
        return 0;
    }
    return m_BuildingAnywhere[index];
}

BuildingRecord const * CultureRecord::GetBuildingAnywhere(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildingAnywhere);
    if((index < 0) || (index >= m_numBuildingAnywhere)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_BuildingAnywhere[index]);
}

sint32 CultureRecord::GetExcludedByBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return m_ExcludedByBuilding[index];
}

BuildingRecord const * CultureRecord::GetExcludedByBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_ExcludedByBuilding[index]);
}

sint32 CultureRecord::GetExcludedByWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return m_ExcludedByWonder[index];
}

WonderRecord const * CultureRecord::GetExcludedByWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_ExcludedByWonder[index]);
}

const BuildingRecord *CultureRecord::BuildingFeat::GetBuilding() const
{
    return g_theBuildingDB->Get(m_Building);
}

const BuildingRecord *CultureRecord::BuildingGold::GetBuilding() const
{
    return g_theBuildingDB->Get(m_Building);
}

