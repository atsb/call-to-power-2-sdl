
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "StrategyRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "GovernmentRecord.h"
#include "ImprovementListRecord.h"
#include "ImprovementListRecord.h"
#include "ImprovementListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "AdvanceListRecord.h"
#include "AdvanceListRecord.h"
#include "ConstRecord.h"
#include "ConstRecord.h"
#include "ConstRecord.h"
#include "ConstRecord.h"
#include "ConstRecord.h"
#include "ConstRecord.h"
#include "GoalRecord.h"
#include "BuildListSequenceRecord.h"
#include "BuildingBuildListRecord.h"

CTPDatabase<StrategyRecord> *g_theStrategyDB = NULL;

void StrategyRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    memset(m_Inherit, 0, sizeof(m_Inherit));
    m_numInherit = 0;
    m_PopAssignmentElement = NULL;
    m_numPopAssignmentElement = 0;
    m_Government = NULL;
    m_numGovernment = 0;
    m_MinimumHappinessValue = 0;
    m_DeficitSpendingValue = 0.000000;
    m_MaximumWagePercentValue = 0.000000;
    m_SliderElement = NULL;
    m_numSliderElement = 0;
    m_SciencePercentValue = 0;
    m_MaxSupportCostPercentValue = 0;
    m_ReadinessLevelValue = 0;
    m_PublicWorksPercentValue = 0;
    m_PublicWorksReserveValue = 0;
    m_MaxEvalTileImprovementsValue = 0;
    m_TimeToFixRoadsValue = 0;
    m_TimeToFixPollutionValue = 0;
    m_FixPollutionThresholdValue = 0;
    m_RoadUtilityBonusValue = 0.000000;
    m_ImproveProductionBonusValue = 0.000000;
    m_ImproveGrowthBonusValue = 0.000000;
    m_ImproveGoodBonusValue = 0.000000;
    m_ImproveSmallCityGrowthBonusValue = 0.000000;
    m_ImproveLargeCityProductionBonusValue = 0.000000;
    m_ImproveGrowthList = 0x7fffffff;
    m_ImproveProductionList = 0x7fffffff;
    m_ImproveRandomList = 0x7fffffff;
    m_GoalElement = NULL;
    m_numGoalElement = 0;
    m_DistanceModifierFactorValue = 0;
    m_DisbandArmyCountValue = 0;
    m_MinSettleDistanceValue = 0;
    m_MinSettleScoreValue = 0;
    m_RushBuyThreatBonusValue = 0;
    m_RushBuyReservePercentValue = 0.000000;
    m_UnitSupportPercentValue = 0.000000;
    m_MaxSettlerBuildTurnsValue = 0;
    m_MaxUnitBuildTurnsValue = 0;
    m_MaxWonderBuildTurnsValue = 0;
    m_BuildTransportProductionLevelValue = 0.000000;
    m_BuildSettlerProductionLevelValue = 0.000000;
    m_OffensiveUnitsPercentValue = 0.000000;
    m_DefensiveUnitsPercentValue = 0.000000;
    m_RangedUnitsPercentValue = 0.000000;
    m_SeaUnitsPercentValue = 0.000000;
    m_AirUnitsPercentValue = 0.000000;
    m_SettlerUnitsCountValue = 0;
    m_SpecialUnitsCountValue = 0;
    m_SpyUnitsCountValue = 0;
    m_SlaveryUnitsCountValue = 0;
    m_DiplomatUnitsCountValue = 0;
    m_MissionaryUnitsCountValue = 0;
    m_SeaTransportUnitsCountValue = 0;
    m_AirTransportUnitsCountValue = 0;
    m_OffensiveUnitListValue = 0;
    m_DefensiveUnitListValue = 0;
    m_RangedUnitListValue = 0;
    m_SeaUnitListValue = 0;
    m_AirUnitListValue = 0;
    m_SettlerUnitListValue = 0;
    m_SeaSettlerUnitListValue = 0;
    m_SpecialUnitListValue = 0;
    m_SpyUnitListValue = 0;
    m_SlaverUnitListValue = 0;
    m_DiplomatUnitListValue = 0;
    m_MissionaryUnitListValue = 0;
    m_SeaTransportUnitListValue = 0;
    m_AirTransportUnitListValue = 0;
    m_FreightUnitListValue = 0;
    m_OffensiveGarrisonCountValue = 0;
    m_DefensiveGarrisonCountValue = 0;
    m_RangedGarrisonCountValue = 0;
    m_BuildListSequenceElement = NULL;
    m_numBuildListSequenceElement = 0;
    m_ResearchValue = 0;
    m_StopResearchValue = 0;
    m_FearInvasionValue = 0;
    m_FearCityDefenseValue = 0;
    m_FearPiracyValue = 0;
    m_FearScienceRankValue = 0;
    m_FearMilitaryRankValue = 0;
    m_FearTradeRankValue = 0;
    m_FearPollutionValue = 0;
    m_DesireAttackValue = 0;
    m_DesireGoldValue = 0;
    m_DesireScienceValue = 0;
    m_DesireMakeFriendValue = 0;
    m_DesireEnlistFriendValue = 0;
    m_PiracyMemoryTurnsValue = 0;
    m_MaxPiracyEventsValue = 0;
    memset(&m_OffensiveValue, 0, sizeof(m_OffensiveValue));
    memset(&m_DefensiveValue, 0, sizeof(m_DefensiveValue));
    memset(&m_StealthAttackValue, 0, sizeof(m_StealthAttackValue));
    memset(&m_BombardValue, 0, sizeof(m_BombardValue));
    memset(&m_SpecialValue, 0, sizeof(m_SpecialValue));
    memset(&m_HarassValue, 0, sizeof(m_HarassValue));
    m_NuclearFirstStrike = 0;
    m_NuclearTargeting = 0;
    m_PreemptiveStrikeRegardValue = 0;
    m_PreemptiveStrikeRiskRatioValue = 0.000000;
    m_PreemptiveStrikeSuperiorityRatioValue = 0.000000;
    m_TurnsAcceptedForOnePopValue = 30;
    m_StopBuildingFoodBeforePopMaxValue = 1;
    m_RoadAlreadyThereCostsCoefficientValue = 0.500000;
    m_UseBaseMoveCostsForRoadsValue = 0;
    m_BuildRoadsToClosestCitiesValue = 5;
    m_BaseRoadPriorityVsThreatRankValue = 0.500000;
    m_SmallCityImproveCoeffValue = 1.000000;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void StrategyRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_flags1;
        archive << m_flags2;
        archive << m_numInherit;
        archive.Store((uint8*)&m_Inherit, sizeof(m_Inherit));

        {
            archive << m_numPopAssignmentElement;
            for(sint32 i = 0; i < m_numPopAssignmentElement; ++i){
                m_PopAssignmentElement[i].Serialize(archive);
            }
        }

        archive << m_numGovernment;
        archive.Store((uint8*)m_Government, m_numGovernment * sizeof(sint32));

        archive << m_MinimumHappinessValue;
        archive << m_DeficitSpendingValue;
        archive << m_MaximumWagePercentValue;

        {
            archive << m_numSliderElement;
            for(sint32 i = 0; i < m_numSliderElement; ++i){
                m_SliderElement[i].Serialize(archive);
            }
        }

        archive << m_SciencePercentValue;
        archive << m_MaxSupportCostPercentValue;
        archive << m_ReadinessLevelValue;
        archive << m_PublicWorksPercentValue;
        archive << m_PublicWorksReserveValue;
        archive << m_MaxEvalTileImprovementsValue;
        archive << m_TimeToFixRoadsValue;
        archive << m_TimeToFixPollutionValue;
        archive << m_FixPollutionThresholdValue;
        archive << m_RoadUtilityBonusValue;
        archive << m_ImproveProductionBonusValue;
        archive << m_ImproveGrowthBonusValue;
        archive << m_ImproveGoodBonusValue;
        archive << m_ImproveSmallCityGrowthBonusValue;
        archive << m_ImproveLargeCityProductionBonusValue;
        archive << m_ImproveGrowthList;
        archive << m_ImproveProductionList;
        archive << m_ImproveRandomList;

        {
            archive << m_numGoalElement;
            for(sint32 i = 0; i < m_numGoalElement; ++i){
                m_GoalElement[i].Serialize(archive);
            }
        }

        archive << m_DistanceModifierFactorValue;
        archive << m_DisbandArmyCountValue;
        archive << m_MinSettleDistanceValue;
        archive << m_MinSettleScoreValue;
        archive << m_RushBuyThreatBonusValue;
        archive << m_RushBuyReservePercentValue;
        archive << m_UnitSupportPercentValue;
        archive << m_MaxSettlerBuildTurnsValue;
        archive << m_MaxUnitBuildTurnsValue;
        archive << m_MaxWonderBuildTurnsValue;
        archive << m_BuildTransportProductionLevelValue;
        archive << m_BuildSettlerProductionLevelValue;
        archive << m_OffensiveUnitsPercentValue;
        archive << m_DefensiveUnitsPercentValue;
        archive << m_RangedUnitsPercentValue;
        archive << m_SeaUnitsPercentValue;
        archive << m_AirUnitsPercentValue;
        archive << m_SettlerUnitsCountValue;
        archive << m_SpecialUnitsCountValue;
        archive << m_SpyUnitsCountValue;
        archive << m_SlaveryUnitsCountValue;
        archive << m_DiplomatUnitsCountValue;
        archive << m_MissionaryUnitsCountValue;
        archive << m_SeaTransportUnitsCountValue;
        archive << m_AirTransportUnitsCountValue;
        archive << m_OffensiveUnitListValue;
        archive << m_DefensiveUnitListValue;
        archive << m_RangedUnitListValue;
        archive << m_SeaUnitListValue;
        archive << m_AirUnitListValue;
        archive << m_SettlerUnitListValue;
        archive << m_SeaSettlerUnitListValue;
        archive << m_SpecialUnitListValue;
        archive << m_SpyUnitListValue;
        archive << m_SlaverUnitListValue;
        archive << m_DiplomatUnitListValue;
        archive << m_MissionaryUnitListValue;
        archive << m_SeaTransportUnitListValue;
        archive << m_AirTransportUnitListValue;
        archive << m_FreightUnitListValue;
        archive << m_OffensiveGarrisonCountValue;
        archive << m_DefensiveGarrisonCountValue;
        archive << m_RangedGarrisonCountValue;

        {
            archive << m_numBuildListSequenceElement;
            for(sint32 i = 0; i < m_numBuildListSequenceElement; ++i){
                m_BuildListSequenceElement[i].Serialize(archive);
            }
        }

        archive << m_ResearchValue;
        archive << m_StopResearchValue;
        archive << m_FearInvasionValue;
        archive << m_FearCityDefenseValue;
        archive << m_FearPiracyValue;
        archive << m_FearScienceRankValue;
        archive << m_FearMilitaryRankValue;
        archive << m_FearTradeRankValue;
        archive << m_FearPollutionValue;
        archive << m_DesireAttackValue;
        archive << m_DesireGoldValue;
        archive << m_DesireScienceValue;
        archive << m_DesireMakeFriendValue;
        archive << m_DesireEnlistFriendValue;
        archive << m_PiracyMemoryTurnsValue;
        archive << m_MaxPiracyEventsValue;
        m_OffensiveValue.Serialize(archive);
        m_DefensiveValue.Serialize(archive);
        m_StealthAttackValue.Serialize(archive);
        m_BombardValue.Serialize(archive);
        m_SpecialValue.Serialize(archive);
        m_HarassValue.Serialize(archive);
        archive << m_NuclearFirstStrike;
        archive << m_NuclearTargeting;
        archive << m_PreemptiveStrikeRegardValue;
        archive << m_PreemptiveStrikeRiskRatioValue;
        archive << m_PreemptiveStrikeSuperiorityRatioValue;
        archive << m_TurnsAcceptedForOnePopValue;
        archive << m_StopBuildingFoodBeforePopMaxValue;
        archive << m_RoadAlreadyThereCostsCoefficientValue;
        archive << m_UseBaseMoveCostsForRoadsValue;
        archive << m_BuildRoadsToClosestCitiesValue;
        archive << m_BaseRoadPriorityVsThreatRankValue;
        archive << m_SmallCityImproveCoeffValue;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_flags2;
        archive >> m_numInherit;
        archive.Load((uint8*)&m_Inherit, sizeof(m_Inherit));

        {
            archive >> m_numPopAssignmentElement;
            m_PopAssignmentElement = new PopAssignmentElement[m_numPopAssignmentElement];
            for(sint32 i = 0; i < m_numPopAssignmentElement; ++i){
                m_PopAssignmentElement[i].Serialize(archive);
            }
        }

        archive >> m_numGovernment;
        archive.Load((uint8*)m_Government, m_numGovernment * sizeof(sint32));

        archive >> m_MinimumHappinessValue;
        archive >> m_DeficitSpendingValue;
        archive >> m_MaximumWagePercentValue;

        {
            archive >> m_numSliderElement;
            m_SliderElement = new SliderElement[m_numSliderElement];
            for(sint32 i = 0; i < m_numSliderElement; ++i){
                m_SliderElement[i].Serialize(archive);
            }
        }

        archive >> m_SciencePercentValue;
        archive >> m_MaxSupportCostPercentValue;
        archive >> m_ReadinessLevelValue;
        archive >> m_PublicWorksPercentValue;
        archive >> m_PublicWorksReserveValue;
        archive >> m_MaxEvalTileImprovementsValue;
        archive >> m_TimeToFixRoadsValue;
        archive >> m_TimeToFixPollutionValue;
        archive >> m_FixPollutionThresholdValue;
        archive >> m_RoadUtilityBonusValue;
        archive >> m_ImproveProductionBonusValue;
        archive >> m_ImproveGrowthBonusValue;
        archive >> m_ImproveGoodBonusValue;
        archive >> m_ImproveSmallCityGrowthBonusValue;
        archive >> m_ImproveLargeCityProductionBonusValue;
        archive >> m_ImproveGrowthList;
        archive >> m_ImproveProductionList;
        archive >> m_ImproveRandomList;

        {
            archive >> m_numGoalElement;
            m_GoalElement = new GoalElement[m_numGoalElement];
            for(sint32 i = 0; i < m_numGoalElement; ++i){
                m_GoalElement[i].Serialize(archive);
            }
        }

        archive >> m_DistanceModifierFactorValue;
        archive >> m_DisbandArmyCountValue;
        archive >> m_MinSettleDistanceValue;
        archive >> m_MinSettleScoreValue;
        archive >> m_RushBuyThreatBonusValue;
        archive >> m_RushBuyReservePercentValue;
        archive >> m_UnitSupportPercentValue;
        archive >> m_MaxSettlerBuildTurnsValue;
        archive >> m_MaxUnitBuildTurnsValue;
        archive >> m_MaxWonderBuildTurnsValue;
        archive >> m_BuildTransportProductionLevelValue;
        archive >> m_BuildSettlerProductionLevelValue;
        archive >> m_OffensiveUnitsPercentValue;
        archive >> m_DefensiveUnitsPercentValue;
        archive >> m_RangedUnitsPercentValue;
        archive >> m_SeaUnitsPercentValue;
        archive >> m_AirUnitsPercentValue;
        archive >> m_SettlerUnitsCountValue;
        archive >> m_SpecialUnitsCountValue;
        archive >> m_SpyUnitsCountValue;
        archive >> m_SlaveryUnitsCountValue;
        archive >> m_DiplomatUnitsCountValue;
        archive >> m_MissionaryUnitsCountValue;
        archive >> m_SeaTransportUnitsCountValue;
        archive >> m_AirTransportUnitsCountValue;
        archive >> m_OffensiveUnitListValue;
        archive >> m_DefensiveUnitListValue;
        archive >> m_RangedUnitListValue;
        archive >> m_SeaUnitListValue;
        archive >> m_AirUnitListValue;
        archive >> m_SettlerUnitListValue;
        archive >> m_SeaSettlerUnitListValue;
        archive >> m_SpecialUnitListValue;
        archive >> m_SpyUnitListValue;
        archive >> m_SlaverUnitListValue;
        archive >> m_DiplomatUnitListValue;
        archive >> m_MissionaryUnitListValue;
        archive >> m_SeaTransportUnitListValue;
        archive >> m_AirTransportUnitListValue;
        archive >> m_FreightUnitListValue;
        archive >> m_OffensiveGarrisonCountValue;
        archive >> m_DefensiveGarrisonCountValue;
        archive >> m_RangedGarrisonCountValue;

        {
            archive >> m_numBuildListSequenceElement;
            m_BuildListSequenceElement = new BuildListSequenceElement[m_numBuildListSequenceElement];
            for(sint32 i = 0; i < m_numBuildListSequenceElement; ++i){
                m_BuildListSequenceElement[i].Serialize(archive);
            }
        }

        archive >> m_ResearchValue;
        archive >> m_StopResearchValue;
        archive >> m_FearInvasionValue;
        archive >> m_FearCityDefenseValue;
        archive >> m_FearPiracyValue;
        archive >> m_FearScienceRankValue;
        archive >> m_FearMilitaryRankValue;
        archive >> m_FearTradeRankValue;
        archive >> m_FearPollutionValue;
        archive >> m_DesireAttackValue;
        archive >> m_DesireGoldValue;
        archive >> m_DesireScienceValue;
        archive >> m_DesireMakeFriendValue;
        archive >> m_DesireEnlistFriendValue;
        archive >> m_PiracyMemoryTurnsValue;
        archive >> m_MaxPiracyEventsValue;
        memset((uint8*)&m_OffensiveValue, 0, sizeof(m_OffensiveValue));
        m_OffensiveValue.Serialize(archive);
        memset((uint8*)&m_DefensiveValue, 0, sizeof(m_DefensiveValue));
        m_DefensiveValue.Serialize(archive);
        memset((uint8*)&m_StealthAttackValue, 0, sizeof(m_StealthAttackValue));
        m_StealthAttackValue.Serialize(archive);
        memset((uint8*)&m_BombardValue, 0, sizeof(m_BombardValue));
        m_BombardValue.Serialize(archive);
        memset((uint8*)&m_SpecialValue, 0, sizeof(m_SpecialValue));
        m_SpecialValue.Serialize(archive);
        memset((uint8*)&m_HarassValue, 0, sizeof(m_HarassValue));
        m_HarassValue.Serialize(archive);
        archive >> m_NuclearFirstStrike;
        archive >> m_NuclearTargeting;
        archive >> m_PreemptiveStrikeRegardValue;
        archive >> m_PreemptiveStrikeRiskRatioValue;
        archive >> m_PreemptiveStrikeSuperiorityRatioValue;
        archive >> m_TurnsAcceptedForOnePopValue;
        archive >> m_StopBuildingFoodBeforePopMaxValue;
        archive >> m_RoadAlreadyThereCostsCoefficientValue;
        archive >> m_UseBaseMoveCostsForRoadsValue;
        archive >> m_BuildRoadsToClosestCitiesValue;
        archive >> m_BaseRoadPriorityVsThreatRankValue;
        archive >> m_SmallCityImproveCoeffValue;
    }
}

StrategyRecord::~StrategyRecord()
{
    delete [] m_PopAssignmentElement;
    delete [] m_Government;
    delete [] m_SliderElement;
    delete [] m_GoalElement;
    delete [] m_BuildListSequenceElement;
}

StrategyRecord const & StrategyRecord::operator = (StrategyRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;
        m_flags2 = rval.m_flags2;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        std::copy(rval.m_Inherit, rval.m_Inherit + rval.m_numInherit, m_Inherit);

        delete [] m_PopAssignmentElement;
        m_PopAssignmentElement = NULL;
        if (rval.m_numPopAssignmentElement > 0)
        {
            m_PopAssignmentElement = new PopAssignmentElement [rval.m_numPopAssignmentElement];
            std::copy(rval.m_PopAssignmentElement, rval.m_PopAssignmentElement + rval.m_numPopAssignmentElement, m_PopAssignmentElement);
        }
        m_numPopAssignmentElement = rval.m_numPopAssignmentElement;

        delete [] m_Government;
        m_Government = NULL;
        if (rval.m_numGovernment > 0)
        {
            m_Government = new sint32 [rval.m_numGovernment];
            std::copy(rval.m_Government, rval.m_Government + rval.m_numGovernment, m_Government);
        }
        m_numGovernment = rval.m_numGovernment;

        m_MinimumHappinessValue = rval.m_MinimumHappinessValue;

        m_DeficitSpendingValue = rval.m_DeficitSpendingValue;

        m_MaximumWagePercentValue = rval.m_MaximumWagePercentValue;

        delete [] m_SliderElement;
        m_SliderElement = NULL;
        if (rval.m_numSliderElement > 0)
        {
            m_SliderElement = new SliderElement [rval.m_numSliderElement];
            std::copy(rval.m_SliderElement, rval.m_SliderElement + rval.m_numSliderElement, m_SliderElement);
        }
        m_numSliderElement = rval.m_numSliderElement;

        m_SciencePercentValue = rval.m_SciencePercentValue;

        m_MaxSupportCostPercentValue = rval.m_MaxSupportCostPercentValue;

        m_ReadinessLevelValue = rval.m_ReadinessLevelValue;

        m_PublicWorksPercentValue = rval.m_PublicWorksPercentValue;

        m_PublicWorksReserveValue = rval.m_PublicWorksReserveValue;

        m_MaxEvalTileImprovementsValue = rval.m_MaxEvalTileImprovementsValue;

        m_TimeToFixRoadsValue = rval.m_TimeToFixRoadsValue;

        m_TimeToFixPollutionValue = rval.m_TimeToFixPollutionValue;

        m_FixPollutionThresholdValue = rval.m_FixPollutionThresholdValue;

        m_RoadUtilityBonusValue = rval.m_RoadUtilityBonusValue;

        m_ImproveProductionBonusValue = rval.m_ImproveProductionBonusValue;

        m_ImproveGrowthBonusValue = rval.m_ImproveGrowthBonusValue;

        m_ImproveGoodBonusValue = rval.m_ImproveGoodBonusValue;

        m_ImproveSmallCityGrowthBonusValue = rval.m_ImproveSmallCityGrowthBonusValue;

        m_ImproveLargeCityProductionBonusValue = rval.m_ImproveLargeCityProductionBonusValue;

        m_ImproveGrowthList = rval.m_ImproveGrowthList;

        m_ImproveProductionList = rval.m_ImproveProductionList;

        m_ImproveRandomList = rval.m_ImproveRandomList;

        delete [] m_GoalElement;
        m_GoalElement = NULL;
        if (rval.m_numGoalElement > 0)
        {
            m_GoalElement = new GoalElement [rval.m_numGoalElement];
            std::copy(rval.m_GoalElement, rval.m_GoalElement + rval.m_numGoalElement, m_GoalElement);
        }
        m_numGoalElement = rval.m_numGoalElement;

        m_DistanceModifierFactorValue = rval.m_DistanceModifierFactorValue;

        m_DisbandArmyCountValue = rval.m_DisbandArmyCountValue;

        m_MinSettleDistanceValue = rval.m_MinSettleDistanceValue;

        m_MinSettleScoreValue = rval.m_MinSettleScoreValue;

        m_RushBuyThreatBonusValue = rval.m_RushBuyThreatBonusValue;

        m_RushBuyReservePercentValue = rval.m_RushBuyReservePercentValue;

        m_UnitSupportPercentValue = rval.m_UnitSupportPercentValue;

        m_MaxSettlerBuildTurnsValue = rval.m_MaxSettlerBuildTurnsValue;

        m_MaxUnitBuildTurnsValue = rval.m_MaxUnitBuildTurnsValue;

        m_MaxWonderBuildTurnsValue = rval.m_MaxWonderBuildTurnsValue;

        m_BuildTransportProductionLevelValue = rval.m_BuildTransportProductionLevelValue;

        m_BuildSettlerProductionLevelValue = rval.m_BuildSettlerProductionLevelValue;

        m_OffensiveUnitsPercentValue = rval.m_OffensiveUnitsPercentValue;

        m_DefensiveUnitsPercentValue = rval.m_DefensiveUnitsPercentValue;

        m_RangedUnitsPercentValue = rval.m_RangedUnitsPercentValue;

        m_SeaUnitsPercentValue = rval.m_SeaUnitsPercentValue;

        m_AirUnitsPercentValue = rval.m_AirUnitsPercentValue;

        m_SettlerUnitsCountValue = rval.m_SettlerUnitsCountValue;

        m_SpecialUnitsCountValue = rval.m_SpecialUnitsCountValue;

        m_SpyUnitsCountValue = rval.m_SpyUnitsCountValue;

        m_SlaveryUnitsCountValue = rval.m_SlaveryUnitsCountValue;

        m_DiplomatUnitsCountValue = rval.m_DiplomatUnitsCountValue;

        m_MissionaryUnitsCountValue = rval.m_MissionaryUnitsCountValue;

        m_SeaTransportUnitsCountValue = rval.m_SeaTransportUnitsCountValue;

        m_AirTransportUnitsCountValue = rval.m_AirTransportUnitsCountValue;

        m_OffensiveUnitListValue = rval.m_OffensiveUnitListValue;

        m_DefensiveUnitListValue = rval.m_DefensiveUnitListValue;

        m_RangedUnitListValue = rval.m_RangedUnitListValue;

        m_SeaUnitListValue = rval.m_SeaUnitListValue;

        m_AirUnitListValue = rval.m_AirUnitListValue;

        m_SettlerUnitListValue = rval.m_SettlerUnitListValue;

        m_SeaSettlerUnitListValue = rval.m_SeaSettlerUnitListValue;

        m_SpecialUnitListValue = rval.m_SpecialUnitListValue;

        m_SpyUnitListValue = rval.m_SpyUnitListValue;

        m_SlaverUnitListValue = rval.m_SlaverUnitListValue;

        m_DiplomatUnitListValue = rval.m_DiplomatUnitListValue;

        m_MissionaryUnitListValue = rval.m_MissionaryUnitListValue;

        m_SeaTransportUnitListValue = rval.m_SeaTransportUnitListValue;

        m_AirTransportUnitListValue = rval.m_AirTransportUnitListValue;

        m_FreightUnitListValue = rval.m_FreightUnitListValue;

        m_OffensiveGarrisonCountValue = rval.m_OffensiveGarrisonCountValue;

        m_DefensiveGarrisonCountValue = rval.m_DefensiveGarrisonCountValue;

        m_RangedGarrisonCountValue = rval.m_RangedGarrisonCountValue;

        delete [] m_BuildListSequenceElement;
        m_BuildListSequenceElement = NULL;
        if (rval.m_numBuildListSequenceElement > 0)
        {
            m_BuildListSequenceElement = new BuildListSequenceElement [rval.m_numBuildListSequenceElement];
            std::copy(rval.m_BuildListSequenceElement, rval.m_BuildListSequenceElement + rval.m_numBuildListSequenceElement, m_BuildListSequenceElement);
        }
        m_numBuildListSequenceElement = rval.m_numBuildListSequenceElement;

        m_ResearchValue = rval.m_ResearchValue;

        m_StopResearchValue = rval.m_StopResearchValue;

        m_FearInvasionValue = rval.m_FearInvasionValue;

        m_FearCityDefenseValue = rval.m_FearCityDefenseValue;

        m_FearPiracyValue = rval.m_FearPiracyValue;

        m_FearScienceRankValue = rval.m_FearScienceRankValue;

        m_FearMilitaryRankValue = rval.m_FearMilitaryRankValue;

        m_FearTradeRankValue = rval.m_FearTradeRankValue;

        m_FearPollutionValue = rval.m_FearPollutionValue;

        m_DesireAttackValue = rval.m_DesireAttackValue;

        m_DesireGoldValue = rval.m_DesireGoldValue;

        m_DesireScienceValue = rval.m_DesireScienceValue;

        m_DesireMakeFriendValue = rval.m_DesireMakeFriendValue;

        m_DesireEnlistFriendValue = rval.m_DesireEnlistFriendValue;

        m_PiracyMemoryTurnsValue = rval.m_PiracyMemoryTurnsValue;

        m_MaxPiracyEventsValue = rval.m_MaxPiracyEventsValue;

        m_OffensiveValue = rval.m_OffensiveValue;

        m_DefensiveValue = rval.m_DefensiveValue;

        m_StealthAttackValue = rval.m_StealthAttackValue;

        m_BombardValue = rval.m_BombardValue;

        m_SpecialValue = rval.m_SpecialValue;

        m_HarassValue = rval.m_HarassValue;

        m_NuclearFirstStrike = rval.m_NuclearFirstStrike;

        m_NuclearTargeting = rval.m_NuclearTargeting;

        m_PreemptiveStrikeRegardValue = rval.m_PreemptiveStrikeRegardValue;

        m_PreemptiveStrikeRiskRatioValue = rval.m_PreemptiveStrikeRiskRatioValue;

        m_PreemptiveStrikeSuperiorityRatioValue = rval.m_PreemptiveStrikeSuperiorityRatioValue;

        m_TurnsAcceptedForOnePopValue = rval.m_TurnsAcceptedForOnePopValue;

        m_StopBuildingFoodBeforePopMaxValue = rval.m_StopBuildingFoodBeforePopMaxValue;

        m_RoadAlreadyThereCostsCoefficientValue = rval.m_RoadAlreadyThereCostsCoefficientValue;

        m_UseBaseMoveCostsForRoadsValue = rval.m_UseBaseMoveCostsForRoadsValue;

        m_BuildRoadsToClosestCitiesValue = rval.m_BuildRoadsToClosestCitiesValue;

        m_BaseRoadPriorityVsThreatRankValue = rval.m_BaseRoadPriorityVsThreatRankValue;

        m_SmallCityImproveCoeffValue = rval.m_SmallCityImproveCoeffValue;

    }

    return *this;
}

const char *g_Strategy_Tokens[] =
{
    "Inherit",
    "PopAssignmentElement",
    "Government",
    "MinimumHappiness",
    "MinimumHappinessValue",
    "DeficitSpending",
    "DeficitSpendingValue",
    "MaximumWagePercent",
    "MaximumWagePercentValue",
    "SliderElement",
    "SciencePercent",
    "SciencePercentValue",
    "MaxSupportCostPercent",
    "MaxSupportCostPercentValue",
    "ReadinessLevel",
    "ReadinessLevelValue",
    "PublicWorksPercent",
    "PublicWorksPercentValue",
    "PublicWorksReserve",
    "PublicWorksReserveValue",
    "MaxEvalTileImprovements",
    "MaxEvalTileImprovementsValue",
    "TimeToFixRoads",
    "TimeToFixRoadsValue",
    "TimeToFixPollution",
    "TimeToFixPollutionValue",
    "FixPollutionThreshold",
    "FixPollutionThresholdValue",
    "RoadUtilityBonus",
    "RoadUtilityBonusValue",
    "ImproveProductionBonus",
    "ImproveProductionBonusValue",
    "ImproveGrowthBonus",
    "ImproveGrowthBonusValue",
    "ImproveGoodBonus",
    "ImproveGoodBonusValue",
    "ImproveSmallCityGrowthBonus",
    "ImproveSmallCityGrowthBonusValue",
    "ImproveLargeCityProductionBonus",
    "ImproveLargeCityProductionBonusValue",
    "ImproveGrowthList",
    "ImproveProductionList",
    "ImproveRandomList",
    "GoalElement",
    "DistanceModifierFactor",
    "DistanceModifierFactorValue",
    "DisbandArmyCount",
    "DisbandArmyCountValue",
    "MinSettleDistance",
    "MinSettleDistanceValue",
    "MinSettleScore",
    "MinSettleScoreValue",
    "RushBuyThreatBonus",
    "RushBuyThreatBonusValue",
    "RushBuyReservePercent",
    "RushBuyReservePercentValue",
    "UnitSupportPercent",
    "UnitSupportPercentValue",
    "MaxSettlerBuildTurns",
    "MaxSettlerBuildTurnsValue",
    "MaxUnitBuildTurns",
    "MaxUnitBuildTurnsValue",
    "MaxWonderBuildTurns",
    "MaxWonderBuildTurnsValue",
    "BuildTransportProductionLevel",
    "BuildTransportProductionLevelValue",
    "BuildSettlerProductionLevel",
    "BuildSettlerProductionLevelValue",
    "OffensiveUnitsPercent",
    "OffensiveUnitsPercentValue",
    "DefensiveUnitsPercent",
    "DefensiveUnitsPercentValue",
    "RangedUnitsPercent",
    "RangedUnitsPercentValue",
    "SeaUnitsPercent",
    "SeaUnitsPercentValue",
    "AirUnitsPercent",
    "AirUnitsPercentValue",
    "SettlerUnitsCount",
    "SettlerUnitsCountValue",
    "SpecialUnitsCount",
    "SpecialUnitsCountValue",
    "SpyUnitsCount",
    "SpyUnitsCountValue",
    "SlaveryUnitsCount",
    "SlaveryUnitsCountValue",
    "DiplomatUnitsCount",
    "DiplomatUnitsCountValue",
    "MissionaryUnitsCount",
    "MissionaryUnitsCountValue",
    "SeaTransportUnitsCount",
    "SeaTransportUnitsCountValue",
    "AirTransportUnitsCount",
    "AirTransportUnitsCountValue",
    "OffensiveUnitList",
    "OffensiveUnitListValue",
    "DefensiveUnitList",
    "DefensiveUnitListValue",
    "RangedUnitList",
    "RangedUnitListValue",
    "SeaUnitList",
    "SeaUnitListValue",
    "AirUnitList",
    "AirUnitListValue",
    "SettlerUnitList",
    "SettlerUnitListValue",
    "SeaSettlerUnitList",
    "SeaSettlerUnitListValue",
    "SpecialUnitList",
    "SpecialUnitListValue",
    "SpyUnitList",
    "SpyUnitListValue",
    "SlaverUnitList",
    "SlaverUnitListValue",
    "DiplomatUnitList",
    "DiplomatUnitListValue",
    "MissionaryUnitList",
    "MissionaryUnitListValue",
    "SeaTransportUnitList",
    "SeaTransportUnitListValue",
    "AirTransportUnitList",
    "AirTransportUnitListValue",
    "FreightUnitList",
    "FreightUnitListValue",
    "OffensiveGarrisonCount",
    "OffensiveGarrisonCountValue",
    "DefensiveGarrisonCount",
    "DefensiveGarrisonCountValue",
    "RangedGarrisonCount",
    "RangedGarrisonCountValue",
    "BuildListSequenceElement",
    "Research",
    "ResearchValue",
    "StopResearch",
    "StopResearchValue",
    "FearInvasion",
    "FearInvasionValue",
    "FearCityDefense",
    "FearCityDefenseValue",
    "FearPiracy",
    "FearPiracyValue",
    "FearScienceRank",
    "FearScienceRankValue",
    "FearMilitaryRank",
    "FearMilitaryRankValue",
    "FearTradeRank",
    "FearTradeRankValue",
    "FearPollution",
    "FearPollutionValue",
    "DesireAttack",
    "DesireAttackValue",
    "DesireGold",
    "DesireGoldValue",
    "DesireScience",
    "DesireScienceValue",
    "DesireMakeFriend",
    "DesireMakeFriendValue",
    "DesireEnlistFriend",
    "DesireEnlistFriendValue",
    "PiracyMemoryTurns",
    "PiracyMemoryTurnsValue",
    "MaxPiracyEvents",
    "MaxPiracyEventsValue",
    "Offensive",
    "OffensiveValue",
    "Defensive",
    "DefensiveValue",
    "StealthAttack",
    "StealthAttackValue",
    "Bombard",
    "BombardValue",
    "Special",
    "SpecialValue",
    "Harass",
    "HarassValue",
    "NuclearFirstStrike",
    "NuclearTargeting",
    "PreemptiveStrikeRegard",
    "PreemptiveStrikeRegardValue",
    "PreemptiveStrikeRiskRatio",
    "PreemptiveStrikeRiskRatioValue",
    "PreemptiveStrikeSuperiorityRatio",
    "PreemptiveStrikeSuperiorityRatioValue",
    "TurnsAcceptedForOnePop",
    "TurnsAcceptedForOnePopValue",
    "StopBuildingFoodBeforePopMax",
    "StopBuildingFoodBeforePopMaxValue",
    "RoadAlreadyThereCostsCoefficient",
    "RoadAlreadyThereCostsCoefficientValue",
    "UseBaseMoveCostsForRoads",
    "UseBaseMoveCostsForRoadsValue",
    "BuildRoadsToClosestCities",
    "BuildRoadsToClosestCitiesValue",
    "BaseRoadPriorityVsThreatRank",
    "BaseRoadPriorityVsThreatRankValue",
    "SmallCityImproveCoeff",
    "SmallCityImproveCoeffValue",
};

StrategyRecordAccessorInfo g_StrategyRecord_Accessors[] =
{
    { &StrategyRecord::GetNumInherit, NULL, NULL, NULL, NULL, &StrategyRecord::GetInheritIndex, NULL}, /* Inherit (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PopAssignmentElement */
    { &StrategyRecord::GetNumGovernment, NULL, NULL, NULL, NULL, &StrategyRecord::GetGovernmentIndex, NULL}, /* Government (array) */
    { NULL, NULL, NULL, &StrategyRecord::GetMinimumHappiness, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MinimumHappiness */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetDeficitSpending, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DeficitSpending */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetMaximumWagePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaximumWagePercent */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SliderElement */
    { NULL, NULL, NULL, &StrategyRecord::GetSciencePercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SciencePercent */
    { NULL, NULL, NULL, &StrategyRecord::GetMaxSupportCostPercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaxSupportCostPercent */
    { NULL, NULL, NULL, &StrategyRecord::GetReadinessLevel, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ReadinessLevel */
    { NULL, NULL, NULL, &StrategyRecord::GetPublicWorksPercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PublicWorksPercent */
    { NULL, NULL, NULL, &StrategyRecord::GetPublicWorksReserve, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PublicWorksReserve */
    { NULL, NULL, NULL, &StrategyRecord::GetMaxEvalTileImprovements, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaxEvalTileImprovements */
    { NULL, NULL, NULL, &StrategyRecord::GetTimeToFixRoads, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TimeToFixRoads */
    { NULL, NULL, NULL, &StrategyRecord::GetTimeToFixPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TimeToFixPollution */
    { NULL, NULL, NULL, &StrategyRecord::GetFixPollutionThreshold, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FixPollutionThreshold */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetRoadUtilityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RoadUtilityBonus */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetImproveProductionBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ImproveProductionBonus */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetImproveGrowthBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ImproveGrowthBonus */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetImproveGoodBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ImproveGoodBonus */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetImproveSmallCityGrowthBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ImproveSmallCityGrowthBonus */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetImproveLargeCityProductionBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ImproveLargeCityProductionBonus */
    { &StrategyRecord::GetImproveGrowthListIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &StrategyRecord::GetImproveProductionListIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &StrategyRecord::GetImproveRandomListIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoalElement */
    { NULL, NULL, NULL, &StrategyRecord::GetDistanceModifierFactor, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DistanceModifierFactor */
    { NULL, NULL, NULL, &StrategyRecord::GetDisbandArmyCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DisbandArmyCount */
    { NULL, NULL, NULL, &StrategyRecord::GetMinSettleDistance, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MinSettleDistance */
    { NULL, NULL, NULL, &StrategyRecord::GetMinSettleScore, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MinSettleScore */
    { NULL, NULL, NULL, &StrategyRecord::GetRushBuyThreatBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RushBuyThreatBonus */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetRushBuyReservePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RushBuyReservePercent */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetUnitSupportPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UnitSupportPercent */
    { NULL, NULL, NULL, &StrategyRecord::GetMaxSettlerBuildTurns, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaxSettlerBuildTurns */
    { NULL, NULL, NULL, &StrategyRecord::GetMaxUnitBuildTurns, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaxUnitBuildTurns */
    { NULL, NULL, NULL, &StrategyRecord::GetMaxWonderBuildTurns, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaxWonderBuildTurns */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetBuildTransportProductionLevel, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildTransportProductionLevel */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetBuildSettlerProductionLevel, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildSettlerProductionLevel */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetOffensiveUnitsPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OffensiveUnitsPercent */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetDefensiveUnitsPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefensiveUnitsPercent */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetRangedUnitsPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedUnitsPercent */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetSeaUnitsPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaUnitsPercent */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetAirUnitsPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirUnitsPercent */
    { NULL, NULL, NULL, &StrategyRecord::GetSettlerUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SettlerUnitsCount */
    { NULL, NULL, NULL, &StrategyRecord::GetSpecialUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpecialUnitsCount */
    { NULL, NULL, NULL, &StrategyRecord::GetSpyUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpyUnitsCount */
    { NULL, NULL, NULL, &StrategyRecord::GetSlaveryUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveryUnitsCount */
    { NULL, NULL, NULL, &StrategyRecord::GetDiplomatUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DiplomatUnitsCount */
    { NULL, NULL, NULL, &StrategyRecord::GetMissionaryUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MissionaryUnitsCount */
    { NULL, NULL, NULL, &StrategyRecord::GetSeaTransportUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaTransportUnitsCount */
    { NULL, NULL, NULL, &StrategyRecord::GetAirTransportUnitsCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirTransportUnitsCount */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OffensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OffensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SettlerUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SettlerUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaSettlerUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaSettlerUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpecialUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpecialUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpyUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpyUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaverUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaverUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DiplomatUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DiplomatUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MissionaryUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MissionaryUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeaTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FreightUnitList */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FreightUnitList */
    { NULL, NULL, NULL, &StrategyRecord::GetOffensiveGarrisonCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OffensiveGarrisonCount */
    { NULL, NULL, NULL, &StrategyRecord::GetDefensiveGarrisonCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefensiveGarrisonCount */
    { NULL, NULL, NULL, &StrategyRecord::GetRangedGarrisonCount, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedGarrisonCount */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildListSequenceElement */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Research */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Research */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StopResearch */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StopResearch */
    { NULL, NULL, NULL, &StrategyRecord::GetFearInvasion, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FearInvasion */
    { NULL, NULL, NULL, &StrategyRecord::GetFearCityDefense, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FearCityDefense */
    { NULL, NULL, NULL, &StrategyRecord::GetFearPiracy, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FearPiracy */
    { NULL, NULL, NULL, &StrategyRecord::GetFearScienceRank, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FearScienceRank */
    { NULL, NULL, NULL, &StrategyRecord::GetFearMilitaryRank, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FearMilitaryRank */
    { NULL, NULL, NULL, &StrategyRecord::GetFearTradeRank, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FearTradeRank */
    { NULL, NULL, NULL, &StrategyRecord::GetFearPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FearPollution */
    { NULL, NULL, NULL, &StrategyRecord::GetDesireAttack, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DesireAttack */
    { NULL, NULL, NULL, &StrategyRecord::GetDesireGold, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DesireGold */
    { NULL, NULL, NULL, &StrategyRecord::GetDesireScience, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DesireScience */
    { NULL, NULL, NULL, &StrategyRecord::GetDesireMakeFriend, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DesireMakeFriend */
    { NULL, NULL, NULL, &StrategyRecord::GetDesireEnlistFriend, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DesireEnlistFriend */
    { NULL, NULL, NULL, &StrategyRecord::GetPiracyMemoryTurns, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PiracyMemoryTurns */
    { NULL, NULL, NULL, &StrategyRecord::GetMaxPiracyEvents, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaxPiracyEvents */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Offensive */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Offensive */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Defensive */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Defensive */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StealthAttack */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StealthAttack */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Bombard */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Bombard */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Special */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Special */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Harass */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Harass */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearFirstStrike */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearTargeting */
    { NULL, NULL, NULL, &StrategyRecord::GetPreemptiveStrikeRegard, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PreemptiveStrikeRegard */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetPreemptiveStrikeRiskRatio, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PreemptiveStrikeRiskRatio */
    { NULL, NULL, NULL, NULL, &StrategyRecord::GetPreemptiveStrikeSuperiorityRatio, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PreemptiveStrikeSuperiorityRatio */
    { &StrategyRecord::GetTurnsAcceptedForOnePop, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TurnsAcceptedForOnePop */
    { &StrategyRecord::GetStopBuildingFoodBeforePopMax, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StopBuildingFoodBeforePopMax */
    { NULL, NULL, &StrategyRecord::GetRoadAlreadyThereCostsCoefficient, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RoadAlreadyThereCostsCoefficient */
    { &StrategyRecord::GetUseBaseMoveCostsForRoads, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UseBaseMoveCostsForRoads */
    { &StrategyRecord::GetBuildRoadsToClosestCities, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildRoadsToClosestCities */
    { NULL, NULL, &StrategyRecord::GetBaseRoadPriorityVsThreatRank, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BaseRoadPriorityVsThreatRank */
    { NULL, NULL, &StrategyRecord::GetSmallCityImproveCoeff, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SmallCityImproveCoeff */
};

#define k_Token_Strategy_Inherit                 ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_PopAssignmentElement    ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_Government              ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_MinimumHappiness        ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_MinimumHappiness_Value  ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_DeficitSpending         ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_DeficitSpending_Value   ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_MaximumWagePercent      ((k_Token_Custom_Base) + 7)
#define k_Token_Strategy_MaximumWagePercent_Value ((k_Token_Custom_Base) + 8)
#define k_Token_Strategy_SliderElement           ((k_Token_Custom_Base) + 9)
#define k_Token_Strategy_SciencePercent          ((k_Token_Custom_Base) + 10)
#define k_Token_Strategy_SciencePercent_Value    ((k_Token_Custom_Base) + 11)
#define k_Token_Strategy_MaxSupportCostPercent   ((k_Token_Custom_Base) + 12)
#define k_Token_Strategy_MaxSupportCostPercent_Value ((k_Token_Custom_Base) + 13)
#define k_Token_Strategy_ReadinessLevel          ((k_Token_Custom_Base) + 14)
#define k_Token_Strategy_ReadinessLevel_Value    ((k_Token_Custom_Base) + 15)
#define k_Token_Strategy_PublicWorksPercent      ((k_Token_Custom_Base) + 16)
#define k_Token_Strategy_PublicWorksPercent_Value ((k_Token_Custom_Base) + 17)
#define k_Token_Strategy_PublicWorksReserve      ((k_Token_Custom_Base) + 18)
#define k_Token_Strategy_PublicWorksReserve_Value ((k_Token_Custom_Base) + 19)
#define k_Token_Strategy_MaxEvalTileImprovements ((k_Token_Custom_Base) + 20)
#define k_Token_Strategy_MaxEvalTileImprovements_Value ((k_Token_Custom_Base) + 21)
#define k_Token_Strategy_TimeToFixRoads          ((k_Token_Custom_Base) + 22)
#define k_Token_Strategy_TimeToFixRoads_Value    ((k_Token_Custom_Base) + 23)
#define k_Token_Strategy_TimeToFixPollution      ((k_Token_Custom_Base) + 24)
#define k_Token_Strategy_TimeToFixPollution_Value ((k_Token_Custom_Base) + 25)
#define k_Token_Strategy_FixPollutionThreshold   ((k_Token_Custom_Base) + 26)
#define k_Token_Strategy_FixPollutionThreshold_Value ((k_Token_Custom_Base) + 27)
#define k_Token_Strategy_RoadUtilityBonus        ((k_Token_Custom_Base) + 28)
#define k_Token_Strategy_RoadUtilityBonus_Value  ((k_Token_Custom_Base) + 29)
#define k_Token_Strategy_ImproveProductionBonus  ((k_Token_Custom_Base) + 30)
#define k_Token_Strategy_ImproveProductionBonus_Value ((k_Token_Custom_Base) + 31)
#define k_Token_Strategy_ImproveGrowthBonus      ((k_Token_Custom_Base) + 32)
#define k_Token_Strategy_ImproveGrowthBonus_Value ((k_Token_Custom_Base) + 33)
#define k_Token_Strategy_ImproveGoodBonus        ((k_Token_Custom_Base) + 34)
#define k_Token_Strategy_ImproveGoodBonus_Value  ((k_Token_Custom_Base) + 35)
#define k_Token_Strategy_ImproveSmallCityGrowthBonus ((k_Token_Custom_Base) + 36)
#define k_Token_Strategy_ImproveSmallCityGrowthBonus_Value ((k_Token_Custom_Base) + 37)
#define k_Token_Strategy_ImproveLargeCityProductionBonus ((k_Token_Custom_Base) + 38)
#define k_Token_Strategy_ImproveLargeCityProductionBonus_Value ((k_Token_Custom_Base) + 39)
#define k_Token_Strategy_ImproveGrowthList       ((k_Token_Custom_Base) + 40)
#define k_Token_Strategy_ImproveProductionList   ((k_Token_Custom_Base) + 41)
#define k_Token_Strategy_ImproveRandomList       ((k_Token_Custom_Base) + 42)
#define k_Token_Strategy_GoalElement             ((k_Token_Custom_Base) + 43)
#define k_Token_Strategy_DistanceModifierFactor  ((k_Token_Custom_Base) + 44)
#define k_Token_Strategy_DistanceModifierFactor_Value ((k_Token_Custom_Base) + 45)
#define k_Token_Strategy_DisbandArmyCount        ((k_Token_Custom_Base) + 46)
#define k_Token_Strategy_DisbandArmyCount_Value  ((k_Token_Custom_Base) + 47)
#define k_Token_Strategy_MinSettleDistance       ((k_Token_Custom_Base) + 48)
#define k_Token_Strategy_MinSettleDistance_Value ((k_Token_Custom_Base) + 49)
#define k_Token_Strategy_MinSettleScore          ((k_Token_Custom_Base) + 50)
#define k_Token_Strategy_MinSettleScore_Value    ((k_Token_Custom_Base) + 51)
#define k_Token_Strategy_RushBuyThreatBonus      ((k_Token_Custom_Base) + 52)
#define k_Token_Strategy_RushBuyThreatBonus_Value ((k_Token_Custom_Base) + 53)
#define k_Token_Strategy_RushBuyReservePercent   ((k_Token_Custom_Base) + 54)
#define k_Token_Strategy_RushBuyReservePercent_Value ((k_Token_Custom_Base) + 55)
#define k_Token_Strategy_UnitSupportPercent      ((k_Token_Custom_Base) + 56)
#define k_Token_Strategy_UnitSupportPercent_Value ((k_Token_Custom_Base) + 57)
#define k_Token_Strategy_MaxSettlerBuildTurns    ((k_Token_Custom_Base) + 58)
#define k_Token_Strategy_MaxSettlerBuildTurns_Value ((k_Token_Custom_Base) + 59)
#define k_Token_Strategy_MaxUnitBuildTurns       ((k_Token_Custom_Base) + 60)
#define k_Token_Strategy_MaxUnitBuildTurns_Value ((k_Token_Custom_Base) + 61)
#define k_Token_Strategy_MaxWonderBuildTurns     ((k_Token_Custom_Base) + 62)
#define k_Token_Strategy_MaxWonderBuildTurns_Value ((k_Token_Custom_Base) + 63)
#define k_Token_Strategy_BuildTransportProductionLevel ((k_Token_Custom_Base) + 64)
#define k_Token_Strategy_BuildTransportProductionLevel_Value ((k_Token_Custom_Base) + 65)
#define k_Token_Strategy_BuildSettlerProductionLevel ((k_Token_Custom_Base) + 66)
#define k_Token_Strategy_BuildSettlerProductionLevel_Value ((k_Token_Custom_Base) + 67)
#define k_Token_Strategy_OffensiveUnitsPercent   ((k_Token_Custom_Base) + 68)
#define k_Token_Strategy_OffensiveUnitsPercent_Value ((k_Token_Custom_Base) + 69)
#define k_Token_Strategy_DefensiveUnitsPercent   ((k_Token_Custom_Base) + 70)
#define k_Token_Strategy_DefensiveUnitsPercent_Value ((k_Token_Custom_Base) + 71)
#define k_Token_Strategy_RangedUnitsPercent      ((k_Token_Custom_Base) + 72)
#define k_Token_Strategy_RangedUnitsPercent_Value ((k_Token_Custom_Base) + 73)
#define k_Token_Strategy_SeaUnitsPercent         ((k_Token_Custom_Base) + 74)
#define k_Token_Strategy_SeaUnitsPercent_Value   ((k_Token_Custom_Base) + 75)
#define k_Token_Strategy_AirUnitsPercent         ((k_Token_Custom_Base) + 76)
#define k_Token_Strategy_AirUnitsPercent_Value   ((k_Token_Custom_Base) + 77)
#define k_Token_Strategy_SettlerUnitsCount       ((k_Token_Custom_Base) + 78)
#define k_Token_Strategy_SettlerUnitsCount_Value ((k_Token_Custom_Base) + 79)
#define k_Token_Strategy_SpecialUnitsCount       ((k_Token_Custom_Base) + 80)
#define k_Token_Strategy_SpecialUnitsCount_Value ((k_Token_Custom_Base) + 81)
#define k_Token_Strategy_SpyUnitsCount           ((k_Token_Custom_Base) + 82)
#define k_Token_Strategy_SpyUnitsCount_Value     ((k_Token_Custom_Base) + 83)
#define k_Token_Strategy_SlaveryUnitsCount       ((k_Token_Custom_Base) + 84)
#define k_Token_Strategy_SlaveryUnitsCount_Value ((k_Token_Custom_Base) + 85)
#define k_Token_Strategy_DiplomatUnitsCount      ((k_Token_Custom_Base) + 86)
#define k_Token_Strategy_DiplomatUnitsCount_Value ((k_Token_Custom_Base) + 87)
#define k_Token_Strategy_MissionaryUnitsCount    ((k_Token_Custom_Base) + 88)
#define k_Token_Strategy_MissionaryUnitsCount_Value ((k_Token_Custom_Base) + 89)
#define k_Token_Strategy_SeaTransportUnitsCount  ((k_Token_Custom_Base) + 90)
#define k_Token_Strategy_SeaTransportUnitsCount_Value ((k_Token_Custom_Base) + 91)
#define k_Token_Strategy_AirTransportUnitsCount  ((k_Token_Custom_Base) + 92)
#define k_Token_Strategy_AirTransportUnitsCount_Value ((k_Token_Custom_Base) + 93)
#define k_Token_Strategy_OffensiveUnitList       ((k_Token_Custom_Base) + 94)
#define k_Token_Strategy_OffensiveUnitList_Value ((k_Token_Custom_Base) + 95)
#define k_Token_Strategy_DefensiveUnitList       ((k_Token_Custom_Base) + 96)
#define k_Token_Strategy_DefensiveUnitList_Value ((k_Token_Custom_Base) + 97)
#define k_Token_Strategy_RangedUnitList          ((k_Token_Custom_Base) + 98)
#define k_Token_Strategy_RangedUnitList_Value    ((k_Token_Custom_Base) + 99)
#define k_Token_Strategy_SeaUnitList             ((k_Token_Custom_Base) + 100)
#define k_Token_Strategy_SeaUnitList_Value       ((k_Token_Custom_Base) + 101)
#define k_Token_Strategy_AirUnitList             ((k_Token_Custom_Base) + 102)
#define k_Token_Strategy_AirUnitList_Value       ((k_Token_Custom_Base) + 103)
#define k_Token_Strategy_SettlerUnitList         ((k_Token_Custom_Base) + 104)
#define k_Token_Strategy_SettlerUnitList_Value   ((k_Token_Custom_Base) + 105)
#define k_Token_Strategy_SeaSettlerUnitList      ((k_Token_Custom_Base) + 106)
#define k_Token_Strategy_SeaSettlerUnitList_Value ((k_Token_Custom_Base) + 107)
#define k_Token_Strategy_SpecialUnitList         ((k_Token_Custom_Base) + 108)
#define k_Token_Strategy_SpecialUnitList_Value   ((k_Token_Custom_Base) + 109)
#define k_Token_Strategy_SpyUnitList             ((k_Token_Custom_Base) + 110)
#define k_Token_Strategy_SpyUnitList_Value       ((k_Token_Custom_Base) + 111)
#define k_Token_Strategy_SlaverUnitList          ((k_Token_Custom_Base) + 112)
#define k_Token_Strategy_SlaverUnitList_Value    ((k_Token_Custom_Base) + 113)
#define k_Token_Strategy_DiplomatUnitList        ((k_Token_Custom_Base) + 114)
#define k_Token_Strategy_DiplomatUnitList_Value  ((k_Token_Custom_Base) + 115)
#define k_Token_Strategy_MissionaryUnitList      ((k_Token_Custom_Base) + 116)
#define k_Token_Strategy_MissionaryUnitList_Value ((k_Token_Custom_Base) + 117)
#define k_Token_Strategy_SeaTransportUnitList    ((k_Token_Custom_Base) + 118)
#define k_Token_Strategy_SeaTransportUnitList_Value ((k_Token_Custom_Base) + 119)
#define k_Token_Strategy_AirTransportUnitList    ((k_Token_Custom_Base) + 120)
#define k_Token_Strategy_AirTransportUnitList_Value ((k_Token_Custom_Base) + 121)
#define k_Token_Strategy_FreightUnitList         ((k_Token_Custom_Base) + 122)
#define k_Token_Strategy_FreightUnitList_Value   ((k_Token_Custom_Base) + 123)
#define k_Token_Strategy_OffensiveGarrisonCount  ((k_Token_Custom_Base) + 124)
#define k_Token_Strategy_OffensiveGarrisonCount_Value ((k_Token_Custom_Base) + 125)
#define k_Token_Strategy_DefensiveGarrisonCount  ((k_Token_Custom_Base) + 126)
#define k_Token_Strategy_DefensiveGarrisonCount_Value ((k_Token_Custom_Base) + 127)
#define k_Token_Strategy_RangedGarrisonCount     ((k_Token_Custom_Base) + 128)
#define k_Token_Strategy_RangedGarrisonCount_Value ((k_Token_Custom_Base) + 129)
#define k_Token_Strategy_BuildListSequenceElement ((k_Token_Custom_Base) + 130)
#define k_Token_Strategy_Research                ((k_Token_Custom_Base) + 131)
#define k_Token_Strategy_Research_Value          ((k_Token_Custom_Base) + 132)
#define k_Token_Strategy_StopResearch            ((k_Token_Custom_Base) + 133)
#define k_Token_Strategy_StopResearch_Value      ((k_Token_Custom_Base) + 134)
#define k_Token_Strategy_FearInvasion            ((k_Token_Custom_Base) + 135)
#define k_Token_Strategy_FearInvasion_Value      ((k_Token_Custom_Base) + 136)
#define k_Token_Strategy_FearCityDefense         ((k_Token_Custom_Base) + 137)
#define k_Token_Strategy_FearCityDefense_Value   ((k_Token_Custom_Base) + 138)
#define k_Token_Strategy_FearPiracy              ((k_Token_Custom_Base) + 139)
#define k_Token_Strategy_FearPiracy_Value        ((k_Token_Custom_Base) + 140)
#define k_Token_Strategy_FearScienceRank         ((k_Token_Custom_Base) + 141)
#define k_Token_Strategy_FearScienceRank_Value   ((k_Token_Custom_Base) + 142)
#define k_Token_Strategy_FearMilitaryRank        ((k_Token_Custom_Base) + 143)
#define k_Token_Strategy_FearMilitaryRank_Value  ((k_Token_Custom_Base) + 144)
#define k_Token_Strategy_FearTradeRank           ((k_Token_Custom_Base) + 145)
#define k_Token_Strategy_FearTradeRank_Value     ((k_Token_Custom_Base) + 146)
#define k_Token_Strategy_FearPollution           ((k_Token_Custom_Base) + 147)
#define k_Token_Strategy_FearPollution_Value     ((k_Token_Custom_Base) + 148)
#define k_Token_Strategy_DesireAttack            ((k_Token_Custom_Base) + 149)
#define k_Token_Strategy_DesireAttack_Value      ((k_Token_Custom_Base) + 150)
#define k_Token_Strategy_DesireGold              ((k_Token_Custom_Base) + 151)
#define k_Token_Strategy_DesireGold_Value        ((k_Token_Custom_Base) + 152)
#define k_Token_Strategy_DesireScience           ((k_Token_Custom_Base) + 153)
#define k_Token_Strategy_DesireScience_Value     ((k_Token_Custom_Base) + 154)
#define k_Token_Strategy_DesireMakeFriend        ((k_Token_Custom_Base) + 155)
#define k_Token_Strategy_DesireMakeFriend_Value  ((k_Token_Custom_Base) + 156)
#define k_Token_Strategy_DesireEnlistFriend      ((k_Token_Custom_Base) + 157)
#define k_Token_Strategy_DesireEnlistFriend_Value ((k_Token_Custom_Base) + 158)
#define k_Token_Strategy_PiracyMemoryTurns       ((k_Token_Custom_Base) + 159)
#define k_Token_Strategy_PiracyMemoryTurns_Value ((k_Token_Custom_Base) + 160)
#define k_Token_Strategy_MaxPiracyEvents         ((k_Token_Custom_Base) + 161)
#define k_Token_Strategy_MaxPiracyEvents_Value   ((k_Token_Custom_Base) + 162)
#define k_Token_Strategy_Offensive               ((k_Token_Custom_Base) + 163)
#define k_Token_Strategy_Offensive_Value         ((k_Token_Custom_Base) + 164)
#define k_Token_Strategy_Defensive               ((k_Token_Custom_Base) + 165)
#define k_Token_Strategy_Defensive_Value         ((k_Token_Custom_Base) + 166)
#define k_Token_Strategy_StealthAttack           ((k_Token_Custom_Base) + 167)
#define k_Token_Strategy_StealthAttack_Value     ((k_Token_Custom_Base) + 168)
#define k_Token_Strategy_Bombard                 ((k_Token_Custom_Base) + 169)
#define k_Token_Strategy_Bombard_Value           ((k_Token_Custom_Base) + 170)
#define k_Token_Strategy_Special                 ((k_Token_Custom_Base) + 171)
#define k_Token_Strategy_Special_Value           ((k_Token_Custom_Base) + 172)
#define k_Token_Strategy_Harass                  ((k_Token_Custom_Base) + 173)
#define k_Token_Strategy_Harass_Value            ((k_Token_Custom_Base) + 174)
#define k_Token_Strategy_NuclearFirstStrike      ((k_Token_Custom_Base) + 175)
#define k_Token_Strategy_NuclearTargeting        ((k_Token_Custom_Base) + 176)
#define k_Token_Strategy_PreemptiveStrikeRegard  ((k_Token_Custom_Base) + 177)
#define k_Token_Strategy_PreemptiveStrikeRegard_Value ((k_Token_Custom_Base) + 178)
#define k_Token_Strategy_PreemptiveStrikeRiskRatio ((k_Token_Custom_Base) + 179)
#define k_Token_Strategy_PreemptiveStrikeRiskRatio_Value ((k_Token_Custom_Base) + 180)
#define k_Token_Strategy_PreemptiveStrikeSuperiorityRatio ((k_Token_Custom_Base) + 181)
#define k_Token_Strategy_PreemptiveStrikeSuperiorityRatio_Value ((k_Token_Custom_Base) + 182)
#define k_Token_Strategy_TurnsAcceptedForOnePop  ((k_Token_Custom_Base) + 183)
#define k_Token_Strategy_TurnsAcceptedForOnePop_Value ((k_Token_Custom_Base) + 184)
#define k_Token_Strategy_StopBuildingFoodBeforePopMax ((k_Token_Custom_Base) + 185)
#define k_Token_Strategy_StopBuildingFoodBeforePopMax_Value ((k_Token_Custom_Base) + 186)
#define k_Token_Strategy_RoadAlreadyThereCostsCoefficient ((k_Token_Custom_Base) + 187)
#define k_Token_Strategy_RoadAlreadyThereCostsCoefficient_Value ((k_Token_Custom_Base) + 188)
#define k_Token_Strategy_UseBaseMoveCostsForRoads ((k_Token_Custom_Base) + 189)
#define k_Token_Strategy_UseBaseMoveCostsForRoads_Value ((k_Token_Custom_Base) + 190)
#define k_Token_Strategy_BuildRoadsToClosestCities ((k_Token_Custom_Base) + 191)
#define k_Token_Strategy_BuildRoadsToClosestCities_Value ((k_Token_Custom_Base) + 192)
#define k_Token_Strategy_BaseRoadPriorityVsThreatRank ((k_Token_Custom_Base) + 193)
#define k_Token_Strategy_BaseRoadPriorityVsThreatRank_Value ((k_Token_Custom_Base) + 194)
#define k_Token_Strategy_SmallCityImproveCoeff   ((k_Token_Custom_Base) + 195)
#define k_Token_Strategy_SmallCityImproveCoeff_Value ((k_Token_Custom_Base) + 196)
#define k_Token_Strategy_Max                     ((k_Token_Custom_Base) + 197)


static BitArray s_ParsedTokens(197);
void StrategyRecord::CheckRequiredFields(DBLexer *lex)
{
}

sint32 StrategyRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Strategy_Tokens, k_Token_Strategy_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "STRATEGY_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Strategy_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Strategy_Inherit:
                if(!g_theStrategyDB->ParseRecordInArray(lex, (sint32 *)m_Inherit, &m_numInherit, k_MAX_Inherit)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement:
                if(!StrategyRecord::PopAssignmentElement::ParseInArray(lex, &m_PopAssignmentElement, &m_numPopAssignmentElement))
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Government:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_Government, &m_numGovernment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MinimumHappiness:
                m_flags0 |= k_Strategy_MinimumHappiness_Bit;
                if(!lex->GetIntAssignment(m_MinimumHappinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DeficitSpending:
                m_flags0 |= k_Strategy_DeficitSpending_Bit;
                if(!lex->GetFloatAssignment(m_DeficitSpendingValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaximumWagePercent:
                m_flags0 |= k_Strategy_MaximumWagePercent_Bit;
                if(!lex->GetFloatAssignment(m_MaximumWagePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SliderElement:
                if(!StrategyRecord::SliderElement::ParseInArray(lex, &m_SliderElement, &m_numSliderElement))
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SciencePercent:
                m_flags0 |= k_Strategy_SciencePercent_Bit;
                if(!lex->GetIntAssignment(m_SciencePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxSupportCostPercent:
                m_flags0 |= k_Strategy_MaxSupportCostPercent_Bit;
                if(!lex->GetIntAssignment(m_MaxSupportCostPercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ReadinessLevel:
                m_flags0 |= k_Strategy_ReadinessLevel_Bit;
                if(!lex->GetIntAssignment(m_ReadinessLevelValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PublicWorksPercent:
                m_flags0 |= k_Strategy_PublicWorksPercent_Bit;
                if(!lex->GetIntAssignment(m_PublicWorksPercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PublicWorksReserve:
                m_flags0 |= k_Strategy_PublicWorksReserve_Bit;
                if(!lex->GetIntAssignment(m_PublicWorksReserveValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxEvalTileImprovements:
                m_flags0 |= k_Strategy_MaxEvalTileImprovements_Bit;
                if(!lex->GetIntAssignment(m_MaxEvalTileImprovementsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_TimeToFixRoads:
                m_flags0 |= k_Strategy_TimeToFixRoads_Bit;
                if(!lex->GetIntAssignment(m_TimeToFixRoadsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_TimeToFixPollution:
                m_flags0 |= k_Strategy_TimeToFixPollution_Bit;
                if(!lex->GetIntAssignment(m_TimeToFixPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FixPollutionThreshold:
                m_flags0 |= k_Strategy_FixPollutionThreshold_Bit;
                if(!lex->GetIntAssignment(m_FixPollutionThresholdValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RoadUtilityBonus:
                m_flags0 |= k_Strategy_RoadUtilityBonus_Bit;
                if(!lex->GetFloatAssignment(m_RoadUtilityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveProductionBonus:
                m_flags0 |= k_Strategy_ImproveProductionBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveProductionBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveGrowthBonus:
                m_flags0 |= k_Strategy_ImproveGrowthBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveGrowthBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveGoodBonus:
                m_flags0 |= k_Strategy_ImproveGoodBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveGoodBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveSmallCityGrowthBonus:
                m_flags0 |= k_Strategy_ImproveSmallCityGrowthBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveSmallCityGrowthBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveLargeCityProductionBonus:
                m_flags0 |= k_Strategy_ImproveLargeCityProductionBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveLargeCityProductionBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveGrowthList:
                if (!g_theImprovementListDB->GetRecordFromLexer(lex, m_ImproveGrowthList)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveProductionList:
                if (!g_theImprovementListDB->GetRecordFromLexer(lex, m_ImproveProductionList)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveRandomList:
                if (!g_theImprovementListDB->GetRecordFromLexer(lex, m_ImproveRandomList)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement:
                if(!StrategyRecord::GoalElement::ParseInArray(lex, &m_GoalElement, &m_numGoalElement))
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DistanceModifierFactor:
                m_flags0 |= k_Strategy_DistanceModifierFactor_Bit;
                if(!lex->GetIntAssignment(m_DistanceModifierFactorValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DisbandArmyCount:
                m_flags0 |= k_Strategy_DisbandArmyCount_Bit;
                if(!lex->GetIntAssignment(m_DisbandArmyCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MinSettleDistance:
                m_flags0 |= k_Strategy_MinSettleDistance_Bit;
                if(!lex->GetIntAssignment(m_MinSettleDistanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MinSettleScore:
                m_flags0 |= k_Strategy_MinSettleScore_Bit;
                if(!lex->GetIntAssignment(m_MinSettleScoreValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RushBuyThreatBonus:
                m_flags0 |= k_Strategy_RushBuyThreatBonus_Bit;
                if(!lex->GetIntAssignment(m_RushBuyThreatBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RushBuyReservePercent:
                m_flags0 |= k_Strategy_RushBuyReservePercent_Bit;
                if(!lex->GetFloatAssignment(m_RushBuyReservePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_UnitSupportPercent:
                m_flags0 |= k_Strategy_UnitSupportPercent_Bit;
                if(!lex->GetFloatAssignment(m_UnitSupportPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxSettlerBuildTurns:
                m_flags0 |= k_Strategy_MaxSettlerBuildTurns_Bit;
                if(!lex->GetIntAssignment(m_MaxSettlerBuildTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxUnitBuildTurns:
                m_flags0 |= k_Strategy_MaxUnitBuildTurns_Bit;
                if(!lex->GetIntAssignment(m_MaxUnitBuildTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxWonderBuildTurns:
                m_flags0 |= k_Strategy_MaxWonderBuildTurns_Bit;
                if(!lex->GetIntAssignment(m_MaxWonderBuildTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildTransportProductionLevel:
                m_flags0 |= k_Strategy_BuildTransportProductionLevel_Bit;
                if(!lex->GetFloatAssignment(m_BuildTransportProductionLevelValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildSettlerProductionLevel:
                m_flags0 |= k_Strategy_BuildSettlerProductionLevel_Bit;
                if(!lex->GetFloatAssignment(m_BuildSettlerProductionLevelValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_OffensiveUnitsPercent:
                m_flags0 |= k_Strategy_OffensiveUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_OffensiveUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DefensiveUnitsPercent:
                m_flags0 |= k_Strategy_DefensiveUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_DefensiveUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RangedUnitsPercent:
                m_flags1 |= k_Strategy_RangedUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_RangedUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaUnitsPercent:
                m_flags1 |= k_Strategy_SeaUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_SeaUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirUnitsPercent:
                m_flags1 |= k_Strategy_AirUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_AirUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SettlerUnitsCount:
                m_flags1 |= k_Strategy_SettlerUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SettlerUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SpecialUnitsCount:
                m_flags1 |= k_Strategy_SpecialUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SpecialUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SpyUnitsCount:
                m_flags1 |= k_Strategy_SpyUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SpyUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SlaveryUnitsCount:
                m_flags1 |= k_Strategy_SlaveryUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SlaveryUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DiplomatUnitsCount:
                m_flags1 |= k_Strategy_DiplomatUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_DiplomatUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MissionaryUnitsCount:
                m_flags1 |= k_Strategy_MissionaryUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_MissionaryUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaTransportUnitsCount:
                m_flags1 |= k_Strategy_SeaTransportUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SeaTransportUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirTransportUnitsCount:
                m_flags1 |= k_Strategy_AirTransportUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_AirTransportUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_OffensiveUnitList:
                m_flags1 |= k_Strategy_OffensiveUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_OffensiveUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DefensiveUnitList:
                m_flags1 |= k_Strategy_DefensiveUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_DefensiveUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RangedUnitList:
                m_flags1 |= k_Strategy_RangedUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_RangedUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaUnitList:
                m_flags1 |= k_Strategy_SeaUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SeaUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirUnitList:
                m_flags1 |= k_Strategy_AirUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_AirUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SettlerUnitList:
                m_flags1 |= k_Strategy_SettlerUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SettlerUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaSettlerUnitList:
                m_flags1 |= k_Strategy_SeaSettlerUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SeaSettlerUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SpecialUnitList:
                m_flags1 |= k_Strategy_SpecialUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SpecialUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SpyUnitList:
                m_flags1 |= k_Strategy_SpyUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SpyUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SlaverUnitList:
                m_flags1 |= k_Strategy_SlaverUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SlaverUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DiplomatUnitList:
                m_flags1 |= k_Strategy_DiplomatUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_DiplomatUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MissionaryUnitList:
                m_flags1 |= k_Strategy_MissionaryUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_MissionaryUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaTransportUnitList:
                m_flags1 |= k_Strategy_SeaTransportUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SeaTransportUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirTransportUnitList:
                m_flags1 |= k_Strategy_AirTransportUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_AirTransportUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FreightUnitList:
                m_flags1 |= k_Strategy_FreightUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_FreightUnitListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_OffensiveGarrisonCount:
                m_flags1 |= k_Strategy_OffensiveGarrisonCount_Bit;
                if(!lex->GetIntAssignment(m_OffensiveGarrisonCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DefensiveGarrisonCount:
                m_flags1 |= k_Strategy_DefensiveGarrisonCount_Bit;
                if(!lex->GetIntAssignment(m_DefensiveGarrisonCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RangedGarrisonCount:
                m_flags1 |= k_Strategy_RangedGarrisonCount_Bit;
                if(!lex->GetIntAssignment(m_RangedGarrisonCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement:
                if(!StrategyRecord::BuildListSequenceElement::ParseInArray(lex, &m_BuildListSequenceElement, &m_numBuildListSequenceElement))
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Research:
                m_flags1 |= k_Strategy_Research_Bit;
                if(!g_theAdvanceListDB->GetRecordFromLexer(lex, m_ResearchValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_StopResearch:
                m_flags1 |= k_Strategy_StopResearch_Bit;
                if(!g_theAdvanceListDB->GetRecordFromLexer(lex, m_StopResearchValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearInvasion:
                m_flags1 |= k_Strategy_FearInvasion_Bit;
                if(!lex->GetIntAssignment(m_FearInvasionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearCityDefense:
                m_flags2 |= k_Strategy_FearCityDefense_Bit;
                if(!lex->GetIntAssignment(m_FearCityDefenseValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearPiracy:
                m_flags2 |= k_Strategy_FearPiracy_Bit;
                if(!lex->GetIntAssignment(m_FearPiracyValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearScienceRank:
                m_flags2 |= k_Strategy_FearScienceRank_Bit;
                if(!lex->GetIntAssignment(m_FearScienceRankValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearMilitaryRank:
                m_flags2 |= k_Strategy_FearMilitaryRank_Bit;
                if(!lex->GetIntAssignment(m_FearMilitaryRankValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearTradeRank:
                m_flags2 |= k_Strategy_FearTradeRank_Bit;
                if(!lex->GetIntAssignment(m_FearTradeRankValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearPollution:
                m_flags2 |= k_Strategy_FearPollution_Bit;
                if(!lex->GetIntAssignment(m_FearPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireAttack:
                m_flags2 |= k_Strategy_DesireAttack_Bit;
                if(!lex->GetIntAssignment(m_DesireAttackValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireGold:
                m_flags2 |= k_Strategy_DesireGold_Bit;
                if(!lex->GetIntAssignment(m_DesireGoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireScience:
                m_flags2 |= k_Strategy_DesireScience_Bit;
                if(!lex->GetIntAssignment(m_DesireScienceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireMakeFriend:
                m_flags2 |= k_Strategy_DesireMakeFriend_Bit;
                if(!lex->GetIntAssignment(m_DesireMakeFriendValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireEnlistFriend:
                m_flags2 |= k_Strategy_DesireEnlistFriend_Bit;
                if(!lex->GetIntAssignment(m_DesireEnlistFriendValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PiracyMemoryTurns:
                m_flags2 |= k_Strategy_PiracyMemoryTurns_Bit;
                if(!lex->GetIntAssignment(m_PiracyMemoryTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxPiracyEvents:
                m_flags2 |= k_Strategy_MaxPiracyEvents_Bit;
                if(!lex->GetIntAssignment(m_MaxPiracyEventsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Offensive:
                m_flags2 |= k_Strategy_Offensive_Bit;
                if(!m_OffensiveValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Defensive:
                m_flags2 |= k_Strategy_Defensive_Bit;
                if(!m_DefensiveValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_StealthAttack:
                m_flags2 |= k_Strategy_StealthAttack_Bit;
                if(!m_StealthAttackValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Bombard:
                m_flags2 |= k_Strategy_Bombard_Bit;
                if(!m_BombardValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Special:
                m_flags2 |= k_Strategy_Special_Bit;
                if(!m_SpecialValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Harass:
                m_flags2 |= k_Strategy_Harass_Bit;
                if(!m_HarassValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_NuclearFirstStrike:
                if(!ParseNuclearFirstStrikeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_NuclearTargeting:
                if(!ParseNuclearTargetingBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PreemptiveStrikeRegard:
                m_flags2 |= k_Strategy_PreemptiveStrikeRegard_Bit;
                if(!lex->GetIntAssignment(m_PreemptiveStrikeRegardValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PreemptiveStrikeRiskRatio:
                m_flags2 |= k_Strategy_PreemptiveStrikeRiskRatio_Bit;
                if(!lex->GetFloatAssignment(m_PreemptiveStrikeRiskRatioValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PreemptiveStrikeSuperiorityRatio:
                m_flags2 |= k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit;
                if(!lex->GetFloatAssignment(m_PreemptiveStrikeSuperiorityRatioValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_TurnsAcceptedForOnePop:
                m_flags2 |= k_Strategy_TurnsAcceptedForOnePop_Bit;
                if(!lex->GetIntAssignment(m_TurnsAcceptedForOnePopValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_StopBuildingFoodBeforePopMax:
                m_flags2 |= k_Strategy_StopBuildingFoodBeforePopMax_Bit;
                if(!lex->GetIntAssignment(m_StopBuildingFoodBeforePopMaxValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RoadAlreadyThereCostsCoefficient:
                m_flags2 |= k_Strategy_RoadAlreadyThereCostsCoefficient_Bit;
                if(!lex->GetFloatAssignment(m_RoadAlreadyThereCostsCoefficientValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_UseBaseMoveCostsForRoads:
                m_flags2 |= k_Strategy_UseBaseMoveCostsForRoads_Bit;
                if(!lex->GetIntAssignment(m_UseBaseMoveCostsForRoadsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildRoadsToClosestCities:
                m_flags2 |= k_Strategy_BuildRoadsToClosestCities_Bit;
                if(!lex->GetIntAssignment(m_BuildRoadsToClosestCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BaseRoadPriorityVsThreatRank:
                m_flags2 |= k_Strategy_BaseRoadPriorityVsThreatRank_Bit;
                if(!lex->GetFloatAssignment(m_BaseRoadPriorityVsThreatRankValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SmallCityImproveCoeff:
                m_flags2 |= k_Strategy_SmallCityImproveCoeff_Bit;
                if(!lex->GetFloatAssignment(m_SmallCityImproveCoeffValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(false)
                if(!g_theStrategyDB->ParseRecordInArray(lex, (sint32 *)m_Inherit, &m_numInherit, k_MAX_Inherit)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void StrategyRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numInherit; i++) {
            if(m_Inherit[i] & 0x80000000) {
                sint32 id = m_Inherit[i] & 0x7fffffff;
                if(!g_theStrategyDB->GetNamedItem(id, m_Inherit[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Strategy database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Inherit[i] == 0x7fffffff){
                m_Inherit[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPopAssignmentElement; i++) {
            m_PopAssignmentElement[i].ResolveDBReferences();
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernment; i++) {
            if(m_Government[i] & 0x80000000) {
                sint32 id = m_Government[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_Government[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Government[i] == 0x7fffffff){
                m_Government[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numSliderElement; i++) {
            m_SliderElement[i].ResolveDBReferences();
        }
    }
    if(m_ImproveGrowthList & 0x80000000) {
        sint32 id = m_ImproveGrowthList & 0x7fffffff;
        if(!g_theImprovementListDB->GetNamedItem(id, m_ImproveGrowthList)) {
            c3errors_ErrorDialog("DB", "%s not found in ImprovementList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ImproveGrowthList == 0x7fffffff) {
        m_ImproveGrowthList = -1;
    }
    if(m_ImproveProductionList & 0x80000000) {
        sint32 id = m_ImproveProductionList & 0x7fffffff;
        if(!g_theImprovementListDB->GetNamedItem(id, m_ImproveProductionList)) {
            c3errors_ErrorDialog("DB", "%s not found in ImprovementList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ImproveProductionList == 0x7fffffff) {
        m_ImproveProductionList = -1;
    }
    if(m_ImproveRandomList & 0x80000000) {
        sint32 id = m_ImproveRandomList & 0x7fffffff;
        if(!g_theImprovementListDB->GetNamedItem(id, m_ImproveRandomList)) {
            c3errors_ErrorDialog("DB", "%s not found in ImprovementList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ImproveRandomList == 0x7fffffff) {
        m_ImproveRandomList = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numGoalElement; i++) {
            m_GoalElement[i].ResolveDBReferences();
        }
    }
    if(m_OffensiveUnitListValue & 0x80000000) {
        sint32 id = m_OffensiveUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_OffensiveUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_OffensiveUnitListValue == 0x7fffffff) {
        m_OffensiveUnitListValue = -1;
    }
    if(m_DefensiveUnitListValue & 0x80000000) {
        sint32 id = m_DefensiveUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_DefensiveUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefensiveUnitListValue == 0x7fffffff) {
        m_DefensiveUnitListValue = -1;
    }
    if(m_RangedUnitListValue & 0x80000000) {
        sint32 id = m_RangedUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_RangedUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_RangedUnitListValue == 0x7fffffff) {
        m_RangedUnitListValue = -1;
    }
    if(m_SeaUnitListValue & 0x80000000) {
        sint32 id = m_SeaUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SeaUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SeaUnitListValue == 0x7fffffff) {
        m_SeaUnitListValue = -1;
    }
    if(m_AirUnitListValue & 0x80000000) {
        sint32 id = m_AirUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_AirUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_AirUnitListValue == 0x7fffffff) {
        m_AirUnitListValue = -1;
    }
    if(m_SettlerUnitListValue & 0x80000000) {
        sint32 id = m_SettlerUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SettlerUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SettlerUnitListValue == 0x7fffffff) {
        m_SettlerUnitListValue = -1;
    }
    if(m_SeaSettlerUnitListValue & 0x80000000) {
        sint32 id = m_SeaSettlerUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SeaSettlerUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SeaSettlerUnitListValue == 0x7fffffff) {
        m_SeaSettlerUnitListValue = -1;
    }
    if(m_SpecialUnitListValue & 0x80000000) {
        sint32 id = m_SpecialUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SpecialUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SpecialUnitListValue == 0x7fffffff) {
        m_SpecialUnitListValue = -1;
    }
    if(m_SpyUnitListValue & 0x80000000) {
        sint32 id = m_SpyUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SpyUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SpyUnitListValue == 0x7fffffff) {
        m_SpyUnitListValue = -1;
    }
    if(m_SlaverUnitListValue & 0x80000000) {
        sint32 id = m_SlaverUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SlaverUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SlaverUnitListValue == 0x7fffffff) {
        m_SlaverUnitListValue = -1;
    }
    if(m_DiplomatUnitListValue & 0x80000000) {
        sint32 id = m_DiplomatUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_DiplomatUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DiplomatUnitListValue == 0x7fffffff) {
        m_DiplomatUnitListValue = -1;
    }
    if(m_MissionaryUnitListValue & 0x80000000) {
        sint32 id = m_MissionaryUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_MissionaryUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_MissionaryUnitListValue == 0x7fffffff) {
        m_MissionaryUnitListValue = -1;
    }
    if(m_SeaTransportUnitListValue & 0x80000000) {
        sint32 id = m_SeaTransportUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SeaTransportUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SeaTransportUnitListValue == 0x7fffffff) {
        m_SeaTransportUnitListValue = -1;
    }
    if(m_AirTransportUnitListValue & 0x80000000) {
        sint32 id = m_AirTransportUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_AirTransportUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_AirTransportUnitListValue == 0x7fffffff) {
        m_AirTransportUnitListValue = -1;
    }
    if(m_FreightUnitListValue & 0x80000000) {
        sint32 id = m_FreightUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_FreightUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_FreightUnitListValue == 0x7fffffff) {
        m_FreightUnitListValue = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numBuildListSequenceElement; i++) {
            m_BuildListSequenceElement[i].ResolveDBReferences();
        }
    }
    if(m_ResearchValue & 0x80000000) {
        sint32 id = m_ResearchValue & 0x7fffffff;
        if(!g_theAdvanceListDB->GetNamedItem(id, m_ResearchValue)) {
            c3errors_ErrorDialog("DB", "%s not found in AdvanceList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ResearchValue == 0x7fffffff) {
        m_ResearchValue = -1;
    }
    if(m_StopResearchValue & 0x80000000) {
        sint32 id = m_StopResearchValue & 0x7fffffff;
        if(!g_theAdvanceListDB->GetNamedItem(id, m_StopResearchValue)) {
            c3errors_ErrorDialog("DB", "%s not found in AdvanceList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_StopResearchValue == 0x7fffffff) {
        m_StopResearchValue = -1;
    }
    m_OffensiveValue.ResolveDBReferences();
    m_DefensiveValue.ResolveDBReferences();
    m_StealthAttackValue.ResolveDBReferences();
    m_BombardValue.ResolveDBReferences();
    m_SpecialValue.ResolveDBReferences();
    m_HarassValue.ResolveDBReferences();
    if(!HasTurnsAcceptedForOnePop()) {
        m_TurnsAcceptedForOnePopValue = g_theConstDB->Get(0)->GetTurnsAcceptedForOnePop();
    }
    if(!HasRoadAlreadyThereCostsCoefficient()) {
        m_RoadAlreadyThereCostsCoefficientValue = g_theConstDB->Get(0)->GetRoadAlreadyThereCostsCoefficient();
    }
    if(!HasUseBaseMoveCostsForRoads()) {
        m_UseBaseMoveCostsForRoadsValue = g_theConstDB->Get(0)->GetUseBaseMoveCostsForRoads();
    }
    if(!HasBuildRoadsToClosestCities()) {
        m_BuildRoadsToClosestCitiesValue = g_theConstDB->Get(0)->GetBuildRoadsToClosestCities();
    }
    if(!HasBaseRoadPriorityVsThreatRank()) {
        m_BaseRoadPriorityVsThreatRankValue = g_theConstDB->Get(0)->GetBaseRoadPriorityVsThreatRank();
    }
    if(!HasSmallCityImproveCoeff()) {
        m_SmallCityImproveCoeffValue = g_theConstDB->Get(0)->GetSmallCityImproveCoeff();
    }
}

StrategyRecord::PopAssignmentElement::PopAssignmentElement()
{
    m_flags0 = 0;
    m_Specialists = 0.000000;
    m_FarmerPercent = 0.000000;
    m_LaborerPercent = 0.000000;
    m_MerchantPercent = 0.000000;
    m_EntertainerPercent = 0.000000;
    m_ScientistPercent = 0.000000;
    m_TopValue = 0.000000;
    m_BottomValue = 0.000000;
}

StrategyRecord::PopAssignmentElement::~PopAssignmentElement()
{
}

StrategyRecord::PopAssignmentElement const & StrategyRecord::PopAssignmentElement::operator = (PopAssignmentElement const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Specialists = rval.m_Specialists;

        m_FarmerPercent = rval.m_FarmerPercent;

        m_LaborerPercent = rval.m_LaborerPercent;

        m_MerchantPercent = rval.m_MerchantPercent;

        m_EntertainerPercent = rval.m_EntertainerPercent;

        m_ScientistPercent = rval.m_ScientistPercent;

        m_TopValue = rval.m_TopValue;

        m_BottomValue = rval.m_BottomValue;

    }

    return *this;
}

void StrategyRecord::PopAssignmentElement::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Specialists;
        archive << m_FarmerPercent;
        archive << m_LaborerPercent;
        archive << m_MerchantPercent;
        archive << m_EntertainerPercent;
        archive << m_ScientistPercent;
        archive << m_TopValue;
        archive << m_BottomValue;
    } else {
        archive >> m_flags0;
        archive >> m_Specialists;
        archive >> m_FarmerPercent;
        archive >> m_LaborerPercent;
        archive >> m_MerchantPercent;
        archive >> m_EntertainerPercent;
        archive >> m_ScientistPercent;
        archive >> m_TopValue;
        archive >> m_BottomValue;
    }
}

static const char *s_Strategy_PopAssignmentElement_Tokens[] = {
    "Specialists",
    "FarmerPercent",
    "LaborerPercent",
    "MerchantPercent",
    "EntertainerPercent",
    "ScientistPercent",
    "Top",
    "Bottom",
    "ProductionCities",
    "GrowthCities",
    "GoldCities",
    "Default",
};
#define k_Token_Strategy_PopAssignmentElement_Specialists ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_PopAssignmentElement_FarmerPercent ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_PopAssignmentElement_LaborerPercent ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_PopAssignmentElement_MerchantPercent ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_PopAssignmentElement_EntertainerPercent ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_PopAssignmentElement_ScientistPercent ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_PopAssignmentElement_Top ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_PopAssignmentElement_Bottom ((k_Token_Custom_Base) + 7)
#define k_Token_Strategy_PopAssignmentElement_ProductionCities ((k_Token_Custom_Base) + 8)
#define k_Token_Strategy_PopAssignmentElement_GrowthCities ((k_Token_Custom_Base) + 9)
#define k_Token_Strategy_PopAssignmentElement_GoldCities ((k_Token_Custom_Base) + 10)
#define k_Token_Strategy_PopAssignmentElement_Default ((k_Token_Custom_Base) + 11)
#define k_Token_Strategy_PopAssignmentElement_Max ((k_Token_Custom_Base) + 12)
sint32 StrategyRecord::PopAssignmentElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for PopAssignmentElement"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Strategy_PopAssignmentElement_Tokens, k_Token_Strategy_PopAssignmentElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_PopAssignmentElement_Specialists:
                if(!lex->GetFloatAssignment(m_Specialists)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_FarmerPercent:
                if(!lex->GetFloatAssignment(m_FarmerPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_LaborerPercent:
                if(!lex->GetFloatAssignment(m_LaborerPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_MerchantPercent:
                if(!lex->GetFloatAssignment(m_MerchantPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_EntertainerPercent:
                if(!lex->GetFloatAssignment(m_EntertainerPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_ScientistPercent:
                if(!lex->GetFloatAssignment(m_ScientistPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_Top:
                m_flags0 |= k_PopAssignmentElement_Top_Bit;
                if(!lex->GetFloatAssignment(m_TopValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_Bottom:
                m_flags0 |= k_PopAssignmentElement_Bottom_Bit;
                if(!lex->GetFloatAssignment(m_BottomValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_ProductionCities:
                m_flags0 |= k_PopAssignmentElement_ProductionCities_Bit;
                break;
            case k_Token_Strategy_PopAssignmentElement_GrowthCities:
                m_flags0 |= k_PopAssignmentElement_GrowthCities_Bit;
                break;
            case k_Token_Strategy_PopAssignmentElement_GoldCities:
                m_flags0 |= k_PopAssignmentElement_GoldCities_Bit;
                break;
            case k_Token_Strategy_PopAssignmentElement_Default:
                m_flags0 |= k_PopAssignmentElement_Default_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Specialists)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::PopAssignmentElement::ParseInArray(DBLexer *lex, PopAssignmentElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        PopAssignmentElement *oldArray = *array;
        *array = new PopAssignmentElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new PopAssignmentElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 StrategyRecord::PopAssignmentElement::ParseInArray(DBLexer *lex, PopAssignmentElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void StrategyRecord::PopAssignmentElement::ResolveDBReferences()
{
}

StrategyRecord::SliderElement::SliderElement()
{
    m_flags0 = 0;
    m_Delta = 0;
}

StrategyRecord::SliderElement::~SliderElement()
{
}

StrategyRecord::SliderElement const & StrategyRecord::SliderElement::operator = (SliderElement const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Delta = rval.m_Delta;

    }

    return *this;
}

void StrategyRecord::SliderElement::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Delta;
    } else {
        archive >> m_flags0;
        archive >> m_Delta;
    }
}

static const char *s_Strategy_SliderElement_Tokens[] = {
    "Delta",
    "Production",
    "Gold",
    "Food",
};
#define k_Token_Strategy_SliderElement_Delta     ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_SliderElement_Production ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_SliderElement_Gold      ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_SliderElement_Food      ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_SliderElement_Max ((k_Token_Custom_Base) + 4)
sint32 StrategyRecord::SliderElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for SliderElement"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Strategy_SliderElement_Tokens, k_Token_Strategy_SliderElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_SliderElement_Delta:
                if(!lex->GetIntAssignment(m_Delta)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SliderElement_Production:
                m_flags0 |= k_SliderElement_Production_Bit;
                break;
            case k_Token_Strategy_SliderElement_Gold:
                m_flags0 |= k_SliderElement_Gold_Bit;
                break;
            case k_Token_Strategy_SliderElement_Food:
                m_flags0 |= k_SliderElement_Food_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Delta)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::SliderElement::ParseInArray(DBLexer *lex, SliderElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SliderElement *oldArray = *array;
        *array = new SliderElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SliderElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 StrategyRecord::SliderElement::ParseInArray(DBLexer *lex, SliderElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void StrategyRecord::SliderElement::ResolveDBReferences()
{
}

StrategyRecord::GoalElement::GoalElement()
{
    m_flags0 = 0;
    m_Goal = 0x7fffffff;
    m_Priority = 0;
    m_MaxEval = 0.000000;
    m_MaxExec = 0.000000;
}

StrategyRecord::GoalElement::~GoalElement()
{
}

StrategyRecord::GoalElement const & StrategyRecord::GoalElement::operator = (GoalElement const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Goal = rval.m_Goal;

        m_Priority = rval.m_Priority;

        m_MaxEval = rval.m_MaxEval;

        m_MaxExec = rval.m_MaxExec;

    }

    return *this;
}

void StrategyRecord::GoalElement::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Goal;
        archive << m_Priority;
        archive << m_MaxEval;
        archive << m_MaxExec;
    } else {
        archive >> m_flags0;
        archive >> m_Goal;
        archive >> m_Priority;
        archive >> m_MaxEval;
        archive >> m_MaxExec;
    }
}

static const char *s_Strategy_GoalElement_Tokens[] = {
    "Goal",
    "Priority",
    "MaxEval",
    "MaxExec",
    "ExecPerCity",
    "EvalPerCity",
    "PerCity",
};
#define k_Token_Strategy_GoalElement_Goal        ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_GoalElement_Priority    ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_GoalElement_MaxEval     ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_GoalElement_MaxExec     ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_GoalElement_ExecPerCity ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_GoalElement_EvalPerCity ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_GoalElement_PerCity     ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_GoalElement_Max ((k_Token_Custom_Base) + 7)
sint32 StrategyRecord::GoalElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for GoalElement"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Strategy_GoalElement_Tokens, k_Token_Strategy_GoalElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_GoalElement_Goal:
                if (!g_theGoalDB->GetRecordFromLexer(lex, m_Goal)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_Priority:
                if(!lex->GetIntAssignment(m_Priority)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_MaxEval:
                if(!lex->GetFloatAssignment(m_MaxEval)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_MaxExec:
                if(!lex->GetFloatAssignment(m_MaxExec)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_ExecPerCity:
                m_flags0 |= k_GoalElement_ExecPerCity_Bit;
                break;
            case k_Token_Strategy_GoalElement_EvalPerCity:
                m_flags0 |= k_GoalElement_EvalPerCity_Bit;
                break;
            case k_Token_Strategy_GoalElement_PerCity:
                m_flags0 |= k_GoalElement_PerCity_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theGoalDB->GetCurrentRecordFromLexer(lex, m_Goal)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::GoalElement::ParseInArray(DBLexer *lex, GoalElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        GoalElement *oldArray = *array;
        *array = new GoalElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new GoalElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 StrategyRecord::GoalElement::ParseInArray(DBLexer *lex, GoalElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void StrategyRecord::GoalElement::ResolveDBReferences()
{
    if(m_Goal & 0x80000000) {
        sint32 id = m_Goal & 0x7fffffff;
        if(!g_theGoalDB->GetNamedItem(id, m_Goal)) {
            c3errors_ErrorDialog("DB", "%s not found in Goal database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Goal == 0x7fffffff) {
        m_Goal = -1;
    }
}

StrategyRecord::BuildListSequenceElement::BuildListSequenceElement()
{
    m_flags0 = 0;
    m_Priority = 0;
    m_BuildListSequence = 0x7fffffff;
    m_TopValue = 0.000000;
    m_BottomValue = 0.000000;
    m_AdviceValue = 0;
    m_SmallCitiesMaxSizeValue = 0;
    m_MinNumUnitsValue = 0;
    m_MinNumCitiesValue = 0;
    m_BeforeMaxCitySizeValue = 0;
    m_HasBuildingsThenStopValue = 0;
    m_MinPollutionValue = 0;
    m_MaxRawHappinessValue = 0;
}

StrategyRecord::BuildListSequenceElement::~BuildListSequenceElement()
{
}

StrategyRecord::BuildListSequenceElement const & StrategyRecord::BuildListSequenceElement::operator = (BuildListSequenceElement const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Priority = rval.m_Priority;

        m_BuildListSequence = rval.m_BuildListSequence;

        m_TopValue = rval.m_TopValue;

        m_BottomValue = rval.m_BottomValue;

        m_AdviceValue = rval.m_AdviceValue;

        m_SmallCitiesMaxSizeValue = rval.m_SmallCitiesMaxSizeValue;

        m_MinNumUnitsValue = rval.m_MinNumUnitsValue;

        m_MinNumCitiesValue = rval.m_MinNumCitiesValue;

        m_BeforeMaxCitySizeValue = rval.m_BeforeMaxCitySizeValue;

        m_HasBuildingsThenStopValue = rval.m_HasBuildingsThenStopValue;

        m_MinPollutionValue = rval.m_MinPollutionValue;

        m_MaxRawHappinessValue = rval.m_MaxRawHappinessValue;

    }

    return *this;
}

void StrategyRecord::BuildListSequenceElement::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Priority;
        archive << m_BuildListSequence;
        archive << m_TopValue;
        archive << m_BottomValue;
        if (HasAdvice()){
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_AdviceValue);
            archive << tmpString;
        }

        archive << m_SmallCitiesMaxSizeValue;
        archive << m_MinNumUnitsValue;
        archive << m_MinNumCitiesValue;
        archive << m_BeforeMaxCitySizeValue;
        archive << m_HasBuildingsThenStopValue;
        archive << m_MinPollutionValue;
        archive << m_MaxRawHappinessValue;
    } else {
        archive >> m_flags0;
        archive >> m_Priority;
        archive >> m_BuildListSequence;
        archive >> m_TopValue;
        archive >> m_BottomValue;
        {
            if (HasAdvice()){
                MBCHAR* tmpString = NULL;
                archive >> tmpString;
                g_theStringDB->GetStringID(tmpString, m_AdviceValue);
                delete[] tmpString;
            }
        }

        archive >> m_SmallCitiesMaxSizeValue;
        archive >> m_MinNumUnitsValue;
        archive >> m_MinNumCitiesValue;
        archive >> m_BeforeMaxCitySizeValue;
        archive >> m_HasBuildingsThenStopValue;
        archive >> m_MinPollutionValue;
        archive >> m_MaxRawHappinessValue;
    }
}

static const char *s_Strategy_BuildListSequenceElement_Tokens[] = {
    "Priority",
    "BuildListSequence",
    "Top",
    "Bottom",
    "AllCities",
    "ProductionCities",
    "GrowthCities",
    "CommerceCities",
    "HappyCities",
    "ThreatenedCities",
    "PowerCities",
    "Default",
    "Advice",
    "SmallCitiesMaxSize",
    "MinNumUnits",
    "MinNumCities",
    "BeforeMaxCitySize",
    "HasBuildingsThenStop",
    "MinPollution",
    "MaxRawHappiness",
    "CanBuildWonders",
    "NoUnits",
};
#define k_Token_Strategy_BuildListSequenceElement_Priority ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_BuildListSequenceElement_BuildListSequence ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_BuildListSequenceElement_Top ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_BuildListSequenceElement_Bottom ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_BuildListSequenceElement_AllCities ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_BuildListSequenceElement_ProductionCities ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_BuildListSequenceElement_GrowthCities ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_BuildListSequenceElement_CommerceCities ((k_Token_Custom_Base) + 7)
#define k_Token_Strategy_BuildListSequenceElement_HappyCities ((k_Token_Custom_Base) + 8)
#define k_Token_Strategy_BuildListSequenceElement_ThreatenedCities ((k_Token_Custom_Base) + 9)
#define k_Token_Strategy_BuildListSequenceElement_PowerCities ((k_Token_Custom_Base) + 10)
#define k_Token_Strategy_BuildListSequenceElement_Default ((k_Token_Custom_Base) + 11)
#define k_Token_Strategy_BuildListSequenceElement_Advice ((k_Token_Custom_Base) + 12)
#define k_Token_Strategy_BuildListSequenceElement_SmallCitiesMaxSize ((k_Token_Custom_Base) + 13)
#define k_Token_Strategy_BuildListSequenceElement_MinNumUnits ((k_Token_Custom_Base) + 14)
#define k_Token_Strategy_BuildListSequenceElement_MinNumCities ((k_Token_Custom_Base) + 15)
#define k_Token_Strategy_BuildListSequenceElement_BeforeMaxCitySize ((k_Token_Custom_Base) + 16)
#define k_Token_Strategy_BuildListSequenceElement_HasBuildingsThenStop ((k_Token_Custom_Base) + 17)
#define k_Token_Strategy_BuildListSequenceElement_MinPollution ((k_Token_Custom_Base) + 18)
#define k_Token_Strategy_BuildListSequenceElement_MaxRawHappiness ((k_Token_Custom_Base) + 19)
#define k_Token_Strategy_BuildListSequenceElement_CanBuildWonders ((k_Token_Custom_Base) + 20)
#define k_Token_Strategy_BuildListSequenceElement_NoUnits ((k_Token_Custom_Base) + 21)
#define k_Token_Strategy_BuildListSequenceElement_Max ((k_Token_Custom_Base) + 22)
sint32 StrategyRecord::BuildListSequenceElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildListSequenceElement"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Strategy_BuildListSequenceElement_Tokens, k_Token_Strategy_BuildListSequenceElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_BuildListSequenceElement_Priority:
                if(!lex->GetIntAssignment(m_Priority)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_BuildListSequence:
                if (!g_theBuildListSequenceDB->GetRecordFromLexer(lex, m_BuildListSequence)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_Top:
                m_flags0 |= k_BuildListSequenceElement_Top_Bit;
                if(!lex->GetFloatAssignment(m_TopValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_Bottom:
                m_flags0 |= k_BuildListSequenceElement_Bottom_Bit;
                if(!lex->GetFloatAssignment(m_BottomValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_AllCities:
                m_flags0 |= k_BuildListSequenceElement_AllCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_ProductionCities:
                m_flags0 |= k_BuildListSequenceElement_ProductionCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_GrowthCities:
                m_flags0 |= k_BuildListSequenceElement_GrowthCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_CommerceCities:
                m_flags0 |= k_BuildListSequenceElement_CommerceCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_HappyCities:
                m_flags0 |= k_BuildListSequenceElement_HappyCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_ThreatenedCities:
                m_flags0 |= k_BuildListSequenceElement_ThreatenedCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_PowerCities:
                m_flags0 |= k_BuildListSequenceElement_PowerCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_Default:
                m_flags0 |= k_BuildListSequenceElement_Default_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_Advice:
                m_flags0 |= k_BuildListSequenceElement_Advice_Bit;
                if(!lex->GetStringIdAssignment(m_AdviceValue)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_SmallCitiesMaxSize:
                m_flags0 |= k_BuildListSequenceElement_SmallCitiesMaxSize_Bit;
                if(!lex->GetIntAssignment(m_SmallCitiesMaxSizeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_MinNumUnits:
                m_flags0 |= k_BuildListSequenceElement_MinNumUnits_Bit;
                if(!lex->GetIntAssignment(m_MinNumUnitsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_MinNumCities:
                m_flags0 |= k_BuildListSequenceElement_MinNumCities_Bit;
                if(!lex->GetIntAssignment(m_MinNumCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_BeforeMaxCitySize:
                m_flags0 |= k_BuildListSequenceElement_BeforeMaxCitySize_Bit;
                if(!lex->GetIntAssignment(m_BeforeMaxCitySizeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_HasBuildingsThenStop:
                m_flags0 |= k_BuildListSequenceElement_HasBuildingsThenStop_Bit;
                if(!g_theBuildingBuildListDB->GetRecordFromLexer(lex, m_HasBuildingsThenStopValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_MinPollution:
                m_flags0 |= k_BuildListSequenceElement_MinPollution_Bit;
                if(!lex->GetIntAssignment(m_MinPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_MaxRawHappiness:
                m_flags0 |= k_BuildListSequenceElement_MaxRawHappiness_Bit;
                if(!lex->GetIntAssignment(m_MaxRawHappinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_CanBuildWonders:
                m_flags0 |= k_BuildListSequenceElement_CanBuildWonders_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_NoUnits:
                m_flags0 |= k_BuildListSequenceElement_NoUnits_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Priority)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::BuildListSequenceElement::ParseInArray(DBLexer *lex, BuildListSequenceElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildListSequenceElement *oldArray = *array;
        *array = new BuildListSequenceElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildListSequenceElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 StrategyRecord::BuildListSequenceElement::ParseInArray(DBLexer *lex, BuildListSequenceElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void StrategyRecord::BuildListSequenceElement::ResolveDBReferences()
{
    if(m_BuildListSequence & 0x80000000) {
        sint32 id = m_BuildListSequence & 0x7fffffff;
        if(!g_theBuildListSequenceDB->GetNamedItem(id, m_BuildListSequence)) {
            c3errors_ErrorDialog("DB", "%s not found in BuildListSequence database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_BuildListSequence == 0x7fffffff) {
        m_BuildListSequence = -1;
    }
}

StrategyRecord::ForceMatch::ForceMatch()
{
    m_AttackMatch = 0.000000;
    m_DefenseMatch = 0.000000;
    m_RangedMatch = 0.000000;
    m_BombardMatch = 0.000000;
    m_ValueMatch = 0.000000;
}

StrategyRecord::ForceMatch::~ForceMatch()
{
}

StrategyRecord::ForceMatch const & StrategyRecord::ForceMatch::operator = (ForceMatch const & rval)
{
    if (this != &rval)
    {

        m_AttackMatch = rval.m_AttackMatch;

        m_DefenseMatch = rval.m_DefenseMatch;

        m_RangedMatch = rval.m_RangedMatch;

        m_BombardMatch = rval.m_BombardMatch;

        m_ValueMatch = rval.m_ValueMatch;

    }

    return *this;
}

void StrategyRecord::ForceMatch::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_AttackMatch;
        archive << m_DefenseMatch;
        archive << m_RangedMatch;
        archive << m_BombardMatch;
        archive << m_ValueMatch;
    } else {
        archive >> m_AttackMatch;
        archive >> m_DefenseMatch;
        archive >> m_RangedMatch;
        archive >> m_BombardMatch;
        archive >> m_ValueMatch;
    }
}

static const char *s_Strategy_ForceMatch_Tokens[] = {
    "AttackMatch",
    "DefenseMatch",
    "RangedMatch",
    "BombardMatch",
    "ValueMatch",
};
#define k_Token_Strategy_ForceMatch_AttackMatch  ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_ForceMatch_DefenseMatch ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_ForceMatch_RangedMatch  ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_ForceMatch_BombardMatch ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_ForceMatch_ValueMatch   ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_ForceMatch_Max ((k_Token_Custom_Base) + 5)
sint32 StrategyRecord::ForceMatch::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_AttackMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DefenseMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_RangedMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_BombardMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_ValueMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 StrategyRecord::ForceMatch::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_AttackMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DefenseMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_RangedMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_BombardMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_ValueMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 StrategyRecord::ForceMatch::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for ForceMatch"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Strategy_ForceMatch_Tokens, k_Token_Strategy_ForceMatch_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_ForceMatch_AttackMatch:
                if(!lex->GetFloatAssignment(m_AttackMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_DefenseMatch:
                if(!lex->GetFloatAssignment(m_DefenseMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_RangedMatch:
                if(!lex->GetFloatAssignment(m_RangedMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_BombardMatch:
                if(!lex->GetFloatAssignment(m_BombardMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_ValueMatch:
                if(!lex->GetFloatAssignment(m_ValueMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_AttackMatch)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::ForceMatch::ParseInArray(DBLexer *lex, ForceMatch **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ForceMatch *oldArray = *array;
        *array = new ForceMatch[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ForceMatch[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 StrategyRecord::ForceMatch::ParseInArray(DBLexer *lex, ForceMatch *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 StrategyRecord::ForceMatch::ParseInArraySequential(DBLexer *lex, ForceMatch **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ForceMatch *oldArray = *array;
        *array = new ForceMatch[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ForceMatch[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 StrategyRecord::ForceMatch::ParseInArraySequential(DBLexer *lex, ForceMatch *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void StrategyRecord::ForceMatch::ResolveDBReferences()
{
}

static const char *s_Strategy_NuclearFirstStrike_BitNames[] = {
    "Enabled",
    "Disabled",
};
#define k_Strategy_NuclearFirstStrike_Num_BitNames 2

sint32 StrategyRecord::ParseNuclearFirstStrikeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Strategy_NuclearFirstStrike_BitNames, k_Strategy_NuclearFirstStrike_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of NuclearFirstStrike", lex->GetTokenText()));
        return 0;
    }
    m_NuclearFirstStrike |= (1 << bitindex);
    return 1;
}

static const char *s_Strategy_NuclearTargeting_BitNames[] = {
    "Enabled",
    "Disabled",
};
#define k_Strategy_NuclearTargeting_Num_BitNames 2

sint32 StrategyRecord::ParseNuclearTargetingBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Strategy_NuclearTargeting_BitNames, k_Strategy_NuclearTargeting_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of NuclearTargeting", lex->GetTokenText()));
        return 0;
    }
    m_NuclearTargeting |= (1 << bitindex);
    return 1;
}

void StrategyRecord::Merge(const StrategyRecord & rval){
    if (rval.m_numInherit > 0)
        std::copy(rval.m_Inherit, rval.m_Inherit + rval.m_numInherit, m_Inherit);

    // replace struct elements of m_PopAssignmentElement
    for (sint32 index_PopAssignmentElement = 0; index_PopAssignmentElement < m_numPopAssignmentElement; ++index_PopAssignmentElement)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numPopAssignmentElement; ++obj_index)
            if (m_PopAssignmentElement[index_PopAssignmentElement] == rval.m_PopAssignmentElement[obj_index]){
                m_PopAssignmentElement[index_PopAssignmentElement] = rval.m_PopAssignmentElement[obj_index];
            }
    }
    // resize m_Government if necessary
    if (rval.m_numGovernment > m_numGovernment)
    {
        delete [] m_Government;
        m_Government = NULL;
        if (rval.m_numGovernment > 0)
            m_Government = new sint32 [rval.m_numGovernment];
        m_numGovernment = rval.m_numGovernment;
    }
    if (rval.m_numGovernment > 0)
        std::copy(rval.m_Government, rval.m_Government + rval.m_numGovernment, m_Government);

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MinimumHappiness_Bit)
    {
        m_MinimumHappinessValue = rval.m_MinimumHappinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_DeficitSpending_Bit)
    {
        m_DeficitSpendingValue = rval.m_DeficitSpendingValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MaximumWagePercent_Bit)
    {
        m_MaximumWagePercentValue = rval.m_MaximumWagePercentValue;
    }

    // replace struct elements of m_SliderElement
    for (sint32 index_SliderElement = 0; index_SliderElement < m_numSliderElement; ++index_SliderElement)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numSliderElement; ++obj_index)
            if (m_SliderElement[index_SliderElement] == rval.m_SliderElement[obj_index]){
                m_SliderElement[index_SliderElement] = rval.m_SliderElement[obj_index];
            }
    }
    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_SciencePercent_Bit)
    {
        m_SciencePercentValue = rval.m_SciencePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MaxSupportCostPercent_Bit)
    {
        m_MaxSupportCostPercentValue = rval.m_MaxSupportCostPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_ReadinessLevel_Bit)
    {
        m_ReadinessLevelValue = rval.m_ReadinessLevelValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_PublicWorksPercent_Bit)
    {
        m_PublicWorksPercentValue = rval.m_PublicWorksPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_PublicWorksReserve_Bit)
    {
        m_PublicWorksReserveValue = rval.m_PublicWorksReserveValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MaxEvalTileImprovements_Bit)
    {
        m_MaxEvalTileImprovementsValue = rval.m_MaxEvalTileImprovementsValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_TimeToFixRoads_Bit)
    {
        m_TimeToFixRoadsValue = rval.m_TimeToFixRoadsValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_TimeToFixPollution_Bit)
    {
        m_TimeToFixPollutionValue = rval.m_TimeToFixPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_FixPollutionThreshold_Bit)
    {
        m_FixPollutionThresholdValue = rval.m_FixPollutionThresholdValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_RoadUtilityBonus_Bit)
    {
        m_RoadUtilityBonusValue = rval.m_RoadUtilityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_ImproveProductionBonus_Bit)
    {
        m_ImproveProductionBonusValue = rval.m_ImproveProductionBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_ImproveGrowthBonus_Bit)
    {
        m_ImproveGrowthBonusValue = rval.m_ImproveGrowthBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_ImproveGoodBonus_Bit)
    {
        m_ImproveGoodBonusValue = rval.m_ImproveGoodBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_ImproveSmallCityGrowthBonus_Bit)
    {
        m_ImproveSmallCityGrowthBonusValue = rval.m_ImproveSmallCityGrowthBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_ImproveLargeCityProductionBonus_Bit)
    {
        m_ImproveLargeCityProductionBonusValue = rval.m_ImproveLargeCityProductionBonusValue;
    }

    // replace struct elements of m_GoalElement
    for (sint32 index_GoalElement = 0; index_GoalElement < m_numGoalElement; ++index_GoalElement)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numGoalElement; ++obj_index)
            if (m_GoalElement[index_GoalElement] == rval.m_GoalElement[obj_index]){
                m_GoalElement[index_GoalElement] = rval.m_GoalElement[obj_index];
            }
    }
    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_DistanceModifierFactor_Bit)
    {
        m_DistanceModifierFactorValue = rval.m_DistanceModifierFactorValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_DisbandArmyCount_Bit)
    {
        m_DisbandArmyCountValue = rval.m_DisbandArmyCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MinSettleDistance_Bit)
    {
        m_MinSettleDistanceValue = rval.m_MinSettleDistanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MinSettleScore_Bit)
    {
        m_MinSettleScoreValue = rval.m_MinSettleScoreValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_RushBuyThreatBonus_Bit)
    {
        m_RushBuyThreatBonusValue = rval.m_RushBuyThreatBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_RushBuyReservePercent_Bit)
    {
        m_RushBuyReservePercentValue = rval.m_RushBuyReservePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_UnitSupportPercent_Bit)
    {
        m_UnitSupportPercentValue = rval.m_UnitSupportPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MaxSettlerBuildTurns_Bit)
    {
        m_MaxSettlerBuildTurnsValue = rval.m_MaxSettlerBuildTurnsValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MaxUnitBuildTurns_Bit)
    {
        m_MaxUnitBuildTurnsValue = rval.m_MaxUnitBuildTurnsValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_MaxWonderBuildTurns_Bit)
    {
        m_MaxWonderBuildTurnsValue = rval.m_MaxWonderBuildTurnsValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_BuildTransportProductionLevel_Bit)
    {
        m_BuildTransportProductionLevelValue = rval.m_BuildTransportProductionLevelValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_BuildSettlerProductionLevel_Bit)
    {
        m_BuildSettlerProductionLevelValue = rval.m_BuildSettlerProductionLevelValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_OffensiveUnitsPercent_Bit)
    {
        m_OffensiveUnitsPercentValue = rval.m_OffensiveUnitsPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Strategy_DefensiveUnitsPercent_Bit)
    {
        m_DefensiveUnitsPercentValue = rval.m_DefensiveUnitsPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_RangedUnitsPercent_Bit)
    {
        m_RangedUnitsPercentValue = rval.m_RangedUnitsPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SeaUnitsPercent_Bit)
    {
        m_SeaUnitsPercentValue = rval.m_SeaUnitsPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_AirUnitsPercent_Bit)
    {
        m_AirUnitsPercentValue = rval.m_AirUnitsPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SettlerUnitsCount_Bit)
    {
        m_SettlerUnitsCountValue = rval.m_SettlerUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SpecialUnitsCount_Bit)
    {
        m_SpecialUnitsCountValue = rval.m_SpecialUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SpyUnitsCount_Bit)
    {
        m_SpyUnitsCountValue = rval.m_SpyUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SlaveryUnitsCount_Bit)
    {
        m_SlaveryUnitsCountValue = rval.m_SlaveryUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_DiplomatUnitsCount_Bit)
    {
        m_DiplomatUnitsCountValue = rval.m_DiplomatUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_MissionaryUnitsCount_Bit)
    {
        m_MissionaryUnitsCountValue = rval.m_MissionaryUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SeaTransportUnitsCount_Bit)
    {
        m_SeaTransportUnitsCountValue = rval.m_SeaTransportUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_AirTransportUnitsCount_Bit)
    {
        m_AirTransportUnitsCountValue = rval.m_AirTransportUnitsCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_OffensiveUnitList_Bit)
    {
        m_OffensiveUnitListValue = rval.m_OffensiveUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_DefensiveUnitList_Bit)
    {
        m_DefensiveUnitListValue = rval.m_DefensiveUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_RangedUnitList_Bit)
    {
        m_RangedUnitListValue = rval.m_RangedUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SeaUnitList_Bit)
    {
        m_SeaUnitListValue = rval.m_SeaUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_AirUnitList_Bit)
    {
        m_AirUnitListValue = rval.m_AirUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SettlerUnitList_Bit)
    {
        m_SettlerUnitListValue = rval.m_SettlerUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SeaSettlerUnitList_Bit)
    {
        m_SeaSettlerUnitListValue = rval.m_SeaSettlerUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SpecialUnitList_Bit)
    {
        m_SpecialUnitListValue = rval.m_SpecialUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SpyUnitList_Bit)
    {
        m_SpyUnitListValue = rval.m_SpyUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SlaverUnitList_Bit)
    {
        m_SlaverUnitListValue = rval.m_SlaverUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_DiplomatUnitList_Bit)
    {
        m_DiplomatUnitListValue = rval.m_DiplomatUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_MissionaryUnitList_Bit)
    {
        m_MissionaryUnitListValue = rval.m_MissionaryUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_SeaTransportUnitList_Bit)
    {
        m_SeaTransportUnitListValue = rval.m_SeaTransportUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_AirTransportUnitList_Bit)
    {
        m_AirTransportUnitListValue = rval.m_AirTransportUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_FreightUnitList_Bit)
    {
        m_FreightUnitListValue = rval.m_FreightUnitListValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_OffensiveGarrisonCount_Bit)
    {
        m_OffensiveGarrisonCountValue = rval.m_OffensiveGarrisonCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_DefensiveGarrisonCount_Bit)
    {
        m_DefensiveGarrisonCountValue = rval.m_DefensiveGarrisonCountValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_RangedGarrisonCount_Bit)
    {
        m_RangedGarrisonCountValue = rval.m_RangedGarrisonCountValue;
    }

    // replace struct elements of m_BuildListSequenceElement
    for (sint32 index_BuildListSequenceElement = 0; index_BuildListSequenceElement < m_numBuildListSequenceElement; ++index_BuildListSequenceElement)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numBuildListSequenceElement; ++obj_index)
            if (m_BuildListSequenceElement[index_BuildListSequenceElement] == rval.m_BuildListSequenceElement[obj_index]){
                m_BuildListSequenceElement[index_BuildListSequenceElement] = rval.m_BuildListSequenceElement[obj_index];
            }
    }
    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_Research_Bit)
    {
        m_ResearchValue = rval.m_ResearchValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_StopResearch_Bit)
    {
        m_StopResearchValue = rval.m_StopResearchValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Strategy_FearInvasion_Bit)
    {
        m_FearInvasionValue = rval.m_FearInvasionValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_FearCityDefense_Bit)
    {
        m_FearCityDefenseValue = rval.m_FearCityDefenseValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_FearPiracy_Bit)
    {
        m_FearPiracyValue = rval.m_FearPiracyValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_FearScienceRank_Bit)
    {
        m_FearScienceRankValue = rval.m_FearScienceRankValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_FearMilitaryRank_Bit)
    {
        m_FearMilitaryRankValue = rval.m_FearMilitaryRankValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_FearTradeRank_Bit)
    {
        m_FearTradeRankValue = rval.m_FearTradeRankValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_FearPollution_Bit)
    {
        m_FearPollutionValue = rval.m_FearPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_DesireAttack_Bit)
    {
        m_DesireAttackValue = rval.m_DesireAttackValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_DesireGold_Bit)
    {
        m_DesireGoldValue = rval.m_DesireGoldValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_DesireScience_Bit)
    {
        m_DesireScienceValue = rval.m_DesireScienceValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_DesireMakeFriend_Bit)
    {
        m_DesireMakeFriendValue = rval.m_DesireMakeFriendValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_DesireEnlistFriend_Bit)
    {
        m_DesireEnlistFriendValue = rval.m_DesireEnlistFriendValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_PiracyMemoryTurns_Bit)
    {
        m_PiracyMemoryTurnsValue = rval.m_PiracyMemoryTurnsValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_MaxPiracyEvents_Bit)
    {
        m_MaxPiracyEventsValue = rval.m_MaxPiracyEventsValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_Offensive_Bit)
    {
        m_OffensiveValue = rval.m_OffensiveValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_Defensive_Bit)
    {
        m_DefensiveValue = rval.m_DefensiveValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_StealthAttack_Bit)
    {
        m_StealthAttackValue = rval.m_StealthAttackValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_Bombard_Bit)
    {
        m_BombardValue = rval.m_BombardValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_Special_Bit)
    {
        m_SpecialValue = rval.m_SpecialValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_Harass_Bit)
    {
        m_HarassValue = rval.m_HarassValue;
    }

    // only replace values that have been set
    if (rval.m_NuclearFirstStrike)
    {
        m_NuclearFirstStrike = rval.m_NuclearFirstStrike;
    }

    // only replace values that have been set
    if (rval.m_NuclearTargeting)
    {
        m_NuclearTargeting = rval.m_NuclearTargeting;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_PreemptiveStrikeRegard_Bit)
    {
        m_PreemptiveStrikeRegardValue = rval.m_PreemptiveStrikeRegardValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_PreemptiveStrikeRiskRatio_Bit)
    {
        m_PreemptiveStrikeRiskRatioValue = rval.m_PreemptiveStrikeRiskRatioValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit)
    {
        m_PreemptiveStrikeSuperiorityRatioValue = rval.m_PreemptiveStrikeSuperiorityRatioValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_TurnsAcceptedForOnePop_Bit)
    {
        m_TurnsAcceptedForOnePopValue = rval.m_TurnsAcceptedForOnePopValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_StopBuildingFoodBeforePopMax_Bit)
    {
        m_StopBuildingFoodBeforePopMaxValue = rval.m_StopBuildingFoodBeforePopMaxValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_RoadAlreadyThereCostsCoefficient_Bit)
    {
        m_RoadAlreadyThereCostsCoefficientValue = rval.m_RoadAlreadyThereCostsCoefficientValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_UseBaseMoveCostsForRoads_Bit)
    {
        m_UseBaseMoveCostsForRoadsValue = rval.m_UseBaseMoveCostsForRoadsValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_BuildRoadsToClosestCities_Bit)
    {
        m_BuildRoadsToClosestCitiesValue = rval.m_BuildRoadsToClosestCitiesValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_BaseRoadPriorityVsThreatRank_Bit)
    {
        m_BaseRoadPriorityVsThreatRankValue = rval.m_BaseRoadPriorityVsThreatRankValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Strategy_SmallCityImproveCoeff_Bit)
    {
        m_SmallCityImproveCoeffValue = rval.m_SmallCityImproveCoeffValue;
    }

}

sint32 StrategyRecord::GetInheritIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return m_Inherit[index];
}

StrategyRecord const * StrategyRecord::GetInherit(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return g_theStrategyDB->Get(m_Inherit[index]);
}

StrategyRecord::PopAssignmentElement const * StrategyRecord::GetPopAssignmentElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPopAssignmentElement);
    if((index < 0) || (index >= m_numPopAssignmentElement)) {
        return 0;
    }
    return &m_PopAssignmentElement[index];
}

sint32 StrategyRecord::GetGovernmentIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernment);
    if((index < 0) || (index >= m_numGovernment)) {
        return 0;
    }
    return m_Government[index];
}

GovernmentRecord const * StrategyRecord::GetGovernment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernment);
    if((index < 0) || (index >= m_numGovernment)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_Government[index]);
}

StrategyRecord::SliderElement const * StrategyRecord::GetSliderElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSliderElement);
    if((index < 0) || (index >= m_numSliderElement)) {
        return 0;
    }
    return &m_SliderElement[index];
}

ImprovementListRecord const * StrategyRecord::GetImproveGrowthList() const
{
    return g_theImprovementListDB->Get(m_ImproveGrowthList);
}

ImprovementListRecord const * StrategyRecord::GetImproveProductionList() const
{
    return g_theImprovementListDB->Get(m_ImproveProductionList);
}

ImprovementListRecord const * StrategyRecord::GetImproveRandomList() const
{
    return g_theImprovementListDB->Get(m_ImproveRandomList);
}

StrategyRecord::GoalElement const * StrategyRecord::GetGoalElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGoalElement);
    if((index < 0) || (index >= m_numGoalElement)) {
        return 0;
    }
    return &m_GoalElement[index];
}

UnitBuildListRecord const * StrategyRecord::GetOffensiveUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_OffensiveUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetDefensiveUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_DefensiveUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetRangedUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_RangedUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetSeaUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SeaUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetAirUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_AirUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetSettlerUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SettlerUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetSeaSettlerUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SeaSettlerUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetSpecialUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SpecialUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetSpyUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SpyUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetSlaverUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SlaverUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetDiplomatUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_DiplomatUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetMissionaryUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_MissionaryUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetSeaTransportUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SeaTransportUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetAirTransportUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_AirTransportUnitListValue);
}

UnitBuildListRecord const * StrategyRecord::GetFreightUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_FreightUnitListValue);
}

StrategyRecord::BuildListSequenceElement const * StrategyRecord::GetBuildListSequenceElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildListSequenceElement);
    if((index < 0) || (index >= m_numBuildListSequenceElement)) {
        return 0;
    }
    return &m_BuildListSequenceElement[index];
}

AdvanceListRecord const * StrategyRecord::GetResearchPtr() const
{
    return g_theAdvanceListDB->Get(m_ResearchValue);
}

AdvanceListRecord const * StrategyRecord::GetStopResearchPtr() const
{
    return g_theAdvanceListDB->Get(m_StopResearchValue);
}

const GoalRecord *StrategyRecord::GoalElement::GetGoal() const
{
    return g_theGoalDB->Get(m_Goal);
}

const BuildListSequenceRecord *StrategyRecord::BuildListSequenceElement::GetBuildListSequence() const
{
    return g_theBuildListSequenceDB->Get(m_BuildListSequence);
}

const BuildingBuildListRecord *StrategyRecord::BuildListSequenceElement::GetHasBuildingsThenStopPtr() const
{
    return g_theBuildingBuildListDB->Get(m_HasBuildingsThenStopValue);
}

