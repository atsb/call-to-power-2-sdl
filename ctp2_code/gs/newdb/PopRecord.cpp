
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "PopRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "AdvanceRecord.h"
#include "GovernmentRecord.h"

CTPDatabase<PopRecord> *g_thePopDB = NULL;

void PopRecord::Init()
{
    m_EnableAdvance = 0x7fffffff;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_Science = 0;
    m_Happiness = 0;
    m_Food = 0;
    m_Production = 0;
    m_Commerce = 0;
    m_Culture = 0;
    m_Defense = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void PopRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_EnableAdvance;
        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_Science;
        archive << m_Happiness;
        archive << m_Food;
        archive << m_Production;
        archive << m_Commerce;
        archive << m_Culture;
        archive << m_Defense;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_EnableAdvance;
        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive >> m_Science;
        archive >> m_Happiness;
        archive >> m_Food;
        archive >> m_Production;
        archive >> m_Commerce;
        archive >> m_Culture;
        archive >> m_Defense;
    }
}

PopRecord::~PopRecord()
{
    delete [] m_GovernmentsModified;
}

PopRecord const & PopRecord::operator = (PopRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_EnableAdvance = rval.m_EnableAdvance;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        m_Science = rval.m_Science;

        m_Happiness = rval.m_Happiness;

        m_Food = rval.m_Food;

        m_Production = rval.m_Production;

        m_Commerce = rval.m_Commerce;

        m_Culture = rval.m_Culture;

        m_Defense = rval.m_Defense;

    }

    return *this;
}

const char *g_Pop_Tokens[] =
{
    "EnableAdvance",
    "GovernmentsModified",
    "Science",
    "Happiness",
    "Food",
    "Production",
    "Commerce",
    "Culture",
    "Defense",
};

PopRecordAccessorInfo g_PopRecord_Accessors[] =
{
    { &PopRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PopRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &PopRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { &PopRecord::GetScience, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PopRecord::GetHappiness, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PopRecord::GetFood, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PopRecord::GetProduction, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PopRecord::GetCommerce, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PopRecord::GetCulture, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PopRecord::GetDefense, NULL, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_Pop_EnableAdvance                ((k_Token_Custom_Base) + 0)
#define k_Token_Pop_GovernmentsModified          ((k_Token_Custom_Base) + 1)
#define k_Token_Pop_Science                      ((k_Token_Custom_Base) + 2)
#define k_Token_Pop_Happiness                    ((k_Token_Custom_Base) + 3)
#define k_Token_Pop_Food                         ((k_Token_Custom_Base) + 4)
#define k_Token_Pop_Production                   ((k_Token_Custom_Base) + 5)
#define k_Token_Pop_Commerce                     ((k_Token_Custom_Base) + 6)
#define k_Token_Pop_Culture                      ((k_Token_Custom_Base) + 7)
#define k_Token_Pop_Defense                      ((k_Token_Custom_Base) + 8)
#define k_Token_Pop_Max                          ((k_Token_Custom_Base) + 9)


static BitArray s_ParsedTokens(9);
void PopRecord::CheckRequiredFields(DBLexer *lex)
{
}

sint32 PopRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Pop_Tokens, k_Token_Pop_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "POP_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Pop_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Pop_EnableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Pop_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_Pop_Science:
                if(!lex->GetIntAssignment(m_Science)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Happiness:
                if(!lex->GetIntAssignment(m_Happiness)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Food:
                if(!lex->GetIntAssignment(m_Food)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Production:
                if(!lex->GetIntAssignment(m_Production)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Commerce:
                if(!lex->GetIntAssignment(m_Commerce)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Culture:
                if(!lex->GetIntAssignment(m_Culture)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Defense:
                if(!lex->GetIntAssignment(m_Defense)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theAdvanceDB->GetCurrentRecordFromLexer(lex, m_EnableAdvance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void PopRecord::ResolveDBReferences()
{
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
}

void PopRecord::Merge(const PopRecord & rval){
    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

}

AdvanceRecord const * PopRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 PopRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * PopRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

