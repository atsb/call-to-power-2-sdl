
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */

#if defined(HAVE_PRAGMA_ONCE)
#pragma once
#endif

#ifndef STRATEGY_RECORD_H__
#define STRATEGY_RECORD_H__

class StrategyRecord;

#include "CTPDatabase.h"
#include "CTPRecord.h"
class CivArchive;
class AdvanceListRecord;
class GovernmentRecord;
class ImprovementListRecord;
class UnitBuildListRecord;
class GoalRecord;
class BuildListSequenceRecord;
class BuildingBuildListRecord;

#define k_Num_StrategyRecord_Tokens 197

//
// m_flags0: Strategy
#define k_Strategy_MinimumHappiness_Bit          0x00000001
#define k_Strategy_DeficitSpending_Bit           0x00000002
#define k_Strategy_MaximumWagePercent_Bit        0x00000004
#define k_Strategy_SciencePercent_Bit            0x00000008
#define k_Strategy_MaxSupportCostPercent_Bit     0x00000010
#define k_Strategy_ReadinessLevel_Bit            0x00000020
#define k_Strategy_PublicWorksPercent_Bit        0x00000040
#define k_Strategy_PublicWorksReserve_Bit        0x00000080
#define k_Strategy_MaxEvalTileImprovements_Bit   0x00000100
#define k_Strategy_TimeToFixRoads_Bit            0x00000200
#define k_Strategy_TimeToFixPollution_Bit        0x00000400
#define k_Strategy_FixPollutionThreshold_Bit     0x00000800
#define k_Strategy_RoadUtilityBonus_Bit          0x00001000
#define k_Strategy_ImproveProductionBonus_Bit    0x00002000
#define k_Strategy_ImproveGrowthBonus_Bit        0x00004000
#define k_Strategy_ImproveGoodBonus_Bit          0x00008000
#define k_Strategy_ImproveSmallCityGrowthBonus_Bit 0x00010000
#define k_Strategy_ImproveLargeCityProductionBonus_Bit 0x00020000
#define k_Strategy_DistanceModifierFactor_Bit    0x00040000
#define k_Strategy_DisbandArmyCount_Bit          0x00080000
#define k_Strategy_MinSettleDistance_Bit         0x00100000
#define k_Strategy_MinSettleScore_Bit            0x00200000
#define k_Strategy_RushBuyThreatBonus_Bit        0x00400000
#define k_Strategy_RushBuyReservePercent_Bit     0x00800000
#define k_Strategy_UnitSupportPercent_Bit        0x01000000
#define k_Strategy_MaxSettlerBuildTurns_Bit      0x02000000
#define k_Strategy_MaxUnitBuildTurns_Bit         0x04000000
#define k_Strategy_MaxWonderBuildTurns_Bit       0x08000000
#define k_Strategy_BuildTransportProductionLevel_Bit 0x10000000
#define k_Strategy_BuildSettlerProductionLevel_Bit 0x20000000
#define k_Strategy_OffensiveUnitsPercent_Bit     0x40000000
#define k_Strategy_DefensiveUnitsPercent_Bit     0x80000000
//
// m_flags1: Strategy
#define k_Strategy_RangedUnitsPercent_Bit        0x00000001
#define k_Strategy_SeaUnitsPercent_Bit           0x00000002
#define k_Strategy_AirUnitsPercent_Bit           0x00000004
#define k_Strategy_SettlerUnitsCount_Bit         0x00000008
#define k_Strategy_SpecialUnitsCount_Bit         0x00000010
#define k_Strategy_SpyUnitsCount_Bit             0x00000020
#define k_Strategy_SlaveryUnitsCount_Bit         0x00000040
#define k_Strategy_DiplomatUnitsCount_Bit        0x00000080
#define k_Strategy_MissionaryUnitsCount_Bit      0x00000100
#define k_Strategy_SeaTransportUnitsCount_Bit    0x00000200
#define k_Strategy_AirTransportUnitsCount_Bit    0x00000400
#define k_Strategy_OffensiveUnitList_Bit         0x00000800
#define k_Strategy_DefensiveUnitList_Bit         0x00001000
#define k_Strategy_RangedUnitList_Bit            0x00002000
#define k_Strategy_SeaUnitList_Bit               0x00004000
#define k_Strategy_AirUnitList_Bit               0x00008000
#define k_Strategy_SettlerUnitList_Bit           0x00010000
#define k_Strategy_SeaSettlerUnitList_Bit        0x00020000
#define k_Strategy_SpecialUnitList_Bit           0x00040000
#define k_Strategy_SpyUnitList_Bit               0x00080000
#define k_Strategy_SlaverUnitList_Bit            0x00100000
#define k_Strategy_DiplomatUnitList_Bit          0x00200000
#define k_Strategy_MissionaryUnitList_Bit        0x00400000
#define k_Strategy_SeaTransportUnitList_Bit      0x00800000
#define k_Strategy_AirTransportUnitList_Bit      0x01000000
#define k_Strategy_FreightUnitList_Bit           0x02000000
#define k_Strategy_OffensiveGarrisonCount_Bit    0x04000000
#define k_Strategy_DefensiveGarrisonCount_Bit    0x08000000
#define k_Strategy_RangedGarrisonCount_Bit       0x10000000
#define k_Strategy_Research_Bit                  0x20000000
#define k_Strategy_StopResearch_Bit              0x40000000
#define k_Strategy_FearInvasion_Bit              0x80000000
//
// m_flags2: Strategy
#define k_Strategy_FearCityDefense_Bit           0x00000001
#define k_Strategy_FearPiracy_Bit                0x00000002
#define k_Strategy_FearScienceRank_Bit           0x00000004
#define k_Strategy_FearMilitaryRank_Bit          0x00000008
#define k_Strategy_FearTradeRank_Bit             0x00000010
#define k_Strategy_FearPollution_Bit             0x00000020
#define k_Strategy_DesireAttack_Bit              0x00000040
#define k_Strategy_DesireGold_Bit                0x00000080
#define k_Strategy_DesireScience_Bit             0x00000100
#define k_Strategy_DesireMakeFriend_Bit          0x00000200
#define k_Strategy_DesireEnlistFriend_Bit        0x00000400
#define k_Strategy_PiracyMemoryTurns_Bit         0x00000800
#define k_Strategy_MaxPiracyEvents_Bit           0x00001000
#define k_Strategy_Offensive_Bit                 0x00002000
#define k_Strategy_Defensive_Bit                 0x00004000
#define k_Strategy_StealthAttack_Bit             0x00008000
#define k_Strategy_Bombard_Bit                   0x00010000
#define k_Strategy_Special_Bit                   0x00020000
#define k_Strategy_Harass_Bit                    0x00040000
#define k_Strategy_PreemptiveStrikeRegard_Bit    0x00080000
#define k_Strategy_PreemptiveStrikeRiskRatio_Bit 0x00100000
#define k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit 0x00200000
#define k_Strategy_TurnsAcceptedForOnePop_Bit    0x00400000
#define k_Strategy_StopBuildingFoodBeforePopMax_Bit 0x00800000
#define k_Strategy_RoadAlreadyThereCostsCoefficient_Bit 0x01000000
#define k_Strategy_UseBaseMoveCostsForRoads_Bit  0x02000000
#define k_Strategy_BuildRoadsToClosestCities_Bit 0x04000000
#define k_Strategy_BaseRoadPriorityVsThreatRank_Bit 0x08000000
#define k_Strategy_SmallCityImproveCoeff_Bit     0x10000000
//
// m_NuclearFirstStrike bit group
#define k_Strategy_NuclearFirstStrike_Enabled_Bit 0x00000001
#define k_Strategy_NuclearFirstStrike_Disabled_Bit 0x00000002
//
// m_NuclearTargeting bit group
#define k_Strategy_NuclearTargeting_Enabled_Bit  0x00000001
#define k_Strategy_NuclearTargeting_Disabled_Bit 0x00000002
//
// m_flags0: PopAssignmentElement
#define k_PopAssignmentElement_Top_Bit           0x00000001
#define k_PopAssignmentElement_Bottom_Bit        0x00000002
#define k_PopAssignmentElement_ProductionCities_Bit 0x00000004
#define k_PopAssignmentElement_GrowthCities_Bit  0x00000008
#define k_PopAssignmentElement_GoldCities_Bit    0x00000010
#define k_PopAssignmentElement_Default_Bit       0x00000020
//
// m_flags0: SliderElement
#define k_SliderElement_Production_Bit           0x00000001
#define k_SliderElement_Gold_Bit                 0x00000002
#define k_SliderElement_Food_Bit                 0x00000004
//
// m_flags0: GoalElement
#define k_GoalElement_ExecPerCity_Bit            0x00000001
#define k_GoalElement_EvalPerCity_Bit            0x00000002
#define k_GoalElement_PerCity_Bit                0x00000004
//
// m_flags0: BuildListSequenceElement
#define k_BuildListSequenceElement_Top_Bit       0x00000001
#define k_BuildListSequenceElement_Bottom_Bit    0x00000002
#define k_BuildListSequenceElement_AllCities_Bit 0x00000004
#define k_BuildListSequenceElement_ProductionCities_Bit 0x00000008
#define k_BuildListSequenceElement_GrowthCities_Bit 0x00000010
#define k_BuildListSequenceElement_CommerceCities_Bit 0x00000020
#define k_BuildListSequenceElement_HappyCities_Bit 0x00000040
#define k_BuildListSequenceElement_ThreatenedCities_Bit 0x00000080
#define k_BuildListSequenceElement_PowerCities_Bit 0x00000100
#define k_BuildListSequenceElement_Default_Bit   0x00000200
#define k_BuildListSequenceElement_Advice_Bit    0x00000400
#define k_BuildListSequenceElement_SmallCitiesMaxSize_Bit 0x00000800
#define k_BuildListSequenceElement_MinNumUnits_Bit 0x00001000
#define k_BuildListSequenceElement_MinNumCities_Bit 0x00002000
#define k_BuildListSequenceElement_BeforeMaxCitySize_Bit 0x00004000
#define k_BuildListSequenceElement_HasBuildingsThenStop_Bit 0x00008000
#define k_BuildListSequenceElement_MinPollution_Bit 0x00010000
#define k_BuildListSequenceElement_MaxRawHappiness_Bit 0x00020000
#define k_BuildListSequenceElement_CanBuildWonders_Bit 0x00040000
#define k_BuildListSequenceElement_NoUnits_Bit   0x00080000
#define k_MAX_Inherit                        1

class StrategyRecord : public CTPRecord
{
public:
    typedef sint32 (StrategyRecord::*IntAccessor)() const;
    typedef bool   (StrategyRecord::*BoolAccessor)() const;
    typedef double (StrategyRecord::*FloatAccessor)() const ;
    typedef bool   (StrategyRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool   (StrategyRecord::*BitFloatAccessor)(double &val) const;
    typedef sint32 (StrategyRecord::*IntArrayAccessor)(sint32 index) const;
    typedef double (StrategyRecord::*FloatArrayAccessor)(sint32 index) const;

    class PopAssignmentElement {
    private:
        uint32            m_flags0;
        double            m_Specialists;
        double            m_FarmerPercent;
        double            m_LaborerPercent;
        double            m_MerchantPercent;
        double            m_EntertainerPercent;
        double            m_ScientistPercent;
        double            m_TopValue;
        double            m_BottomValue;

    public:
        PopAssignmentElement();
        PopAssignmentElement(CivArchive & archive){ Serialize(archive); };
        ~PopAssignmentElement();
        PopAssignmentElement const & operator = (PopAssignmentElement const & rval);
        bool operator == (PopAssignmentElement const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, PopAssignmentElement **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, PopAssignmentElement *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetSpecialists() const { return m_Specialists; }
        double GetFarmerPercent() const { return m_FarmerPercent; }
        double GetLaborerPercent() const { return m_LaborerPercent; }
        double GetMerchantPercent() const { return m_MerchantPercent; }
        double GetEntertainerPercent() const { return m_EntertainerPercent; }
        double GetScientistPercent() const { return m_ScientistPercent; }
        bool HasTop() const { return (m_flags0 & k_PopAssignmentElement_Top_Bit) != 0; }
        bool GetTop(double & value) const
        {
            if (m_flags0 & k_PopAssignmentElement_Top_Bit)
            {
                value = m_TopValue;
            }
            return (m_flags0 & k_PopAssignmentElement_Top_Bit) != 0;
        }
        bool HasBottom() const { return (m_flags0 & k_PopAssignmentElement_Bottom_Bit) != 0; }
        bool GetBottom(double & value) const
        {
            if (m_flags0 & k_PopAssignmentElement_Bottom_Bit)
            {
                value = m_BottomValue;
            }
            return (m_flags0 & k_PopAssignmentElement_Bottom_Bit) != 0;
        }
        bool GetProductionCities() const { return (m_flags0 & k_PopAssignmentElement_ProductionCities_Bit) != 0; }
        bool GetGrowthCities() const { return (m_flags0 & k_PopAssignmentElement_GrowthCities_Bit) != 0; }
        bool GetGoldCities() const { return (m_flags0 & k_PopAssignmentElement_GoldCities_Bit) != 0; }
        bool GetDefault() const { return (m_flags0 & k_PopAssignmentElement_Default_Bit) != 0; }

    }; /* class PopAssignmentElement */

    class SliderElement {
    private:
        uint32            m_flags0;
        sint32            m_Delta;

    public:
        SliderElement();
        SliderElement(CivArchive & archive){ Serialize(archive); };
        ~SliderElement();
        SliderElement const & operator = (SliderElement const & rval);
        bool operator == (SliderElement const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SliderElement **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SliderElement *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        sint32 GetDelta() const { return m_Delta; }
        bool GetProduction() const { return (m_flags0 & k_SliderElement_Production_Bit) != 0; }
        bool GetGold() const { return (m_flags0 & k_SliderElement_Gold_Bit) != 0; }
        bool GetFood() const { return (m_flags0 & k_SliderElement_Food_Bit) != 0; }

    }; /* class SliderElement */

    class GoalElement {
    private:
        uint32            m_flags0;
        sint32            m_Goal; // Index into Goal database
        sint32            m_Priority;
        double            m_MaxEval;
        double            m_MaxExec;

    public:
        GoalElement();
        GoalElement(CivArchive & archive){ Serialize(archive); };
        ~GoalElement();
        GoalElement const & operator = (GoalElement const & rval);
        bool operator == (GoalElement const & rval) {
          if (m_Goal != rval.m_Goal)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, GoalElement **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, GoalElement *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        sint32           GetGoalIndex() const { return m_Goal; }
        GoalRecord const * GetGoal() const;
        sint32 GetPriority() const { return m_Priority; }
        double GetMaxEval() const { return m_MaxEval; }
        double GetMaxExec() const { return m_MaxExec; }
        bool GetExecPerCity() const { return (m_flags0 & k_GoalElement_ExecPerCity_Bit) != 0; }
        bool GetEvalPerCity() const { return (m_flags0 & k_GoalElement_EvalPerCity_Bit) != 0; }
        bool GetPerCity() const { return (m_flags0 & k_GoalElement_PerCity_Bit) != 0; }

    }; /* class GoalElement */

    class BuildListSequenceElement {
    private:
        uint32            m_flags0;
        sint32            m_Priority;
        sint32            m_BuildListSequence; // Index into BuildListSequence database
        double            m_TopValue;
        double            m_BottomValue;
        sint32            m_AdviceValue;
        sint32            m_SmallCitiesMaxSizeValue;
        sint32            m_MinNumUnitsValue;
        sint32            m_MinNumCitiesValue;
        sint32            m_BeforeMaxCitySizeValue;
        sint32            m_HasBuildingsThenStopValue; // Index into BuildingBuildList database
        sint32            m_MinPollutionValue;
        sint32            m_MaxRawHappinessValue;

    public:
        BuildListSequenceElement();
        BuildListSequenceElement(CivArchive & archive){ Serialize(archive); };
        ~BuildListSequenceElement();
        BuildListSequenceElement const & operator = (BuildListSequenceElement const & rval);
        bool operator == (BuildListSequenceElement const & rval) {
          if (m_BuildListSequence != rval.m_BuildListSequence)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, BuildListSequenceElement **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, BuildListSequenceElement *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        sint32 GetPriority() const { return m_Priority; }
        sint32           GetBuildListSequenceIndex() const { return m_BuildListSequence; }
        BuildListSequenceRecord const * GetBuildListSequence() const;
        bool HasTop() const { return (m_flags0 & k_BuildListSequenceElement_Top_Bit) != 0; }
        bool GetTop(double & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_Top_Bit)
            {
                value = m_TopValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_Top_Bit) != 0;
        }
        bool HasBottom() const { return (m_flags0 & k_BuildListSequenceElement_Bottom_Bit) != 0; }
        bool GetBottom(double & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_Bottom_Bit)
            {
                value = m_BottomValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_Bottom_Bit) != 0;
        }
        bool GetAllCities() const { return (m_flags0 & k_BuildListSequenceElement_AllCities_Bit) != 0; }
        bool GetProductionCities() const { return (m_flags0 & k_BuildListSequenceElement_ProductionCities_Bit) != 0; }
        bool GetGrowthCities() const { return (m_flags0 & k_BuildListSequenceElement_GrowthCities_Bit) != 0; }
        bool GetCommerceCities() const { return (m_flags0 & k_BuildListSequenceElement_CommerceCities_Bit) != 0; }
        bool GetHappyCities() const { return (m_flags0 & k_BuildListSequenceElement_HappyCities_Bit) != 0; }
        bool GetThreatenedCities() const { return (m_flags0 & k_BuildListSequenceElement_ThreatenedCities_Bit) != 0; }
        bool GetPowerCities() const { return (m_flags0 & k_BuildListSequenceElement_PowerCities_Bit) != 0; }
        bool GetDefault() const { return (m_flags0 & k_BuildListSequenceElement_Default_Bit) != 0; }
        bool HasAdvice() const { return (m_flags0 & k_BuildListSequenceElement_Advice_Bit) != 0; }
        bool GetAdvice(sint32 & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_Advice_Bit)
            {
                value = m_AdviceValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_Advice_Bit) != 0;
        }
        bool HasSmallCitiesMaxSize() const { return (m_flags0 & k_BuildListSequenceElement_SmallCitiesMaxSize_Bit) != 0; }
        bool GetSmallCitiesMaxSize(sint32 & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_SmallCitiesMaxSize_Bit)
            {
                value = m_SmallCitiesMaxSizeValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_SmallCitiesMaxSize_Bit) != 0;
        }
        bool HasMinNumUnits() const { return (m_flags0 & k_BuildListSequenceElement_MinNumUnits_Bit) != 0; }
        bool GetMinNumUnits(sint32 & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_MinNumUnits_Bit)
            {
                value = m_MinNumUnitsValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_MinNumUnits_Bit) != 0;
        }
        bool HasMinNumCities() const { return (m_flags0 & k_BuildListSequenceElement_MinNumCities_Bit) != 0; }
        bool GetMinNumCities(sint32 & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_MinNumCities_Bit)
            {
                value = m_MinNumCitiesValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_MinNumCities_Bit) != 0;
        }
        bool HasBeforeMaxCitySize() const { return (m_flags0 & k_BuildListSequenceElement_BeforeMaxCitySize_Bit) != 0; }
        bool GetBeforeMaxCitySize(sint32 & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_BeforeMaxCitySize_Bit)
            {
                value = m_BeforeMaxCitySizeValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_BeforeMaxCitySize_Bit) != 0;
        }
        bool HasHasBuildingsThenStop() const { return (m_flags0 & k_BuildListSequenceElement_HasBuildingsThenStop_Bit) != 0; }
        bool GetHasBuildingsThenStopIndex(sint32 & index) const
        {
            index = (m_flags0 & k_BuildListSequenceElement_HasBuildingsThenStop_Bit) ? m_HasBuildingsThenStopValue : -1;
            return (m_flags0 & k_BuildListSequenceElement_HasBuildingsThenStop_Bit) != 0;
        }
        bool GetHasBuildingsThenStop(const BuildingBuildListRecord * & rec) const;
        const BuildingBuildListRecord * GetHasBuildingsThenStopPtr() const;
        bool HasMinPollution() const { return (m_flags0 & k_BuildListSequenceElement_MinPollution_Bit) != 0; }
        bool GetMinPollution(sint32 & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_MinPollution_Bit)
            {
                value = m_MinPollutionValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_MinPollution_Bit) != 0;
        }
        bool HasMaxRawHappiness() const { return (m_flags0 & k_BuildListSequenceElement_MaxRawHappiness_Bit) != 0; }
        bool GetMaxRawHappiness(sint32 & value) const
        {
            if (m_flags0 & k_BuildListSequenceElement_MaxRawHappiness_Bit)
            {
                value = m_MaxRawHappinessValue;
            }
            return (m_flags0 & k_BuildListSequenceElement_MaxRawHappiness_Bit) != 0;
        }
        bool GetCanBuildWonders() const { return (m_flags0 & k_BuildListSequenceElement_CanBuildWonders_Bit) != 0; }
        bool GetNoUnits() const { return (m_flags0 & k_BuildListSequenceElement_NoUnits_Bit) != 0; }

    }; /* class BuildListSequenceElement */

    class ForceMatch {
    private:
        double            m_AttackMatch;
        double            m_DefenseMatch;
        double            m_RangedMatch;
        double            m_BombardMatch;
        double            m_ValueMatch;

    public:
        ForceMatch();
        ForceMatch(CivArchive & archive){ Serialize(archive); };
        ~ForceMatch();
        ForceMatch const & operator = (ForceMatch const & rval);
        bool operator == (ForceMatch const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, ForceMatch **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, ForceMatch *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, ForceMatch **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, ForceMatch *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetAttackMatch() const { return m_AttackMatch; }
        double GetDefenseMatch() const { return m_DefenseMatch; }
        double GetRangedMatch() const { return m_RangedMatch; }
        double GetBombardMatch() const { return m_BombardMatch; }
        double GetValueMatch() const { return m_ValueMatch; }

    }; /* class ForceMatch */

private:
    uint32 m_flags0;
    uint32 m_flags1;
    uint32 m_flags2;
    sint32            m_Inherit[k_MAX_Inherit]; // Index into Strategy database
    sint32            m_numInherit;
    PopAssignmentElement * m_PopAssignmentElement;
    sint32            m_numPopAssignmentElement;
    sint32          * m_Government; // Index into Government database
    sint32            m_numGovernment;
    sint32            m_MinimumHappinessValue;
    double            m_DeficitSpendingValue;
    double            m_MaximumWagePercentValue;
    SliderElement   * m_SliderElement;
    sint32            m_numSliderElement;
    sint32            m_SciencePercentValue;
    sint32            m_MaxSupportCostPercentValue;
    sint32            m_ReadinessLevelValue;
    sint32            m_PublicWorksPercentValue;
    sint32            m_PublicWorksReserveValue;
    sint32            m_MaxEvalTileImprovementsValue;
    sint32            m_TimeToFixRoadsValue;
    sint32            m_TimeToFixPollutionValue;
    sint32            m_FixPollutionThresholdValue;
    double            m_RoadUtilityBonusValue;
    double            m_ImproveProductionBonusValue;
    double            m_ImproveGrowthBonusValue;
    double            m_ImproveGoodBonusValue;
    double            m_ImproveSmallCityGrowthBonusValue;
    double            m_ImproveLargeCityProductionBonusValue;
    sint32            m_ImproveGrowthList; // Index into ImprovementList database
    sint32            m_ImproveProductionList; // Index into ImprovementList database
    sint32            m_ImproveRandomList; // Index into ImprovementList database
    GoalElement     * m_GoalElement;
    sint32            m_numGoalElement;
    sint32            m_DistanceModifierFactorValue;
    sint32            m_DisbandArmyCountValue;
    sint32            m_MinSettleDistanceValue;
    sint32            m_MinSettleScoreValue;
    sint32            m_RushBuyThreatBonusValue;
    double            m_RushBuyReservePercentValue;
    double            m_UnitSupportPercentValue;
    sint32            m_MaxSettlerBuildTurnsValue;
    sint32            m_MaxUnitBuildTurnsValue;
    sint32            m_MaxWonderBuildTurnsValue;
    double            m_BuildTransportProductionLevelValue;
    double            m_BuildSettlerProductionLevelValue;
    double            m_OffensiveUnitsPercentValue;
    double            m_DefensiveUnitsPercentValue;
    double            m_RangedUnitsPercentValue;
    double            m_SeaUnitsPercentValue;
    double            m_AirUnitsPercentValue;
    sint32            m_SettlerUnitsCountValue;
    sint32            m_SpecialUnitsCountValue;
    sint32            m_SpyUnitsCountValue;
    sint32            m_SlaveryUnitsCountValue;
    sint32            m_DiplomatUnitsCountValue;
    sint32            m_MissionaryUnitsCountValue;
    sint32            m_SeaTransportUnitsCountValue;
    sint32            m_AirTransportUnitsCountValue;
    sint32            m_OffensiveUnitListValue; // Index into UnitBuildList database
    sint32            m_DefensiveUnitListValue; // Index into UnitBuildList database
    sint32            m_RangedUnitListValue; // Index into UnitBuildList database
    sint32            m_SeaUnitListValue; // Index into UnitBuildList database
    sint32            m_AirUnitListValue; // Index into UnitBuildList database
    sint32            m_SettlerUnitListValue; // Index into UnitBuildList database
    sint32            m_SeaSettlerUnitListValue; // Index into UnitBuildList database
    sint32            m_SpecialUnitListValue; // Index into UnitBuildList database
    sint32            m_SpyUnitListValue; // Index into UnitBuildList database
    sint32            m_SlaverUnitListValue; // Index into UnitBuildList database
    sint32            m_DiplomatUnitListValue; // Index into UnitBuildList database
    sint32            m_MissionaryUnitListValue; // Index into UnitBuildList database
    sint32            m_SeaTransportUnitListValue; // Index into UnitBuildList database
    sint32            m_AirTransportUnitListValue; // Index into UnitBuildList database
    sint32            m_FreightUnitListValue; // Index into UnitBuildList database
    sint32            m_OffensiveGarrisonCountValue;
    sint32            m_DefensiveGarrisonCountValue;
    sint32            m_RangedGarrisonCountValue;
    BuildListSequenceElement * m_BuildListSequenceElement;
    sint32            m_numBuildListSequenceElement;
    sint32            m_ResearchValue; // Index into AdvanceList database
    sint32            m_StopResearchValue; // Index into AdvanceList database
    sint32            m_FearInvasionValue;
    sint32            m_FearCityDefenseValue;
    sint32            m_FearPiracyValue;
    sint32            m_FearScienceRankValue;
    sint32            m_FearMilitaryRankValue;
    sint32            m_FearTradeRankValue;
    sint32            m_FearPollutionValue;
    sint32            m_DesireAttackValue;
    sint32            m_DesireGoldValue;
    sint32            m_DesireScienceValue;
    sint32            m_DesireMakeFriendValue;
    sint32            m_DesireEnlistFriendValue;
    sint32            m_PiracyMemoryTurnsValue;
    sint32            m_MaxPiracyEventsValue;
    ForceMatch        m_OffensiveValue;
    ForceMatch        m_DefensiveValue;
    ForceMatch        m_StealthAttackValue;
    ForceMatch        m_BombardValue;
    ForceMatch        m_SpecialValue;
    ForceMatch        m_HarassValue;
    uint32            m_NuclearFirstStrike;
    uint32            m_NuclearTargeting;
    sint32            m_PreemptiveStrikeRegardValue;
    double            m_PreemptiveStrikeRiskRatioValue;
    double            m_PreemptiveStrikeSuperiorityRatioValue;
    sint32            m_TurnsAcceptedForOnePopValue;
    sint32            m_StopBuildingFoodBeforePopMaxValue;
    double            m_RoadAlreadyThereCostsCoefficientValue;
    sint32            m_UseBaseMoveCostsForRoadsValue;
    sint32            m_BuildRoadsToClosestCitiesValue;
    double            m_BaseRoadPriorityVsThreatRankValue;
    double            m_SmallCityImproveCoeffValue;
    bool m_hasGovernmentsModified; // GovMod specific flag

public:
    StrategyRecord() { Init(); };
    StrategyRecord(CivArchive &archive) { Serialize(archive); };
    StrategyRecord(StrategyRecord const & rval) { Init(); *this = rval; }
    ~StrategyRecord();
    StrategyRecord const & operator = (StrategyRecord const & rval);

    void Init();
    void Serialize(CivArchive &archive);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex, sint32 numRecords);

    void ResolveDBReferences();
    void Merge(const StrategyRecord & rval);
    sint32 ParseNuclearFirstStrikeBit(DBLexer *lex);
    sint32 ParseNuclearTargetingBit(DBLexer *lex);

    sint32 GetInheritIndex(sint32 index) const;
    const StrategyRecord * GetInherit(sint32 index) const;
    sint32 GetNumInherit() const { return m_numInherit;}
    const PopAssignmentElement * GetPopAssignmentElement(sint32 index) const;
    sint32 GetNumPopAssignmentElement() const { return m_numPopAssignmentElement;}
    sint32 GetGovernmentIndex(sint32 index) const;
    const GovernmentRecord * GetGovernment(sint32 index) const;
    sint32 GetNumGovernment() const { return m_numGovernment;}
    bool HasMinimumHappiness() const { return (m_flags0 & k_Strategy_MinimumHappiness_Bit) != 0; }
    bool GetMinimumHappiness(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MinimumHappiness_Bit)
        {
            value = m_MinimumHappinessValue;
        }
        return (m_flags0 & k_Strategy_MinimumHappiness_Bit) != 0;
    }
    bool HasDeficitSpending() const { return (m_flags0 & k_Strategy_DeficitSpending_Bit) != 0; }
    bool GetDeficitSpending(double & value) const
    {
        if (m_flags0 & k_Strategy_DeficitSpending_Bit)
        {
            value = m_DeficitSpendingValue;
        }
        return (m_flags0 & k_Strategy_DeficitSpending_Bit) != 0;
    }
    bool HasMaximumWagePercent() const { return (m_flags0 & k_Strategy_MaximumWagePercent_Bit) != 0; }
    bool GetMaximumWagePercent(double & value) const
    {
        if (m_flags0 & k_Strategy_MaximumWagePercent_Bit)
        {
            value = m_MaximumWagePercentValue;
        }
        return (m_flags0 & k_Strategy_MaximumWagePercent_Bit) != 0;
    }
    const SliderElement * GetSliderElement(sint32 index) const;
    sint32 GetNumSliderElement() const { return m_numSliderElement;}
    bool HasSciencePercent() const { return (m_flags0 & k_Strategy_SciencePercent_Bit) != 0; }
    bool GetSciencePercent(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_SciencePercent_Bit)
        {
            value = m_SciencePercentValue;
        }
        return (m_flags0 & k_Strategy_SciencePercent_Bit) != 0;
    }
    bool HasMaxSupportCostPercent() const { return (m_flags0 & k_Strategy_MaxSupportCostPercent_Bit) != 0; }
    bool GetMaxSupportCostPercent(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MaxSupportCostPercent_Bit)
        {
            value = m_MaxSupportCostPercentValue;
        }
        return (m_flags0 & k_Strategy_MaxSupportCostPercent_Bit) != 0;
    }
    bool HasReadinessLevel() const { return (m_flags0 & k_Strategy_ReadinessLevel_Bit) != 0; }
    bool GetReadinessLevel(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_ReadinessLevel_Bit)
        {
            value = m_ReadinessLevelValue;
        }
        return (m_flags0 & k_Strategy_ReadinessLevel_Bit) != 0;
    }
    bool HasPublicWorksPercent() const { return (m_flags0 & k_Strategy_PublicWorksPercent_Bit) != 0; }
    bool GetPublicWorksPercent(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_PublicWorksPercent_Bit)
        {
            value = m_PublicWorksPercentValue;
        }
        return (m_flags0 & k_Strategy_PublicWorksPercent_Bit) != 0;
    }
    bool HasPublicWorksReserve() const { return (m_flags0 & k_Strategy_PublicWorksReserve_Bit) != 0; }
    bool GetPublicWorksReserve(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_PublicWorksReserve_Bit)
        {
            value = m_PublicWorksReserveValue;
        }
        return (m_flags0 & k_Strategy_PublicWorksReserve_Bit) != 0;
    }
    bool HasMaxEvalTileImprovements() const { return (m_flags0 & k_Strategy_MaxEvalTileImprovements_Bit) != 0; }
    bool GetMaxEvalTileImprovements(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MaxEvalTileImprovements_Bit)
        {
            value = m_MaxEvalTileImprovementsValue;
        }
        return (m_flags0 & k_Strategy_MaxEvalTileImprovements_Bit) != 0;
    }
    bool HasTimeToFixRoads() const { return (m_flags0 & k_Strategy_TimeToFixRoads_Bit) != 0; }
    bool GetTimeToFixRoads(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_TimeToFixRoads_Bit)
        {
            value = m_TimeToFixRoadsValue;
        }
        return (m_flags0 & k_Strategy_TimeToFixRoads_Bit) != 0;
    }
    bool HasTimeToFixPollution() const { return (m_flags0 & k_Strategy_TimeToFixPollution_Bit) != 0; }
    bool GetTimeToFixPollution(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_TimeToFixPollution_Bit)
        {
            value = m_TimeToFixPollutionValue;
        }
        return (m_flags0 & k_Strategy_TimeToFixPollution_Bit) != 0;
    }
    bool HasFixPollutionThreshold() const { return (m_flags0 & k_Strategy_FixPollutionThreshold_Bit) != 0; }
    bool GetFixPollutionThreshold(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_FixPollutionThreshold_Bit)
        {
            value = m_FixPollutionThresholdValue;
        }
        return (m_flags0 & k_Strategy_FixPollutionThreshold_Bit) != 0;
    }
    bool HasRoadUtilityBonus() const { return (m_flags0 & k_Strategy_RoadUtilityBonus_Bit) != 0; }
    bool GetRoadUtilityBonus(double & value) const
    {
        if (m_flags0 & k_Strategy_RoadUtilityBonus_Bit)
        {
            value = m_RoadUtilityBonusValue;
        }
        return (m_flags0 & k_Strategy_RoadUtilityBonus_Bit) != 0;
    }
    bool HasImproveProductionBonus() const { return (m_flags0 & k_Strategy_ImproveProductionBonus_Bit) != 0; }
    bool GetImproveProductionBonus(double & value) const
    {
        if (m_flags0 & k_Strategy_ImproveProductionBonus_Bit)
        {
            value = m_ImproveProductionBonusValue;
        }
        return (m_flags0 & k_Strategy_ImproveProductionBonus_Bit) != 0;
    }
    bool HasImproveGrowthBonus() const { return (m_flags0 & k_Strategy_ImproveGrowthBonus_Bit) != 0; }
    bool GetImproveGrowthBonus(double & value) const
    {
        if (m_flags0 & k_Strategy_ImproveGrowthBonus_Bit)
        {
            value = m_ImproveGrowthBonusValue;
        }
        return (m_flags0 & k_Strategy_ImproveGrowthBonus_Bit) != 0;
    }
    bool HasImproveGoodBonus() const { return (m_flags0 & k_Strategy_ImproveGoodBonus_Bit) != 0; }
    bool GetImproveGoodBonus(double & value) const
    {
        if (m_flags0 & k_Strategy_ImproveGoodBonus_Bit)
        {
            value = m_ImproveGoodBonusValue;
        }
        return (m_flags0 & k_Strategy_ImproveGoodBonus_Bit) != 0;
    }
    bool HasImproveSmallCityGrowthBonus() const { return (m_flags0 & k_Strategy_ImproveSmallCityGrowthBonus_Bit) != 0; }
    bool GetImproveSmallCityGrowthBonus(double & value) const
    {
        if (m_flags0 & k_Strategy_ImproveSmallCityGrowthBonus_Bit)
        {
            value = m_ImproveSmallCityGrowthBonusValue;
        }
        return (m_flags0 & k_Strategy_ImproveSmallCityGrowthBonus_Bit) != 0;
    }
    bool HasImproveLargeCityProductionBonus() const { return (m_flags0 & k_Strategy_ImproveLargeCityProductionBonus_Bit) != 0; }
    bool GetImproveLargeCityProductionBonus(double & value) const
    {
        if (m_flags0 & k_Strategy_ImproveLargeCityProductionBonus_Bit)
        {
            value = m_ImproveLargeCityProductionBonusValue;
        }
        return (m_flags0 & k_Strategy_ImproveLargeCityProductionBonus_Bit) != 0;
    }
    sint32           GetImproveGrowthListIndex() const { return m_ImproveGrowthList; }
    ImprovementListRecord const * GetImproveGrowthList() const;
    sint32           GetImproveProductionListIndex() const { return m_ImproveProductionList; }
    ImprovementListRecord const * GetImproveProductionList() const;
    sint32           GetImproveRandomListIndex() const { return m_ImproveRandomList; }
    ImprovementListRecord const * GetImproveRandomList() const;
    const GoalElement * GetGoalElement(sint32 index) const;
    sint32 GetNumGoalElement() const { return m_numGoalElement;}
    bool HasDistanceModifierFactor() const { return (m_flags0 & k_Strategy_DistanceModifierFactor_Bit) != 0; }
    bool GetDistanceModifierFactor(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_DistanceModifierFactor_Bit)
        {
            value = m_DistanceModifierFactorValue;
        }
        return (m_flags0 & k_Strategy_DistanceModifierFactor_Bit) != 0;
    }
    bool HasDisbandArmyCount() const { return (m_flags0 & k_Strategy_DisbandArmyCount_Bit) != 0; }
    bool GetDisbandArmyCount(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_DisbandArmyCount_Bit)
        {
            value = m_DisbandArmyCountValue;
        }
        return (m_flags0 & k_Strategy_DisbandArmyCount_Bit) != 0;
    }
    bool HasMinSettleDistance() const { return (m_flags0 & k_Strategy_MinSettleDistance_Bit) != 0; }
    bool GetMinSettleDistance(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MinSettleDistance_Bit)
        {
            value = m_MinSettleDistanceValue;
        }
        return (m_flags0 & k_Strategy_MinSettleDistance_Bit) != 0;
    }
    bool HasMinSettleScore() const { return (m_flags0 & k_Strategy_MinSettleScore_Bit) != 0; }
    bool GetMinSettleScore(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MinSettleScore_Bit)
        {
            value = m_MinSettleScoreValue;
        }
        return (m_flags0 & k_Strategy_MinSettleScore_Bit) != 0;
    }
    bool HasRushBuyThreatBonus() const { return (m_flags0 & k_Strategy_RushBuyThreatBonus_Bit) != 0; }
    bool GetRushBuyThreatBonus(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_RushBuyThreatBonus_Bit)
        {
            value = m_RushBuyThreatBonusValue;
        }
        return (m_flags0 & k_Strategy_RushBuyThreatBonus_Bit) != 0;
    }
    bool HasRushBuyReservePercent() const { return (m_flags0 & k_Strategy_RushBuyReservePercent_Bit) != 0; }
    bool GetRushBuyReservePercent(double & value) const
    {
        if (m_flags0 & k_Strategy_RushBuyReservePercent_Bit)
        {
            value = m_RushBuyReservePercentValue;
        }
        return (m_flags0 & k_Strategy_RushBuyReservePercent_Bit) != 0;
    }
    bool HasUnitSupportPercent() const { return (m_flags0 & k_Strategy_UnitSupportPercent_Bit) != 0; }
    bool GetUnitSupportPercent(double & value) const
    {
        if (m_flags0 & k_Strategy_UnitSupportPercent_Bit)
        {
            value = m_UnitSupportPercentValue;
        }
        return (m_flags0 & k_Strategy_UnitSupportPercent_Bit) != 0;
    }
    bool HasMaxSettlerBuildTurns() const { return (m_flags0 & k_Strategy_MaxSettlerBuildTurns_Bit) != 0; }
    bool GetMaxSettlerBuildTurns(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MaxSettlerBuildTurns_Bit)
        {
            value = m_MaxSettlerBuildTurnsValue;
        }
        return (m_flags0 & k_Strategy_MaxSettlerBuildTurns_Bit) != 0;
    }
    bool HasMaxUnitBuildTurns() const { return (m_flags0 & k_Strategy_MaxUnitBuildTurns_Bit) != 0; }
    bool GetMaxUnitBuildTurns(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MaxUnitBuildTurns_Bit)
        {
            value = m_MaxUnitBuildTurnsValue;
        }
        return (m_flags0 & k_Strategy_MaxUnitBuildTurns_Bit) != 0;
    }
    bool HasMaxWonderBuildTurns() const { return (m_flags0 & k_Strategy_MaxWonderBuildTurns_Bit) != 0; }
    bool GetMaxWonderBuildTurns(sint32 & value) const
    {
        if (m_flags0 & k_Strategy_MaxWonderBuildTurns_Bit)
        {
            value = m_MaxWonderBuildTurnsValue;
        }
        return (m_flags0 & k_Strategy_MaxWonderBuildTurns_Bit) != 0;
    }
    bool HasBuildTransportProductionLevel() const { return (m_flags0 & k_Strategy_BuildTransportProductionLevel_Bit) != 0; }
    bool GetBuildTransportProductionLevel(double & value) const
    {
        if (m_flags0 & k_Strategy_BuildTransportProductionLevel_Bit)
        {
            value = m_BuildTransportProductionLevelValue;
        }
        return (m_flags0 & k_Strategy_BuildTransportProductionLevel_Bit) != 0;
    }
    bool HasBuildSettlerProductionLevel() const { return (m_flags0 & k_Strategy_BuildSettlerProductionLevel_Bit) != 0; }
    bool GetBuildSettlerProductionLevel(double & value) const
    {
        if (m_flags0 & k_Strategy_BuildSettlerProductionLevel_Bit)
        {
            value = m_BuildSettlerProductionLevelValue;
        }
        return (m_flags0 & k_Strategy_BuildSettlerProductionLevel_Bit) != 0;
    }
    bool HasOffensiveUnitsPercent() const { return (m_flags0 & k_Strategy_OffensiveUnitsPercent_Bit) != 0; }
    bool GetOffensiveUnitsPercent(double & value) const
    {
        if (m_flags0 & k_Strategy_OffensiveUnitsPercent_Bit)
        {
            value = m_OffensiveUnitsPercentValue;
        }
        return (m_flags0 & k_Strategy_OffensiveUnitsPercent_Bit) != 0;
    }
    bool HasDefensiveUnitsPercent() const { return (m_flags0 & k_Strategy_DefensiveUnitsPercent_Bit) != 0; }
    bool GetDefensiveUnitsPercent(double & value) const
    {
        if (m_flags0 & k_Strategy_DefensiveUnitsPercent_Bit)
        {
            value = m_DefensiveUnitsPercentValue;
        }
        return (m_flags0 & k_Strategy_DefensiveUnitsPercent_Bit) != 0;
    }
    bool HasRangedUnitsPercent() const { return (m_flags1 & k_Strategy_RangedUnitsPercent_Bit) != 0; }
    bool GetRangedUnitsPercent(double & value) const
    {
        if (m_flags1 & k_Strategy_RangedUnitsPercent_Bit)
        {
            value = m_RangedUnitsPercentValue;
        }
        return (m_flags1 & k_Strategy_RangedUnitsPercent_Bit) != 0;
    }
    bool HasSeaUnitsPercent() const { return (m_flags1 & k_Strategy_SeaUnitsPercent_Bit) != 0; }
    bool GetSeaUnitsPercent(double & value) const
    {
        if (m_flags1 & k_Strategy_SeaUnitsPercent_Bit)
        {
            value = m_SeaUnitsPercentValue;
        }
        return (m_flags1 & k_Strategy_SeaUnitsPercent_Bit) != 0;
    }
    bool HasAirUnitsPercent() const { return (m_flags1 & k_Strategy_AirUnitsPercent_Bit) != 0; }
    bool GetAirUnitsPercent(double & value) const
    {
        if (m_flags1 & k_Strategy_AirUnitsPercent_Bit)
        {
            value = m_AirUnitsPercentValue;
        }
        return (m_flags1 & k_Strategy_AirUnitsPercent_Bit) != 0;
    }
    bool HasSettlerUnitsCount() const { return (m_flags1 & k_Strategy_SettlerUnitsCount_Bit) != 0; }
    bool GetSettlerUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_SettlerUnitsCount_Bit)
        {
            value = m_SettlerUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_SettlerUnitsCount_Bit) != 0;
    }
    bool HasSpecialUnitsCount() const { return (m_flags1 & k_Strategy_SpecialUnitsCount_Bit) != 0; }
    bool GetSpecialUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_SpecialUnitsCount_Bit)
        {
            value = m_SpecialUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_SpecialUnitsCount_Bit) != 0;
    }
    bool HasSpyUnitsCount() const { return (m_flags1 & k_Strategy_SpyUnitsCount_Bit) != 0; }
    bool GetSpyUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_SpyUnitsCount_Bit)
        {
            value = m_SpyUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_SpyUnitsCount_Bit) != 0;
    }
    bool HasSlaveryUnitsCount() const { return (m_flags1 & k_Strategy_SlaveryUnitsCount_Bit) != 0; }
    bool GetSlaveryUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_SlaveryUnitsCount_Bit)
        {
            value = m_SlaveryUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_SlaveryUnitsCount_Bit) != 0;
    }
    bool HasDiplomatUnitsCount() const { return (m_flags1 & k_Strategy_DiplomatUnitsCount_Bit) != 0; }
    bool GetDiplomatUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_DiplomatUnitsCount_Bit)
        {
            value = m_DiplomatUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_DiplomatUnitsCount_Bit) != 0;
    }
    bool HasMissionaryUnitsCount() const { return (m_flags1 & k_Strategy_MissionaryUnitsCount_Bit) != 0; }
    bool GetMissionaryUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_MissionaryUnitsCount_Bit)
        {
            value = m_MissionaryUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_MissionaryUnitsCount_Bit) != 0;
    }
    bool HasSeaTransportUnitsCount() const { return (m_flags1 & k_Strategy_SeaTransportUnitsCount_Bit) != 0; }
    bool GetSeaTransportUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_SeaTransportUnitsCount_Bit)
        {
            value = m_SeaTransportUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_SeaTransportUnitsCount_Bit) != 0;
    }
    bool HasAirTransportUnitsCount() const { return (m_flags1 & k_Strategy_AirTransportUnitsCount_Bit) != 0; }
    bool GetAirTransportUnitsCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_AirTransportUnitsCount_Bit)
        {
            value = m_AirTransportUnitsCountValue;
        }
        return (m_flags1 & k_Strategy_AirTransportUnitsCount_Bit) != 0;
    }
    bool HasOffensiveUnitList() const { return (m_flags1 & k_Strategy_OffensiveUnitList_Bit) != 0; }
    bool GetOffensiveUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_OffensiveUnitList_Bit) ? m_OffensiveUnitListValue : -1;
        return (m_flags1 & k_Strategy_OffensiveUnitList_Bit) != 0;
    }
    bool GetOffensiveUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetOffensiveUnitListPtr() const;
    bool HasDefensiveUnitList() const { return (m_flags1 & k_Strategy_DefensiveUnitList_Bit) != 0; }
    bool GetDefensiveUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_DefensiveUnitList_Bit) ? m_DefensiveUnitListValue : -1;
        return (m_flags1 & k_Strategy_DefensiveUnitList_Bit) != 0;
    }
    bool GetDefensiveUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetDefensiveUnitListPtr() const;
    bool HasRangedUnitList() const { return (m_flags1 & k_Strategy_RangedUnitList_Bit) != 0; }
    bool GetRangedUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_RangedUnitList_Bit) ? m_RangedUnitListValue : -1;
        return (m_flags1 & k_Strategy_RangedUnitList_Bit) != 0;
    }
    bool GetRangedUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetRangedUnitListPtr() const;
    bool HasSeaUnitList() const { return (m_flags1 & k_Strategy_SeaUnitList_Bit) != 0; }
    bool GetSeaUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_SeaUnitList_Bit) ? m_SeaUnitListValue : -1;
        return (m_flags1 & k_Strategy_SeaUnitList_Bit) != 0;
    }
    bool GetSeaUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetSeaUnitListPtr() const;
    bool HasAirUnitList() const { return (m_flags1 & k_Strategy_AirUnitList_Bit) != 0; }
    bool GetAirUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_AirUnitList_Bit) ? m_AirUnitListValue : -1;
        return (m_flags1 & k_Strategy_AirUnitList_Bit) != 0;
    }
    bool GetAirUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetAirUnitListPtr() const;
    bool HasSettlerUnitList() const { return (m_flags1 & k_Strategy_SettlerUnitList_Bit) != 0; }
    bool GetSettlerUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_SettlerUnitList_Bit) ? m_SettlerUnitListValue : -1;
        return (m_flags1 & k_Strategy_SettlerUnitList_Bit) != 0;
    }
    bool GetSettlerUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetSettlerUnitListPtr() const;
    bool HasSeaSettlerUnitList() const { return (m_flags1 & k_Strategy_SeaSettlerUnitList_Bit) != 0; }
    bool GetSeaSettlerUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_SeaSettlerUnitList_Bit) ? m_SeaSettlerUnitListValue : -1;
        return (m_flags1 & k_Strategy_SeaSettlerUnitList_Bit) != 0;
    }
    bool GetSeaSettlerUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetSeaSettlerUnitListPtr() const;
    bool HasSpecialUnitList() const { return (m_flags1 & k_Strategy_SpecialUnitList_Bit) != 0; }
    bool GetSpecialUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_SpecialUnitList_Bit) ? m_SpecialUnitListValue : -1;
        return (m_flags1 & k_Strategy_SpecialUnitList_Bit) != 0;
    }
    bool GetSpecialUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetSpecialUnitListPtr() const;
    bool HasSpyUnitList() const { return (m_flags1 & k_Strategy_SpyUnitList_Bit) != 0; }
    bool GetSpyUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_SpyUnitList_Bit) ? m_SpyUnitListValue : -1;
        return (m_flags1 & k_Strategy_SpyUnitList_Bit) != 0;
    }
    bool GetSpyUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetSpyUnitListPtr() const;
    bool HasSlaverUnitList() const { return (m_flags1 & k_Strategy_SlaverUnitList_Bit) != 0; }
    bool GetSlaverUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_SlaverUnitList_Bit) ? m_SlaverUnitListValue : -1;
        return (m_flags1 & k_Strategy_SlaverUnitList_Bit) != 0;
    }
    bool GetSlaverUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetSlaverUnitListPtr() const;
    bool HasDiplomatUnitList() const { return (m_flags1 & k_Strategy_DiplomatUnitList_Bit) != 0; }
    bool GetDiplomatUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_DiplomatUnitList_Bit) ? m_DiplomatUnitListValue : -1;
        return (m_flags1 & k_Strategy_DiplomatUnitList_Bit) != 0;
    }
    bool GetDiplomatUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetDiplomatUnitListPtr() const;
    bool HasMissionaryUnitList() const { return (m_flags1 & k_Strategy_MissionaryUnitList_Bit) != 0; }
    bool GetMissionaryUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_MissionaryUnitList_Bit) ? m_MissionaryUnitListValue : -1;
        return (m_flags1 & k_Strategy_MissionaryUnitList_Bit) != 0;
    }
    bool GetMissionaryUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetMissionaryUnitListPtr() const;
    bool HasSeaTransportUnitList() const { return (m_flags1 & k_Strategy_SeaTransportUnitList_Bit) != 0; }
    bool GetSeaTransportUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_SeaTransportUnitList_Bit) ? m_SeaTransportUnitListValue : -1;
        return (m_flags1 & k_Strategy_SeaTransportUnitList_Bit) != 0;
    }
    bool GetSeaTransportUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetSeaTransportUnitListPtr() const;
    bool HasAirTransportUnitList() const { return (m_flags1 & k_Strategy_AirTransportUnitList_Bit) != 0; }
    bool GetAirTransportUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_AirTransportUnitList_Bit) ? m_AirTransportUnitListValue : -1;
        return (m_flags1 & k_Strategy_AirTransportUnitList_Bit) != 0;
    }
    bool GetAirTransportUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetAirTransportUnitListPtr() const;
    bool HasFreightUnitList() const { return (m_flags1 & k_Strategy_FreightUnitList_Bit) != 0; }
    bool GetFreightUnitListIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_FreightUnitList_Bit) ? m_FreightUnitListValue : -1;
        return (m_flags1 & k_Strategy_FreightUnitList_Bit) != 0;
    }
    bool GetFreightUnitList(const UnitBuildListRecord * & rec) const;
    const UnitBuildListRecord * GetFreightUnitListPtr() const;
    bool HasOffensiveGarrisonCount() const { return (m_flags1 & k_Strategy_OffensiveGarrisonCount_Bit) != 0; }
    bool GetOffensiveGarrisonCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_OffensiveGarrisonCount_Bit)
        {
            value = m_OffensiveGarrisonCountValue;
        }
        return (m_flags1 & k_Strategy_OffensiveGarrisonCount_Bit) != 0;
    }
    bool HasDefensiveGarrisonCount() const { return (m_flags1 & k_Strategy_DefensiveGarrisonCount_Bit) != 0; }
    bool GetDefensiveGarrisonCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_DefensiveGarrisonCount_Bit)
        {
            value = m_DefensiveGarrisonCountValue;
        }
        return (m_flags1 & k_Strategy_DefensiveGarrisonCount_Bit) != 0;
    }
    bool HasRangedGarrisonCount() const { return (m_flags1 & k_Strategy_RangedGarrisonCount_Bit) != 0; }
    bool GetRangedGarrisonCount(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_RangedGarrisonCount_Bit)
        {
            value = m_RangedGarrisonCountValue;
        }
        return (m_flags1 & k_Strategy_RangedGarrisonCount_Bit) != 0;
    }
    const BuildListSequenceElement * GetBuildListSequenceElement(sint32 index) const;
    sint32 GetNumBuildListSequenceElement() const { return m_numBuildListSequenceElement;}
    bool HasResearch() const { return (m_flags1 & k_Strategy_Research_Bit) != 0; }
    bool GetResearchIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_Research_Bit) ? m_ResearchValue : -1;
        return (m_flags1 & k_Strategy_Research_Bit) != 0;
    }
    bool GetResearch(const AdvanceListRecord * & rec) const;
    const AdvanceListRecord * GetResearchPtr() const;
    bool HasStopResearch() const { return (m_flags1 & k_Strategy_StopResearch_Bit) != 0; }
    bool GetStopResearchIndex(sint32 & index) const
    {
        index = (m_flags1 & k_Strategy_StopResearch_Bit) ? m_StopResearchValue : -1;
        return (m_flags1 & k_Strategy_StopResearch_Bit) != 0;
    }
    bool GetStopResearch(const AdvanceListRecord * & rec) const;
    const AdvanceListRecord * GetStopResearchPtr() const;
    bool HasFearInvasion() const { return (m_flags1 & k_Strategy_FearInvasion_Bit) != 0; }
    bool GetFearInvasion(sint32 & value) const
    {
        if (m_flags1 & k_Strategy_FearInvasion_Bit)
        {
            value = m_FearInvasionValue;
        }
        return (m_flags1 & k_Strategy_FearInvasion_Bit) != 0;
    }
    bool HasFearCityDefense() const { return (m_flags2 & k_Strategy_FearCityDefense_Bit) != 0; }
    bool GetFearCityDefense(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_FearCityDefense_Bit)
        {
            value = m_FearCityDefenseValue;
        }
        return (m_flags2 & k_Strategy_FearCityDefense_Bit) != 0;
    }
    bool HasFearPiracy() const { return (m_flags2 & k_Strategy_FearPiracy_Bit) != 0; }
    bool GetFearPiracy(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_FearPiracy_Bit)
        {
            value = m_FearPiracyValue;
        }
        return (m_flags2 & k_Strategy_FearPiracy_Bit) != 0;
    }
    bool HasFearScienceRank() const { return (m_flags2 & k_Strategy_FearScienceRank_Bit) != 0; }
    bool GetFearScienceRank(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_FearScienceRank_Bit)
        {
            value = m_FearScienceRankValue;
        }
        return (m_flags2 & k_Strategy_FearScienceRank_Bit) != 0;
    }
    bool HasFearMilitaryRank() const { return (m_flags2 & k_Strategy_FearMilitaryRank_Bit) != 0; }
    bool GetFearMilitaryRank(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_FearMilitaryRank_Bit)
        {
            value = m_FearMilitaryRankValue;
        }
        return (m_flags2 & k_Strategy_FearMilitaryRank_Bit) != 0;
    }
    bool HasFearTradeRank() const { return (m_flags2 & k_Strategy_FearTradeRank_Bit) != 0; }
    bool GetFearTradeRank(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_FearTradeRank_Bit)
        {
            value = m_FearTradeRankValue;
        }
        return (m_flags2 & k_Strategy_FearTradeRank_Bit) != 0;
    }
    bool HasFearPollution() const { return (m_flags2 & k_Strategy_FearPollution_Bit) != 0; }
    bool GetFearPollution(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_FearPollution_Bit)
        {
            value = m_FearPollutionValue;
        }
        return (m_flags2 & k_Strategy_FearPollution_Bit) != 0;
    }
    bool HasDesireAttack() const { return (m_flags2 & k_Strategy_DesireAttack_Bit) != 0; }
    bool GetDesireAttack(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_DesireAttack_Bit)
        {
            value = m_DesireAttackValue;
        }
        return (m_flags2 & k_Strategy_DesireAttack_Bit) != 0;
    }
    bool HasDesireGold() const { return (m_flags2 & k_Strategy_DesireGold_Bit) != 0; }
    bool GetDesireGold(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_DesireGold_Bit)
        {
            value = m_DesireGoldValue;
        }
        return (m_flags2 & k_Strategy_DesireGold_Bit) != 0;
    }
    bool HasDesireScience() const { return (m_flags2 & k_Strategy_DesireScience_Bit) != 0; }
    bool GetDesireScience(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_DesireScience_Bit)
        {
            value = m_DesireScienceValue;
        }
        return (m_flags2 & k_Strategy_DesireScience_Bit) != 0;
    }
    bool HasDesireMakeFriend() const { return (m_flags2 & k_Strategy_DesireMakeFriend_Bit) != 0; }
    bool GetDesireMakeFriend(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_DesireMakeFriend_Bit)
        {
            value = m_DesireMakeFriendValue;
        }
        return (m_flags2 & k_Strategy_DesireMakeFriend_Bit) != 0;
    }
    bool HasDesireEnlistFriend() const { return (m_flags2 & k_Strategy_DesireEnlistFriend_Bit) != 0; }
    bool GetDesireEnlistFriend(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_DesireEnlistFriend_Bit)
        {
            value = m_DesireEnlistFriendValue;
        }
        return (m_flags2 & k_Strategy_DesireEnlistFriend_Bit) != 0;
    }
    bool HasPiracyMemoryTurns() const { return (m_flags2 & k_Strategy_PiracyMemoryTurns_Bit) != 0; }
    bool GetPiracyMemoryTurns(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_PiracyMemoryTurns_Bit)
        {
            value = m_PiracyMemoryTurnsValue;
        }
        return (m_flags2 & k_Strategy_PiracyMemoryTurns_Bit) != 0;
    }
    bool HasMaxPiracyEvents() const { return (m_flags2 & k_Strategy_MaxPiracyEvents_Bit) != 0; }
    bool GetMaxPiracyEvents(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_MaxPiracyEvents_Bit)
        {
            value = m_MaxPiracyEventsValue;
        }
        return (m_flags2 & k_Strategy_MaxPiracyEvents_Bit) != 0;
    }
    bool HasOffensive() const { return (m_flags2 & k_Strategy_Offensive_Bit) != 0; }
    bool GetOffensive(const ForceMatch *&ptr) const
    {
        ptr = (m_flags2 & k_Strategy_Offensive_Bit) ? &m_OffensiveValue : NULL;
        return (m_flags2 & k_Strategy_Offensive_Bit) != 0;
    }
    const ForceMatch * GetOffensivePtr() const
    {
        return (m_flags2 & k_Strategy_Offensive_Bit) ? &m_OffensiveValue : NULL;
    }
    bool HasDefensive() const { return (m_flags2 & k_Strategy_Defensive_Bit) != 0; }
    bool GetDefensive(const ForceMatch *&ptr) const
    {
        ptr = (m_flags2 & k_Strategy_Defensive_Bit) ? &m_DefensiveValue : NULL;
        return (m_flags2 & k_Strategy_Defensive_Bit) != 0;
    }
    const ForceMatch * GetDefensivePtr() const
    {
        return (m_flags2 & k_Strategy_Defensive_Bit) ? &m_DefensiveValue : NULL;
    }
    bool HasStealthAttack() const { return (m_flags2 & k_Strategy_StealthAttack_Bit) != 0; }
    bool GetStealthAttack(const ForceMatch *&ptr) const
    {
        ptr = (m_flags2 & k_Strategy_StealthAttack_Bit) ? &m_StealthAttackValue : NULL;
        return (m_flags2 & k_Strategy_StealthAttack_Bit) != 0;
    }
    const ForceMatch * GetStealthAttackPtr() const
    {
        return (m_flags2 & k_Strategy_StealthAttack_Bit) ? &m_StealthAttackValue : NULL;
    }
    bool HasBombard() const { return (m_flags2 & k_Strategy_Bombard_Bit) != 0; }
    bool GetBombard(const ForceMatch *&ptr) const
    {
        ptr = (m_flags2 & k_Strategy_Bombard_Bit) ? &m_BombardValue : NULL;
        return (m_flags2 & k_Strategy_Bombard_Bit) != 0;
    }
    const ForceMatch * GetBombardPtr() const
    {
        return (m_flags2 & k_Strategy_Bombard_Bit) ? &m_BombardValue : NULL;
    }
    bool HasSpecial() const { return (m_flags2 & k_Strategy_Special_Bit) != 0; }
    bool GetSpecial(const ForceMatch *&ptr) const
    {
        ptr = (m_flags2 & k_Strategy_Special_Bit) ? &m_SpecialValue : NULL;
        return (m_flags2 & k_Strategy_Special_Bit) != 0;
    }
    const ForceMatch * GetSpecialPtr() const
    {
        return (m_flags2 & k_Strategy_Special_Bit) ? &m_SpecialValue : NULL;
    }
    bool HasHarass() const { return (m_flags2 & k_Strategy_Harass_Bit) != 0; }
    bool GetHarass(const ForceMatch *&ptr) const
    {
        ptr = (m_flags2 & k_Strategy_Harass_Bit) ? &m_HarassValue : NULL;
        return (m_flags2 & k_Strategy_Harass_Bit) != 0;
    }
    const ForceMatch * GetHarassPtr() const
    {
        return (m_flags2 & k_Strategy_Harass_Bit) ? &m_HarassValue : NULL;
    }
    uint32           GetNuclearFirstStrike() const { return m_NuclearFirstStrike; }
    bool             GetNuclearFirstStrikeEnabled() const { return (m_NuclearFirstStrike & k_Strategy_NuclearFirstStrike_Enabled_Bit) != 0; }
    bool             GetNuclearFirstStrikeDisabled() const { return (m_NuclearFirstStrike & k_Strategy_NuclearFirstStrike_Disabled_Bit) != 0; }
    uint32           GetNuclearTargeting() const { return m_NuclearTargeting; }
    bool             GetNuclearTargetingEnabled() const { return (m_NuclearTargeting & k_Strategy_NuclearTargeting_Enabled_Bit) != 0; }
    bool             GetNuclearTargetingDisabled() const { return (m_NuclearTargeting & k_Strategy_NuclearTargeting_Disabled_Bit) != 0; }
    bool HasPreemptiveStrikeRegard() const { return (m_flags2 & k_Strategy_PreemptiveStrikeRegard_Bit) != 0; }
    bool GetPreemptiveStrikeRegard(sint32 & value) const
    {
        if (m_flags2 & k_Strategy_PreemptiveStrikeRegard_Bit)
        {
            value = m_PreemptiveStrikeRegardValue;
        }
        return (m_flags2 & k_Strategy_PreemptiveStrikeRegard_Bit) != 0;
    }
    bool HasPreemptiveStrikeRiskRatio() const { return (m_flags2 & k_Strategy_PreemptiveStrikeRiskRatio_Bit) != 0; }
    bool GetPreemptiveStrikeRiskRatio(double & value) const
    {
        if (m_flags2 & k_Strategy_PreemptiveStrikeRiskRatio_Bit)
        {
            value = m_PreemptiveStrikeRiskRatioValue;
        }
        return (m_flags2 & k_Strategy_PreemptiveStrikeRiskRatio_Bit) != 0;
    }
    bool HasPreemptiveStrikeSuperiorityRatio() const { return (m_flags2 & k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit) != 0; }
    bool GetPreemptiveStrikeSuperiorityRatio(double & value) const
    {
        if (m_flags2 & k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit)
        {
            value = m_PreemptiveStrikeSuperiorityRatioValue;
        }
        return (m_flags2 & k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit) != 0;
    }
    bool HasTurnsAcceptedForOnePop() const { return (m_flags2 & k_Strategy_TurnsAcceptedForOnePop_Bit) != 0; }
    sint32 GetTurnsAcceptedForOnePop() const { return m_TurnsAcceptedForOnePopValue; }
    bool HasStopBuildingFoodBeforePopMax() const { return (m_flags2 & k_Strategy_StopBuildingFoodBeforePopMax_Bit) != 0; }
    sint32 GetStopBuildingFoodBeforePopMax() const { return m_StopBuildingFoodBeforePopMaxValue; }
    bool HasRoadAlreadyThereCostsCoefficient() const { return (m_flags2 & k_Strategy_RoadAlreadyThereCostsCoefficient_Bit) != 0; }
    double GetRoadAlreadyThereCostsCoefficient() const { return m_RoadAlreadyThereCostsCoefficientValue; }
    bool HasUseBaseMoveCostsForRoads() const { return (m_flags2 & k_Strategy_UseBaseMoveCostsForRoads_Bit) != 0; }
    sint32 GetUseBaseMoveCostsForRoads() const { return m_UseBaseMoveCostsForRoadsValue; }
    bool HasBuildRoadsToClosestCities() const { return (m_flags2 & k_Strategy_BuildRoadsToClosestCities_Bit) != 0; }
    sint32 GetBuildRoadsToClosestCities() const { return m_BuildRoadsToClosestCitiesValue; }
    bool HasBaseRoadPriorityVsThreatRank() const { return (m_flags2 & k_Strategy_BaseRoadPriorityVsThreatRank_Bit) != 0; }
    double GetBaseRoadPriorityVsThreatRank() const { return m_BaseRoadPriorityVsThreatRankValue; }
    bool HasSmallCityImproveCoeff() const { return (m_flags2 & k_Strategy_SmallCityImproveCoeff_Bit) != 0; }
    double GetSmallCityImproveCoeff() const { return m_SmallCityImproveCoeffValue; }
    bool GetHasGovernmentsModified() const { return m_hasGovernmentsModified; }
    sint32 GenericGetNumGovernmentsModified() const { return 0; }
    sint32 GenericGetGovernmentsModifiedIndex(sint32 index) const { return -1; }

}; /* StrategyRecord */

struct StrategyRecordAccessorInfo
{
    StrategyRecord::IntAccessor        m_intAccessor;
    StrategyRecord::BoolAccessor       m_boolAccessor;
    StrategyRecord::FloatAccessor      m_floatAccessor;
    StrategyRecord::BitIntAccessor     m_bitIntAccessor;
    StrategyRecord::BitFloatAccessor   m_bitFloatAccessor;
    StrategyRecord::IntArrayAccessor   m_intArrayAccessor;
    StrategyRecord::FloatArrayAccessor m_floatArrayAccessor;
};

extern StrategyRecordAccessorInfo      g_StrategyRecord_Accessors[];
extern CTPDatabase<StrategyRecord> *   g_theStrategyDB;

extern const char * g_Strategy_Tokens[];

#endif
