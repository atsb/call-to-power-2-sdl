
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */

#if defined(HAVE_PRAGMA_ONCE)
#pragma once
#endif

#ifndef BUILDLISTSEQUENCE_RECORD_H__
#define BUILDLISTSEQUENCE_RECORD_H__

class BuildListSequenceRecord;

#include "CTPDatabase.h"
#include "CTPRecord.h"
class CivArchive;
class WonderBuildListRecord;
class BuildingBuildListRecord;

#define k_Num_BuildListSequenceRecord_Tokens 1

//
// m_flags0: BuildListElement
#define k_BuildListElement_WonderBuildList_Bit   0x00000001
#define k_BuildListElement_BuildingBuildList_Bit 0x00000002
#define k_BuildListElement_AllUnitBuildList_Bit  0x00000004
#define k_BuildListElement_GarrisonUnitBuildList_Bit 0x00000008
#define k_BuildListElement_Capitalization_Bit    0x00000010
#define k_BuildListElement_Infrastructure_Bit    0x00000020
#define k_BuildListElement_Freight_Bit           0x00000040

class BuildListSequenceRecord : public CTPRecord
{
public:
    typedef sint32 (BuildListSequenceRecord::*IntAccessor)() const;
    typedef bool   (BuildListSequenceRecord::*BoolAccessor)() const;
    typedef double (BuildListSequenceRecord::*FloatAccessor)() const ;
    typedef bool   (BuildListSequenceRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool   (BuildListSequenceRecord::*BitFloatAccessor)(double &val) const;
    typedef sint32 (BuildListSequenceRecord::*IntArrayAccessor)(sint32 index) const;
    typedef double (BuildListSequenceRecord::*FloatArrayAccessor)(sint32 index) const;

    class BuildListElement {
    private:
        uint32            m_flags0;
        sint32            m_WonderBuildListValue; // Index into WonderBuildList database
        sint32            m_BuildingBuildListValue; // Index into BuildingBuildList database

    public:
        BuildListElement();
        BuildListElement(CivArchive & archive){ Serialize(archive); };
        ~BuildListElement();
        BuildListElement const & operator = (BuildListElement const & rval);
        bool operator == (BuildListElement const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, BuildListElement **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, BuildListElement *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        bool HasWonderBuildList() const { return (m_flags0 & k_BuildListElement_WonderBuildList_Bit) != 0; }
        bool GetWonderBuildListIndex(sint32 & index) const
        {
            index = (m_flags0 & k_BuildListElement_WonderBuildList_Bit) ? m_WonderBuildListValue : -1;
            return (m_flags0 & k_BuildListElement_WonderBuildList_Bit) != 0;
        }
        bool GetWonderBuildList(const WonderBuildListRecord * & rec) const;
        const WonderBuildListRecord * GetWonderBuildListPtr() const;
        bool HasBuildingBuildList() const { return (m_flags0 & k_BuildListElement_BuildingBuildList_Bit) != 0; }
        bool GetBuildingBuildListIndex(sint32 & index) const
        {
            index = (m_flags0 & k_BuildListElement_BuildingBuildList_Bit) ? m_BuildingBuildListValue : -1;
            return (m_flags0 & k_BuildListElement_BuildingBuildList_Bit) != 0;
        }
        bool GetBuildingBuildList(const BuildingBuildListRecord * & rec) const;
        const BuildingBuildListRecord * GetBuildingBuildListPtr() const;
        bool GetAllUnitBuildList() const { return (m_flags0 & k_BuildListElement_AllUnitBuildList_Bit) != 0; }
        bool GetGarrisonUnitBuildList() const { return (m_flags0 & k_BuildListElement_GarrisonUnitBuildList_Bit) != 0; }
        bool GetCapitalization() const { return (m_flags0 & k_BuildListElement_Capitalization_Bit) != 0; }
        bool GetInfrastructure() const { return (m_flags0 & k_BuildListElement_Infrastructure_Bit) != 0; }
        bool GetFreight() const { return (m_flags0 & k_BuildListElement_Freight_Bit) != 0; }

    }; /* class BuildListElement */

private:
    BuildListElement * m_BuildListElement;
    sint32            m_numBuildListElement;
    bool m_hasGovernmentsModified; // GovMod specific flag

public:
    BuildListSequenceRecord() { Init(); };
    BuildListSequenceRecord(CivArchive &archive) { Serialize(archive); };
    BuildListSequenceRecord(BuildListSequenceRecord const & rval) { Init(); *this = rval; }
    ~BuildListSequenceRecord();
    BuildListSequenceRecord const & operator = (BuildListSequenceRecord const & rval);

    void Init();
    void Serialize(CivArchive &archive);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex, sint32 numRecords);

    void ResolveDBReferences();
    void Merge(const BuildListSequenceRecord & rval);

    const BuildListElement * GetBuildListElement(sint32 index) const;
    sint32 GetNumBuildListElement() const { return m_numBuildListElement;}
    bool GetHasGovernmentsModified() const { return m_hasGovernmentsModified; }
    sint32 GenericGetNumGovernmentsModified() const { return 0; }
    sint32 GenericGetGovernmentsModifiedIndex(sint32 index) const { return -1; }

}; /* BuildListSequenceRecord */

struct BuildListSequenceRecordAccessorInfo
{
    BuildListSequenceRecord::IntAccessor        m_intAccessor;
    BuildListSequenceRecord::BoolAccessor       m_boolAccessor;
    BuildListSequenceRecord::FloatAccessor      m_floatAccessor;
    BuildListSequenceRecord::BitIntAccessor     m_bitIntAccessor;
    BuildListSequenceRecord::BitFloatAccessor   m_bitFloatAccessor;
    BuildListSequenceRecord::IntArrayAccessor   m_intArrayAccessor;
    BuildListSequenceRecord::FloatArrayAccessor m_floatArrayAccessor;
};

extern BuildListSequenceRecordAccessorInfo      g_BuildListSequenceRecord_Accessors[];
extern CTPDatabase<BuildListSequenceRecord> *   g_theBuildListSequenceDB;

extern const char * g_BuildListSequence_Tokens[];

#endif
