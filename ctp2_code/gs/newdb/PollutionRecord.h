
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */

#if defined(HAVE_PRAGMA_ONCE)
#pragma once
#endif

#ifndef POLLUTION_RECORD_H__
#define POLLUTION_RECORD_H__

class PollutionRecord;

#include "CTPDatabase.h"
#include "CTPRecord.h"
class CivArchive;

#define k_Num_PollutionRecord_Tokens 1

//
// m_flags0: Phase
#define k_Phase_OzoneDisaster_Bit                0x00000001
#define k_Phase_FloodDisaster_Bit                0x00000002
#define k_Phase_Warning_Bit                      0x00000004

class PollutionRecord : public CTPRecord
{
public:
    typedef sint32 (PollutionRecord::*IntAccessor)() const;
    typedef bool   (PollutionRecord::*BoolAccessor)() const;
    typedef double (PollutionRecord::*FloatAccessor)() const ;
    typedef bool   (PollutionRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool   (PollutionRecord::*BitFloatAccessor)(double &val) const;
    typedef sint32 (PollutionRecord::*IntArrayAccessor)(sint32 index) const;
    typedef double (PollutionRecord::*FloatArrayAccessor)(sint32 index) const;

    class Phase {
    private:
        uint32            m_flags0;
        sint32            m_PollutionTrigger;

    public:
        Phase();
        Phase(CivArchive & archive){ Serialize(archive); };
        ~Phase();
        Phase const & operator = (Phase const & rval);
        bool operator == (Phase const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseNum(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, Phase **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, Phase *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        sint32 GetPollutionTrigger() const { return m_PollutionTrigger; }
        bool GetOzoneDisaster() const { return (m_flags0 & k_Phase_OzoneDisaster_Bit) != 0; }
        bool GetFloodDisaster() const { return (m_flags0 & k_Phase_FloodDisaster_Bit) != 0; }
        bool GetWarning() const { return (m_flags0 & k_Phase_Warning_Bit) != 0; }

    }; /* class Phase */

private:
    Phase           * m_Phase;
    sint32            m_numPhase;
    bool m_hasGovernmentsModified; // GovMod specific flag

public:
    PollutionRecord() { Init(); };
    PollutionRecord(CivArchive &archive) { Serialize(archive); };
    PollutionRecord(PollutionRecord const & rval) { Init(); *this = rval; }
    ~PollutionRecord();
    PollutionRecord const & operator = (PollutionRecord const & rval);

    void Init();
    void Serialize(CivArchive &archive);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex, sint32 numRecords);

    void ResolveDBReferences();
    void Merge(const PollutionRecord & rval);

    const Phase * GetPhase(sint32 index) const;
    sint32 GetNumPhase() const { return m_numPhase;}
    bool GetHasGovernmentsModified() const { return m_hasGovernmentsModified; }
    sint32 GenericGetNumGovernmentsModified() const { return 0; }
    sint32 GenericGetGovernmentsModifiedIndex(sint32 index) const { return -1; }

}; /* PollutionRecord */

struct PollutionRecordAccessorInfo
{
    PollutionRecord::IntAccessor        m_intAccessor;
    PollutionRecord::BoolAccessor       m_boolAccessor;
    PollutionRecord::FloatAccessor      m_floatAccessor;
    PollutionRecord::BitIntAccessor     m_bitIntAccessor;
    PollutionRecord::BitFloatAccessor   m_bitFloatAccessor;
    PollutionRecord::IntArrayAccessor   m_intArrayAccessor;
    PollutionRecord::FloatArrayAccessor m_floatArrayAccessor;
};

extern PollutionRecordAccessorInfo      g_PollutionRecord_Accessors[];
extern CTPDatabase<PollutionRecord> *   g_thePollutionDB;

extern const char * g_Pollution_Tokens[];

#endif
