
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "WonderRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "IconRecord.h"
#include "WonderMovieRecord.h"
#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "BuildingRecord.h"
#include "GovernmentRecord.h"
#include "CityStyleRecord.h"
#include "GovernmentRecord.h"
#include "GovernmentRecord.h"
#include "CityStyleRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "TerrainImprovementRecord.h"
#include "TerrainImprovementRecord.h"
#include "CivilisationRecord.h"
#include "FeatRecord.h"
#include "FeatRecord.h"
#include "MapIconRecord.h"
#include "MapIconRecord.h"
#include "MapIconRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"

CTPDatabase<WonderRecord> *g_theWonderDB = NULL;

void WonderRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    m_ProductionCost = 0;
    m_DefaultIcon = 0x7fffffff;
    m_Movie = 0x7fffffff;
    m_Description = 0;
    m_EnableAdvance = 0x7fffffff;
    memset(m_ObsoleteAdvance, 0, sizeof(m_ObsoleteAdvance));
    m_numObsoleteAdvance = 0;
    m_PrerequisiteBuilding = NULL;
    m_numPrerequisiteBuilding = 0;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    m_ObsoleteGovernmentType = NULL;
    m_numObsoleteGovernmentType = 0;
    m_CityStyleOnly = NULL;
    m_numCityStyleOnly = 0;
    m_NeedsCityGood = NULL;
    m_numNeedsCityGood = 0;
    m_NeedsCityGoodAll = NULL;
    m_numNeedsCityGoodAll = 0;
    m_NeedsCityGoodAnyCity = NULL;
    m_numNeedsCityGoodAnyCity = 0;
    m_EnablesGood = NULL;
    m_numEnablesGood = 0;
    m_ShowOnMap = NULL;
    m_numShowOnMap = 0;
    m_ShowOnMapRadius = NULL;
    m_numShowOnMapRadius = 0;
    m_CivilisationOnly = NULL;
    m_numCivilisationOnly = 0;
    m_NeedsFeatToBuild = NULL;
    m_numNeedsFeatToBuild = 0;
    m_NeedsAnyPlayerFeatToBuild = NULL;
    m_numNeedsAnyPlayerFeatToBuild = 0;
    m_ShowCityIconTopValue = 0;
    m_ShowCityIconBottomValue = 0;
    m_SquaredBorderRadiusValue = 0;
    m_IntBorderRadiusValue = 0;
    m_IsReligionIconValue = 0;
    m_ReduceReadinessCostValue = 0;
    m_DecCrimePercentValue = 0;
    m_IncKnowledgePercentValue = 0;
    m_DecEmpireSizeValue = 0;
    m_IncHappinessEmpireValue = 0;
    m_IncConvertedCitiesFeePercentValue = 0;
    m_GoldPerWaterTradeRouteValue = 0;
    m_GoldPerTelevisionValue = 0;
    m_GoldPerInternationalTradeRouteValue = 0;
    m_PollutersToParksValue = 0;
    m_ReduceWorldPollutionValue = 0;
    m_IncreaseBoatMovementValue = 0;
    m_DecreaseMaintenanceValue = 0;
    m_RandomAdvanceChanceValue = 0;
    m_IncreaseHpValue = 0;
    m_MultiplyTradeRoutesValue = 0;
    m_IncreaseScientistsValue = 0;
    m_OtherCivRandomAdvanceChanceValue = 0;
    m_IncreaseProductionValue = 0;
    m_BonusGoldValue = 0;
    m_IncreaseFoodAllCitiesValue = 0;
    m_TemporaryFullHappinessValue = 0;
    m_IncreaseSpecialistsValue = 0;
    m_IncreaseCathedralsValue = 0;
    m_IncreaseBrokeragesValue = 0;
    m_IncreaseRegardValue = 0;
    memset(&m_BuildingFeatValue, 0, sizeof(m_BuildingFeatValue));
    memset(&m_BuildingGoldValue, 0, sizeof(m_BuildingGoldValue));
    m_BuildingEverywhereValue = 0;
    m_ActualBuildingEverywhereValue = 0;
    m_BuildingEffectEverywhereValue = 0;
    m_ConflictsWithBuildingValue = 0;
    m_BuildingAnywhere = NULL;
    m_numBuildingAnywhere = 0;
    m_GoldPerBuildingAnywhereValue = 0;
    m_PollutionPercentValue = 0.000000;
    m_PollutionAmountValue = 0.000000;
    m_ExcludedByBuilding = NULL;
    m_numExcludedByBuilding = 0;
    m_ExcludedByWonder = NULL;
    m_numExcludedByWonder = 0;
    m_EnergyHungerValue = 0;
    m_ProducesEnergyValue = 0;
    m_EnergyHungerPerPopValue = 0;
    m_ProducesEnergyPerPopValue = 0;
    m_TooManyCitiesThresholdModifierValue = 0;
    m_TooManyCitiesCoefficientModifierValue = 0.000000;
    m_RiotLevelModifierValue = 0;
    m_OtherPlayerRiotLevelModifierValue = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void WonderRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_flags1;
        archive << m_flags2;
        archive << m_ProductionCost;
        archive << m_DefaultIcon;
        archive << m_Movie;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Description);
            archive << tmpString;
        }

        archive << m_EnableAdvance;
        archive << m_numObsoleteAdvance;
        archive.Store((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive << m_numPrerequisiteBuilding;
        archive.Store((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_numGovernmentType;
        archive.Store((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive << m_numObsoleteGovernmentType;
        archive.Store((uint8*)m_ObsoleteGovernmentType, m_numObsoleteGovernmentType * sizeof(sint32));

        archive << m_numCityStyleOnly;
        archive.Store((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive << m_numNeedsCityGood;
        archive.Store((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive << m_numNeedsCityGoodAll;
        archive.Store((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive << m_numNeedsCityGoodAnyCity;
        archive.Store((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive << m_numEnablesGood;
        archive.Store((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive << m_numShowOnMap;
        archive.Store((uint8*)m_ShowOnMap, m_numShowOnMap * sizeof(sint32));

        archive << m_numShowOnMapRadius;
        archive.Store((uint8*)m_ShowOnMapRadius, m_numShowOnMapRadius * sizeof(sint32));

        archive << m_numCivilisationOnly;
        archive.Store((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive << m_numNeedsFeatToBuild;
        archive.Store((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive << m_numNeedsAnyPlayerFeatToBuild;
        archive.Store((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive << m_ShowCityIconTopValue;
        archive << m_ShowCityIconBottomValue;
        archive << m_SquaredBorderRadiusValue;
        archive << m_IntBorderRadiusValue;
        archive << m_IsReligionIconValue;
        archive << m_ReduceReadinessCostValue;
        archive << m_DecCrimePercentValue;
        archive << m_IncKnowledgePercentValue;
        archive << m_DecEmpireSizeValue;
        archive << m_IncHappinessEmpireValue;
        archive << m_IncConvertedCitiesFeePercentValue;
        archive << m_GoldPerWaterTradeRouteValue;
        archive << m_GoldPerTelevisionValue;
        archive << m_GoldPerInternationalTradeRouteValue;
        archive << m_PollutersToParksValue;
        archive << m_ReduceWorldPollutionValue;
        archive << m_IncreaseBoatMovementValue;
        archive << m_DecreaseMaintenanceValue;
        archive << m_RandomAdvanceChanceValue;
        archive << m_IncreaseHpValue;
        archive << m_MultiplyTradeRoutesValue;
        archive << m_IncreaseScientistsValue;
        archive << m_OtherCivRandomAdvanceChanceValue;
        archive << m_IncreaseProductionValue;
        archive << m_BonusGoldValue;
        archive << m_IncreaseFoodAllCitiesValue;
        archive << m_TemporaryFullHappinessValue;
        archive << m_IncreaseSpecialistsValue;
        archive << m_IncreaseCathedralsValue;
        archive << m_IncreaseBrokeragesValue;
        archive << m_IncreaseRegardValue;
        m_BuildingFeatValue.Serialize(archive);
        m_BuildingGoldValue.Serialize(archive);
        archive << m_BuildingEverywhereValue;
        archive << m_ActualBuildingEverywhereValue;
        archive << m_BuildingEffectEverywhereValue;
        archive << m_ConflictsWithBuildingValue;
        archive << m_numBuildingAnywhere;
        archive.Store((uint8*)m_BuildingAnywhere, m_numBuildingAnywhere * sizeof(sint32));

        archive << m_GoldPerBuildingAnywhereValue;
        archive << m_PollutionPercentValue;
        archive << m_PollutionAmountValue;
        archive << m_numExcludedByBuilding;
        archive.Store((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive << m_numExcludedByWonder;
        archive.Store((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive << m_EnergyHungerValue;
        archive << m_ProducesEnergyValue;
        archive << m_EnergyHungerPerPopValue;
        archive << m_ProducesEnergyPerPopValue;
        archive << m_TooManyCitiesThresholdModifierValue;
        archive << m_TooManyCitiesCoefficientModifierValue;
        archive << m_RiotLevelModifierValue;
        archive << m_OtherPlayerRiotLevelModifierValue;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_flags2;
        archive >> m_ProductionCost;
        archive >> m_DefaultIcon;
        archive >> m_Movie;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Description);
            delete[] tmpString;
        }

        archive >> m_EnableAdvance;
        archive >> m_numObsoleteAdvance;
        archive.Load((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive >> m_numPrerequisiteBuilding;
        archive.Load((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_numGovernmentType;
        archive.Load((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive >> m_numObsoleteGovernmentType;
        archive.Load((uint8*)m_ObsoleteGovernmentType, m_numObsoleteGovernmentType * sizeof(sint32));

        archive >> m_numCityStyleOnly;
        archive.Load((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive >> m_numNeedsCityGood;
        archive.Load((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive >> m_numNeedsCityGoodAll;
        archive.Load((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive >> m_numNeedsCityGoodAnyCity;
        archive.Load((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive >> m_numEnablesGood;
        archive.Load((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive >> m_numShowOnMap;
        archive.Load((uint8*)m_ShowOnMap, m_numShowOnMap * sizeof(sint32));

        archive >> m_numShowOnMapRadius;
        archive.Load((uint8*)m_ShowOnMapRadius, m_numShowOnMapRadius * sizeof(sint32));

        archive >> m_numCivilisationOnly;
        archive.Load((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive >> m_numNeedsFeatToBuild;
        archive.Load((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive >> m_numNeedsAnyPlayerFeatToBuild;
        archive.Load((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive >> m_ShowCityIconTopValue;
        archive >> m_ShowCityIconBottomValue;
        archive >> m_SquaredBorderRadiusValue;
        archive >> m_IntBorderRadiusValue;
        archive >> m_IsReligionIconValue;
        archive >> m_ReduceReadinessCostValue;
        archive >> m_DecCrimePercentValue;
        archive >> m_IncKnowledgePercentValue;
        archive >> m_DecEmpireSizeValue;
        archive >> m_IncHappinessEmpireValue;
        archive >> m_IncConvertedCitiesFeePercentValue;
        archive >> m_GoldPerWaterTradeRouteValue;
        archive >> m_GoldPerTelevisionValue;
        archive >> m_GoldPerInternationalTradeRouteValue;
        archive >> m_PollutersToParksValue;
        archive >> m_ReduceWorldPollutionValue;
        archive >> m_IncreaseBoatMovementValue;
        archive >> m_DecreaseMaintenanceValue;
        archive >> m_RandomAdvanceChanceValue;
        archive >> m_IncreaseHpValue;
        archive >> m_MultiplyTradeRoutesValue;
        archive >> m_IncreaseScientistsValue;
        archive >> m_OtherCivRandomAdvanceChanceValue;
        archive >> m_IncreaseProductionValue;
        archive >> m_BonusGoldValue;
        archive >> m_IncreaseFoodAllCitiesValue;
        archive >> m_TemporaryFullHappinessValue;
        archive >> m_IncreaseSpecialistsValue;
        archive >> m_IncreaseCathedralsValue;
        archive >> m_IncreaseBrokeragesValue;
        archive >> m_IncreaseRegardValue;
        memset((uint8*)&m_BuildingFeatValue, 0, sizeof(m_BuildingFeatValue));
        m_BuildingFeatValue.Serialize(archive);
        memset((uint8*)&m_BuildingGoldValue, 0, sizeof(m_BuildingGoldValue));
        m_BuildingGoldValue.Serialize(archive);
        archive >> m_BuildingEverywhereValue;
        archive >> m_ActualBuildingEverywhereValue;
        archive >> m_BuildingEffectEverywhereValue;
        archive >> m_ConflictsWithBuildingValue;
        archive >> m_numBuildingAnywhere;
        archive.Load((uint8*)m_BuildingAnywhere, m_numBuildingAnywhere * sizeof(sint32));

        archive >> m_GoldPerBuildingAnywhereValue;
        archive >> m_PollutionPercentValue;
        archive >> m_PollutionAmountValue;
        archive >> m_numExcludedByBuilding;
        archive.Load((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive >> m_numExcludedByWonder;
        archive.Load((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive >> m_EnergyHungerValue;
        archive >> m_ProducesEnergyValue;
        archive >> m_EnergyHungerPerPopValue;
        archive >> m_ProducesEnergyPerPopValue;
        archive >> m_TooManyCitiesThresholdModifierValue;
        archive >> m_TooManyCitiesCoefficientModifierValue;
        archive >> m_RiotLevelModifierValue;
        archive >> m_OtherPlayerRiotLevelModifierValue;
    }
}

WonderRecord::~WonderRecord()
{
    delete [] m_PrerequisiteBuilding;
    delete [] m_GovernmentsModified;
    delete [] m_CultureOnly;
    delete [] m_GovernmentType;
    delete [] m_ObsoleteGovernmentType;
    delete [] m_CityStyleOnly;
    delete [] m_NeedsCityGood;
    delete [] m_NeedsCityGoodAll;
    delete [] m_NeedsCityGoodAnyCity;
    delete [] m_EnablesGood;
    delete [] m_ShowOnMap;
    delete [] m_ShowOnMapRadius;
    delete [] m_CivilisationOnly;
    delete [] m_NeedsFeatToBuild;
    delete [] m_NeedsAnyPlayerFeatToBuild;
    delete [] m_BuildingAnywhere;
    delete [] m_ExcludedByBuilding;
    delete [] m_ExcludedByWonder;
}

WonderRecord const & WonderRecord::operator = (WonderRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;
        m_flags2 = rval.m_flags2;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_ProductionCost = rval.m_ProductionCost;

        m_DefaultIcon = rval.m_DefaultIcon;

        m_Movie = rval.m_Movie;

        m_Description = rval.m_Description;

        m_EnableAdvance = rval.m_EnableAdvance;

        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
        {
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
            std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);
        }
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
        {
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
            std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);
        }
        m_numGovernmentType = rval.m_numGovernmentType;

        delete [] m_ObsoleteGovernmentType;
        m_ObsoleteGovernmentType = NULL;
        if (rval.m_numObsoleteGovernmentType > 0)
        {
            m_ObsoleteGovernmentType = new sint32 [rval.m_numObsoleteGovernmentType];
            std::copy(rval.m_ObsoleteGovernmentType, rval.m_ObsoleteGovernmentType + rval.m_numObsoleteGovernmentType, m_ObsoleteGovernmentType);
        }
        m_numObsoleteGovernmentType = rval.m_numObsoleteGovernmentType;

        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
        {
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
            std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);
        }
        m_numCityStyleOnly = rval.m_numCityStyleOnly;

        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
        {
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
            std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);
        }
        m_numNeedsCityGood = rval.m_numNeedsCityGood;

        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
        {
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
            std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);
        }
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;

        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
        {
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
            std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);
        }
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;

        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
        {
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
            std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);
        }
        m_numEnablesGood = rval.m_numEnablesGood;

        delete [] m_ShowOnMap;
        m_ShowOnMap = NULL;
        if (rval.m_numShowOnMap > 0)
        {
            m_ShowOnMap = new sint32 [rval.m_numShowOnMap];
            std::copy(rval.m_ShowOnMap, rval.m_ShowOnMap + rval.m_numShowOnMap, m_ShowOnMap);
        }
        m_numShowOnMap = rval.m_numShowOnMap;

        delete [] m_ShowOnMapRadius;
        m_ShowOnMapRadius = NULL;
        if (rval.m_numShowOnMapRadius > 0)
        {
            m_ShowOnMapRadius = new sint32 [rval.m_numShowOnMapRadius];
            std::copy(rval.m_ShowOnMapRadius, rval.m_ShowOnMapRadius + rval.m_numShowOnMapRadius, m_ShowOnMapRadius);
        }
        m_numShowOnMapRadius = rval.m_numShowOnMapRadius;

        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
        {
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
            std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);
        }
        m_numCivilisationOnly = rval.m_numCivilisationOnly;

        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
        {
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
            std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);
        }
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;

        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        {
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
            std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);
        }
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;

        m_ShowCityIconTopValue = rval.m_ShowCityIconTopValue;

        m_ShowCityIconBottomValue = rval.m_ShowCityIconBottomValue;

        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;

        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;

        m_IsReligionIconValue = rval.m_IsReligionIconValue;

        m_ReduceReadinessCostValue = rval.m_ReduceReadinessCostValue;

        m_DecCrimePercentValue = rval.m_DecCrimePercentValue;

        m_IncKnowledgePercentValue = rval.m_IncKnowledgePercentValue;

        m_DecEmpireSizeValue = rval.m_DecEmpireSizeValue;

        m_IncHappinessEmpireValue = rval.m_IncHappinessEmpireValue;

        m_IncConvertedCitiesFeePercentValue = rval.m_IncConvertedCitiesFeePercentValue;

        m_GoldPerWaterTradeRouteValue = rval.m_GoldPerWaterTradeRouteValue;

        m_GoldPerTelevisionValue = rval.m_GoldPerTelevisionValue;

        m_GoldPerInternationalTradeRouteValue = rval.m_GoldPerInternationalTradeRouteValue;

        m_PollutersToParksValue = rval.m_PollutersToParksValue;

        m_ReduceWorldPollutionValue = rval.m_ReduceWorldPollutionValue;

        m_IncreaseBoatMovementValue = rval.m_IncreaseBoatMovementValue;

        m_DecreaseMaintenanceValue = rval.m_DecreaseMaintenanceValue;

        m_RandomAdvanceChanceValue = rval.m_RandomAdvanceChanceValue;

        m_IncreaseHpValue = rval.m_IncreaseHpValue;

        m_MultiplyTradeRoutesValue = rval.m_MultiplyTradeRoutesValue;

        m_IncreaseScientistsValue = rval.m_IncreaseScientistsValue;

        m_OtherCivRandomAdvanceChanceValue = rval.m_OtherCivRandomAdvanceChanceValue;

        m_IncreaseProductionValue = rval.m_IncreaseProductionValue;

        m_BonusGoldValue = rval.m_BonusGoldValue;

        m_IncreaseFoodAllCitiesValue = rval.m_IncreaseFoodAllCitiesValue;

        m_TemporaryFullHappinessValue = rval.m_TemporaryFullHappinessValue;

        m_IncreaseSpecialistsValue = rval.m_IncreaseSpecialistsValue;

        m_IncreaseCathedralsValue = rval.m_IncreaseCathedralsValue;

        m_IncreaseBrokeragesValue = rval.m_IncreaseBrokeragesValue;

        m_IncreaseRegardValue = rval.m_IncreaseRegardValue;

        m_BuildingFeatValue = rval.m_BuildingFeatValue;

        m_BuildingGoldValue = rval.m_BuildingGoldValue;

        m_BuildingEverywhereValue = rval.m_BuildingEverywhereValue;

        m_ActualBuildingEverywhereValue = rval.m_ActualBuildingEverywhereValue;

        m_BuildingEffectEverywhereValue = rval.m_BuildingEffectEverywhereValue;

        m_ConflictsWithBuildingValue = rval.m_ConflictsWithBuildingValue;

        delete [] m_BuildingAnywhere;
        m_BuildingAnywhere = NULL;
        if (rval.m_numBuildingAnywhere > 0)
        {
            m_BuildingAnywhere = new sint32 [rval.m_numBuildingAnywhere];
            std::copy(rval.m_BuildingAnywhere, rval.m_BuildingAnywhere + rval.m_numBuildingAnywhere, m_BuildingAnywhere);
        }
        m_numBuildingAnywhere = rval.m_numBuildingAnywhere;

        m_GoldPerBuildingAnywhereValue = rval.m_GoldPerBuildingAnywhereValue;

        m_PollutionPercentValue = rval.m_PollutionPercentValue;

        m_PollutionAmountValue = rval.m_PollutionAmountValue;

        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
        {
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
            std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);
        }
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;

        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
        {
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
            std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);
        }
        m_numExcludedByWonder = rval.m_numExcludedByWonder;

        m_EnergyHungerValue = rval.m_EnergyHungerValue;

        m_ProducesEnergyValue = rval.m_ProducesEnergyValue;

        m_EnergyHungerPerPopValue = rval.m_EnergyHungerPerPopValue;

        m_ProducesEnergyPerPopValue = rval.m_ProducesEnergyPerPopValue;

        m_TooManyCitiesThresholdModifierValue = rval.m_TooManyCitiesThresholdModifierValue;

        m_TooManyCitiesCoefficientModifierValue = rval.m_TooManyCitiesCoefficientModifierValue;

        m_RiotLevelModifierValue = rval.m_RiotLevelModifierValue;

        m_OtherPlayerRiotLevelModifierValue = rval.m_OtherPlayerRiotLevelModifierValue;

    }

    return *this;
}

const char *g_Wonder_Tokens[] =
{
    "ProductionCost",
    "DefaultIcon",
    "Movie",
    "Description",
    "EnableAdvance",
    "ObsoleteAdvance",
    "PrerequisiteBuilding",
    "GovernmentsModified",
    "CultureOnly",
    "GovernmentType",
    "ObsoleteGovernmentType",
    "CityStyleOnly",
    "NeedsCityGood",
    "NeedsCityGoodAll",
    "NeedsCityGoodAnyCity",
    "EnablesGood",
    "ShowOnMap",
    "ShowOnMapRadius",
    "CivilisationOnly",
    "NeedsFeatToBuild",
    "NeedsAnyPlayerFeatToBuild",
    "ShowCityIconTop",
    "ShowCityIconTopValue",
    "ShowCityIconBottom",
    "ShowCityIconBottomValue",
    "SquaredBorderRadius",
    "SquaredBorderRadiusValue",
    "IntBorderRadius",
    "IntBorderRadiusValue",
    "OnePerCiv",
    "IsReligionIcon",
    "IsReligionIconValue",
    "IsHolyCity",
    "ReduceReadinessCost",
    "ReduceReadinessCostValue",
    "EmbassiesEverywhere",
    "DecCrimePercent",
    "DecCrimePercentValue",
    "IncKnowledgePercent",
    "IncKnowledgePercentValue",
    "DecEmpireSize",
    "DecEmpireSizeValue",
    "IncHappinessEmpire",
    "IncHappinessEmpireValue",
    "CloseEmbassies",
    "ReformCities",
    "FreeSlaves",
    "ProhibitSlavers",
    "IncConvertedCitiesFeePercent",
    "IncConvertedCitiesFeePercentValue",
    "GoldPerWaterTradeRoute",
    "GoldPerWaterTradeRouteValue",
    "GoldPerTelevision",
    "GoldPerTelevisionValue",
    "GlobalRadar",
    "SpiesEverywhere",
    "GoldPerInternationalTradeRoute",
    "GoldPerInternationalTradeRouteValue",
    "ProtectFromBiologicalWarfare",
    "PollutersToParks",
    "PollutersToParksValue",
    "EnableParkRangers",
    "ReduceWorldPollution",
    "ReduceWorldPollutionValue",
    "AllCitizensContent",
    "EliminateNukes",
    "AllBoatsDeepWater",
    "IncreaseBoatMovement",
    "IncreaseBoatMovementValue",
    "FreeTradeRoutes",
    "DecreaseMaintenance",
    "DecreaseMaintenanceValue",
    "RandomAdvanceChance",
    "RandomAdvanceChanceValue",
    "IncreaseHp",
    "IncreaseHpValue",
    "MultiplyTradeRoutes",
    "MultiplyTradeRoutesValue",
    "ForcefieldEverywhere",
    "IncreaseScientists",
    "IncreaseScientistsValue",
    "OtherCivRandomAdvanceChance",
    "OtherCivRandomAdvanceChanceValue",
    "IncreaseProduction",
    "IncreaseProductionValue",
    "BonusGold",
    "BonusGoldValue",
    "CantBuildInSea",
    "CantBuildOnLand",
    "CoastalBuilding",
    "EnablesPunativeAirstrikes",
    "IncreaseFoodAllCities",
    "IncreaseFoodAllCitiesValue",
    "TemporaryFullHappiness",
    "TemporaryFullHappinessValue",
    "RevoltingCitiesJoinPlayer",
    "NoPollutionUnhappiness",
    "EmbassiesEverywhereEvenAtWar",
    "IncreaseSpecialists",
    "IncreaseSpecialistsValue",
    "IncreaseCathedrals",
    "IncreaseCathedralsValue",
    "IncreaseBrokerages",
    "IncreaseBrokeragesValue",
    "IncreaseRegard",
    "IncreaseRegardValue",
    "PreventConversion",
    "ProtectFromBarbarians",
    "StartGaiaController",
    "GLHidden",
    "BuildingFeat",
    "BuildingFeatValue",
    "BuildingGold",
    "BuildingGoldValue",
    "BuildingEverywhere",
    "BuildingEverywhereValue",
    "ActualBuildingEverywhere",
    "ActualBuildingEverywhereValue",
    "BuildingEffectEverywhere",
    "BuildingEffectEverywhereValue",
    "ConflictsWithBuilding",
    "ConflictsWithBuildingValue",
    "BuildingAnywhere",
    "GoldPerBuildingAnywhere",
    "GoldPerBuildingAnywhereValue",
    "PollutionPercent",
    "PollutionPercentValue",
    "PollutionAmount",
    "PollutionAmountValue",
    "ExcludedByBuilding",
    "ExcludedByWonder",
    "EnergyHunger",
    "EnergyHungerValue",
    "ProducesEnergy",
    "ProducesEnergyValue",
    "EnergyHungerPerPop",
    "EnergyHungerPerPopValue",
    "ProducesEnergyPerPop",
    "ProducesEnergyPerPopValue",
    "TooManyCitiesThresholdModifier",
    "TooManyCitiesThresholdModifierValue",
    "TooManyCitiesCoefficientModifier",
    "TooManyCitiesCoefficientModifierValue",
    "RiotLevelModifier",
    "RiotLevelModifierValue",
    "OtherPlayerRiotLevelModifier",
    "OtherPlayerRiotLevelModifierValue",
};

WonderRecordAccessorInfo g_WonderRecord_Accessors[] =
{
    { &WonderRecord::GetProductionCost, NULL, NULL, NULL, NULL, NULL, NULL },
    { &WonderRecord::GetDefaultIconIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &WonderRecord::GetMovieIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Description */
    { &WonderRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &WonderRecord::GetNumObsoleteAdvance, NULL, NULL, NULL, NULL, &WonderRecord::GetObsoleteAdvanceIndex, NULL}, /* ObsoleteAdvance (array) */
    { &WonderRecord::GetNumPrerequisiteBuilding, NULL, NULL, NULL, NULL, &WonderRecord::GetPrerequisiteBuildingIndex, NULL}, /* PrerequisiteBuilding (array) */
    { &WonderRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &WonderRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { &WonderRecord::GetNumCultureOnly, NULL, NULL, NULL, NULL, &WonderRecord::GetCultureOnlyIndex, NULL}, /* CultureOnly (array) */
    { &WonderRecord::GetNumGovernmentType, NULL, NULL, NULL, NULL, &WonderRecord::GetGovernmentTypeIndex, NULL}, /* GovernmentType (array) */
    { &WonderRecord::GetNumObsoleteGovernmentType, NULL, NULL, NULL, NULL, &WonderRecord::GetObsoleteGovernmentTypeIndex, NULL}, /* ObsoleteGovernmentType (array) */
    { &WonderRecord::GetNumCityStyleOnly, NULL, NULL, NULL, NULL, &WonderRecord::GetCityStyleOnlyIndex, NULL}, /* CityStyleOnly (array) */
    { &WonderRecord::GetNumNeedsCityGood, NULL, NULL, NULL, NULL, &WonderRecord::GetNeedsCityGoodIndex, NULL}, /* NeedsCityGood (array) */
    { &WonderRecord::GetNumNeedsCityGoodAll, NULL, NULL, NULL, NULL, &WonderRecord::GetNeedsCityGoodAllIndex, NULL}, /* NeedsCityGoodAll (array) */
    { &WonderRecord::GetNumNeedsCityGoodAnyCity, NULL, NULL, NULL, NULL, &WonderRecord::GetNeedsCityGoodAnyCityIndex, NULL}, /* NeedsCityGoodAnyCity (array) */
    { &WonderRecord::GetNumEnablesGood, NULL, NULL, NULL, NULL, &WonderRecord::GetEnablesGoodIndex, NULL}, /* EnablesGood (array) */
    { &WonderRecord::GetNumShowOnMap, NULL, NULL, NULL, NULL, &WonderRecord::GetShowOnMapIndex, NULL}, /* ShowOnMap (array) */
    { &WonderRecord::GetNumShowOnMapRadius, NULL, NULL, NULL, NULL, &WonderRecord::GetShowOnMapRadiusIndex, NULL}, /* ShowOnMapRadius (array) */
    { &WonderRecord::GetNumCivilisationOnly, NULL, NULL, NULL, NULL, &WonderRecord::GetCivilisationOnlyIndex, NULL}, /* CivilisationOnly (array) */
    { &WonderRecord::GetNumNeedsFeatToBuild, NULL, NULL, NULL, NULL, &WonderRecord::GetNeedsFeatToBuildIndex, NULL}, /* NeedsFeatToBuild (array) */
    { &WonderRecord::GetNumNeedsAnyPlayerFeatToBuild, NULL, NULL, NULL, NULL, &WonderRecord::GetNeedsAnyPlayerFeatToBuildIndex, NULL}, /* NeedsAnyPlayerFeatToBuild (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconTop */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconTop */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconBottom */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconBottom */
    { NULL, NULL, NULL, &WonderRecord::GetSquaredBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SquaredBorderRadius */
    { NULL, NULL, NULL, &WonderRecord::GetIntBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IntBorderRadius */
    { NULL, &WonderRecord::GetOnePerCiv, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IsReligionIcon */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IsReligionIcon */
    { NULL, &WonderRecord::GetIsHolyCity, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetReduceReadinessCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ReduceReadinessCost */
    { NULL, &WonderRecord::GetEmbassiesEverywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetDecCrimePercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DecCrimePercent */
    { NULL, NULL, NULL, &WonderRecord::GetIncKnowledgePercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncKnowledgePercent */
    { NULL, NULL, NULL, &WonderRecord::GetDecEmpireSize, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DecEmpireSize */
    { NULL, NULL, NULL, &WonderRecord::GetIncHappinessEmpire, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncHappinessEmpire */
    { NULL, &WonderRecord::GetCloseEmbassies, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetReformCities, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetFreeSlaves, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetProhibitSlavers, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetIncConvertedCitiesFeePercent, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncConvertedCitiesFeePercent */
    { NULL, NULL, NULL, &WonderRecord::GetGoldPerWaterTradeRoute, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerWaterTradeRoute */
    { NULL, NULL, NULL, &WonderRecord::GetGoldPerTelevision, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerTelevision */
    { NULL, &WonderRecord::GetGlobalRadar, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetSpiesEverywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetGoldPerInternationalTradeRoute, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerInternationalTradeRoute */
    { NULL, &WonderRecord::GetProtectFromBiologicalWarfare, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetPollutersToParks, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutersToParks */
    { NULL, &WonderRecord::GetEnableParkRangers, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetReduceWorldPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ReduceWorldPollution */
    { NULL, &WonderRecord::GetAllCitizensContent, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetEliminateNukes, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetAllBoatsDeepWater, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseBoatMovement, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseBoatMovement */
    { NULL, &WonderRecord::GetFreeTradeRoutes, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetDecreaseMaintenance, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DecreaseMaintenance */
    { NULL, NULL, NULL, &WonderRecord::GetRandomAdvanceChance, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RandomAdvanceChance */
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseHp, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseHp */
    { NULL, NULL, NULL, &WonderRecord::GetMultiplyTradeRoutes, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MultiplyTradeRoutes */
    { NULL, &WonderRecord::GetForcefieldEverywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseScientists, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseScientists */
    { NULL, NULL, NULL, &WonderRecord::GetOtherCivRandomAdvanceChance, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OtherCivRandomAdvanceChance */
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseProduction, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseProduction */
    { NULL, NULL, NULL, &WonderRecord::GetBonusGold, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BonusGold */
    { NULL, &WonderRecord::GetCantBuildInSea, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetCantBuildOnLand, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetCoastalBuilding, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetEnablesPunativeAirstrikes, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseFoodAllCities, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseFoodAllCities */
    { NULL, NULL, NULL, &WonderRecord::GetTemporaryFullHappiness, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TemporaryFullHappiness */
    { NULL, &WonderRecord::GetRevoltingCitiesJoinPlayer, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetNoPollutionUnhappiness, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetEmbassiesEverywhereEvenAtWar, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseSpecialists, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseSpecialists */
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseCathedrals, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseCathedrals */
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseBrokerages, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseBrokerages */
    { NULL, NULL, NULL, &WonderRecord::GetIncreaseRegard, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseRegard */
    { NULL, &WonderRecord::GetPreventConversion, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetProtectFromBarbarians, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetStartGaiaController, NULL, NULL, NULL, NULL, NULL },
    { NULL, &WonderRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingFeat */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingFeat */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingGold */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingGold */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ActualBuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ActualBuildingEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEffectEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingEffectEverywhere */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConflictsWithBuilding */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConflictsWithBuilding */
    { &WonderRecord::GetNumBuildingAnywhere, NULL, NULL, NULL, NULL, &WonderRecord::GetBuildingAnywhereIndex, NULL}, /* BuildingAnywhere (array) */
    { NULL, NULL, NULL, &WonderRecord::GetGoldPerBuildingAnywhere, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerBuildingAnywhere */
    { NULL, NULL, NULL, NULL, &WonderRecord::GetPollutionPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutionPercent */
    { NULL, NULL, NULL, NULL, &WonderRecord::GetPollutionAmount, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutionAmount */
    { &WonderRecord::GetNumExcludedByBuilding, NULL, NULL, NULL, NULL, &WonderRecord::GetExcludedByBuildingIndex, NULL}, /* ExcludedByBuilding (array) */
    { &WonderRecord::GetNumExcludedByWonder, NULL, NULL, NULL, NULL, &WonderRecord::GetExcludedByWonderIndex, NULL}, /* ExcludedByWonder (array) */
    { NULL, NULL, NULL, &WonderRecord::GetEnergyHunger, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EnergyHunger */
    { NULL, NULL, NULL, &WonderRecord::GetProducesEnergy, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProducesEnergy */
    { NULL, NULL, NULL, &WonderRecord::GetEnergyHungerPerPop, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EnergyHungerPerPop */
    { NULL, NULL, NULL, &WonderRecord::GetProducesEnergyPerPop, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProducesEnergyPerPop */
    { NULL, NULL, NULL, &WonderRecord::GetTooManyCitiesThresholdModifier, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TooManyCitiesThresholdModifier */
    { NULL, NULL, NULL, NULL, &WonderRecord::GetTooManyCitiesCoefficientModifier, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TooManyCitiesCoefficientModifier */
    { NULL, NULL, NULL, &WonderRecord::GetRiotLevelModifier, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RiotLevelModifier */
    { NULL, NULL, NULL, &WonderRecord::GetOtherPlayerRiotLevelModifier, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OtherPlayerRiotLevelModifier */
};

#define k_Token_Wonder_ProductionCost            ((k_Token_Custom_Base) + 0)
#define k_Token_Wonder_DefaultIcon               ((k_Token_Custom_Base) + 1)
#define k_Token_Wonder_Movie                     ((k_Token_Custom_Base) + 2)
#define k_Token_Wonder_Description               ((k_Token_Custom_Base) + 3)
#define k_Token_Wonder_EnableAdvance             ((k_Token_Custom_Base) + 4)
#define k_Token_Wonder_ObsoleteAdvance           ((k_Token_Custom_Base) + 5)
#define k_Token_Wonder_PrerequisiteBuilding      ((k_Token_Custom_Base) + 6)
#define k_Token_Wonder_GovernmentsModified       ((k_Token_Custom_Base) + 7)
#define k_Token_Wonder_CultureOnly               ((k_Token_Custom_Base) + 8)
#define k_Token_Wonder_GovernmentType            ((k_Token_Custom_Base) + 9)
#define k_Token_Wonder_ObsoleteGovernmentType    ((k_Token_Custom_Base) + 10)
#define k_Token_Wonder_CityStyleOnly             ((k_Token_Custom_Base) + 11)
#define k_Token_Wonder_NeedsCityGood             ((k_Token_Custom_Base) + 12)
#define k_Token_Wonder_NeedsCityGoodAll          ((k_Token_Custom_Base) + 13)
#define k_Token_Wonder_NeedsCityGoodAnyCity      ((k_Token_Custom_Base) + 14)
#define k_Token_Wonder_EnablesGood               ((k_Token_Custom_Base) + 15)
#define k_Token_Wonder_ShowOnMap                 ((k_Token_Custom_Base) + 16)
#define k_Token_Wonder_ShowOnMapRadius           ((k_Token_Custom_Base) + 17)
#define k_Token_Wonder_CivilisationOnly          ((k_Token_Custom_Base) + 18)
#define k_Token_Wonder_NeedsFeatToBuild          ((k_Token_Custom_Base) + 19)
#define k_Token_Wonder_NeedsAnyPlayerFeatToBuild ((k_Token_Custom_Base) + 20)
#define k_Token_Wonder_ShowCityIconTop           ((k_Token_Custom_Base) + 21)
#define k_Token_Wonder_ShowCityIconTop_Value     ((k_Token_Custom_Base) + 22)
#define k_Token_Wonder_ShowCityIconBottom        ((k_Token_Custom_Base) + 23)
#define k_Token_Wonder_ShowCityIconBottom_Value  ((k_Token_Custom_Base) + 24)
#define k_Token_Wonder_SquaredBorderRadius       ((k_Token_Custom_Base) + 25)
#define k_Token_Wonder_SquaredBorderRadius_Value ((k_Token_Custom_Base) + 26)
#define k_Token_Wonder_IntBorderRadius           ((k_Token_Custom_Base) + 27)
#define k_Token_Wonder_IntBorderRadius_Value     ((k_Token_Custom_Base) + 28)
#define k_Token_Wonder_OnePerCiv                 ((k_Token_Custom_Base) + 29)
#define k_Token_Wonder_IsReligionIcon            ((k_Token_Custom_Base) + 30)
#define k_Token_Wonder_IsReligionIcon_Value      ((k_Token_Custom_Base) + 31)
#define k_Token_Wonder_IsHolyCity                ((k_Token_Custom_Base) + 32)
#define k_Token_Wonder_ReduceReadinessCost       ((k_Token_Custom_Base) + 33)
#define k_Token_Wonder_ReduceReadinessCost_Value ((k_Token_Custom_Base) + 34)
#define k_Token_Wonder_EmbassiesEverywhere       ((k_Token_Custom_Base) + 35)
#define k_Token_Wonder_DecCrimePercent           ((k_Token_Custom_Base) + 36)
#define k_Token_Wonder_DecCrimePercent_Value     ((k_Token_Custom_Base) + 37)
#define k_Token_Wonder_IncKnowledgePercent       ((k_Token_Custom_Base) + 38)
#define k_Token_Wonder_IncKnowledgePercent_Value ((k_Token_Custom_Base) + 39)
#define k_Token_Wonder_DecEmpireSize             ((k_Token_Custom_Base) + 40)
#define k_Token_Wonder_DecEmpireSize_Value       ((k_Token_Custom_Base) + 41)
#define k_Token_Wonder_IncHappinessEmpire        ((k_Token_Custom_Base) + 42)
#define k_Token_Wonder_IncHappinessEmpire_Value  ((k_Token_Custom_Base) + 43)
#define k_Token_Wonder_CloseEmbassies            ((k_Token_Custom_Base) + 44)
#define k_Token_Wonder_ReformCities              ((k_Token_Custom_Base) + 45)
#define k_Token_Wonder_FreeSlaves                ((k_Token_Custom_Base) + 46)
#define k_Token_Wonder_ProhibitSlavers           ((k_Token_Custom_Base) + 47)
#define k_Token_Wonder_IncConvertedCitiesFeePercent ((k_Token_Custom_Base) + 48)
#define k_Token_Wonder_IncConvertedCitiesFeePercent_Value ((k_Token_Custom_Base) + 49)
#define k_Token_Wonder_GoldPerWaterTradeRoute    ((k_Token_Custom_Base) + 50)
#define k_Token_Wonder_GoldPerWaterTradeRoute_Value ((k_Token_Custom_Base) + 51)
#define k_Token_Wonder_GoldPerTelevision         ((k_Token_Custom_Base) + 52)
#define k_Token_Wonder_GoldPerTelevision_Value   ((k_Token_Custom_Base) + 53)
#define k_Token_Wonder_GlobalRadar               ((k_Token_Custom_Base) + 54)
#define k_Token_Wonder_SpiesEverywhere           ((k_Token_Custom_Base) + 55)
#define k_Token_Wonder_GoldPerInternationalTradeRoute ((k_Token_Custom_Base) + 56)
#define k_Token_Wonder_GoldPerInternationalTradeRoute_Value ((k_Token_Custom_Base) + 57)
#define k_Token_Wonder_ProtectFromBiologicalWarfare ((k_Token_Custom_Base) + 58)
#define k_Token_Wonder_PollutersToParks          ((k_Token_Custom_Base) + 59)
#define k_Token_Wonder_PollutersToParks_Value    ((k_Token_Custom_Base) + 60)
#define k_Token_Wonder_EnableParkRangers         ((k_Token_Custom_Base) + 61)
#define k_Token_Wonder_ReduceWorldPollution      ((k_Token_Custom_Base) + 62)
#define k_Token_Wonder_ReduceWorldPollution_Value ((k_Token_Custom_Base) + 63)
#define k_Token_Wonder_AllCitizensContent        ((k_Token_Custom_Base) + 64)
#define k_Token_Wonder_EliminateNukes            ((k_Token_Custom_Base) + 65)
#define k_Token_Wonder_AllBoatsDeepWater         ((k_Token_Custom_Base) + 66)
#define k_Token_Wonder_IncreaseBoatMovement      ((k_Token_Custom_Base) + 67)
#define k_Token_Wonder_IncreaseBoatMovement_Value ((k_Token_Custom_Base) + 68)
#define k_Token_Wonder_FreeTradeRoutes           ((k_Token_Custom_Base) + 69)
#define k_Token_Wonder_DecreaseMaintenance       ((k_Token_Custom_Base) + 70)
#define k_Token_Wonder_DecreaseMaintenance_Value ((k_Token_Custom_Base) + 71)
#define k_Token_Wonder_RandomAdvanceChance       ((k_Token_Custom_Base) + 72)
#define k_Token_Wonder_RandomAdvanceChance_Value ((k_Token_Custom_Base) + 73)
#define k_Token_Wonder_IncreaseHp                ((k_Token_Custom_Base) + 74)
#define k_Token_Wonder_IncreaseHp_Value          ((k_Token_Custom_Base) + 75)
#define k_Token_Wonder_MultiplyTradeRoutes       ((k_Token_Custom_Base) + 76)
#define k_Token_Wonder_MultiplyTradeRoutes_Value ((k_Token_Custom_Base) + 77)
#define k_Token_Wonder_ForcefieldEverywhere      ((k_Token_Custom_Base) + 78)
#define k_Token_Wonder_IncreaseScientists        ((k_Token_Custom_Base) + 79)
#define k_Token_Wonder_IncreaseScientists_Value  ((k_Token_Custom_Base) + 80)
#define k_Token_Wonder_OtherCivRandomAdvanceChance ((k_Token_Custom_Base) + 81)
#define k_Token_Wonder_OtherCivRandomAdvanceChance_Value ((k_Token_Custom_Base) + 82)
#define k_Token_Wonder_IncreaseProduction        ((k_Token_Custom_Base) + 83)
#define k_Token_Wonder_IncreaseProduction_Value  ((k_Token_Custom_Base) + 84)
#define k_Token_Wonder_BonusGold                 ((k_Token_Custom_Base) + 85)
#define k_Token_Wonder_BonusGold_Value           ((k_Token_Custom_Base) + 86)
#define k_Token_Wonder_CantBuildInSea            ((k_Token_Custom_Base) + 87)
#define k_Token_Wonder_CantBuildOnLand           ((k_Token_Custom_Base) + 88)
#define k_Token_Wonder_CoastalBuilding           ((k_Token_Custom_Base) + 89)
#define k_Token_Wonder_EnablesPunativeAirstrikes ((k_Token_Custom_Base) + 90)
#define k_Token_Wonder_IncreaseFoodAllCities     ((k_Token_Custom_Base) + 91)
#define k_Token_Wonder_IncreaseFoodAllCities_Value ((k_Token_Custom_Base) + 92)
#define k_Token_Wonder_TemporaryFullHappiness    ((k_Token_Custom_Base) + 93)
#define k_Token_Wonder_TemporaryFullHappiness_Value ((k_Token_Custom_Base) + 94)
#define k_Token_Wonder_RevoltingCitiesJoinPlayer ((k_Token_Custom_Base) + 95)
#define k_Token_Wonder_NoPollutionUnhappiness    ((k_Token_Custom_Base) + 96)
#define k_Token_Wonder_EmbassiesEverywhereEvenAtWar ((k_Token_Custom_Base) + 97)
#define k_Token_Wonder_IncreaseSpecialists       ((k_Token_Custom_Base) + 98)
#define k_Token_Wonder_IncreaseSpecialists_Value ((k_Token_Custom_Base) + 99)
#define k_Token_Wonder_IncreaseCathedrals        ((k_Token_Custom_Base) + 100)
#define k_Token_Wonder_IncreaseCathedrals_Value  ((k_Token_Custom_Base) + 101)
#define k_Token_Wonder_IncreaseBrokerages        ((k_Token_Custom_Base) + 102)
#define k_Token_Wonder_IncreaseBrokerages_Value  ((k_Token_Custom_Base) + 103)
#define k_Token_Wonder_IncreaseRegard            ((k_Token_Custom_Base) + 104)
#define k_Token_Wonder_IncreaseRegard_Value      ((k_Token_Custom_Base) + 105)
#define k_Token_Wonder_PreventConversion         ((k_Token_Custom_Base) + 106)
#define k_Token_Wonder_ProtectFromBarbarians     ((k_Token_Custom_Base) + 107)
#define k_Token_Wonder_StartGaiaController       ((k_Token_Custom_Base) + 108)
#define k_Token_Wonder_GLHidden                  ((k_Token_Custom_Base) + 109)
#define k_Token_Wonder_BuildingFeat              ((k_Token_Custom_Base) + 110)
#define k_Token_Wonder_BuildingFeat_Value        ((k_Token_Custom_Base) + 111)
#define k_Token_Wonder_BuildingGold              ((k_Token_Custom_Base) + 112)
#define k_Token_Wonder_BuildingGold_Value        ((k_Token_Custom_Base) + 113)
#define k_Token_Wonder_BuildingEverywhere        ((k_Token_Custom_Base) + 114)
#define k_Token_Wonder_BuildingEverywhere_Value  ((k_Token_Custom_Base) + 115)
#define k_Token_Wonder_ActualBuildingEverywhere  ((k_Token_Custom_Base) + 116)
#define k_Token_Wonder_ActualBuildingEverywhere_Value ((k_Token_Custom_Base) + 117)
#define k_Token_Wonder_BuildingEffectEverywhere  ((k_Token_Custom_Base) + 118)
#define k_Token_Wonder_BuildingEffectEverywhere_Value ((k_Token_Custom_Base) + 119)
#define k_Token_Wonder_ConflictsWithBuilding     ((k_Token_Custom_Base) + 120)
#define k_Token_Wonder_ConflictsWithBuilding_Value ((k_Token_Custom_Base) + 121)
#define k_Token_Wonder_BuildingAnywhere          ((k_Token_Custom_Base) + 122)
#define k_Token_Wonder_GoldPerBuildingAnywhere   ((k_Token_Custom_Base) + 123)
#define k_Token_Wonder_GoldPerBuildingAnywhere_Value ((k_Token_Custom_Base) + 124)
#define k_Token_Wonder_PollutionPercent          ((k_Token_Custom_Base) + 125)
#define k_Token_Wonder_PollutionPercent_Value    ((k_Token_Custom_Base) + 126)
#define k_Token_Wonder_PollutionAmount           ((k_Token_Custom_Base) + 127)
#define k_Token_Wonder_PollutionAmount_Value     ((k_Token_Custom_Base) + 128)
#define k_Token_Wonder_ExcludedByBuilding        ((k_Token_Custom_Base) + 129)
#define k_Token_Wonder_ExcludedByWonder          ((k_Token_Custom_Base) + 130)
#define k_Token_Wonder_EnergyHunger              ((k_Token_Custom_Base) + 131)
#define k_Token_Wonder_EnergyHunger_Value        ((k_Token_Custom_Base) + 132)
#define k_Token_Wonder_ProducesEnergy            ((k_Token_Custom_Base) + 133)
#define k_Token_Wonder_ProducesEnergy_Value      ((k_Token_Custom_Base) + 134)
#define k_Token_Wonder_EnergyHungerPerPop        ((k_Token_Custom_Base) + 135)
#define k_Token_Wonder_EnergyHungerPerPop_Value  ((k_Token_Custom_Base) + 136)
#define k_Token_Wonder_ProducesEnergyPerPop      ((k_Token_Custom_Base) + 137)
#define k_Token_Wonder_ProducesEnergyPerPop_Value ((k_Token_Custom_Base) + 138)
#define k_Token_Wonder_TooManyCitiesThresholdModifier ((k_Token_Custom_Base) + 139)
#define k_Token_Wonder_TooManyCitiesThresholdModifier_Value ((k_Token_Custom_Base) + 140)
#define k_Token_Wonder_TooManyCitiesCoefficientModifier ((k_Token_Custom_Base) + 141)
#define k_Token_Wonder_TooManyCitiesCoefficientModifier_Value ((k_Token_Custom_Base) + 142)
#define k_Token_Wonder_RiotLevelModifier         ((k_Token_Custom_Base) + 143)
#define k_Token_Wonder_RiotLevelModifier_Value   ((k_Token_Custom_Base) + 144)
#define k_Token_Wonder_OtherPlayerRiotLevelModifier ((k_Token_Custom_Base) + 145)
#define k_Token_Wonder_OtherPlayerRiotLevelModifier_Value ((k_Token_Custom_Base) + 146)
#define k_Token_Wonder_Max                       ((k_Token_Custom_Base) + 147)


static BitArray s_ParsedTokens(147);
void WonderRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Wonder_ProductionCost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ProductionCost missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Wonder_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
}

sint32 WonderRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Wonder_Tokens, k_Token_Wonder_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "WONDER_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Wonder_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Wonder_ProductionCost:
                if(!lex->GetIntAssignment(m_ProductionCost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_DefaultIcon:
                if (!g_theIconDB->GetRecordFromLexer(lex, m_DefaultIcon)) {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_Movie:
                if (!g_theWonderMovieDB->GetRecordFromLexer(lex, m_Movie)) {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_EnableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ObsoleteAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_ObsoleteAdvance, &m_numObsoleteAdvance, k_MAX_ObsoleteAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_PrerequisiteBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteBuilding, &m_numPrerequisiteBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CultureOnly, &m_numCultureOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ObsoleteGovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_ObsoleteGovernmentType, &m_numObsoleteGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_CityStyleOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CityStyleOnly, &m_numCityStyleOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_NeedsCityGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGood, &m_numNeedsCityGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_NeedsCityGoodAll:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAll, &m_numNeedsCityGoodAll))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_NeedsCityGoodAnyCity:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAnyCity, &m_numNeedsCityGoodAnyCity))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_EnablesGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_EnablesGood, &m_numEnablesGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ShowOnMap:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_ShowOnMap, &m_numShowOnMap))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ShowOnMapRadius:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_ShowOnMapRadius, &m_numShowOnMapRadius))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_CivilisationOnly:
                if(!g_theCivilisationDB->ParseRecordInArray(lex, (sint32 **)&m_CivilisationOnly, &m_numCivilisationOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_NeedsFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsFeatToBuild, &m_numNeedsFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_NeedsAnyPlayerFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsAnyPlayerFeatToBuild, &m_numNeedsAnyPlayerFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ShowCityIconTop:
                m_flags0 |= k_Wonder_ShowCityIconTop_Bit;
                if(!g_theMapIconDB->GetRecordFromLexer(lex, m_ShowCityIconTopValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ShowCityIconBottom:
                m_flags0 |= k_Wonder_ShowCityIconBottom_Bit;
                if(!g_theMapIconDB->GetRecordFromLexer(lex, m_ShowCityIconBottomValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_SquaredBorderRadius:
                m_flags0 |= k_Wonder_SquaredBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_SquaredBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IntBorderRadius:
                m_flags0 |= k_Wonder_IntBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_IntBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_OnePerCiv:
                m_flags0 |= k_Wonder_OnePerCiv_Bit;
                break;
            case k_Token_Wonder_IsReligionIcon:
                m_flags0 |= k_Wonder_IsReligionIcon_Bit;
                if(!g_theMapIconDB->GetRecordFromLexer(lex, m_IsReligionIconValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IsHolyCity:
                m_flags0 |= k_Wonder_IsHolyCity_Bit;
                break;
            case k_Token_Wonder_ReduceReadinessCost:
                m_flags0 |= k_Wonder_ReduceReadinessCost_Bit;
                if(!lex->GetIntAssignment(m_ReduceReadinessCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_EmbassiesEverywhere:
                m_flags0 |= k_Wonder_EmbassiesEverywhere_Bit;
                break;
            case k_Token_Wonder_DecCrimePercent:
                m_flags0 |= k_Wonder_DecCrimePercent_Bit;
                if(!lex->GetIntAssignment(m_DecCrimePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IncKnowledgePercent:
                m_flags0 |= k_Wonder_IncKnowledgePercent_Bit;
                if(!lex->GetIntAssignment(m_IncKnowledgePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_DecEmpireSize:
                m_flags0 |= k_Wonder_DecEmpireSize_Bit;
                if(!lex->GetIntAssignment(m_DecEmpireSizeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IncHappinessEmpire:
                m_flags0 |= k_Wonder_IncHappinessEmpire_Bit;
                if(!lex->GetIntAssignment(m_IncHappinessEmpireValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_CloseEmbassies:
                m_flags0 |= k_Wonder_CloseEmbassies_Bit;
                break;
            case k_Token_Wonder_ReformCities:
                m_flags0 |= k_Wonder_ReformCities_Bit;
                break;
            case k_Token_Wonder_FreeSlaves:
                m_flags0 |= k_Wonder_FreeSlaves_Bit;
                break;
            case k_Token_Wonder_ProhibitSlavers:
                m_flags0 |= k_Wonder_ProhibitSlavers_Bit;
                break;
            case k_Token_Wonder_IncConvertedCitiesFeePercent:
                m_flags0 |= k_Wonder_IncConvertedCitiesFeePercent_Bit;
                if(!lex->GetIntAssignment(m_IncConvertedCitiesFeePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_GoldPerWaterTradeRoute:
                m_flags0 |= k_Wonder_GoldPerWaterTradeRoute_Bit;
                if(!lex->GetIntAssignment(m_GoldPerWaterTradeRouteValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_GoldPerTelevision:
                m_flags0 |= k_Wonder_GoldPerTelevision_Bit;
                if(!lex->GetIntAssignment(m_GoldPerTelevisionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_GlobalRadar:
                m_flags0 |= k_Wonder_GlobalRadar_Bit;
                break;
            case k_Token_Wonder_SpiesEverywhere:
                m_flags0 |= k_Wonder_SpiesEverywhere_Bit;
                break;
            case k_Token_Wonder_GoldPerInternationalTradeRoute:
                m_flags0 |= k_Wonder_GoldPerInternationalTradeRoute_Bit;
                if(!lex->GetIntAssignment(m_GoldPerInternationalTradeRouteValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ProtectFromBiologicalWarfare:
                m_flags0 |= k_Wonder_ProtectFromBiologicalWarfare_Bit;
                break;
            case k_Token_Wonder_PollutersToParks:
                m_flags0 |= k_Wonder_PollutersToParks_Bit;
                if(!lex->GetIntAssignment(m_PollutersToParksValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_EnableParkRangers:
                m_flags0 |= k_Wonder_EnableParkRangers_Bit;
                break;
            case k_Token_Wonder_ReduceWorldPollution:
                m_flags0 |= k_Wonder_ReduceWorldPollution_Bit;
                if(!lex->GetIntAssignment(m_ReduceWorldPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_AllCitizensContent:
                m_flags0 |= k_Wonder_AllCitizensContent_Bit;
                break;
            case k_Token_Wonder_EliminateNukes:
                m_flags0 |= k_Wonder_EliminateNukes_Bit;
                break;
            case k_Token_Wonder_AllBoatsDeepWater:
                m_flags0 |= k_Wonder_AllBoatsDeepWater_Bit;
                break;
            case k_Token_Wonder_IncreaseBoatMovement:
                m_flags0 |= k_Wonder_IncreaseBoatMovement_Bit;
                if(!lex->GetIntAssignment(m_IncreaseBoatMovementValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_FreeTradeRoutes:
                m_flags0 |= k_Wonder_FreeTradeRoutes_Bit;
                break;
            case k_Token_Wonder_DecreaseMaintenance:
                m_flags1 |= k_Wonder_DecreaseMaintenance_Bit;
                if(!lex->GetIntAssignment(m_DecreaseMaintenanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_RandomAdvanceChance:
                m_flags1 |= k_Wonder_RandomAdvanceChance_Bit;
                if(!lex->GetIntAssignment(m_RandomAdvanceChanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IncreaseHp:
                m_flags1 |= k_Wonder_IncreaseHp_Bit;
                if(!lex->GetIntAssignment(m_IncreaseHpValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_MultiplyTradeRoutes:
                m_flags1 |= k_Wonder_MultiplyTradeRoutes_Bit;
                if(!lex->GetIntAssignment(m_MultiplyTradeRoutesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ForcefieldEverywhere:
                m_flags1 |= k_Wonder_ForcefieldEverywhere_Bit;
                break;
            case k_Token_Wonder_IncreaseScientists:
                m_flags1 |= k_Wonder_IncreaseScientists_Bit;
                if(!lex->GetIntAssignment(m_IncreaseScientistsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_OtherCivRandomAdvanceChance:
                m_flags1 |= k_Wonder_OtherCivRandomAdvanceChance_Bit;
                if(!lex->GetIntAssignment(m_OtherCivRandomAdvanceChanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IncreaseProduction:
                m_flags1 |= k_Wonder_IncreaseProduction_Bit;
                if(!lex->GetIntAssignment(m_IncreaseProductionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BonusGold:
                m_flags1 |= k_Wonder_BonusGold_Bit;
                if(!lex->GetIntAssignment(m_BonusGoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_CantBuildInSea:
                m_flags1 |= k_Wonder_CantBuildInSea_Bit;
                break;
            case k_Token_Wonder_CantBuildOnLand:
                m_flags1 |= k_Wonder_CantBuildOnLand_Bit;
                break;
            case k_Token_Wonder_CoastalBuilding:
                m_flags1 |= k_Wonder_CoastalBuilding_Bit;
                break;
            case k_Token_Wonder_EnablesPunativeAirstrikes:
                m_flags1 |= k_Wonder_EnablesPunativeAirstrikes_Bit;
                break;
            case k_Token_Wonder_IncreaseFoodAllCities:
                m_flags1 |= k_Wonder_IncreaseFoodAllCities_Bit;
                if(!lex->GetIntAssignment(m_IncreaseFoodAllCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_TemporaryFullHappiness:
                m_flags1 |= k_Wonder_TemporaryFullHappiness_Bit;
                if(!lex->GetIntAssignment(m_TemporaryFullHappinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_RevoltingCitiesJoinPlayer:
                m_flags1 |= k_Wonder_RevoltingCitiesJoinPlayer_Bit;
                break;
            case k_Token_Wonder_NoPollutionUnhappiness:
                m_flags1 |= k_Wonder_NoPollutionUnhappiness_Bit;
                break;
            case k_Token_Wonder_EmbassiesEverywhereEvenAtWar:
                m_flags1 |= k_Wonder_EmbassiesEverywhereEvenAtWar_Bit;
                break;
            case k_Token_Wonder_IncreaseSpecialists:
                m_flags1 |= k_Wonder_IncreaseSpecialists_Bit;
                if(!lex->GetIntAssignment(m_IncreaseSpecialistsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IncreaseCathedrals:
                m_flags1 |= k_Wonder_IncreaseCathedrals_Bit;
                if(!lex->GetIntAssignment(m_IncreaseCathedralsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IncreaseBrokerages:
                m_flags1 |= k_Wonder_IncreaseBrokerages_Bit;
                if(!lex->GetIntAssignment(m_IncreaseBrokeragesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_IncreaseRegard:
                m_flags1 |= k_Wonder_IncreaseRegard_Bit;
                if(!lex->GetIntAssignment(m_IncreaseRegardValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_PreventConversion:
                m_flags1 |= k_Wonder_PreventConversion_Bit;
                break;
            case k_Token_Wonder_ProtectFromBarbarians:
                m_flags1 |= k_Wonder_ProtectFromBarbarians_Bit;
                break;
            case k_Token_Wonder_StartGaiaController:
                m_flags1 |= k_Wonder_StartGaiaController_Bit;
                break;
            case k_Token_Wonder_GLHidden:
                m_flags1 |= k_Wonder_GLHidden_Bit;
                break;
            case k_Token_Wonder_BuildingFeat:
                m_flags1 |= k_Wonder_BuildingFeat_Bit;
                if(!m_BuildingFeatValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BuildingGold:
                m_flags1 |= k_Wonder_BuildingGold_Bit;
                if(!m_BuildingGoldValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BuildingEverywhere:
                m_flags1 |= k_Wonder_BuildingEverywhere_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_BuildingEverywhereValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ActualBuildingEverywhere:
                m_flags1 |= k_Wonder_ActualBuildingEverywhere_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_ActualBuildingEverywhereValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BuildingEffectEverywhere:
                m_flags1 |= k_Wonder_BuildingEffectEverywhere_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_BuildingEffectEverywhereValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ConflictsWithBuilding:
                m_flags1 |= k_Wonder_ConflictsWithBuilding_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_ConflictsWithBuildingValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BuildingAnywhere:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_BuildingAnywhere, &m_numBuildingAnywhere))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_GoldPerBuildingAnywhere:
                m_flags2 |= k_Wonder_GoldPerBuildingAnywhere_Bit;
                if(!lex->GetIntAssignment(m_GoldPerBuildingAnywhereValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_PollutionPercent:
                m_flags2 |= k_Wonder_PollutionPercent_Bit;
                if(!lex->GetFloatAssignment(m_PollutionPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_PollutionAmount:
                m_flags2 |= k_Wonder_PollutionAmount_Bit;
                if(!lex->GetFloatAssignment(m_PollutionAmountValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ExcludedByBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByBuilding, &m_numExcludedByBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ExcludedByWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByWonder, &m_numExcludedByWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_EnergyHunger:
                m_flags2 |= k_Wonder_EnergyHunger_Bit;
                if(!lex->GetIntAssignment(m_EnergyHungerValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ProducesEnergy:
                m_flags2 |= k_Wonder_ProducesEnergy_Bit;
                if(!lex->GetIntAssignment(m_ProducesEnergyValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_EnergyHungerPerPop:
                m_flags2 |= k_Wonder_EnergyHungerPerPop_Bit;
                if(!lex->GetIntAssignment(m_EnergyHungerPerPopValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_ProducesEnergyPerPop:
                m_flags2 |= k_Wonder_ProducesEnergyPerPop_Bit;
                if(!lex->GetIntAssignment(m_ProducesEnergyPerPopValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_TooManyCitiesThresholdModifier:
                m_flags2 |= k_Wonder_TooManyCitiesThresholdModifier_Bit;
                if(!lex->GetIntAssignment(m_TooManyCitiesThresholdModifierValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_TooManyCitiesCoefficientModifier:
                m_flags2 |= k_Wonder_TooManyCitiesCoefficientModifier_Bit;
                if(!lex->GetFloatAssignment(m_TooManyCitiesCoefficientModifierValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_RiotLevelModifier:
                m_flags2 |= k_Wonder_RiotLevelModifier_Bit;
                if(!lex->GetIntAssignment(m_RiotLevelModifierValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_OtherPlayerRiotLevelModifier:
                m_flags2 |= k_Wonder_OtherPlayerRiotLevelModifier_Bit;
                if(!lex->GetIntAssignment(m_OtherPlayerRiotLevelModifierValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_ProductionCost)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void WonderRecord::ResolveDBReferences()
{
    if(m_DefaultIcon & 0x80000000) {
        sint32 id = m_DefaultIcon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_DefaultIcon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultIcon == 0x7fffffff) {
        m_DefaultIcon = -1;
    }
    if(m_Movie & 0x80000000) {
        sint32 id = m_Movie & 0x7fffffff;
        if(!g_theWonderMovieDB->GetNamedItem(id, m_Movie)) {
            c3errors_ErrorDialog("DB", "%s not found in WonderMovie database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Movie == 0x7fffffff) {
        m_Movie = -1;
    }
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteAdvance; i++) {
            if(m_ObsoleteAdvance[i] & 0x80000000) {
                sint32 id = m_ObsoleteAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ObsoleteAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteAdvance[i] == 0x7fffffff){
                m_ObsoleteAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteBuilding; i++) {
            if(m_PrerequisiteBuilding[i] & 0x80000000) {
                sint32 id = m_PrerequisiteBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_PrerequisiteBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteBuilding[i] == 0x7fffffff){
                m_PrerequisiteBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteGovernmentType; i++) {
            if(m_ObsoleteGovernmentType[i] & 0x80000000) {
                sint32 id = m_ObsoleteGovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_ObsoleteGovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteGovernmentType[i] == 0x7fffffff){
                m_ObsoleteGovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCityStyleOnly; i++) {
            if(m_CityStyleOnly[i] & 0x80000000) {
                sint32 id = m_CityStyleOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CityStyleOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CityStyleOnly[i] == 0x7fffffff){
                m_CityStyleOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGood; i++) {
            if(m_NeedsCityGood[i] & 0x80000000) {
                sint32 id = m_NeedsCityGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGood[i] == 0x7fffffff){
                m_NeedsCityGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAll; i++) {
            if(m_NeedsCityGoodAll[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAll[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAll[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAll[i] == 0x7fffffff){
                m_NeedsCityGoodAll[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAnyCity; i++) {
            if(m_NeedsCityGoodAnyCity[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAnyCity[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAnyCity[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAnyCity[i] == 0x7fffffff){
                m_NeedsCityGoodAnyCity[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numEnablesGood; i++) {
            if(m_EnablesGood[i] & 0x80000000) {
                sint32 id = m_EnablesGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_EnablesGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_EnablesGood[i] == 0x7fffffff){
                m_EnablesGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numShowOnMap; i++) {
            if(m_ShowOnMap[i] & 0x80000000) {
                sint32 id = m_ShowOnMap[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_ShowOnMap[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ShowOnMap[i] == 0x7fffffff){
                m_ShowOnMap[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numShowOnMapRadius; i++) {
            if(m_ShowOnMapRadius[i] & 0x80000000) {
                sint32 id = m_ShowOnMapRadius[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_ShowOnMapRadius[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ShowOnMapRadius[i] == 0x7fffffff){
                m_ShowOnMapRadius[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCivilisationOnly; i++) {
            if(m_CivilisationOnly[i] & 0x80000000) {
                sint32 id = m_CivilisationOnly[i] & 0x7fffffff;
                if(!g_theCivilisationDB->GetNamedItem(id, m_CivilisationOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Civilisation database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CivilisationOnly[i] == 0x7fffffff){
                m_CivilisationOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsFeatToBuild; i++) {
            if(m_NeedsFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsFeatToBuild[i] == 0x7fffffff){
                m_NeedsFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsAnyPlayerFeatToBuild; i++) {
            if(m_NeedsAnyPlayerFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsAnyPlayerFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsAnyPlayerFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsAnyPlayerFeatToBuild[i] == 0x7fffffff){
                m_NeedsAnyPlayerFeatToBuild[i] = -1;
            }
        }
    }
    if(m_ShowCityIconTopValue & 0x80000000) {
        sint32 id = m_ShowCityIconTopValue & 0x7fffffff;
        if(!g_theMapIconDB->GetNamedItem(id, m_ShowCityIconTopValue)) {
            c3errors_ErrorDialog("DB", "%s not found in MapIcon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ShowCityIconTopValue == 0x7fffffff) {
        m_ShowCityIconTopValue = -1;
    }
    if(m_ShowCityIconBottomValue & 0x80000000) {
        sint32 id = m_ShowCityIconBottomValue & 0x7fffffff;
        if(!g_theMapIconDB->GetNamedItem(id, m_ShowCityIconBottomValue)) {
            c3errors_ErrorDialog("DB", "%s not found in MapIcon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ShowCityIconBottomValue == 0x7fffffff) {
        m_ShowCityIconBottomValue = -1;
    }
    if(m_IsReligionIconValue & 0x80000000) {
        sint32 id = m_IsReligionIconValue & 0x7fffffff;
        if(!g_theMapIconDB->GetNamedItem(id, m_IsReligionIconValue)) {
            c3errors_ErrorDialog("DB", "%s not found in MapIcon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_IsReligionIconValue == 0x7fffffff) {
        m_IsReligionIconValue = -1;
    }
    m_BuildingFeatValue.ResolveDBReferences();
    m_BuildingGoldValue.ResolveDBReferences();
    if(m_BuildingEverywhereValue & 0x80000000) {
        sint32 id = m_BuildingEverywhereValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_BuildingEverywhereValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_BuildingEverywhereValue == 0x7fffffff) {
        m_BuildingEverywhereValue = -1;
    }
    if(m_ActualBuildingEverywhereValue & 0x80000000) {
        sint32 id = m_ActualBuildingEverywhereValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_ActualBuildingEverywhereValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ActualBuildingEverywhereValue == 0x7fffffff) {
        m_ActualBuildingEverywhereValue = -1;
    }
    if(m_BuildingEffectEverywhereValue & 0x80000000) {
        sint32 id = m_BuildingEffectEverywhereValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_BuildingEffectEverywhereValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_BuildingEffectEverywhereValue == 0x7fffffff) {
        m_BuildingEffectEverywhereValue = -1;
    }
    if(m_ConflictsWithBuildingValue & 0x80000000) {
        sint32 id = m_ConflictsWithBuildingValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_ConflictsWithBuildingValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ConflictsWithBuildingValue == 0x7fffffff) {
        m_ConflictsWithBuildingValue = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numBuildingAnywhere; i++) {
            if(m_BuildingAnywhere[i] & 0x80000000) {
                sint32 id = m_BuildingAnywhere[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_BuildingAnywhere[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_BuildingAnywhere[i] == 0x7fffffff){
                m_BuildingAnywhere[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByBuilding; i++) {
            if(m_ExcludedByBuilding[i] & 0x80000000) {
                sint32 id = m_ExcludedByBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_ExcludedByBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByBuilding[i] == 0x7fffffff){
                m_ExcludedByBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByWonder; i++) {
            if(m_ExcludedByWonder[i] & 0x80000000) {
                sint32 id = m_ExcludedByWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_ExcludedByWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByWonder[i] == 0x7fffffff){
                m_ExcludedByWonder[i] = -1;
            }
        }
    }
}

WonderRecord::BuildingFeat::BuildingFeat()
{
    m_flags0 = 0;
    m_Building = 0x7fffffff;
    m_NumValue = 0;
    m_PercentCitiesValue = 0;
}

WonderRecord::BuildingFeat::~BuildingFeat()
{
}

WonderRecord::BuildingFeat const & WonderRecord::BuildingFeat::operator = (BuildingFeat const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Building = rval.m_Building;

        m_NumValue = rval.m_NumValue;

        m_PercentCitiesValue = rval.m_PercentCitiesValue;

    }

    return *this;
}

void WonderRecord::BuildingFeat::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Building;
        archive << m_NumValue;
        archive << m_PercentCitiesValue;
    } else {
        archive >> m_flags0;
        archive >> m_Building;
        archive >> m_NumValue;
        archive >> m_PercentCitiesValue;
    }
}

static const char *s_Wonder_BuildingFeat_Tokens[] = {
    "Building",
    "Num",
    "PercentCities",
};
#define k_Token_Wonder_BuildingFeat_Building     ((k_Token_Custom_Base) + 0)
#define k_Token_Wonder_BuildingFeat_Num          ((k_Token_Custom_Base) + 1)
#define k_Token_Wonder_BuildingFeat_PercentCities ((k_Token_Custom_Base) + 2)
#define k_Token_Wonder_BuildingFeat_Max ((k_Token_Custom_Base) + 3)
sint32 WonderRecord::BuildingFeat::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildingFeat"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Wonder_BuildingFeat_Tokens, k_Token_Wonder_BuildingFeat_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Wonder_BuildingFeat_Building:
                if (!g_theBuildingDB->GetRecordFromLexer(lex, m_Building)) {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BuildingFeat_Num:
                m_flags0 |= k_BuildingFeat_Num_Bit;
                if(!lex->GetIntAssignment(m_NumValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BuildingFeat_PercentCities:
                m_flags0 |= k_BuildingFeat_PercentCities_Bit;
                if(!lex->GetIntAssignment(m_PercentCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theBuildingDB->GetCurrentRecordFromLexer(lex, m_Building)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 WonderRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildingFeat *oldArray = *array;
        *array = new BuildingFeat[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildingFeat[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 WonderRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void WonderRecord::BuildingFeat::ResolveDBReferences()
{
    if(m_Building & 0x80000000) {
        sint32 id = m_Building & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_Building)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Building == 0x7fffffff) {
        m_Building = -1;
    }
}

WonderRecord::BuildingGold::BuildingGold()
{
    m_flags0 = 0;
    m_Building = 0x7fffffff;
    m_GoldValue = 0;
}

WonderRecord::BuildingGold::~BuildingGold()
{
}

WonderRecord::BuildingGold const & WonderRecord::BuildingGold::operator = (BuildingGold const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Building = rval.m_Building;

        m_GoldValue = rval.m_GoldValue;

    }

    return *this;
}

void WonderRecord::BuildingGold::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Building;
        archive << m_GoldValue;
    } else {
        archive >> m_flags0;
        archive >> m_Building;
        archive >> m_GoldValue;
    }
}

static const char *s_Wonder_BuildingGold_Tokens[] = {
    "Building",
    "Gold",
};
#define k_Token_Wonder_BuildingGold_Building     ((k_Token_Custom_Base) + 0)
#define k_Token_Wonder_BuildingGold_Gold         ((k_Token_Custom_Base) + 1)
#define k_Token_Wonder_BuildingGold_Max ((k_Token_Custom_Base) + 2)
sint32 WonderRecord::BuildingGold::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildingGold"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Wonder_BuildingGold_Tokens, k_Token_Wonder_BuildingGold_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Wonder_BuildingGold_Building:
                if (!g_theBuildingDB->GetRecordFromLexer(lex, m_Building)) {
                    done = true; break;
                }
                break;
            case k_Token_Wonder_BuildingGold_Gold:
                m_flags0 |= k_BuildingGold_Gold_Bit;
                if(!lex->GetIntAssignment(m_GoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theBuildingDB->GetCurrentRecordFromLexer(lex, m_Building)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 WonderRecord::BuildingGold::ParseInArray(DBLexer *lex, BuildingGold **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildingGold *oldArray = *array;
        *array = new BuildingGold[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildingGold[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 WonderRecord::BuildingGold::ParseInArray(DBLexer *lex, BuildingGold *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void WonderRecord::BuildingGold::ResolveDBReferences()
{
    if(m_Building & 0x80000000) {
        sint32 id = m_Building & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_Building)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Building == 0x7fffffff) {
        m_Building = -1;
    }
}

void WonderRecord::Merge(const WonderRecord & rval){
    if (rval.m_numObsoleteAdvance > 0)
        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

    // resize m_PrerequisiteBuilding if necessary
    if (rval.m_numPrerequisiteBuilding > m_numPrerequisiteBuilding)
    {
        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;
    }
    if (rval.m_numPrerequisiteBuilding > 0)
        std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);

    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

    // resize m_CultureOnly if necessary
    if (rval.m_numCultureOnly > m_numCultureOnly)
    {
        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
        m_numCultureOnly = rval.m_numCultureOnly;
    }
    if (rval.m_numCultureOnly > 0)
        std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);

    // resize m_GovernmentType if necessary
    if (rval.m_numGovernmentType > m_numGovernmentType)
    {
        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
        m_numGovernmentType = rval.m_numGovernmentType;
    }
    if (rval.m_numGovernmentType > 0)
        std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);

    // resize m_ObsoleteGovernmentType if necessary
    if (rval.m_numObsoleteGovernmentType > m_numObsoleteGovernmentType)
    {
        delete [] m_ObsoleteGovernmentType;
        m_ObsoleteGovernmentType = NULL;
        if (rval.m_numObsoleteGovernmentType > 0)
            m_ObsoleteGovernmentType = new sint32 [rval.m_numObsoleteGovernmentType];
        m_numObsoleteGovernmentType = rval.m_numObsoleteGovernmentType;
    }
    if (rval.m_numObsoleteGovernmentType > 0)
        std::copy(rval.m_ObsoleteGovernmentType, rval.m_ObsoleteGovernmentType + rval.m_numObsoleteGovernmentType, m_ObsoleteGovernmentType);

    // resize m_CityStyleOnly if necessary
    if (rval.m_numCityStyleOnly > m_numCityStyleOnly)
    {
        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
        m_numCityStyleOnly = rval.m_numCityStyleOnly;
    }
    if (rval.m_numCityStyleOnly > 0)
        std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);

    // resize m_NeedsCityGood if necessary
    if (rval.m_numNeedsCityGood > m_numNeedsCityGood)
    {
        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
        m_numNeedsCityGood = rval.m_numNeedsCityGood;
    }
    if (rval.m_numNeedsCityGood > 0)
        std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);

    // resize m_NeedsCityGoodAll if necessary
    if (rval.m_numNeedsCityGoodAll > m_numNeedsCityGoodAll)
    {
        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;
    }
    if (rval.m_numNeedsCityGoodAll > 0)
        std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);

    // resize m_NeedsCityGoodAnyCity if necessary
    if (rval.m_numNeedsCityGoodAnyCity > m_numNeedsCityGoodAnyCity)
    {
        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;
    }
    if (rval.m_numNeedsCityGoodAnyCity > 0)
        std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);

    // resize m_EnablesGood if necessary
    if (rval.m_numEnablesGood > m_numEnablesGood)
    {
        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
        m_numEnablesGood = rval.m_numEnablesGood;
    }
    if (rval.m_numEnablesGood > 0)
        std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);

    // resize m_ShowOnMap if necessary
    if (rval.m_numShowOnMap > m_numShowOnMap)
    {
        delete [] m_ShowOnMap;
        m_ShowOnMap = NULL;
        if (rval.m_numShowOnMap > 0)
            m_ShowOnMap = new sint32 [rval.m_numShowOnMap];
        m_numShowOnMap = rval.m_numShowOnMap;
    }
    if (rval.m_numShowOnMap > 0)
        std::copy(rval.m_ShowOnMap, rval.m_ShowOnMap + rval.m_numShowOnMap, m_ShowOnMap);

    // resize m_ShowOnMapRadius if necessary
    if (rval.m_numShowOnMapRadius > m_numShowOnMapRadius)
    {
        delete [] m_ShowOnMapRadius;
        m_ShowOnMapRadius = NULL;
        if (rval.m_numShowOnMapRadius > 0)
            m_ShowOnMapRadius = new sint32 [rval.m_numShowOnMapRadius];
        m_numShowOnMapRadius = rval.m_numShowOnMapRadius;
    }
    if (rval.m_numShowOnMapRadius > 0)
        std::copy(rval.m_ShowOnMapRadius, rval.m_ShowOnMapRadius + rval.m_numShowOnMapRadius, m_ShowOnMapRadius);

    // resize m_CivilisationOnly if necessary
    if (rval.m_numCivilisationOnly > m_numCivilisationOnly)
    {
        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
        m_numCivilisationOnly = rval.m_numCivilisationOnly;
    }
    if (rval.m_numCivilisationOnly > 0)
        std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);

    // resize m_NeedsFeatToBuild if necessary
    if (rval.m_numNeedsFeatToBuild > m_numNeedsFeatToBuild)
    {
        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;
    }
    if (rval.m_numNeedsFeatToBuild > 0)
        std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);

    // resize m_NeedsAnyPlayerFeatToBuild if necessary
    if (rval.m_numNeedsAnyPlayerFeatToBuild > m_numNeedsAnyPlayerFeatToBuild)
    {
        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;
    }
    if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_ShowCityIconTop_Bit)
    {
        m_ShowCityIconTopValue = rval.m_ShowCityIconTopValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_ShowCityIconBottom_Bit)
    {
        m_ShowCityIconBottomValue = rval.m_ShowCityIconBottomValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_SquaredBorderRadius_Bit)
    {
        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_IntBorderRadius_Bit)
    {
        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_IsReligionIcon_Bit)
    {
        m_IsReligionIconValue = rval.m_IsReligionIconValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_ReduceReadinessCost_Bit)
    {
        m_ReduceReadinessCostValue = rval.m_ReduceReadinessCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_DecCrimePercent_Bit)
    {
        m_DecCrimePercentValue = rval.m_DecCrimePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_IncKnowledgePercent_Bit)
    {
        m_IncKnowledgePercentValue = rval.m_IncKnowledgePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_DecEmpireSize_Bit)
    {
        m_DecEmpireSizeValue = rval.m_DecEmpireSizeValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_IncHappinessEmpire_Bit)
    {
        m_IncHappinessEmpireValue = rval.m_IncHappinessEmpireValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_IncConvertedCitiesFeePercent_Bit)
    {
        m_IncConvertedCitiesFeePercentValue = rval.m_IncConvertedCitiesFeePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_GoldPerWaterTradeRoute_Bit)
    {
        m_GoldPerWaterTradeRouteValue = rval.m_GoldPerWaterTradeRouteValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_GoldPerTelevision_Bit)
    {
        m_GoldPerTelevisionValue = rval.m_GoldPerTelevisionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_GoldPerInternationalTradeRoute_Bit)
    {
        m_GoldPerInternationalTradeRouteValue = rval.m_GoldPerInternationalTradeRouteValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_PollutersToParks_Bit)
    {
        m_PollutersToParksValue = rval.m_PollutersToParksValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_ReduceWorldPollution_Bit)
    {
        m_ReduceWorldPollutionValue = rval.m_ReduceWorldPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Wonder_IncreaseBoatMovement_Bit)
    {
        m_IncreaseBoatMovementValue = rval.m_IncreaseBoatMovementValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_DecreaseMaintenance_Bit)
    {
        m_DecreaseMaintenanceValue = rval.m_DecreaseMaintenanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_RandomAdvanceChance_Bit)
    {
        m_RandomAdvanceChanceValue = rval.m_RandomAdvanceChanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseHp_Bit)
    {
        m_IncreaseHpValue = rval.m_IncreaseHpValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_MultiplyTradeRoutes_Bit)
    {
        m_MultiplyTradeRoutesValue = rval.m_MultiplyTradeRoutesValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseScientists_Bit)
    {
        m_IncreaseScientistsValue = rval.m_IncreaseScientistsValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_OtherCivRandomAdvanceChance_Bit)
    {
        m_OtherCivRandomAdvanceChanceValue = rval.m_OtherCivRandomAdvanceChanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseProduction_Bit)
    {
        m_IncreaseProductionValue = rval.m_IncreaseProductionValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_BonusGold_Bit)
    {
        m_BonusGoldValue = rval.m_BonusGoldValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseFoodAllCities_Bit)
    {
        m_IncreaseFoodAllCitiesValue = rval.m_IncreaseFoodAllCitiesValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_TemporaryFullHappiness_Bit)
    {
        m_TemporaryFullHappinessValue = rval.m_TemporaryFullHappinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseSpecialists_Bit)
    {
        m_IncreaseSpecialistsValue = rval.m_IncreaseSpecialistsValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseCathedrals_Bit)
    {
        m_IncreaseCathedralsValue = rval.m_IncreaseCathedralsValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseBrokerages_Bit)
    {
        m_IncreaseBrokeragesValue = rval.m_IncreaseBrokeragesValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_IncreaseRegard_Bit)
    {
        m_IncreaseRegardValue = rval.m_IncreaseRegardValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_BuildingFeat_Bit)
    {
        m_BuildingFeatValue = rval.m_BuildingFeatValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_BuildingGold_Bit)
    {
        m_BuildingGoldValue = rval.m_BuildingGoldValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_BuildingEverywhere_Bit)
    {
        m_BuildingEverywhereValue = rval.m_BuildingEverywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_ActualBuildingEverywhere_Bit)
    {
        m_ActualBuildingEverywhereValue = rval.m_ActualBuildingEverywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_BuildingEffectEverywhere_Bit)
    {
        m_BuildingEffectEverywhereValue = rval.m_BuildingEffectEverywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Wonder_ConflictsWithBuilding_Bit)
    {
        m_ConflictsWithBuildingValue = rval.m_ConflictsWithBuildingValue;
    }

    // resize m_BuildingAnywhere if necessary
    if (rval.m_numBuildingAnywhere > m_numBuildingAnywhere)
    {
        delete [] m_BuildingAnywhere;
        m_BuildingAnywhere = NULL;
        if (rval.m_numBuildingAnywhere > 0)
            m_BuildingAnywhere = new sint32 [rval.m_numBuildingAnywhere];
        m_numBuildingAnywhere = rval.m_numBuildingAnywhere;
    }
    if (rval.m_numBuildingAnywhere > 0)
        std::copy(rval.m_BuildingAnywhere, rval.m_BuildingAnywhere + rval.m_numBuildingAnywhere, m_BuildingAnywhere);

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_GoldPerBuildingAnywhere_Bit)
    {
        m_GoldPerBuildingAnywhereValue = rval.m_GoldPerBuildingAnywhereValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_PollutionPercent_Bit)
    {
        m_PollutionPercentValue = rval.m_PollutionPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_PollutionAmount_Bit)
    {
        m_PollutionAmountValue = rval.m_PollutionAmountValue;
    }

    // resize m_ExcludedByBuilding if necessary
    if (rval.m_numExcludedByBuilding > m_numExcludedByBuilding)
    {
        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;
    }
    if (rval.m_numExcludedByBuilding > 0)
        std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);

    // resize m_ExcludedByWonder if necessary
    if (rval.m_numExcludedByWonder > m_numExcludedByWonder)
    {
        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
        m_numExcludedByWonder = rval.m_numExcludedByWonder;
    }
    if (rval.m_numExcludedByWonder > 0)
        std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_EnergyHunger_Bit)
    {
        m_EnergyHungerValue = rval.m_EnergyHungerValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_ProducesEnergy_Bit)
    {
        m_ProducesEnergyValue = rval.m_ProducesEnergyValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_EnergyHungerPerPop_Bit)
    {
        m_EnergyHungerPerPopValue = rval.m_EnergyHungerPerPopValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_ProducesEnergyPerPop_Bit)
    {
        m_ProducesEnergyPerPopValue = rval.m_ProducesEnergyPerPopValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_TooManyCitiesThresholdModifier_Bit)
    {
        m_TooManyCitiesThresholdModifierValue = rval.m_TooManyCitiesThresholdModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_TooManyCitiesCoefficientModifier_Bit)
    {
        m_TooManyCitiesCoefficientModifierValue = rval.m_TooManyCitiesCoefficientModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_RiotLevelModifier_Bit)
    {
        m_RiotLevelModifierValue = rval.m_RiotLevelModifierValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Wonder_OtherPlayerRiotLevelModifier_Bit)
    {
        m_OtherPlayerRiotLevelModifierValue = rval.m_OtherPlayerRiotLevelModifierValue;
    }

}

IconRecord const * WonderRecord::GetDefaultIcon() const
{
    return g_theIconDB->Get(m_DefaultIcon);
}

WonderMovieRecord const * WonderRecord::GetMovie() const
{
    return g_theWonderMovieDB->Get(m_Movie);
}

AdvanceRecord const * WonderRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 WonderRecord::GetObsoleteAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return m_ObsoleteAdvance[index];
}

AdvanceRecord const * WonderRecord::GetObsoleteAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ObsoleteAdvance[index]);
}

sint32 WonderRecord::GetPrerequisiteBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return m_PrerequisiteBuilding[index];
}

BuildingRecord const * WonderRecord::GetPrerequisiteBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_PrerequisiteBuilding[index]);
}

sint32 WonderRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * WonderRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

sint32 WonderRecord::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

CityStyleRecord const * WonderRecord::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

sint32 WonderRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

GovernmentRecord const * WonderRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

sint32 WonderRecord::GetObsoleteGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteGovernmentType);
    if((index < 0) || (index >= m_numObsoleteGovernmentType)) {
        return 0;
    }
    return m_ObsoleteGovernmentType[index];
}

GovernmentRecord const * WonderRecord::GetObsoleteGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteGovernmentType);
    if((index < 0) || (index >= m_numObsoleteGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_ObsoleteGovernmentType[index]);
}

sint32 WonderRecord::GetCityStyleOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return m_CityStyleOnly[index];
}

CityStyleRecord const * WonderRecord::GetCityStyleOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CityStyleOnly[index]);
}

sint32 WonderRecord::GetNeedsCityGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return m_NeedsCityGood[index];
}

ResourceRecord const * WonderRecord::GetNeedsCityGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGood[index]);
}

sint32 WonderRecord::GetNeedsCityGoodAllIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return m_NeedsCityGoodAll[index];
}

ResourceRecord const * WonderRecord::GetNeedsCityGoodAll(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAll[index]);
}

sint32 WonderRecord::GetNeedsCityGoodAnyCityIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return m_NeedsCityGoodAnyCity[index];
}

ResourceRecord const * WonderRecord::GetNeedsCityGoodAnyCity(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAnyCity[index]);
}

sint32 WonderRecord::GetEnablesGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return m_EnablesGood[index];
}

ResourceRecord const * WonderRecord::GetEnablesGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_EnablesGood[index]);
}

sint32 WonderRecord::GetShowOnMapIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMap);
    if((index < 0) || (index >= m_numShowOnMap)) {
        return 0;
    }
    return m_ShowOnMap[index];
}

TerrainImprovementRecord const * WonderRecord::GetShowOnMap(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMap);
    if((index < 0) || (index >= m_numShowOnMap)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_ShowOnMap[index]);
}

sint32 WonderRecord::GetShowOnMapRadiusIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMapRadius);
    if((index < 0) || (index >= m_numShowOnMapRadius)) {
        return 0;
    }
    return m_ShowOnMapRadius[index];
}

TerrainImprovementRecord const * WonderRecord::GetShowOnMapRadius(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMapRadius);
    if((index < 0) || (index >= m_numShowOnMapRadius)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_ShowOnMapRadius[index]);
}

sint32 WonderRecord::GetCivilisationOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return m_CivilisationOnly[index];
}

CivilisationRecord const * WonderRecord::GetCivilisationOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return g_theCivilisationDB->Get(m_CivilisationOnly[index]);
}

sint32 WonderRecord::GetNeedsFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return m_NeedsFeatToBuild[index];
}

FeatRecord const * WonderRecord::GetNeedsFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsFeatToBuild[index]);
}

sint32 WonderRecord::GetNeedsAnyPlayerFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return m_NeedsAnyPlayerFeatToBuild[index];
}

FeatRecord const * WonderRecord::GetNeedsAnyPlayerFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsAnyPlayerFeatToBuild[index]);
}

MapIconRecord const * WonderRecord::GetShowCityIconTopPtr() const
{
    return g_theMapIconDB->Get(m_ShowCityIconTopValue);
}

MapIconRecord const * WonderRecord::GetShowCityIconBottomPtr() const
{
    return g_theMapIconDB->Get(m_ShowCityIconBottomValue);
}

MapIconRecord const * WonderRecord::GetIsReligionIconPtr() const
{
    return g_theMapIconDB->Get(m_IsReligionIconValue);
}

BuildingRecord const * WonderRecord::GetBuildingEverywherePtr() const
{
    return g_theBuildingDB->Get(m_BuildingEverywhereValue);
}

BuildingRecord const * WonderRecord::GetActualBuildingEverywherePtr() const
{
    return g_theBuildingDB->Get(m_ActualBuildingEverywhereValue);
}

BuildingRecord const * WonderRecord::GetBuildingEffectEverywherePtr() const
{
    return g_theBuildingDB->Get(m_BuildingEffectEverywhereValue);
}

BuildingRecord const * WonderRecord::GetConflictsWithBuildingPtr() const
{
    return g_theBuildingDB->Get(m_ConflictsWithBuildingValue);
}

sint32 WonderRecord::GetBuildingAnywhereIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildingAnywhere);
    if((index < 0) || (index >= m_numBuildingAnywhere)) {
        return 0;
    }
    return m_BuildingAnywhere[index];
}

BuildingRecord const * WonderRecord::GetBuildingAnywhere(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildingAnywhere);
    if((index < 0) || (index >= m_numBuildingAnywhere)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_BuildingAnywhere[index]);
}

sint32 WonderRecord::GetExcludedByBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return m_ExcludedByBuilding[index];
}

BuildingRecord const * WonderRecord::GetExcludedByBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_ExcludedByBuilding[index]);
}

sint32 WonderRecord::GetExcludedByWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return m_ExcludedByWonder[index];
}

WonderRecord const * WonderRecord::GetExcludedByWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_ExcludedByWonder[index]);
}

const BuildingRecord *WonderRecord::BuildingFeat::GetBuilding() const
{
    return g_theBuildingDB->Get(m_Building);
}

const BuildingRecord *WonderRecord::BuildingGold::GetBuilding() const
{
    return g_theBuildingDB->Get(m_Building);
}

