
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "IconRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"


CTPDatabase<IconRecord> *g_theIconDB = NULL;

void IconRecord::Init()
{
    m_Icon = NULL;
    m_Movie = NULL;
    m_Gameplay = NULL;
    m_Historical = NULL;
    m_Prereq = NULL;
    m_Vari = NULL;
    m_FirstFrame = NULL;
    m_StatText = NULL;
    m_LargeIcon = NULL;
    m_SmallIcon = NULL;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void IconRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_Icon;
        archive << m_Movie;
        archive << m_Gameplay;
        archive << m_Historical;
        archive << m_Prereq;
        archive << m_Vari;
        archive << m_FirstFrame;
        archive << m_StatText;
        archive << m_LargeIcon;
        archive << m_SmallIcon;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        m_Icon = NULL;
        archive >> m_Icon;

        m_Movie = NULL;
        archive >> m_Movie;

        m_Gameplay = NULL;
        archive >> m_Gameplay;

        m_Historical = NULL;
        archive >> m_Historical;

        m_Prereq = NULL;
        archive >> m_Prereq;

        m_Vari = NULL;
        archive >> m_Vari;

        m_FirstFrame = NULL;
        archive >> m_FirstFrame;

        m_StatText = NULL;
        archive >> m_StatText;

        m_LargeIcon = NULL;
        archive >> m_LargeIcon;

        m_SmallIcon = NULL;
        archive >> m_SmallIcon;

    }
}

IconRecord::~IconRecord()
{
    delete m_Icon;
    delete m_Movie;
    delete m_Gameplay;
    delete m_Historical;
    delete m_Prereq;
    delete m_Vari;
    delete m_FirstFrame;
    delete m_StatText;
    delete m_LargeIcon;
    delete m_SmallIcon;
}

IconRecord const & IconRecord::operator = (IconRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        delete [] m_Icon;
        m_Icon = NULL;

        if (rval.m_Icon)
        {
            m_Icon = new char [strlen(rval.m_Icon)+1];
            strcpy(m_Icon, rval.m_Icon);
        }

        delete [] m_Movie;
        m_Movie = NULL;

        if (rval.m_Movie)
        {
            m_Movie = new char [strlen(rval.m_Movie)+1];
            strcpy(m_Movie, rval.m_Movie);
        }

        delete [] m_Gameplay;
        m_Gameplay = NULL;

        if (rval.m_Gameplay)
        {
            m_Gameplay = new char [strlen(rval.m_Gameplay)+1];
            strcpy(m_Gameplay, rval.m_Gameplay);
        }

        delete [] m_Historical;
        m_Historical = NULL;

        if (rval.m_Historical)
        {
            m_Historical = new char [strlen(rval.m_Historical)+1];
            strcpy(m_Historical, rval.m_Historical);
        }

        delete [] m_Prereq;
        m_Prereq = NULL;

        if (rval.m_Prereq)
        {
            m_Prereq = new char [strlen(rval.m_Prereq)+1];
            strcpy(m_Prereq, rval.m_Prereq);
        }

        delete [] m_Vari;
        m_Vari = NULL;

        if (rval.m_Vari)
        {
            m_Vari = new char [strlen(rval.m_Vari)+1];
            strcpy(m_Vari, rval.m_Vari);
        }

        delete [] m_FirstFrame;
        m_FirstFrame = NULL;

        if (rval.m_FirstFrame)
        {
            m_FirstFrame = new char [strlen(rval.m_FirstFrame)+1];
            strcpy(m_FirstFrame, rval.m_FirstFrame);
        }

        delete [] m_StatText;
        m_StatText = NULL;

        if (rval.m_StatText)
        {
            m_StatText = new char [strlen(rval.m_StatText)+1];
            strcpy(m_StatText, rval.m_StatText);
        }

        delete [] m_LargeIcon;
        m_LargeIcon = NULL;

        if (rval.m_LargeIcon)
        {
            m_LargeIcon = new char [strlen(rval.m_LargeIcon)+1];
            strcpy(m_LargeIcon, rval.m_LargeIcon);
        }

        delete [] m_SmallIcon;
        m_SmallIcon = NULL;

        if (rval.m_SmallIcon)
        {
            m_SmallIcon = new char [strlen(rval.m_SmallIcon)+1];
            strcpy(m_SmallIcon, rval.m_SmallIcon);
        }

    }

    return *this;
}

const char *g_Icon_Tokens[] =
{
    "Icon",
    "Movie",
    "Gameplay",
    "Historical",
    "Prereq",
    "Vari",
    "FirstFrame",
    "StatText",
    "LargeIcon",
    "SmallIcon",
};

IconRecordAccessorInfo g_IconRecord_Accessors[] =
{
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Icon */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Movie */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Gameplay */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Historical */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Prereq */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Vari */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FirstFrame */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StatText */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LargeIcon */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SmallIcon */
};

#define k_Token_Icon_Icon                        ((k_Token_Custom_Base) + 0)
#define k_Token_Icon_Movie                       ((k_Token_Custom_Base) + 1)
#define k_Token_Icon_Gameplay                    ((k_Token_Custom_Base) + 2)
#define k_Token_Icon_Historical                  ((k_Token_Custom_Base) + 3)
#define k_Token_Icon_Prereq                      ((k_Token_Custom_Base) + 4)
#define k_Token_Icon_Vari                        ((k_Token_Custom_Base) + 5)
#define k_Token_Icon_FirstFrame                  ((k_Token_Custom_Base) + 6)
#define k_Token_Icon_StatText                    ((k_Token_Custom_Base) + 7)
#define k_Token_Icon_LargeIcon                   ((k_Token_Custom_Base) + 8)
#define k_Token_Icon_SmallIcon                   ((k_Token_Custom_Base) + 9)
#define k_Token_Icon_Max                         ((k_Token_Custom_Base) + 10)


static BitArray s_ParsedTokens(10);
void IconRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Icon_Icon - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Icon missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Movie - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Movie missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Gameplay - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Gameplay missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Historical - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Historical missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Prereq - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Prereq missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Vari - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Vari missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_FirstFrame - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field FirstFrame missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_StatText - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field StatText missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_LargeIcon - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field LargeIcon missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_SmallIcon - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field SmallIcon missing"));
    }
}

sint32 IconRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Icon_Tokens, k_Token_Icon_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "ICON_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Icon_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Icon_Icon:
                if(!lex->GetFileAssignment(m_Icon)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Movie:
                if(!lex->GetFileAssignment(m_Movie)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Gameplay:
                if(!lex->GetFileAssignment(m_Gameplay)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Historical:
                if(!lex->GetFileAssignment(m_Historical)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Prereq:
                if(!lex->GetFileAssignment(m_Prereq)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Vari:
                if(!lex->GetFileAssignment(m_Vari)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_FirstFrame:
                if(!lex->GetFileAssignment(m_FirstFrame)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_StatText:
                if(!lex->GetFileAssignment(m_StatText)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_LargeIcon:
                if(!lex->GetFileAssignment(m_LargeIcon)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_SmallIcon:
                if(!lex->GetFileAssignment(m_SmallIcon)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFile(m_Icon)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void IconRecord::ResolveDBReferences()
{
}

void IconRecord::Merge(const IconRecord & rval){
}

