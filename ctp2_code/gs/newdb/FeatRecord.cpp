
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "FeatRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "AdvanceRecord.h"
#include "WonderRecord.h"
#include "GovernmentRecord.h"
#include "AdvanceRecord.h"
#include "WonderRecord.h"
#include "AdvanceRecord.h"
#include "BuildingRecord.h"
#include "TerrainImprovementRecord.h"

CTPDatabase<FeatRecord> *g_theFeatDB = NULL;

void FeatRecord::Init()
{
    m_flags0 = 0;
    m_Duration = 0;
    m_Description = 0;
    m_SlicMessageValue = NULL;
    m_EffectBoatMovementValue = 0;
    m_EffectCityDefenseBonusValue = 0;
    m_EffectReduceCityWallsValue = 0;
    m_EffectIncreaseCityVisionValue = 0;
    m_EffectIncreaseProductionValue = 0;
    m_EffectIncreaseCommerceValue = 0;
    m_EffectIncreaseHappinessValue = 0;
    m_EffectEliminateDistancePenaltyValue = 0;
    m_EffectIncreaseBoatVisionValue = 0;
    m_EffectIncreaseScienceValue = 0;
    m_EffectIncreaseHitPointsValue = 0;
    m_EffectScriptedTurnValue = NULL;
    m_EffectScriptedCityValue = NULL;
    m_ExcludeAdvance = NULL;
    m_numExcludeAdvance = 0;
    m_ExcludeWonder = NULL;
    m_numExcludeWonder = 0;
    m_ExcludeFeat = NULL;
    m_numExcludeFeat = 0;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_ExcludeFunctionValue = NULL;
    m_CancelAdvance = NULL;
    m_numCancelAdvance = 0;
    m_CancelWonder = NULL;
    m_numCancelWonder = 0;
    m_CancelFeat = NULL;
    m_numCancelFeat = 0;
    m_CancelFunctionValue = NULL;
    memset(&m_BuildingValue, 0, sizeof(m_BuildingValue));
    m_MinimumSizeOfCivValue = 0;
    memset(&m_TileImpValue, 0, sizeof(m_TileImpValue));
    m_GrantAdvance = NULL;
    m_numGrantAdvance = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void FeatRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_Duration;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Description);
            archive << tmpString;
        }

        archive << m_SlicMessageValue;
        archive << m_EffectBoatMovementValue;
        archive << m_EffectCityDefenseBonusValue;
        archive << m_EffectReduceCityWallsValue;
        archive << m_EffectIncreaseCityVisionValue;
        archive << m_EffectIncreaseProductionValue;
        archive << m_EffectIncreaseCommerceValue;
        archive << m_EffectIncreaseHappinessValue;
        archive << m_EffectEliminateDistancePenaltyValue;
        archive << m_EffectIncreaseBoatVisionValue;
        archive << m_EffectIncreaseScienceValue;
        archive << m_EffectIncreaseHitPointsValue;
        archive << m_EffectScriptedTurnValue;
        archive << m_EffectScriptedCityValue;
        archive << m_numExcludeAdvance;
        archive.Store((uint8*)m_ExcludeAdvance, m_numExcludeAdvance * sizeof(sint32));

        archive << m_numExcludeWonder;
        archive.Store((uint8*)m_ExcludeWonder, m_numExcludeWonder * sizeof(sint32));

        archive << m_numExcludeFeat;
        archive.Store((uint8*)m_ExcludeFeat, m_numExcludeFeat * sizeof(sint32));

        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_ExcludeFunctionValue;
        archive << m_numCancelAdvance;
        archive.Store((uint8*)m_CancelAdvance, m_numCancelAdvance * sizeof(sint32));

        archive << m_numCancelWonder;
        archive.Store((uint8*)m_CancelWonder, m_numCancelWonder * sizeof(sint32));

        archive << m_numCancelFeat;
        archive.Store((uint8*)m_CancelFeat, m_numCancelFeat * sizeof(sint32));

        archive << m_CancelFunctionValue;
        m_BuildingValue.Serialize(archive);
        archive << m_MinimumSizeOfCivValue;
        m_TileImpValue.Serialize(archive);
        archive << m_numGrantAdvance;
        archive.Store((uint8*)m_GrantAdvance, m_numGrantAdvance * sizeof(sint32));

    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_Duration;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Description);
            delete[] tmpString;
        }

        m_SlicMessageValue = NULL;
        archive >> m_SlicMessageValue;

        archive >> m_EffectBoatMovementValue;
        archive >> m_EffectCityDefenseBonusValue;
        archive >> m_EffectReduceCityWallsValue;
        archive >> m_EffectIncreaseCityVisionValue;
        archive >> m_EffectIncreaseProductionValue;
        archive >> m_EffectIncreaseCommerceValue;
        archive >> m_EffectIncreaseHappinessValue;
        archive >> m_EffectEliminateDistancePenaltyValue;
        archive >> m_EffectIncreaseBoatVisionValue;
        archive >> m_EffectIncreaseScienceValue;
        archive >> m_EffectIncreaseHitPointsValue;
        m_EffectScriptedTurnValue = NULL;
        archive >> m_EffectScriptedTurnValue;

        m_EffectScriptedCityValue = NULL;
        archive >> m_EffectScriptedCityValue;

        archive >> m_numExcludeAdvance;
        archive.Load((uint8*)m_ExcludeAdvance, m_numExcludeAdvance * sizeof(sint32));

        archive >> m_numExcludeWonder;
        archive.Load((uint8*)m_ExcludeWonder, m_numExcludeWonder * sizeof(sint32));

        archive >> m_numExcludeFeat;
        archive.Load((uint8*)m_ExcludeFeat, m_numExcludeFeat * sizeof(sint32));

        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        m_ExcludeFunctionValue = NULL;
        archive >> m_ExcludeFunctionValue;

        archive >> m_numCancelAdvance;
        archive.Load((uint8*)m_CancelAdvance, m_numCancelAdvance * sizeof(sint32));

        archive >> m_numCancelWonder;
        archive.Load((uint8*)m_CancelWonder, m_numCancelWonder * sizeof(sint32));

        archive >> m_numCancelFeat;
        archive.Load((uint8*)m_CancelFeat, m_numCancelFeat * sizeof(sint32));

        m_CancelFunctionValue = NULL;
        archive >> m_CancelFunctionValue;

        memset((uint8*)&m_BuildingValue, 0, sizeof(m_BuildingValue));
        m_BuildingValue.Serialize(archive);
        archive >> m_MinimumSizeOfCivValue;
        memset((uint8*)&m_TileImpValue, 0, sizeof(m_TileImpValue));
        m_TileImpValue.Serialize(archive);
        archive >> m_numGrantAdvance;
        archive.Load((uint8*)m_GrantAdvance, m_numGrantAdvance * sizeof(sint32));

    }
}

FeatRecord::~FeatRecord()
{
    delete m_SlicMessageValue;
    delete m_EffectScriptedTurnValue;
    delete m_EffectScriptedCityValue;
    delete [] m_ExcludeAdvance;
    delete [] m_ExcludeWonder;
    delete [] m_ExcludeFeat;
    delete [] m_GovernmentsModified;
    delete m_ExcludeFunctionValue;
    delete [] m_CancelAdvance;
    delete [] m_CancelWonder;
    delete [] m_CancelFeat;
    delete m_CancelFunctionValue;
    delete [] m_GrantAdvance;
}

FeatRecord const & FeatRecord::operator = (FeatRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_Duration = rval.m_Duration;

        m_Description = rval.m_Description;

        {
            delete [] m_SlicMessageValue;
            m_SlicMessageValue = new char[strlen(rval.m_SlicMessageValue)+1];
            strcpy(m_SlicMessageValue, rval.m_SlicMessageValue);
        }

        m_EffectBoatMovementValue = rval.m_EffectBoatMovementValue;

        m_EffectCityDefenseBonusValue = rval.m_EffectCityDefenseBonusValue;

        m_EffectReduceCityWallsValue = rval.m_EffectReduceCityWallsValue;

        m_EffectIncreaseCityVisionValue = rval.m_EffectIncreaseCityVisionValue;

        m_EffectIncreaseProductionValue = rval.m_EffectIncreaseProductionValue;

        m_EffectIncreaseCommerceValue = rval.m_EffectIncreaseCommerceValue;

        m_EffectIncreaseHappinessValue = rval.m_EffectIncreaseHappinessValue;

        m_EffectEliminateDistancePenaltyValue = rval.m_EffectEliminateDistancePenaltyValue;

        m_EffectIncreaseBoatVisionValue = rval.m_EffectIncreaseBoatVisionValue;

        m_EffectIncreaseScienceValue = rval.m_EffectIncreaseScienceValue;

        m_EffectIncreaseHitPointsValue = rval.m_EffectIncreaseHitPointsValue;

        {
            delete [] m_EffectScriptedTurnValue;
            m_EffectScriptedTurnValue = new char[strlen(rval.m_EffectScriptedTurnValue)+1];
            strcpy(m_EffectScriptedTurnValue, rval.m_EffectScriptedTurnValue);
        }

        {
            delete [] m_EffectScriptedCityValue;
            m_EffectScriptedCityValue = new char[strlen(rval.m_EffectScriptedCityValue)+1];
            strcpy(m_EffectScriptedCityValue, rval.m_EffectScriptedCityValue);
        }

        delete [] m_ExcludeAdvance;
        m_ExcludeAdvance = NULL;
        if (rval.m_numExcludeAdvance > 0)
        {
            m_ExcludeAdvance = new sint32 [rval.m_numExcludeAdvance];
            std::copy(rval.m_ExcludeAdvance, rval.m_ExcludeAdvance + rval.m_numExcludeAdvance, m_ExcludeAdvance);
        }
        m_numExcludeAdvance = rval.m_numExcludeAdvance;

        delete [] m_ExcludeWonder;
        m_ExcludeWonder = NULL;
        if (rval.m_numExcludeWonder > 0)
        {
            m_ExcludeWonder = new sint32 [rval.m_numExcludeWonder];
            std::copy(rval.m_ExcludeWonder, rval.m_ExcludeWonder + rval.m_numExcludeWonder, m_ExcludeWonder);
        }
        m_numExcludeWonder = rval.m_numExcludeWonder;

        delete [] m_ExcludeFeat;
        m_ExcludeFeat = NULL;
        if (rval.m_numExcludeFeat > 0)
        {
            m_ExcludeFeat = new sint32 [rval.m_numExcludeFeat];
            std::copy(rval.m_ExcludeFeat, rval.m_ExcludeFeat + rval.m_numExcludeFeat, m_ExcludeFeat);
        }
        m_numExcludeFeat = rval.m_numExcludeFeat;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        {
            delete [] m_ExcludeFunctionValue;
            m_ExcludeFunctionValue = new char[strlen(rval.m_ExcludeFunctionValue)+1];
            strcpy(m_ExcludeFunctionValue, rval.m_ExcludeFunctionValue);
        }

        delete [] m_CancelAdvance;
        m_CancelAdvance = NULL;
        if (rval.m_numCancelAdvance > 0)
        {
            m_CancelAdvance = new sint32 [rval.m_numCancelAdvance];
            std::copy(rval.m_CancelAdvance, rval.m_CancelAdvance + rval.m_numCancelAdvance, m_CancelAdvance);
        }
        m_numCancelAdvance = rval.m_numCancelAdvance;

        delete [] m_CancelWonder;
        m_CancelWonder = NULL;
        if (rval.m_numCancelWonder > 0)
        {
            m_CancelWonder = new sint32 [rval.m_numCancelWonder];
            std::copy(rval.m_CancelWonder, rval.m_CancelWonder + rval.m_numCancelWonder, m_CancelWonder);
        }
        m_numCancelWonder = rval.m_numCancelWonder;

        delete [] m_CancelFeat;
        m_CancelFeat = NULL;
        if (rval.m_numCancelFeat > 0)
        {
            m_CancelFeat = new sint32 [rval.m_numCancelFeat];
            std::copy(rval.m_CancelFeat, rval.m_CancelFeat + rval.m_numCancelFeat, m_CancelFeat);
        }
        m_numCancelFeat = rval.m_numCancelFeat;

        {
            delete [] m_CancelFunctionValue;
            m_CancelFunctionValue = new char[strlen(rval.m_CancelFunctionValue)+1];
            strcpy(m_CancelFunctionValue, rval.m_CancelFunctionValue);
        }

        m_BuildingValue = rval.m_BuildingValue;

        m_MinimumSizeOfCivValue = rval.m_MinimumSizeOfCivValue;

        m_TileImpValue = rval.m_TileImpValue;

        delete [] m_GrantAdvance;
        m_GrantAdvance = NULL;
        if (rval.m_numGrantAdvance > 0)
        {
            m_GrantAdvance = new sint32 [rval.m_numGrantAdvance];
            std::copy(rval.m_GrantAdvance, rval.m_GrantAdvance + rval.m_numGrantAdvance, m_GrantAdvance);
        }
        m_numGrantAdvance = rval.m_numGrantAdvance;

    }

    return *this;
}

const char *g_Feat_Tokens[] =
{
    "Duration",
    "Description",
    "SlicMessage",
    "SlicMessageValue",
    "EffectBoatMovement",
    "EffectBoatMovementValue",
    "EffectCityDefenseBonus",
    "EffectCityDefenseBonusValue",
    "EffectReduceCityWalls",
    "EffectReduceCityWallsValue",
    "EffectIncreaseCityVision",
    "EffectIncreaseCityVisionValue",
    "EffectIncreaseProduction",
    "EffectIncreaseProductionValue",
    "EffectIncreaseCommerce",
    "EffectIncreaseCommerceValue",
    "EffectIncreaseHappiness",
    "EffectIncreaseHappinessValue",
    "EffectEliminateDistancePenalty",
    "EffectEliminateDistancePenaltyValue",
    "EffectIncreaseBoatVision",
    "EffectIncreaseBoatVisionValue",
    "EffectIncreaseScience",
    "EffectIncreaseScienceValue",
    "EffectGiveMaps",
    "EffectIncreaseHitPoints",
    "EffectIncreaseHitPointsValue",
    "EffectScriptedTurn",
    "EffectScriptedTurnValue",
    "EffectScriptedCity",
    "EffectScriptedCityValue",
    "ExcludeAdvance",
    "ExcludeWonder",
    "ExcludeFeat",
    "GovernmentsModified",
    "ExcludeFunction",
    "ExcludeFunctionValue",
    "CancelAdvance",
    "CancelWonder",
    "CancelFeat",
    "CancelFunction",
    "CancelFunctionValue",
    "Building",
    "BuildingValue",
    "MinimumSizeOfCiv",
    "MinimumSizeOfCivValue",
    "TileImp",
    "TileImpValue",
    "GrantAdvance",
};

FeatRecordAccessorInfo g_FeatRecord_Accessors[] =
{
    { &FeatRecord::GetDuration, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Description */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlicMessage */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlicMessage */
    { NULL, NULL, NULL, &FeatRecord::GetEffectBoatMovement, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectBoatMovement */
    { NULL, NULL, NULL, &FeatRecord::GetEffectCityDefenseBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectCityDefenseBonus */
    { NULL, NULL, NULL, &FeatRecord::GetEffectReduceCityWalls, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectReduceCityWalls */
    { NULL, NULL, NULL, &FeatRecord::GetEffectIncreaseCityVision, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectIncreaseCityVision */
    { NULL, NULL, NULL, &FeatRecord::GetEffectIncreaseProduction, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectIncreaseProduction */
    { NULL, NULL, NULL, &FeatRecord::GetEffectIncreaseCommerce, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectIncreaseCommerce */
    { NULL, NULL, NULL, &FeatRecord::GetEffectIncreaseHappiness, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectIncreaseHappiness */
    { NULL, NULL, NULL, &FeatRecord::GetEffectEliminateDistancePenalty, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectEliminateDistancePenalty */
    { NULL, NULL, NULL, &FeatRecord::GetEffectIncreaseBoatVision, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectIncreaseBoatVision */
    { NULL, NULL, NULL, &FeatRecord::GetEffectIncreaseScience, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectIncreaseScience */
    { NULL, &FeatRecord::GetEffectGiveMaps, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &FeatRecord::GetEffectIncreaseHitPoints, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectIncreaseHitPoints */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectScriptedTurn */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectScriptedTurn */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectScriptedCity */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EffectScriptedCity */
    { &FeatRecord::GetNumExcludeAdvance, NULL, NULL, NULL, NULL, &FeatRecord::GetExcludeAdvanceIndex, NULL}, /* ExcludeAdvance (array) */
    { &FeatRecord::GetNumExcludeWonder, NULL, NULL, NULL, NULL, &FeatRecord::GetExcludeWonderIndex, NULL}, /* ExcludeWonder (array) */
    { &FeatRecord::GetNumExcludeFeat, NULL, NULL, NULL, NULL, &FeatRecord::GetExcludeFeatIndex, NULL}, /* ExcludeFeat (array) */
    { &FeatRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &FeatRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ExcludeFunction */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ExcludeFunction */
    { &FeatRecord::GetNumCancelAdvance, NULL, NULL, NULL, NULL, &FeatRecord::GetCancelAdvanceIndex, NULL}, /* CancelAdvance (array) */
    { &FeatRecord::GetNumCancelWonder, NULL, NULL, NULL, NULL, &FeatRecord::GetCancelWonderIndex, NULL}, /* CancelWonder (array) */
    { &FeatRecord::GetNumCancelFeat, NULL, NULL, NULL, NULL, &FeatRecord::GetCancelFeatIndex, NULL}, /* CancelFeat (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CancelFunction */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CancelFunction */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Building */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Building */
    { NULL, NULL, NULL, &FeatRecord::GetMinimumSizeOfCiv, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MinimumSizeOfCiv */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TileImp */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TileImp */
    { &FeatRecord::GetNumGrantAdvance, NULL, NULL, NULL, NULL, &FeatRecord::GetGrantAdvanceIndex, NULL}, /* GrantAdvance (array) */
};

#define k_Token_Feat_Duration                    ((k_Token_Custom_Base) + 0)
#define k_Token_Feat_Description                 ((k_Token_Custom_Base) + 1)
#define k_Token_Feat_SlicMessage                 ((k_Token_Custom_Base) + 2)
#define k_Token_Feat_SlicMessage_Value           ((k_Token_Custom_Base) + 3)
#define k_Token_Feat_EffectBoatMovement          ((k_Token_Custom_Base) + 4)
#define k_Token_Feat_EffectBoatMovement_Value    ((k_Token_Custom_Base) + 5)
#define k_Token_Feat_EffectCityDefenseBonus      ((k_Token_Custom_Base) + 6)
#define k_Token_Feat_EffectCityDefenseBonus_Value ((k_Token_Custom_Base) + 7)
#define k_Token_Feat_EffectReduceCityWalls       ((k_Token_Custom_Base) + 8)
#define k_Token_Feat_EffectReduceCityWalls_Value ((k_Token_Custom_Base) + 9)
#define k_Token_Feat_EffectIncreaseCityVision    ((k_Token_Custom_Base) + 10)
#define k_Token_Feat_EffectIncreaseCityVision_Value ((k_Token_Custom_Base) + 11)
#define k_Token_Feat_EffectIncreaseProduction    ((k_Token_Custom_Base) + 12)
#define k_Token_Feat_EffectIncreaseProduction_Value ((k_Token_Custom_Base) + 13)
#define k_Token_Feat_EffectIncreaseCommerce      ((k_Token_Custom_Base) + 14)
#define k_Token_Feat_EffectIncreaseCommerce_Value ((k_Token_Custom_Base) + 15)
#define k_Token_Feat_EffectIncreaseHappiness     ((k_Token_Custom_Base) + 16)
#define k_Token_Feat_EffectIncreaseHappiness_Value ((k_Token_Custom_Base) + 17)
#define k_Token_Feat_EffectEliminateDistancePenalty ((k_Token_Custom_Base) + 18)
#define k_Token_Feat_EffectEliminateDistancePenalty_Value ((k_Token_Custom_Base) + 19)
#define k_Token_Feat_EffectIncreaseBoatVision    ((k_Token_Custom_Base) + 20)
#define k_Token_Feat_EffectIncreaseBoatVision_Value ((k_Token_Custom_Base) + 21)
#define k_Token_Feat_EffectIncreaseScience       ((k_Token_Custom_Base) + 22)
#define k_Token_Feat_EffectIncreaseScience_Value ((k_Token_Custom_Base) + 23)
#define k_Token_Feat_EffectGiveMaps              ((k_Token_Custom_Base) + 24)
#define k_Token_Feat_EffectIncreaseHitPoints     ((k_Token_Custom_Base) + 25)
#define k_Token_Feat_EffectIncreaseHitPoints_Value ((k_Token_Custom_Base) + 26)
#define k_Token_Feat_EffectScriptedTurn          ((k_Token_Custom_Base) + 27)
#define k_Token_Feat_EffectScriptedTurn_Value    ((k_Token_Custom_Base) + 28)
#define k_Token_Feat_EffectScriptedCity          ((k_Token_Custom_Base) + 29)
#define k_Token_Feat_EffectScriptedCity_Value    ((k_Token_Custom_Base) + 30)
#define k_Token_Feat_ExcludeAdvance              ((k_Token_Custom_Base) + 31)
#define k_Token_Feat_ExcludeWonder               ((k_Token_Custom_Base) + 32)
#define k_Token_Feat_ExcludeFeat                 ((k_Token_Custom_Base) + 33)
#define k_Token_Feat_GovernmentsModified         ((k_Token_Custom_Base) + 34)
#define k_Token_Feat_ExcludeFunction             ((k_Token_Custom_Base) + 35)
#define k_Token_Feat_ExcludeFunction_Value       ((k_Token_Custom_Base) + 36)
#define k_Token_Feat_CancelAdvance               ((k_Token_Custom_Base) + 37)
#define k_Token_Feat_CancelWonder                ((k_Token_Custom_Base) + 38)
#define k_Token_Feat_CancelFeat                  ((k_Token_Custom_Base) + 39)
#define k_Token_Feat_CancelFunction              ((k_Token_Custom_Base) + 40)
#define k_Token_Feat_CancelFunction_Value        ((k_Token_Custom_Base) + 41)
#define k_Token_Feat_Building                    ((k_Token_Custom_Base) + 42)
#define k_Token_Feat_Building_Value              ((k_Token_Custom_Base) + 43)
#define k_Token_Feat_MinimumSizeOfCiv            ((k_Token_Custom_Base) + 44)
#define k_Token_Feat_MinimumSizeOfCiv_Value      ((k_Token_Custom_Base) + 45)
#define k_Token_Feat_TileImp                     ((k_Token_Custom_Base) + 46)
#define k_Token_Feat_TileImp_Value               ((k_Token_Custom_Base) + 47)
#define k_Token_Feat_GrantAdvance                ((k_Token_Custom_Base) + 48)
#define k_Token_Feat_Max                         ((k_Token_Custom_Base) + 49)


static BitArray s_ParsedTokens(49);
void FeatRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Feat_Duration - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Duration missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Feat_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
}

sint32 FeatRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Feat_Tokens, k_Token_Feat_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "FEAT_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Feat_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Feat_Duration:
                if(!lex->GetIntAssignment(m_Duration)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_SlicMessage:
                m_flags0 |= k_Feat_SlicMessage_Bit;
                if(!lex->GetFileAssignment(m_SlicMessageValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectBoatMovement:
                m_flags0 |= k_Feat_EffectBoatMovement_Bit;
                if(!lex->GetIntAssignment(m_EffectBoatMovementValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectCityDefenseBonus:
                m_flags0 |= k_Feat_EffectCityDefenseBonus_Bit;
                if(!lex->GetIntAssignment(m_EffectCityDefenseBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectReduceCityWalls:
                m_flags0 |= k_Feat_EffectReduceCityWalls_Bit;
                if(!lex->GetIntAssignment(m_EffectReduceCityWallsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseCityVision:
                m_flags0 |= k_Feat_EffectIncreaseCityVision_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseCityVisionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseProduction:
                m_flags0 |= k_Feat_EffectIncreaseProduction_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseProductionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseCommerce:
                m_flags0 |= k_Feat_EffectIncreaseCommerce_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseCommerceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseHappiness:
                m_flags0 |= k_Feat_EffectIncreaseHappiness_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseHappinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectEliminateDistancePenalty:
                m_flags0 |= k_Feat_EffectEliminateDistancePenalty_Bit;
                if(!lex->GetIntAssignment(m_EffectEliminateDistancePenaltyValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseBoatVision:
                m_flags0 |= k_Feat_EffectIncreaseBoatVision_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseBoatVisionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseScience:
                m_flags0 |= k_Feat_EffectIncreaseScience_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseScienceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectGiveMaps:
                m_flags0 |= k_Feat_EffectGiveMaps_Bit;
                break;
            case k_Token_Feat_EffectIncreaseHitPoints:
                m_flags0 |= k_Feat_EffectIncreaseHitPoints_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseHitPointsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectScriptedTurn:
                m_flags0 |= k_Feat_EffectScriptedTurn_Bit;
                if(!lex->GetFileAssignment(m_EffectScriptedTurnValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectScriptedCity:
                m_flags0 |= k_Feat_EffectScriptedCity_Bit;
                if(!lex->GetFileAssignment(m_EffectScriptedCityValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludeAdvance, &m_numExcludeAdvance))
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludeWonder, &m_numExcludeWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeFeat:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludeFeat, &m_numExcludeFeat))
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeFunction:
                m_flags0 |= k_Feat_ExcludeFunction_Bit;
                if(!lex->GetFileAssignment(m_ExcludeFunctionValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_CancelAdvance, &m_numCancelAdvance))
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_CancelWonder, &m_numCancelWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelFeat:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_CancelFeat, &m_numCancelFeat))
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelFunction:
                m_flags0 |= k_Feat_CancelFunction_Bit;
                if(!lex->GetFileAssignment(m_CancelFunctionValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_Building:
                m_flags0 |= k_Feat_Building_Bit;
                if(!m_BuildingValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_MinimumSizeOfCiv:
                m_flags0 |= k_Feat_MinimumSizeOfCiv_Bit;
                if(!lex->GetIntAssignment(m_MinimumSizeOfCivValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_TileImp:
                m_flags0 |= k_Feat_TileImp_Bit;
                if(!m_TileImpValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_GrantAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_GrantAdvance, &m_numGrantAdvance))
                {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Duration)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void FeatRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numExcludeAdvance; i++) {
            if(m_ExcludeAdvance[i] & 0x80000000) {
                sint32 id = m_ExcludeAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ExcludeAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludeAdvance[i] == 0x7fffffff){
                m_ExcludeAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludeWonder; i++) {
            if(m_ExcludeWonder[i] & 0x80000000) {
                sint32 id = m_ExcludeWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_ExcludeWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludeWonder[i] == 0x7fffffff){
                m_ExcludeWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludeFeat; i++) {
            if(m_ExcludeFeat[i] & 0x80000000) {
                sint32 id = m_ExcludeFeat[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_ExcludeFeat[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludeFeat[i] == 0x7fffffff){
                m_ExcludeFeat[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCancelAdvance; i++) {
            if(m_CancelAdvance[i] & 0x80000000) {
                sint32 id = m_CancelAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_CancelAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CancelAdvance[i] == 0x7fffffff){
                m_CancelAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCancelWonder; i++) {
            if(m_CancelWonder[i] & 0x80000000) {
                sint32 id = m_CancelWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_CancelWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CancelWonder[i] == 0x7fffffff){
                m_CancelWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCancelFeat; i++) {
            if(m_CancelFeat[i] & 0x80000000) {
                sint32 id = m_CancelFeat[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_CancelFeat[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CancelFeat[i] == 0x7fffffff){
                m_CancelFeat[i] = -1;
            }
        }
    }
    m_BuildingValue.ResolveDBReferences();
    m_TileImpValue.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numGrantAdvance; i++) {
            if(m_GrantAdvance[i] & 0x80000000) {
                sint32 id = m_GrantAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_GrantAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GrantAdvance[i] == 0x7fffffff){
                m_GrantAdvance[i] = -1;
            }
        }
    }
}

FeatRecord::BuildingFeat::BuildingFeat()
{
    m_flags0 = 0;
    m_Building = 0x7fffffff;
    m_NumValue = 0;
    m_PercentCitiesValue = 0;
}

FeatRecord::BuildingFeat::~BuildingFeat()
{
}

FeatRecord::BuildingFeat const & FeatRecord::BuildingFeat::operator = (BuildingFeat const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Building = rval.m_Building;

        m_NumValue = rval.m_NumValue;

        m_PercentCitiesValue = rval.m_PercentCitiesValue;

    }

    return *this;
}

void FeatRecord::BuildingFeat::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Building;
        archive << m_NumValue;
        archive << m_PercentCitiesValue;
    } else {
        archive >> m_flags0;
        archive >> m_Building;
        archive >> m_NumValue;
        archive >> m_PercentCitiesValue;
    }
}

static const char *s_Feat_BuildingFeat_Tokens[] = {
    "Building",
    "Num",
    "PercentCities",
};
#define k_Token_Feat_BuildingFeat_Building       ((k_Token_Custom_Base) + 0)
#define k_Token_Feat_BuildingFeat_Num            ((k_Token_Custom_Base) + 1)
#define k_Token_Feat_BuildingFeat_PercentCities  ((k_Token_Custom_Base) + 2)
#define k_Token_Feat_BuildingFeat_Max ((k_Token_Custom_Base) + 3)
sint32 FeatRecord::BuildingFeat::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildingFeat"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Feat_BuildingFeat_Tokens, k_Token_Feat_BuildingFeat_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Feat_BuildingFeat_Building:
                if (!g_theBuildingDB->GetRecordFromLexer(lex, m_Building)) {
                    done = true; break;
                }
                break;
            case k_Token_Feat_BuildingFeat_Num:
                m_flags0 |= k_BuildingFeat_Num_Bit;
                if(!lex->GetIntAssignment(m_NumValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_BuildingFeat_PercentCities:
                m_flags0 |= k_BuildingFeat_PercentCities_Bit;
                if(!lex->GetIntAssignment(m_PercentCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theBuildingDB->GetCurrentRecordFromLexer(lex, m_Building)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 FeatRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildingFeat *oldArray = *array;
        *array = new BuildingFeat[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildingFeat[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 FeatRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void FeatRecord::BuildingFeat::ResolveDBReferences()
{
    if(m_Building & 0x80000000) {
        sint32 id = m_Building & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_Building)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Building == 0x7fffffff) {
        m_Building = -1;
    }
}

FeatRecord::InfrastructureFeat::InfrastructureFeat()
{
    m_flags0 = 0;
    m_TileImp = 0x7fffffff;
    m_NumValue = 0;
}

FeatRecord::InfrastructureFeat::~InfrastructureFeat()
{
}

FeatRecord::InfrastructureFeat const & FeatRecord::InfrastructureFeat::operator = (InfrastructureFeat const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_TileImp = rval.m_TileImp;

        m_NumValue = rval.m_NumValue;

    }

    return *this;
}

void FeatRecord::InfrastructureFeat::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_TileImp;
        archive << m_NumValue;
    } else {
        archive >> m_flags0;
        archive >> m_TileImp;
        archive >> m_NumValue;
    }
}

static const char *s_Feat_InfrastructureFeat_Tokens[] = {
    "TileImp",
    "Num",
};
#define k_Token_Feat_InfrastructureFeat_TileImp  ((k_Token_Custom_Base) + 0)
#define k_Token_Feat_InfrastructureFeat_Num      ((k_Token_Custom_Base) + 1)
#define k_Token_Feat_InfrastructureFeat_Max ((k_Token_Custom_Base) + 2)
sint32 FeatRecord::InfrastructureFeat::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for InfrastructureFeat"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Feat_InfrastructureFeat_Tokens, k_Token_Feat_InfrastructureFeat_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Feat_InfrastructureFeat_TileImp:
                if (!g_theTerrainImprovementDB->GetRecordFromLexer(lex, m_TileImp)) {
                    done = true; break;
                }
                break;
            case k_Token_Feat_InfrastructureFeat_Num:
                m_flags0 |= k_InfrastructureFeat_Num_Bit;
                if(!lex->GetIntAssignment(m_NumValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theTerrainImprovementDB->GetCurrentRecordFromLexer(lex, m_TileImp)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 FeatRecord::InfrastructureFeat::ParseInArray(DBLexer *lex, InfrastructureFeat **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InfrastructureFeat *oldArray = *array;
        *array = new InfrastructureFeat[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InfrastructureFeat[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 FeatRecord::InfrastructureFeat::ParseInArray(DBLexer *lex, InfrastructureFeat *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void FeatRecord::InfrastructureFeat::ResolveDBReferences()
{
    if(m_TileImp & 0x80000000) {
        sint32 id = m_TileImp & 0x7fffffff;
        if(!g_theTerrainImprovementDB->GetNamedItem(id, m_TileImp)) {
            c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_TileImp == 0x7fffffff) {
        m_TileImp = -1;
    }
}

void FeatRecord::Merge(const FeatRecord & rval){
    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_SlicMessage_Bit)
    {
        delete m_SlicMessageValue;
        m_SlicMessageValue = new char[strlen(rval.m_SlicMessageValue)+1];
        strcpy(m_SlicMessageValue, rval.m_SlicMessageValue);
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectBoatMovement_Bit)
    {
        m_EffectBoatMovementValue = rval.m_EffectBoatMovementValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectCityDefenseBonus_Bit)
    {
        m_EffectCityDefenseBonusValue = rval.m_EffectCityDefenseBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectReduceCityWalls_Bit)
    {
        m_EffectReduceCityWallsValue = rval.m_EffectReduceCityWallsValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectIncreaseCityVision_Bit)
    {
        m_EffectIncreaseCityVisionValue = rval.m_EffectIncreaseCityVisionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectIncreaseProduction_Bit)
    {
        m_EffectIncreaseProductionValue = rval.m_EffectIncreaseProductionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectIncreaseCommerce_Bit)
    {
        m_EffectIncreaseCommerceValue = rval.m_EffectIncreaseCommerceValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectIncreaseHappiness_Bit)
    {
        m_EffectIncreaseHappinessValue = rval.m_EffectIncreaseHappinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectEliminateDistancePenalty_Bit)
    {
        m_EffectEliminateDistancePenaltyValue = rval.m_EffectEliminateDistancePenaltyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectIncreaseBoatVision_Bit)
    {
        m_EffectIncreaseBoatVisionValue = rval.m_EffectIncreaseBoatVisionValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectIncreaseScience_Bit)
    {
        m_EffectIncreaseScienceValue = rval.m_EffectIncreaseScienceValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectIncreaseHitPoints_Bit)
    {
        m_EffectIncreaseHitPointsValue = rval.m_EffectIncreaseHitPointsValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectScriptedTurn_Bit)
    {
        delete m_EffectScriptedTurnValue;
        m_EffectScriptedTurnValue = new char[strlen(rval.m_EffectScriptedTurnValue)+1];
        strcpy(m_EffectScriptedTurnValue, rval.m_EffectScriptedTurnValue);
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_EffectScriptedCity_Bit)
    {
        delete m_EffectScriptedCityValue;
        m_EffectScriptedCityValue = new char[strlen(rval.m_EffectScriptedCityValue)+1];
        strcpy(m_EffectScriptedCityValue, rval.m_EffectScriptedCityValue);
    }

    // resize m_ExcludeAdvance if necessary
    if (rval.m_numExcludeAdvance > m_numExcludeAdvance)
    {
        delete [] m_ExcludeAdvance;
        m_ExcludeAdvance = NULL;
        if (rval.m_numExcludeAdvance > 0)
            m_ExcludeAdvance = new sint32 [rval.m_numExcludeAdvance];
        m_numExcludeAdvance = rval.m_numExcludeAdvance;
    }
    if (rval.m_numExcludeAdvance > 0)
        std::copy(rval.m_ExcludeAdvance, rval.m_ExcludeAdvance + rval.m_numExcludeAdvance, m_ExcludeAdvance);

    // resize m_ExcludeWonder if necessary
    if (rval.m_numExcludeWonder > m_numExcludeWonder)
    {
        delete [] m_ExcludeWonder;
        m_ExcludeWonder = NULL;
        if (rval.m_numExcludeWonder > 0)
            m_ExcludeWonder = new sint32 [rval.m_numExcludeWonder];
        m_numExcludeWonder = rval.m_numExcludeWonder;
    }
    if (rval.m_numExcludeWonder > 0)
        std::copy(rval.m_ExcludeWonder, rval.m_ExcludeWonder + rval.m_numExcludeWonder, m_ExcludeWonder);

    // resize m_ExcludeFeat if necessary
    if (rval.m_numExcludeFeat > m_numExcludeFeat)
    {
        delete [] m_ExcludeFeat;
        m_ExcludeFeat = NULL;
        if (rval.m_numExcludeFeat > 0)
            m_ExcludeFeat = new sint32 [rval.m_numExcludeFeat];
        m_numExcludeFeat = rval.m_numExcludeFeat;
    }
    if (rval.m_numExcludeFeat > 0)
        std::copy(rval.m_ExcludeFeat, rval.m_ExcludeFeat + rval.m_numExcludeFeat, m_ExcludeFeat);

    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_ExcludeFunction_Bit)
    {
        delete m_ExcludeFunctionValue;
        m_ExcludeFunctionValue = new char[strlen(rval.m_ExcludeFunctionValue)+1];
        strcpy(m_ExcludeFunctionValue, rval.m_ExcludeFunctionValue);
    }

    // resize m_CancelAdvance if necessary
    if (rval.m_numCancelAdvance > m_numCancelAdvance)
    {
        delete [] m_CancelAdvance;
        m_CancelAdvance = NULL;
        if (rval.m_numCancelAdvance > 0)
            m_CancelAdvance = new sint32 [rval.m_numCancelAdvance];
        m_numCancelAdvance = rval.m_numCancelAdvance;
    }
    if (rval.m_numCancelAdvance > 0)
        std::copy(rval.m_CancelAdvance, rval.m_CancelAdvance + rval.m_numCancelAdvance, m_CancelAdvance);

    // resize m_CancelWonder if necessary
    if (rval.m_numCancelWonder > m_numCancelWonder)
    {
        delete [] m_CancelWonder;
        m_CancelWonder = NULL;
        if (rval.m_numCancelWonder > 0)
            m_CancelWonder = new sint32 [rval.m_numCancelWonder];
        m_numCancelWonder = rval.m_numCancelWonder;
    }
    if (rval.m_numCancelWonder > 0)
        std::copy(rval.m_CancelWonder, rval.m_CancelWonder + rval.m_numCancelWonder, m_CancelWonder);

    // resize m_CancelFeat if necessary
    if (rval.m_numCancelFeat > m_numCancelFeat)
    {
        delete [] m_CancelFeat;
        m_CancelFeat = NULL;
        if (rval.m_numCancelFeat > 0)
            m_CancelFeat = new sint32 [rval.m_numCancelFeat];
        m_numCancelFeat = rval.m_numCancelFeat;
    }
    if (rval.m_numCancelFeat > 0)
        std::copy(rval.m_CancelFeat, rval.m_CancelFeat + rval.m_numCancelFeat, m_CancelFeat);

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_CancelFunction_Bit)
    {
        delete m_CancelFunctionValue;
        m_CancelFunctionValue = new char[strlen(rval.m_CancelFunctionValue)+1];
        strcpy(m_CancelFunctionValue, rval.m_CancelFunctionValue);
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_Building_Bit)
    {
        m_BuildingValue = rval.m_BuildingValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_MinimumSizeOfCiv_Bit)
    {
        m_MinimumSizeOfCivValue = rval.m_MinimumSizeOfCivValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Feat_TileImp_Bit)
    {
        m_TileImpValue = rval.m_TileImpValue;
    }

    // resize m_GrantAdvance if necessary
    if (rval.m_numGrantAdvance > m_numGrantAdvance)
    {
        delete [] m_GrantAdvance;
        m_GrantAdvance = NULL;
        if (rval.m_numGrantAdvance > 0)
            m_GrantAdvance = new sint32 [rval.m_numGrantAdvance];
        m_numGrantAdvance = rval.m_numGrantAdvance;
    }
    if (rval.m_numGrantAdvance > 0)
        std::copy(rval.m_GrantAdvance, rval.m_GrantAdvance + rval.m_numGrantAdvance, m_GrantAdvance);

}

sint32 FeatRecord::GetExcludeAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeAdvance);
    if((index < 0) || (index >= m_numExcludeAdvance)) {
        return 0;
    }
    return m_ExcludeAdvance[index];
}

AdvanceRecord const * FeatRecord::GetExcludeAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeAdvance);
    if((index < 0) || (index >= m_numExcludeAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ExcludeAdvance[index]);
}

sint32 FeatRecord::GetExcludeWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeWonder);
    if((index < 0) || (index >= m_numExcludeWonder)) {
        return 0;
    }
    return m_ExcludeWonder[index];
}

WonderRecord const * FeatRecord::GetExcludeWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeWonder);
    if((index < 0) || (index >= m_numExcludeWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_ExcludeWonder[index]);
}

sint32 FeatRecord::GetExcludeFeatIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeFeat);
    if((index < 0) || (index >= m_numExcludeFeat)) {
        return 0;
    }
    return m_ExcludeFeat[index];
}

FeatRecord const * FeatRecord::GetExcludeFeat(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeFeat);
    if((index < 0) || (index >= m_numExcludeFeat)) {
        return 0;
    }
    return g_theFeatDB->Get(m_ExcludeFeat[index]);
}

sint32 FeatRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * FeatRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

sint32 FeatRecord::GetCancelAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelAdvance);
    if((index < 0) || (index >= m_numCancelAdvance)) {
        return 0;
    }
    return m_CancelAdvance[index];
}

AdvanceRecord const * FeatRecord::GetCancelAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelAdvance);
    if((index < 0) || (index >= m_numCancelAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_CancelAdvance[index]);
}

sint32 FeatRecord::GetCancelWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelWonder);
    if((index < 0) || (index >= m_numCancelWonder)) {
        return 0;
    }
    return m_CancelWonder[index];
}

WonderRecord const * FeatRecord::GetCancelWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelWonder);
    if((index < 0) || (index >= m_numCancelWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_CancelWonder[index]);
}

sint32 FeatRecord::GetCancelFeatIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelFeat);
    if((index < 0) || (index >= m_numCancelFeat)) {
        return 0;
    }
    return m_CancelFeat[index];
}

FeatRecord const * FeatRecord::GetCancelFeat(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelFeat);
    if((index < 0) || (index >= m_numCancelFeat)) {
        return 0;
    }
    return g_theFeatDB->Get(m_CancelFeat[index]);
}

sint32 FeatRecord::GetGrantAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGrantAdvance);
    if((index < 0) || (index >= m_numGrantAdvance)) {
        return 0;
    }
    return m_GrantAdvance[index];
}

AdvanceRecord const * FeatRecord::GetGrantAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGrantAdvance);
    if((index < 0) || (index >= m_numGrantAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_GrantAdvance[index]);
}

const BuildingRecord *FeatRecord::BuildingFeat::GetBuilding() const
{
    return g_theBuildingDB->Get(m_Building);
}

const TerrainImprovementRecord *FeatRecord::InfrastructureFeat::GetTileImp() const
{
    return g_theTerrainImprovementDB->Get(m_TileImp);
}

