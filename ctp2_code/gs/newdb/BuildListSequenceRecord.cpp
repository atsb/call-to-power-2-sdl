
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "BuildListSequenceRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "WonderBuildListRecord.h"
#include "BuildingBuildListRecord.h"

CTPDatabase<BuildListSequenceRecord> *g_theBuildListSequenceDB = NULL;

void BuildListSequenceRecord::Init()
{
    m_BuildListElement = NULL;
    m_numBuildListElement = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void BuildListSequenceRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }

        {
            archive << m_numBuildListElement;
            for(sint32 i = 0; i < m_numBuildListElement; ++i){
                m_BuildListElement[i].Serialize(archive);
            }
        }

    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }

        {
            archive >> m_numBuildListElement;
            m_BuildListElement = new BuildListElement[m_numBuildListElement];
            for(sint32 i = 0; i < m_numBuildListElement; ++i){
                m_BuildListElement[i].Serialize(archive);
            }
        }

    }
}

BuildListSequenceRecord::~BuildListSequenceRecord()
{
    delete [] m_BuildListElement;
}

BuildListSequenceRecord const & BuildListSequenceRecord::operator = (BuildListSequenceRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        delete [] m_BuildListElement;
        m_BuildListElement = NULL;
        if (rval.m_numBuildListElement > 0)
        {
            m_BuildListElement = new BuildListElement [rval.m_numBuildListElement];
            std::copy(rval.m_BuildListElement, rval.m_BuildListElement + rval.m_numBuildListElement, m_BuildListElement);
        }
        m_numBuildListElement = rval.m_numBuildListElement;

    }

    return *this;
}

const char *g_BuildListSequence_Tokens[] =
{
    "BuildListElement",
};

BuildListSequenceRecordAccessorInfo g_BuildListSequenceRecord_Accessors[] =
{
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildListElement */
};

#define k_Token_BuildListSequence_BuildListElement ((k_Token_Custom_Base) + 0)
#define k_Token_BuildListSequence_Max            ((k_Token_Custom_Base) + 1)


static BitArray s_ParsedTokens(1);
void BuildListSequenceRecord::CheckRequiredFields(DBLexer *lex)
{
}

sint32 BuildListSequenceRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_BuildListSequence_Tokens, k_Token_BuildListSequence_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "BUILDLISTSEQUENCE_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_BuildListSequence_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_BuildListSequence_BuildListElement:
                if(!BuildListSequenceRecord::BuildListElement::ParseInArray(lex, &m_BuildListElement, &m_numBuildListElement))
                {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!BuildListSequenceRecord::BuildListElement::ParseInArray(lex, &m_BuildListElement, &m_numBuildListElement)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void BuildListSequenceRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numBuildListElement; i++) {
            m_BuildListElement[i].ResolveDBReferences();
        }
    }
}

BuildListSequenceRecord::BuildListElement::BuildListElement()
{
    m_flags0 = 0;
    m_WonderBuildListValue = 0;
    m_BuildingBuildListValue = 0;
}

BuildListSequenceRecord::BuildListElement::~BuildListElement()
{
}

BuildListSequenceRecord::BuildListElement const & BuildListSequenceRecord::BuildListElement::operator = (BuildListElement const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_WonderBuildListValue = rval.m_WonderBuildListValue;

        m_BuildingBuildListValue = rval.m_BuildingBuildListValue;

    }

    return *this;
}

void BuildListSequenceRecord::BuildListElement::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_WonderBuildListValue;
        archive << m_BuildingBuildListValue;
    } else {
        archive >> m_flags0;
        archive >> m_WonderBuildListValue;
        archive >> m_BuildingBuildListValue;
    }
}

static const char *s_BuildListSequence_BuildListElement_Tokens[] = {
    "WonderBuildList",
    "BuildingBuildList",
    "AllUnitBuildList",
    "GarrisonUnitBuildList",
    "Capitalization",
    "Infrastructure",
    "Freight",
};
#define k_Token_BuildListSequence_BuildListElement_WonderBuildList ((k_Token_Custom_Base) + 0)
#define k_Token_BuildListSequence_BuildListElement_BuildingBuildList ((k_Token_Custom_Base) + 1)
#define k_Token_BuildListSequence_BuildListElement_AllUnitBuildList ((k_Token_Custom_Base) + 2)
#define k_Token_BuildListSequence_BuildListElement_GarrisonUnitBuildList ((k_Token_Custom_Base) + 3)
#define k_Token_BuildListSequence_BuildListElement_Capitalization ((k_Token_Custom_Base) + 4)
#define k_Token_BuildListSequence_BuildListElement_Infrastructure ((k_Token_Custom_Base) + 5)
#define k_Token_BuildListSequence_BuildListElement_Freight ((k_Token_Custom_Base) + 6)
#define k_Token_BuildListSequence_BuildListElement_Max ((k_Token_Custom_Base) + 7)
sint32 BuildListSequenceRecord::BuildListElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildListElement"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_BuildListSequence_BuildListElement_Tokens, k_Token_BuildListSequence_BuildListElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_BuildListSequence_BuildListElement_WonderBuildList:
                m_flags0 |= k_BuildListElement_WonderBuildList_Bit;
                if(!g_theWonderBuildListDB->GetRecordFromLexer(lex, m_WonderBuildListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_BuildListSequence_BuildListElement_BuildingBuildList:
                m_flags0 |= k_BuildListElement_BuildingBuildList_Bit;
                if(!g_theBuildingBuildListDB->GetRecordFromLexer(lex, m_BuildingBuildListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_BuildListSequence_BuildListElement_AllUnitBuildList:
                m_flags0 |= k_BuildListElement_AllUnitBuildList_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_GarrisonUnitBuildList:
                m_flags0 |= k_BuildListElement_GarrisonUnitBuildList_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_Capitalization:
                m_flags0 |= k_BuildListElement_Capitalization_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_Infrastructure:
                m_flags0 |= k_BuildListElement_Infrastructure_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_Freight:
                m_flags0 |= k_BuildListElement_Freight_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                m_flags0 |= k_BuildListElement_WonderBuildList_Bit;
                if(!g_theWonderBuildListDB->GetRecordFromLexer(lex, m_WonderBuildListValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 BuildListSequenceRecord::BuildListElement::ParseInArray(DBLexer *lex, BuildListElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildListElement *oldArray = *array;
        *array = new BuildListElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildListElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 BuildListSequenceRecord::BuildListElement::ParseInArray(DBLexer *lex, BuildListElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void BuildListSequenceRecord::BuildListElement::ResolveDBReferences()
{
}

void BuildListSequenceRecord::Merge(const BuildListSequenceRecord & rval){
    // replace struct elements of m_BuildListElement
    for (sint32 index_BuildListElement = 0; index_BuildListElement < m_numBuildListElement; ++index_BuildListElement)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numBuildListElement; ++obj_index)
            if (m_BuildListElement[index_BuildListElement] == rval.m_BuildListElement[obj_index]){
                m_BuildListElement[index_BuildListElement] = rval.m_BuildListElement[obj_index];
            }
    }
}

BuildListSequenceRecord::BuildListElement const * BuildListSequenceRecord::GetBuildListElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildListElement);
    if((index < 0) || (index >= m_numBuildListElement)) {
        return 0;
    }
    return &m_BuildListElement[index];
}

const WonderBuildListRecord *BuildListSequenceRecord::BuildListElement::GetWonderBuildListPtr() const
{
    return g_theWonderBuildListDB->Get(m_WonderBuildListValue);
}

const BuildingBuildListRecord *BuildListSequenceRecord::BuildListElement::GetBuildingBuildListPtr() const
{
    return g_theBuildingBuildListDB->Get(m_BuildingBuildListValue);
}

