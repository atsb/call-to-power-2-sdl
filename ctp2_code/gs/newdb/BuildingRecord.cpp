
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "BuildingRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "IconRecord.h"
#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "GovernmentRecord.h"
#include "CityStyleRecord.h"
#include "CityStyleRecord.h"
#include "GovernmentRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "CivilisationRecord.h"
#include "FeatRecord.h"
#include "FeatRecord.h"
#include "GovernmentRecord.h"
#include "WonderRecord.h"
#include "WonderRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "TerrainImprovementRecord.h"
#include "TerrainImprovementRecord.h"
#include "MapIconRecord.h"
#include "MapIconRecord.h"
#include "MapIconRecord.h"
#include "BuildingRecord.h"

CTPDatabase<BuildingRecord> *g_theBuildingDB = NULL;

void BuildingRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    m_DefaultIcon = 0x7fffffff;
    m_Description = 0;
    m_EnableAdvance = 0x7fffffff;
    memset(m_ObsoleteAdvance, 0, sizeof(m_ObsoleteAdvance));
    m_numObsoleteAdvance = 0;
    m_PrerequisiteBuilding = NULL;
    m_numPrerequisiteBuilding = 0;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_CityStyleOnly = NULL;
    m_numCityStyleOnly = 0;
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    m_NeedsCityGood = NULL;
    m_numNeedsCityGood = 0;
    m_NeedsCityGoodAll = NULL;
    m_numNeedsCityGoodAll = 0;
    m_NeedsCityGoodAnyCity = NULL;
    m_numNeedsCityGoodAnyCity = 0;
    m_EnablesGood = NULL;
    m_numEnablesGood = 0;
    m_CivilisationOnly = NULL;
    m_numCivilisationOnly = 0;
    m_NeedsFeatToBuild = NULL;
    m_numNeedsFeatToBuild = 0;
    m_NeedsAnyPlayerFeatToBuild = NULL;
    m_numNeedsAnyPlayerFeatToBuild = 0;
    m_ConflictsWithBuilding = NULL;
    m_numConflictsWithBuilding = 0;
    m_ExcludedByBuilding = NULL;
    m_numExcludedByBuilding = 0;
    m_ExcludedByGovernmentType = NULL;
    m_numExcludedByGovernmentType = 0;
    m_PrerequisiteWonder = NULL;
    m_numPrerequisiteWonder = 0;
    m_ExcludedByWonder = NULL;
    m_numExcludedByWonder = 0;
    m_NeedsPopCountToBuildValue = 0;
    m_PopCountBuildLimitValue = 0;
    m_RequiresGood = NULL;
    m_numRequiresGood = 0;
    m_ProducesGood = NULL;
    m_numProducesGood = 0;
    m_SquaredBorderRadiusValue = 0;
    m_IntBorderRadiusValue = 0;
    m_ShowOnMap = NULL;
    m_numShowOnMap = 0;
    m_ShowOnMapRadius = NULL;
    m_numShowOnMapRadius = 0;
    m_ShowCityIconTopValue = 0;
    m_ShowCityIconBottomValue = 0;
    m_IsReligionIconValue = 0;
    m_TreasuryInterestValue = 0.000000;
    m_DisbandsCitySettlerNumValue = 0;
    m_ActualBuildingEverywhere = NULL;
    m_numActualBuildingEverywhere = 0;
    m_ProductionCost = 0;
    m_Upkeep = 0;
    m_GoldPerCityValue = 0;
    m_GoldPerUnitValue = 0;
    m_GoldPerUnitSupportValue = 0;
    m_GoldPerUnitReadinessValue = 0;
    m_UpkeepPerUnitValue = 0;
    m_UpkeepPerUnitWagesReadinessValue = 0;
    m_UpkeepPerCityValue = 0;
    m_UpkeepPerCitySqValue = 0;
    m_NewPopLimitValue = 0;
    m_UpkeepPerUnitSupportValue = 0;
    m_DefendersPercentValue = 0.000000;
    m_HappyIncValue = 0;
    m_ProductionPercentValue = 0.000000;
    m_FoodPercentValue = 0.000000;
    m_CommercePercentValue = 0.000000;
    m_SciencePercentValue = 0.000000;
    m_IncreaseBaseOvercrowdingValue = 0;
    m_IncreaseMaxPopulationValue = 0;
    m_FoodVatValue = 0.000000;
    m_LowerCrimeValue = 0.000000;
    m_PreventConversionValue = 0.000000;
    m_PreventSlaveryValue = 0.000000;
    m_LowerPeaceMovementValue = 0.000000;
    m_GoldPerCitizenValue = 0;
    m_ProtectFromBioAgentsValue = 0.000000;
    m_ProtectFromNanoVirusValue = 0.000000;
    m_SciencePerPopValue = 0.000000;
    m_RaiseOvercrowdingLevelValue = 0;
    m_RaiseMaxPopulationValue = 0;
    m_StarvationProtectionValue = 0;
    m_IncreaseHPValue = 0;
    memset(&m_BuildingFeatValue, 0, sizeof(m_BuildingFeatValue));
    m_OffenseBonusLandValue = 0.000000;
    m_OffenseBonusWaterValue = 0.000000;
    m_OffenseBonusAirValue = 0.000000;
    m_PopulationPollutionPercentValue = 0.000000;
    m_ProductionPollutionPercentValue = 0.000000;
    m_PollutionAmountValue = 0.000000;
    m_ShowAsIconValue = NULL;
    m_EnergyHungerValue = 0;
    m_ProducesEnergyValue = 0;
    m_EnergyHungerPerPopValue = 0;
    m_ProducesEnergyPerPopValue = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void BuildingRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_flags1;
        archive << m_flags2;
        archive << m_DefaultIcon;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Description);
            archive << tmpString;
        }

        archive << m_EnableAdvance;
        archive << m_numObsoleteAdvance;
        archive.Store((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive << m_numPrerequisiteBuilding;
        archive.Store((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_numCityStyleOnly;
        archive.Store((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive << m_numGovernmentType;
        archive.Store((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive << m_numNeedsCityGood;
        archive.Store((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive << m_numNeedsCityGoodAll;
        archive.Store((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive << m_numNeedsCityGoodAnyCity;
        archive.Store((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive << m_numEnablesGood;
        archive.Store((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive << m_numCivilisationOnly;
        archive.Store((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive << m_numNeedsFeatToBuild;
        archive.Store((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive << m_numNeedsAnyPlayerFeatToBuild;
        archive.Store((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive << m_numConflictsWithBuilding;
        archive.Store((uint8*)m_ConflictsWithBuilding, m_numConflictsWithBuilding * sizeof(sint32));

        archive << m_numExcludedByBuilding;
        archive.Store((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive << m_numExcludedByGovernmentType;
        archive.Store((uint8*)m_ExcludedByGovernmentType, m_numExcludedByGovernmentType * sizeof(sint32));

        archive << m_numPrerequisiteWonder;
        archive.Store((uint8*)m_PrerequisiteWonder, m_numPrerequisiteWonder * sizeof(sint32));

        archive << m_numExcludedByWonder;
        archive.Store((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive << m_NeedsPopCountToBuildValue;
        archive << m_PopCountBuildLimitValue;
        archive << m_numRequiresGood;
        archive.Store((uint8*)m_RequiresGood, m_numRequiresGood * sizeof(sint32));

        archive << m_numProducesGood;
        archive.Store((uint8*)m_ProducesGood, m_numProducesGood * sizeof(sint32));

        archive << m_SquaredBorderRadiusValue;
        archive << m_IntBorderRadiusValue;
        archive << m_numShowOnMap;
        archive.Store((uint8*)m_ShowOnMap, m_numShowOnMap * sizeof(sint32));

        archive << m_numShowOnMapRadius;
        archive.Store((uint8*)m_ShowOnMapRadius, m_numShowOnMapRadius * sizeof(sint32));

        archive << m_ShowCityIconTopValue;
        archive << m_ShowCityIconBottomValue;
        archive << m_IsReligionIconValue;
        archive << m_TreasuryInterestValue;
        archive << m_DisbandsCitySettlerNumValue;
        archive << m_numActualBuildingEverywhere;
        archive.Store((uint8*)m_ActualBuildingEverywhere, m_numActualBuildingEverywhere * sizeof(sint32));

        archive << m_ProductionCost;
        archive << m_Upkeep;
        archive << m_GoldPerCityValue;
        archive << m_GoldPerUnitValue;
        archive << m_GoldPerUnitSupportValue;
        archive << m_GoldPerUnitReadinessValue;
        archive << m_UpkeepPerUnitValue;
        archive << m_UpkeepPerUnitWagesReadinessValue;
        archive << m_UpkeepPerCityValue;
        archive << m_UpkeepPerCitySqValue;
        archive << m_NewPopLimitValue;
        archive << m_UpkeepPerUnitSupportValue;
        archive << m_DefendersPercentValue;
        archive << m_HappyIncValue;
        archive << m_ProductionPercentValue;
        archive << m_FoodPercentValue;
        archive << m_CommercePercentValue;
        archive << m_SciencePercentValue;
        archive << m_IncreaseBaseOvercrowdingValue;
        archive << m_IncreaseMaxPopulationValue;
        archive << m_FoodVatValue;
        archive << m_LowerCrimeValue;
        archive << m_PreventConversionValue;
        archive << m_PreventSlaveryValue;
        archive << m_LowerPeaceMovementValue;
        archive << m_GoldPerCitizenValue;
        archive << m_ProtectFromBioAgentsValue;
        archive << m_ProtectFromNanoVirusValue;
        archive << m_SciencePerPopValue;
        archive << m_RaiseOvercrowdingLevelValue;
        archive << m_RaiseMaxPopulationValue;
        archive << m_StarvationProtectionValue;
        archive << m_IncreaseHPValue;
        m_BuildingFeatValue.Serialize(archive);
        archive << m_OffenseBonusLandValue;
        archive << m_OffenseBonusWaterValue;
        archive << m_OffenseBonusAirValue;
        archive << m_PopulationPollutionPercentValue;
        archive << m_ProductionPollutionPercentValue;
        archive << m_PollutionAmountValue;
        archive << m_ShowAsIconValue;
        archive << m_EnergyHungerValue;
        archive << m_ProducesEnergyValue;
        archive << m_EnergyHungerPerPopValue;
        archive << m_ProducesEnergyPerPopValue;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_flags2;
        archive >> m_DefaultIcon;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Description);
            delete[] tmpString;
        }

        archive >> m_EnableAdvance;
        archive >> m_numObsoleteAdvance;
        archive.Load((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive >> m_numPrerequisiteBuilding;
        archive.Load((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_numCityStyleOnly;
        archive.Load((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive >> m_numGovernmentType;
        archive.Load((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive >> m_numNeedsCityGood;
        archive.Load((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive >> m_numNeedsCityGoodAll;
        archive.Load((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive >> m_numNeedsCityGoodAnyCity;
        archive.Load((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive >> m_numEnablesGood;
        archive.Load((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive >> m_numCivilisationOnly;
        archive.Load((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive >> m_numNeedsFeatToBuild;
        archive.Load((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive >> m_numNeedsAnyPlayerFeatToBuild;
        archive.Load((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive >> m_numConflictsWithBuilding;
        archive.Load((uint8*)m_ConflictsWithBuilding, m_numConflictsWithBuilding * sizeof(sint32));

        archive >> m_numExcludedByBuilding;
        archive.Load((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive >> m_numExcludedByGovernmentType;
        archive.Load((uint8*)m_ExcludedByGovernmentType, m_numExcludedByGovernmentType * sizeof(sint32));

        archive >> m_numPrerequisiteWonder;
        archive.Load((uint8*)m_PrerequisiteWonder, m_numPrerequisiteWonder * sizeof(sint32));

        archive >> m_numExcludedByWonder;
        archive.Load((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive >> m_NeedsPopCountToBuildValue;
        archive >> m_PopCountBuildLimitValue;
        archive >> m_numRequiresGood;
        archive.Load((uint8*)m_RequiresGood, m_numRequiresGood * sizeof(sint32));

        archive >> m_numProducesGood;
        archive.Load((uint8*)m_ProducesGood, m_numProducesGood * sizeof(sint32));

        archive >> m_SquaredBorderRadiusValue;
        archive >> m_IntBorderRadiusValue;
        archive >> m_numShowOnMap;
        archive.Load((uint8*)m_ShowOnMap, m_numShowOnMap * sizeof(sint32));

        archive >> m_numShowOnMapRadius;
        archive.Load((uint8*)m_ShowOnMapRadius, m_numShowOnMapRadius * sizeof(sint32));

        archive >> m_ShowCityIconTopValue;
        archive >> m_ShowCityIconBottomValue;
        archive >> m_IsReligionIconValue;
        archive >> m_TreasuryInterestValue;
        archive >> m_DisbandsCitySettlerNumValue;
        archive >> m_numActualBuildingEverywhere;
        archive.Load((uint8*)m_ActualBuildingEverywhere, m_numActualBuildingEverywhere * sizeof(sint32));

        archive >> m_ProductionCost;
        archive >> m_Upkeep;
        archive >> m_GoldPerCityValue;
        archive >> m_GoldPerUnitValue;
        archive >> m_GoldPerUnitSupportValue;
        archive >> m_GoldPerUnitReadinessValue;
        archive >> m_UpkeepPerUnitValue;
        archive >> m_UpkeepPerUnitWagesReadinessValue;
        archive >> m_UpkeepPerCityValue;
        archive >> m_UpkeepPerCitySqValue;
        archive >> m_NewPopLimitValue;
        archive >> m_UpkeepPerUnitSupportValue;
        archive >> m_DefendersPercentValue;
        archive >> m_HappyIncValue;
        archive >> m_ProductionPercentValue;
        archive >> m_FoodPercentValue;
        archive >> m_CommercePercentValue;
        archive >> m_SciencePercentValue;
        archive >> m_IncreaseBaseOvercrowdingValue;
        archive >> m_IncreaseMaxPopulationValue;
        archive >> m_FoodVatValue;
        archive >> m_LowerCrimeValue;
        archive >> m_PreventConversionValue;
        archive >> m_PreventSlaveryValue;
        archive >> m_LowerPeaceMovementValue;
        archive >> m_GoldPerCitizenValue;
        archive >> m_ProtectFromBioAgentsValue;
        archive >> m_ProtectFromNanoVirusValue;
        archive >> m_SciencePerPopValue;
        archive >> m_RaiseOvercrowdingLevelValue;
        archive >> m_RaiseMaxPopulationValue;
        archive >> m_StarvationProtectionValue;
        archive >> m_IncreaseHPValue;
        memset((uint8*)&m_BuildingFeatValue, 0, sizeof(m_BuildingFeatValue));
        m_BuildingFeatValue.Serialize(archive);
        archive >> m_OffenseBonusLandValue;
        archive >> m_OffenseBonusWaterValue;
        archive >> m_OffenseBonusAirValue;
        archive >> m_PopulationPollutionPercentValue;
        archive >> m_ProductionPollutionPercentValue;
        archive >> m_PollutionAmountValue;
        m_ShowAsIconValue = NULL;
        archive >> m_ShowAsIconValue;

        archive >> m_EnergyHungerValue;
        archive >> m_ProducesEnergyValue;
        archive >> m_EnergyHungerPerPopValue;
        archive >> m_ProducesEnergyPerPopValue;
    }
}

BuildingRecord::~BuildingRecord()
{
    delete [] m_PrerequisiteBuilding;
    delete [] m_GovernmentsModified;
    delete [] m_CultureOnly;
    delete [] m_CityStyleOnly;
    delete [] m_GovernmentType;
    delete [] m_NeedsCityGood;
    delete [] m_NeedsCityGoodAll;
    delete [] m_NeedsCityGoodAnyCity;
    delete [] m_EnablesGood;
    delete [] m_CivilisationOnly;
    delete [] m_NeedsFeatToBuild;
    delete [] m_NeedsAnyPlayerFeatToBuild;
    delete [] m_ConflictsWithBuilding;
    delete [] m_ExcludedByBuilding;
    delete [] m_ExcludedByGovernmentType;
    delete [] m_PrerequisiteWonder;
    delete [] m_ExcludedByWonder;
    delete [] m_RequiresGood;
    delete [] m_ProducesGood;
    delete [] m_ShowOnMap;
    delete [] m_ShowOnMapRadius;
    delete [] m_ActualBuildingEverywhere;
    delete m_ShowAsIconValue;
}

BuildingRecord const & BuildingRecord::operator = (BuildingRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;
        m_flags2 = rval.m_flags2;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_DefaultIcon = rval.m_DefaultIcon;

        m_Description = rval.m_Description;

        m_EnableAdvance = rval.m_EnableAdvance;

        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
        {
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
            std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);
        }
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
        {
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
            std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);
        }
        m_numCityStyleOnly = rval.m_numCityStyleOnly;

        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
        {
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
            std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);
        }
        m_numGovernmentType = rval.m_numGovernmentType;

        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
        {
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
            std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);
        }
        m_numNeedsCityGood = rval.m_numNeedsCityGood;

        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
        {
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
            std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);
        }
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;

        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
        {
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
            std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);
        }
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;

        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
        {
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
            std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);
        }
        m_numEnablesGood = rval.m_numEnablesGood;

        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
        {
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
            std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);
        }
        m_numCivilisationOnly = rval.m_numCivilisationOnly;

        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
        {
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
            std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);
        }
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;

        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        {
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
            std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);
        }
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;

        delete [] m_ConflictsWithBuilding;
        m_ConflictsWithBuilding = NULL;
        if (rval.m_numConflictsWithBuilding > 0)
        {
            m_ConflictsWithBuilding = new sint32 [rval.m_numConflictsWithBuilding];
            std::copy(rval.m_ConflictsWithBuilding, rval.m_ConflictsWithBuilding + rval.m_numConflictsWithBuilding, m_ConflictsWithBuilding);
        }
        m_numConflictsWithBuilding = rval.m_numConflictsWithBuilding;

        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
        {
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
            std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);
        }
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;

        delete [] m_ExcludedByGovernmentType;
        m_ExcludedByGovernmentType = NULL;
        if (rval.m_numExcludedByGovernmentType > 0)
        {
            m_ExcludedByGovernmentType = new sint32 [rval.m_numExcludedByGovernmentType];
            std::copy(rval.m_ExcludedByGovernmentType, rval.m_ExcludedByGovernmentType + rval.m_numExcludedByGovernmentType, m_ExcludedByGovernmentType);
        }
        m_numExcludedByGovernmentType = rval.m_numExcludedByGovernmentType;

        delete [] m_PrerequisiteWonder;
        m_PrerequisiteWonder = NULL;
        if (rval.m_numPrerequisiteWonder > 0)
        {
            m_PrerequisiteWonder = new sint32 [rval.m_numPrerequisiteWonder];
            std::copy(rval.m_PrerequisiteWonder, rval.m_PrerequisiteWonder + rval.m_numPrerequisiteWonder, m_PrerequisiteWonder);
        }
        m_numPrerequisiteWonder = rval.m_numPrerequisiteWonder;

        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
        {
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
            std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);
        }
        m_numExcludedByWonder = rval.m_numExcludedByWonder;

        m_NeedsPopCountToBuildValue = rval.m_NeedsPopCountToBuildValue;

        m_PopCountBuildLimitValue = rval.m_PopCountBuildLimitValue;

        delete [] m_RequiresGood;
        m_RequiresGood = NULL;
        if (rval.m_numRequiresGood > 0)
        {
            m_RequiresGood = new sint32 [rval.m_numRequiresGood];
            std::copy(rval.m_RequiresGood, rval.m_RequiresGood + rval.m_numRequiresGood, m_RequiresGood);
        }
        m_numRequiresGood = rval.m_numRequiresGood;

        delete [] m_ProducesGood;
        m_ProducesGood = NULL;
        if (rval.m_numProducesGood > 0)
        {
            m_ProducesGood = new sint32 [rval.m_numProducesGood];
            std::copy(rval.m_ProducesGood, rval.m_ProducesGood + rval.m_numProducesGood, m_ProducesGood);
        }
        m_numProducesGood = rval.m_numProducesGood;

        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;

        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;

        delete [] m_ShowOnMap;
        m_ShowOnMap = NULL;
        if (rval.m_numShowOnMap > 0)
        {
            m_ShowOnMap = new sint32 [rval.m_numShowOnMap];
            std::copy(rval.m_ShowOnMap, rval.m_ShowOnMap + rval.m_numShowOnMap, m_ShowOnMap);
        }
        m_numShowOnMap = rval.m_numShowOnMap;

        delete [] m_ShowOnMapRadius;
        m_ShowOnMapRadius = NULL;
        if (rval.m_numShowOnMapRadius > 0)
        {
            m_ShowOnMapRadius = new sint32 [rval.m_numShowOnMapRadius];
            std::copy(rval.m_ShowOnMapRadius, rval.m_ShowOnMapRadius + rval.m_numShowOnMapRadius, m_ShowOnMapRadius);
        }
        m_numShowOnMapRadius = rval.m_numShowOnMapRadius;

        m_ShowCityIconTopValue = rval.m_ShowCityIconTopValue;

        m_ShowCityIconBottomValue = rval.m_ShowCityIconBottomValue;

        m_IsReligionIconValue = rval.m_IsReligionIconValue;

        m_TreasuryInterestValue = rval.m_TreasuryInterestValue;

        m_DisbandsCitySettlerNumValue = rval.m_DisbandsCitySettlerNumValue;

        delete [] m_ActualBuildingEverywhere;
        m_ActualBuildingEverywhere = NULL;
        if (rval.m_numActualBuildingEverywhere > 0)
        {
            m_ActualBuildingEverywhere = new sint32 [rval.m_numActualBuildingEverywhere];
            std::copy(rval.m_ActualBuildingEverywhere, rval.m_ActualBuildingEverywhere + rval.m_numActualBuildingEverywhere, m_ActualBuildingEverywhere);
        }
        m_numActualBuildingEverywhere = rval.m_numActualBuildingEverywhere;

        m_ProductionCost = rval.m_ProductionCost;

        m_Upkeep = rval.m_Upkeep;

        m_GoldPerCityValue = rval.m_GoldPerCityValue;

        m_GoldPerUnitValue = rval.m_GoldPerUnitValue;

        m_GoldPerUnitSupportValue = rval.m_GoldPerUnitSupportValue;

        m_GoldPerUnitReadinessValue = rval.m_GoldPerUnitReadinessValue;

        m_UpkeepPerUnitValue = rval.m_UpkeepPerUnitValue;

        m_UpkeepPerUnitWagesReadinessValue = rval.m_UpkeepPerUnitWagesReadinessValue;

        m_UpkeepPerCityValue = rval.m_UpkeepPerCityValue;

        m_UpkeepPerCitySqValue = rval.m_UpkeepPerCitySqValue;

        m_NewPopLimitValue = rval.m_NewPopLimitValue;

        m_UpkeepPerUnitSupportValue = rval.m_UpkeepPerUnitSupportValue;

        m_DefendersPercentValue = rval.m_DefendersPercentValue;

        m_HappyIncValue = rval.m_HappyIncValue;

        m_ProductionPercentValue = rval.m_ProductionPercentValue;

        m_FoodPercentValue = rval.m_FoodPercentValue;

        m_CommercePercentValue = rval.m_CommercePercentValue;

        m_SciencePercentValue = rval.m_SciencePercentValue;

        m_IncreaseBaseOvercrowdingValue = rval.m_IncreaseBaseOvercrowdingValue;

        m_IncreaseMaxPopulationValue = rval.m_IncreaseMaxPopulationValue;

        m_FoodVatValue = rval.m_FoodVatValue;

        m_LowerCrimeValue = rval.m_LowerCrimeValue;

        m_PreventConversionValue = rval.m_PreventConversionValue;

        m_PreventSlaveryValue = rval.m_PreventSlaveryValue;

        m_LowerPeaceMovementValue = rval.m_LowerPeaceMovementValue;

        m_GoldPerCitizenValue = rval.m_GoldPerCitizenValue;

        m_ProtectFromBioAgentsValue = rval.m_ProtectFromBioAgentsValue;

        m_ProtectFromNanoVirusValue = rval.m_ProtectFromNanoVirusValue;

        m_SciencePerPopValue = rval.m_SciencePerPopValue;

        m_RaiseOvercrowdingLevelValue = rval.m_RaiseOvercrowdingLevelValue;

        m_RaiseMaxPopulationValue = rval.m_RaiseMaxPopulationValue;

        m_StarvationProtectionValue = rval.m_StarvationProtectionValue;

        m_IncreaseHPValue = rval.m_IncreaseHPValue;

        m_BuildingFeatValue = rval.m_BuildingFeatValue;

        m_OffenseBonusLandValue = rval.m_OffenseBonusLandValue;

        m_OffenseBonusWaterValue = rval.m_OffenseBonusWaterValue;

        m_OffenseBonusAirValue = rval.m_OffenseBonusAirValue;

        m_PopulationPollutionPercentValue = rval.m_PopulationPollutionPercentValue;

        m_ProductionPollutionPercentValue = rval.m_ProductionPollutionPercentValue;

        m_PollutionAmountValue = rval.m_PollutionAmountValue;

        {
            delete [] m_ShowAsIconValue;
            m_ShowAsIconValue = new char[strlen(rval.m_ShowAsIconValue)+1];
            strcpy(m_ShowAsIconValue, rval.m_ShowAsIconValue);
        }

        m_EnergyHungerValue = rval.m_EnergyHungerValue;

        m_ProducesEnergyValue = rval.m_ProducesEnergyValue;

        m_EnergyHungerPerPopValue = rval.m_EnergyHungerPerPopValue;

        m_ProducesEnergyPerPopValue = rval.m_ProducesEnergyPerPopValue;

    }

    return *this;
}

const char *g_Building_Tokens[] =
{
    "DefaultIcon",
    "Description",
    "EnableAdvance",
    "ObsoleteAdvance",
    "PrerequisiteBuilding",
    "GovernmentsModified",
    "CultureOnly",
    "CityStyleOnly",
    "GovernmentType",
    "NeedsCityGood",
    "NeedsCityGoodAll",
    "NeedsCityGoodAnyCity",
    "EnablesGood",
    "CivilisationOnly",
    "NeedsFeatToBuild",
    "NeedsAnyPlayerFeatToBuild",
    "ConflictsWithBuilding",
    "ExcludedByBuilding",
    "ExcludedByGovernmentType",
    "PrerequisiteWonder",
    "ExcludedByWonder",
    "NeedsPopCountToBuild",
    "NeedsPopCountToBuildValue",
    "PopCountBuildLimit",
    "PopCountBuildLimitValue",
    "RequiresGood",
    "ProducesGood",
    "SquaredBorderRadius",
    "SquaredBorderRadiusValue",
    "IntBorderRadius",
    "IntBorderRadiusValue",
    "ShowOnMap",
    "ShowOnMapRadius",
    "ShowCityIconTop",
    "ShowCityIconTopValue",
    "ShowCityIconBottom",
    "ShowCityIconBottomValue",
    "IsReligionIcon",
    "IsReligionIconValue",
    "TreasuryInterest",
    "TreasuryInterestValue",
    "CantSell",
    "DisbandsCitySettlerNum",
    "DisbandsCitySettlerNumValue",
    "CreatesMiltiaUnit",
    "ActualBuildingEverywhere",
    "ProductionCost",
    "Upkeep",
    "GoldPerCity",
    "GoldPerCityValue",
    "GoldPerUnit",
    "GoldPerUnitValue",
    "GoldPerUnitSupport",
    "GoldPerUnitSupportValue",
    "GoldPerUnitReadiness",
    "GoldPerUnitReadinessValue",
    "UpkeepPerUnit",
    "UpkeepPerUnitValue",
    "UpkeepPerUnitWagesReadiness",
    "UpkeepPerUnitWagesReadinessValue",
    "UpkeepPerCity",
    "UpkeepPerCityValue",
    "UpkeepPerCitySq",
    "UpkeepPerCitySqValue",
    "NewPopLimit",
    "NewPopLimitValue",
    "UpkeepPerUnitSupport",
    "UpkeepPerUnitSupportValue",
    "ProductionCostPopModifier",
    "Capitol",
    "DefendersPercent",
    "DefendersPercentValue",
    "HappyInc",
    "HappyIncValue",
    "DoubleTelevangelists",
    "ProductionPercent",
    "ProductionPercentValue",
    "FoodPercent",
    "FoodPercentValue",
    "CommercePercent",
    "CommercePercentValue",
    "SciencePercent",
    "SciencePercentValue",
    "IncreaseBaseOvercrowding",
    "IncreaseBaseOvercrowdingValue",
    "IncreaseMaxPopulation",
    "IncreaseMaxPopulationValue",
    "FoodVat",
    "FoodVatValue",
    "Airport",
    "NoUnhappyPeople",
    "NoRushBuyPenalty",
    "LowerCrime",
    "LowerCrimeValue",
    "PreventConversion",
    "PreventConversionValue",
    "PreventSlavery",
    "PreventSlaveryValue",
    "AllowGrunts",
    "LowerPeaceMovement",
    "LowerPeaceMovementValue",
    "GoldPerCitizen",
    "GoldPerCitizenValue",
    "ProtectFromNukes",
    "ProtectFromBioAgents",
    "ProtectFromBioAgentsValue",
    "ProtectFromNanoVirus",
    "ProtectFromNanoVirusValue",
    "Television",
    "CityWalls",
    "IsReligious",
    "ForceField",
    "CantBuildInSea",
    "CantBuildOnLand",
    "Cathedral",
    "Brokerage",
    "NuclearPlant",
    "SciencePerPop",
    "SciencePerPopValue",
    "RaiseOvercrowdingLevel",
    "RaiseOvercrowdingLevelValue",
    "RaiseMaxPopulation",
    "RaiseMaxPopulationValue",
    "StarvationProtection",
    "StarvationProtectionValue",
    "EmbassiesEverywhereEvenAtWar",
    "CoastalBuilding",
    "OnePerCiv",
    "IncreaseHP",
    "IncreaseHPValue",
    "EnablesAllVeterans",
    "EnablesLandVeterans",
    "EnablesSeaVeterans",
    "EnablesAirVeterans",
    "BuildingFeat",
    "BuildingFeatValue",
    "OffenseBonusLand",
    "OffenseBonusLandValue",
    "OffenseBonusWater",
    "OffenseBonusWaterValue",
    "OffenseBonusAir",
    "OffenseBonusAirValue",
    "PopulationPollutionPercent",
    "PopulationPollutionPercentValue",
    "ProductionPollutionPercent",
    "ProductionPollutionPercentValue",
    "PollutionAmount",
    "PollutionAmountValue",
    "ShowAsIcon",
    "ShowAsIconValue",
    "EnergyHunger",
    "EnergyHungerValue",
    "ProducesEnergy",
    "ProducesEnergyValue",
    "EnergyHungerPerPop",
    "EnergyHungerPerPopValue",
    "ProducesEnergyPerPop",
    "ProducesEnergyPerPopValue",
    "GLHidden",
};

BuildingRecordAccessorInfo g_BuildingRecord_Accessors[] =
{
    { &BuildingRecord::GetDefaultIconIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Description */
    { &BuildingRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &BuildingRecord::GetNumObsoleteAdvance, NULL, NULL, NULL, NULL, &BuildingRecord::GetObsoleteAdvanceIndex, NULL}, /* ObsoleteAdvance (array) */
    { &BuildingRecord::GetNumPrerequisiteBuilding, NULL, NULL, NULL, NULL, &BuildingRecord::GetPrerequisiteBuildingIndex, NULL}, /* PrerequisiteBuilding (array) */
    { &BuildingRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &BuildingRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { &BuildingRecord::GetNumCultureOnly, NULL, NULL, NULL, NULL, &BuildingRecord::GetCultureOnlyIndex, NULL}, /* CultureOnly (array) */
    { &BuildingRecord::GetNumCityStyleOnly, NULL, NULL, NULL, NULL, &BuildingRecord::GetCityStyleOnlyIndex, NULL}, /* CityStyleOnly (array) */
    { &BuildingRecord::GetNumGovernmentType, NULL, NULL, NULL, NULL, &BuildingRecord::GetGovernmentTypeIndex, NULL}, /* GovernmentType (array) */
    { &BuildingRecord::GetNumNeedsCityGood, NULL, NULL, NULL, NULL, &BuildingRecord::GetNeedsCityGoodIndex, NULL}, /* NeedsCityGood (array) */
    { &BuildingRecord::GetNumNeedsCityGoodAll, NULL, NULL, NULL, NULL, &BuildingRecord::GetNeedsCityGoodAllIndex, NULL}, /* NeedsCityGoodAll (array) */
    { &BuildingRecord::GetNumNeedsCityGoodAnyCity, NULL, NULL, NULL, NULL, &BuildingRecord::GetNeedsCityGoodAnyCityIndex, NULL}, /* NeedsCityGoodAnyCity (array) */
    { &BuildingRecord::GetNumEnablesGood, NULL, NULL, NULL, NULL, &BuildingRecord::GetEnablesGoodIndex, NULL}, /* EnablesGood (array) */
    { &BuildingRecord::GetNumCivilisationOnly, NULL, NULL, NULL, NULL, &BuildingRecord::GetCivilisationOnlyIndex, NULL}, /* CivilisationOnly (array) */
    { &BuildingRecord::GetNumNeedsFeatToBuild, NULL, NULL, NULL, NULL, &BuildingRecord::GetNeedsFeatToBuildIndex, NULL}, /* NeedsFeatToBuild (array) */
    { &BuildingRecord::GetNumNeedsAnyPlayerFeatToBuild, NULL, NULL, NULL, NULL, &BuildingRecord::GetNeedsAnyPlayerFeatToBuildIndex, NULL}, /* NeedsAnyPlayerFeatToBuild (array) */
    { &BuildingRecord::GetNumConflictsWithBuilding, NULL, NULL, NULL, NULL, &BuildingRecord::GetConflictsWithBuildingIndex, NULL}, /* ConflictsWithBuilding (array) */
    { &BuildingRecord::GetNumExcludedByBuilding, NULL, NULL, NULL, NULL, &BuildingRecord::GetExcludedByBuildingIndex, NULL}, /* ExcludedByBuilding (array) */
    { &BuildingRecord::GetNumExcludedByGovernmentType, NULL, NULL, NULL, NULL, &BuildingRecord::GetExcludedByGovernmentTypeIndex, NULL}, /* ExcludedByGovernmentType (array) */
    { &BuildingRecord::GetNumPrerequisiteWonder, NULL, NULL, NULL, NULL, &BuildingRecord::GetPrerequisiteWonderIndex, NULL}, /* PrerequisiteWonder (array) */
    { &BuildingRecord::GetNumExcludedByWonder, NULL, NULL, NULL, NULL, &BuildingRecord::GetExcludedByWonderIndex, NULL}, /* ExcludedByWonder (array) */
    { NULL, NULL, NULL, &BuildingRecord::GetNeedsPopCountToBuild, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NeedsPopCountToBuild */
    { NULL, NULL, NULL, &BuildingRecord::GetPopCountBuildLimit, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PopCountBuildLimit */
    { &BuildingRecord::GetNumRequiresGood, NULL, NULL, NULL, NULL, &BuildingRecord::GetRequiresGoodIndex, NULL}, /* RequiresGood (array) */
    { &BuildingRecord::GetNumProducesGood, NULL, NULL, NULL, NULL, &BuildingRecord::GetProducesGoodIndex, NULL}, /* ProducesGood (array) */
    { NULL, NULL, NULL, &BuildingRecord::GetSquaredBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SquaredBorderRadius */
    { NULL, NULL, NULL, &BuildingRecord::GetIntBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IntBorderRadius */
    { &BuildingRecord::GetNumShowOnMap, NULL, NULL, NULL, NULL, &BuildingRecord::GetShowOnMapIndex, NULL}, /* ShowOnMap (array) */
    { &BuildingRecord::GetNumShowOnMapRadius, NULL, NULL, NULL, NULL, &BuildingRecord::GetShowOnMapRadiusIndex, NULL}, /* ShowOnMapRadius (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconTop */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconTop */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconBottom */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowCityIconBottom */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IsReligionIcon */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IsReligionIcon */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetTreasuryInterest, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TreasuryInterest */
    { NULL, &BuildingRecord::GetCantSell, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &BuildingRecord::GetDisbandsCitySettlerNum, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DisbandsCitySettlerNum */
    { NULL, &BuildingRecord::GetCreatesMiltiaUnit, NULL, NULL, NULL, NULL, NULL },
    { &BuildingRecord::GetNumActualBuildingEverywhere, NULL, NULL, NULL, NULL, &BuildingRecord::GetActualBuildingEverywhereIndex, NULL}, /* ActualBuildingEverywhere (array) */
    { &BuildingRecord::GetProductionCost, NULL, NULL, NULL, NULL, NULL, NULL },
    { &BuildingRecord::GetUpkeep, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &BuildingRecord::GetGoldPerCity, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerCity */
    { NULL, NULL, NULL, &BuildingRecord::GetGoldPerUnit, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerUnit */
    { NULL, NULL, NULL, &BuildingRecord::GetGoldPerUnitSupport, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerUnitSupport */
    { NULL, NULL, NULL, &BuildingRecord::GetGoldPerUnitReadiness, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerUnitReadiness */
    { NULL, NULL, NULL, &BuildingRecord::GetUpkeepPerUnit, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UpkeepPerUnit */
    { NULL, NULL, NULL, &BuildingRecord::GetUpkeepPerUnitWagesReadiness, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UpkeepPerUnitWagesReadiness */
    { NULL, NULL, NULL, &BuildingRecord::GetUpkeepPerCity, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UpkeepPerCity */
    { NULL, NULL, NULL, &BuildingRecord::GetUpkeepPerCitySq, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UpkeepPerCitySq */
    { NULL, NULL, NULL, &BuildingRecord::GetNewPopLimit, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NewPopLimit */
    { NULL, NULL, NULL, &BuildingRecord::GetUpkeepPerUnitSupport, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UpkeepPerUnitSupport */
    { NULL, &BuildingRecord::GetProductionCostPopModifier, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetCapitol, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetDefendersPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendersPercent */
    { NULL, NULL, NULL, &BuildingRecord::GetHappyInc, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* HappyInc */
    { NULL, &BuildingRecord::GetDoubleTelevangelists, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetProductionPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProductionPercent */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetFoodPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FoodPercent */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetCommercePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CommercePercent */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetSciencePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SciencePercent */
    { NULL, NULL, NULL, &BuildingRecord::GetIncreaseBaseOvercrowding, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseBaseOvercrowding */
    { NULL, NULL, NULL, &BuildingRecord::GetIncreaseMaxPopulation, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseMaxPopulation */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetFoodVat, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FoodVat */
    { NULL, &BuildingRecord::GetAirport, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetNoUnhappyPeople, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetNoRushBuyPenalty, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetLowerCrime, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LowerCrime */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetPreventConversion, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PreventConversion */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetPreventSlavery, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PreventSlavery */
    { NULL, &BuildingRecord::GetAllowGrunts, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetLowerPeaceMovement, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LowerPeaceMovement */
    { NULL, NULL, NULL, &BuildingRecord::GetGoldPerCitizen, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerCitizen */
    { NULL, &BuildingRecord::GetProtectFromNukes, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetProtectFromBioAgents, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProtectFromBioAgents */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetProtectFromNanoVirus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProtectFromNanoVirus */
    { NULL, &BuildingRecord::GetTelevision, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetCityWalls, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetIsReligious, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetForceField, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetCantBuildInSea, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetCantBuildOnLand, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetCathedral, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetBrokerage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetNuclearPlant, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetSciencePerPop, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SciencePerPop */
    { NULL, NULL, NULL, &BuildingRecord::GetRaiseOvercrowdingLevel, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RaiseOvercrowdingLevel */
    { NULL, NULL, NULL, &BuildingRecord::GetRaiseMaxPopulation, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RaiseMaxPopulation */
    { NULL, NULL, NULL, &BuildingRecord::GetStarvationProtection, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StarvationProtection */
    { NULL, &BuildingRecord::GetEmbassiesEverywhereEvenAtWar, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetCoastalBuilding, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetOnePerCiv, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &BuildingRecord::GetIncreaseHP, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IncreaseHP */
    { NULL, &BuildingRecord::GetEnablesAllVeterans, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetEnablesLandVeterans, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetEnablesSeaVeterans, NULL, NULL, NULL, NULL, NULL },
    { NULL, &BuildingRecord::GetEnablesAirVeterans, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingFeat */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildingFeat */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetOffenseBonusLand, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OffenseBonusLand */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetOffenseBonusWater, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OffenseBonusWater */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetOffenseBonusAir, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OffenseBonusAir */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetPopulationPollutionPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PopulationPollutionPercent */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetProductionPollutionPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProductionPollutionPercent */
    { NULL, NULL, NULL, NULL, &BuildingRecord::GetPollutionAmount, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PollutionAmount */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowAsIcon */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ShowAsIcon */
    { NULL, NULL, NULL, &BuildingRecord::GetEnergyHunger, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EnergyHunger */
    { NULL, NULL, NULL, &BuildingRecord::GetProducesEnergy, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProducesEnergy */
    { NULL, NULL, NULL, &BuildingRecord::GetEnergyHungerPerPop, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EnergyHungerPerPop */
    { NULL, NULL, NULL, &BuildingRecord::GetProducesEnergyPerPop, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProducesEnergyPerPop */
    { NULL, &BuildingRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_Building_DefaultIcon             ((k_Token_Custom_Base) + 0)
#define k_Token_Building_Description             ((k_Token_Custom_Base) + 1)
#define k_Token_Building_EnableAdvance           ((k_Token_Custom_Base) + 2)
#define k_Token_Building_ObsoleteAdvance         ((k_Token_Custom_Base) + 3)
#define k_Token_Building_PrerequisiteBuilding    ((k_Token_Custom_Base) + 4)
#define k_Token_Building_GovernmentsModified     ((k_Token_Custom_Base) + 5)
#define k_Token_Building_CultureOnly             ((k_Token_Custom_Base) + 6)
#define k_Token_Building_CityStyleOnly           ((k_Token_Custom_Base) + 7)
#define k_Token_Building_GovernmentType          ((k_Token_Custom_Base) + 8)
#define k_Token_Building_NeedsCityGood           ((k_Token_Custom_Base) + 9)
#define k_Token_Building_NeedsCityGoodAll        ((k_Token_Custom_Base) + 10)
#define k_Token_Building_NeedsCityGoodAnyCity    ((k_Token_Custom_Base) + 11)
#define k_Token_Building_EnablesGood             ((k_Token_Custom_Base) + 12)
#define k_Token_Building_CivilisationOnly        ((k_Token_Custom_Base) + 13)
#define k_Token_Building_NeedsFeatToBuild        ((k_Token_Custom_Base) + 14)
#define k_Token_Building_NeedsAnyPlayerFeatToBuild ((k_Token_Custom_Base) + 15)
#define k_Token_Building_ConflictsWithBuilding   ((k_Token_Custom_Base) + 16)
#define k_Token_Building_ExcludedByBuilding      ((k_Token_Custom_Base) + 17)
#define k_Token_Building_ExcludedByGovernmentType ((k_Token_Custom_Base) + 18)
#define k_Token_Building_PrerequisiteWonder      ((k_Token_Custom_Base) + 19)
#define k_Token_Building_ExcludedByWonder        ((k_Token_Custom_Base) + 20)
#define k_Token_Building_NeedsPopCountToBuild    ((k_Token_Custom_Base) + 21)
#define k_Token_Building_NeedsPopCountToBuild_Value ((k_Token_Custom_Base) + 22)
#define k_Token_Building_PopCountBuildLimit      ((k_Token_Custom_Base) + 23)
#define k_Token_Building_PopCountBuildLimit_Value ((k_Token_Custom_Base) + 24)
#define k_Token_Building_RequiresGood            ((k_Token_Custom_Base) + 25)
#define k_Token_Building_ProducesGood            ((k_Token_Custom_Base) + 26)
#define k_Token_Building_SquaredBorderRadius     ((k_Token_Custom_Base) + 27)
#define k_Token_Building_SquaredBorderRadius_Value ((k_Token_Custom_Base) + 28)
#define k_Token_Building_IntBorderRadius         ((k_Token_Custom_Base) + 29)
#define k_Token_Building_IntBorderRadius_Value   ((k_Token_Custom_Base) + 30)
#define k_Token_Building_ShowOnMap               ((k_Token_Custom_Base) + 31)
#define k_Token_Building_ShowOnMapRadius         ((k_Token_Custom_Base) + 32)
#define k_Token_Building_ShowCityIconTop         ((k_Token_Custom_Base) + 33)
#define k_Token_Building_ShowCityIconTop_Value   ((k_Token_Custom_Base) + 34)
#define k_Token_Building_ShowCityIconBottom      ((k_Token_Custom_Base) + 35)
#define k_Token_Building_ShowCityIconBottom_Value ((k_Token_Custom_Base) + 36)
#define k_Token_Building_IsReligionIcon          ((k_Token_Custom_Base) + 37)
#define k_Token_Building_IsReligionIcon_Value    ((k_Token_Custom_Base) + 38)
#define k_Token_Building_TreasuryInterest        ((k_Token_Custom_Base) + 39)
#define k_Token_Building_TreasuryInterest_Value  ((k_Token_Custom_Base) + 40)
#define k_Token_Building_CantSell                ((k_Token_Custom_Base) + 41)
#define k_Token_Building_DisbandsCitySettlerNum  ((k_Token_Custom_Base) + 42)
#define k_Token_Building_DisbandsCitySettlerNum_Value ((k_Token_Custom_Base) + 43)
#define k_Token_Building_CreatesMiltiaUnit       ((k_Token_Custom_Base) + 44)
#define k_Token_Building_ActualBuildingEverywhere ((k_Token_Custom_Base) + 45)
#define k_Token_Building_ProductionCost          ((k_Token_Custom_Base) + 46)
#define k_Token_Building_Upkeep                  ((k_Token_Custom_Base) + 47)
#define k_Token_Building_GoldPerCity             ((k_Token_Custom_Base) + 48)
#define k_Token_Building_GoldPerCity_Value       ((k_Token_Custom_Base) + 49)
#define k_Token_Building_GoldPerUnit             ((k_Token_Custom_Base) + 50)
#define k_Token_Building_GoldPerUnit_Value       ((k_Token_Custom_Base) + 51)
#define k_Token_Building_GoldPerUnitSupport      ((k_Token_Custom_Base) + 52)
#define k_Token_Building_GoldPerUnitSupport_Value ((k_Token_Custom_Base) + 53)
#define k_Token_Building_GoldPerUnitReadiness    ((k_Token_Custom_Base) + 54)
#define k_Token_Building_GoldPerUnitReadiness_Value ((k_Token_Custom_Base) + 55)
#define k_Token_Building_UpkeepPerUnit           ((k_Token_Custom_Base) + 56)
#define k_Token_Building_UpkeepPerUnit_Value     ((k_Token_Custom_Base) + 57)
#define k_Token_Building_UpkeepPerUnitWagesReadiness ((k_Token_Custom_Base) + 58)
#define k_Token_Building_UpkeepPerUnitWagesReadiness_Value ((k_Token_Custom_Base) + 59)
#define k_Token_Building_UpkeepPerCity           ((k_Token_Custom_Base) + 60)
#define k_Token_Building_UpkeepPerCity_Value     ((k_Token_Custom_Base) + 61)
#define k_Token_Building_UpkeepPerCitySq         ((k_Token_Custom_Base) + 62)
#define k_Token_Building_UpkeepPerCitySq_Value   ((k_Token_Custom_Base) + 63)
#define k_Token_Building_NewPopLimit             ((k_Token_Custom_Base) + 64)
#define k_Token_Building_NewPopLimit_Value       ((k_Token_Custom_Base) + 65)
#define k_Token_Building_UpkeepPerUnitSupport    ((k_Token_Custom_Base) + 66)
#define k_Token_Building_UpkeepPerUnitSupport_Value ((k_Token_Custom_Base) + 67)
#define k_Token_Building_ProductionCostPopModifier ((k_Token_Custom_Base) + 68)
#define k_Token_Building_Capitol                 ((k_Token_Custom_Base) + 69)
#define k_Token_Building_DefendersPercent        ((k_Token_Custom_Base) + 70)
#define k_Token_Building_DefendersPercent_Value  ((k_Token_Custom_Base) + 71)
#define k_Token_Building_HappyInc                ((k_Token_Custom_Base) + 72)
#define k_Token_Building_HappyInc_Value          ((k_Token_Custom_Base) + 73)
#define k_Token_Building_DoubleTelevangelists    ((k_Token_Custom_Base) + 74)
#define k_Token_Building_ProductionPercent       ((k_Token_Custom_Base) + 75)
#define k_Token_Building_ProductionPercent_Value ((k_Token_Custom_Base) + 76)
#define k_Token_Building_FoodPercent             ((k_Token_Custom_Base) + 77)
#define k_Token_Building_FoodPercent_Value       ((k_Token_Custom_Base) + 78)
#define k_Token_Building_CommercePercent         ((k_Token_Custom_Base) + 79)
#define k_Token_Building_CommercePercent_Value   ((k_Token_Custom_Base) + 80)
#define k_Token_Building_SciencePercent          ((k_Token_Custom_Base) + 81)
#define k_Token_Building_SciencePercent_Value    ((k_Token_Custom_Base) + 82)
#define k_Token_Building_IncreaseBaseOvercrowding ((k_Token_Custom_Base) + 83)
#define k_Token_Building_IncreaseBaseOvercrowding_Value ((k_Token_Custom_Base) + 84)
#define k_Token_Building_IncreaseMaxPopulation   ((k_Token_Custom_Base) + 85)
#define k_Token_Building_IncreaseMaxPopulation_Value ((k_Token_Custom_Base) + 86)
#define k_Token_Building_FoodVat                 ((k_Token_Custom_Base) + 87)
#define k_Token_Building_FoodVat_Value           ((k_Token_Custom_Base) + 88)
#define k_Token_Building_Airport                 ((k_Token_Custom_Base) + 89)
#define k_Token_Building_NoUnhappyPeople         ((k_Token_Custom_Base) + 90)
#define k_Token_Building_NoRushBuyPenalty        ((k_Token_Custom_Base) + 91)
#define k_Token_Building_LowerCrime              ((k_Token_Custom_Base) + 92)
#define k_Token_Building_LowerCrime_Value        ((k_Token_Custom_Base) + 93)
#define k_Token_Building_PreventConversion       ((k_Token_Custom_Base) + 94)
#define k_Token_Building_PreventConversion_Value ((k_Token_Custom_Base) + 95)
#define k_Token_Building_PreventSlavery          ((k_Token_Custom_Base) + 96)
#define k_Token_Building_PreventSlavery_Value    ((k_Token_Custom_Base) + 97)
#define k_Token_Building_AllowGrunts             ((k_Token_Custom_Base) + 98)
#define k_Token_Building_LowerPeaceMovement      ((k_Token_Custom_Base) + 99)
#define k_Token_Building_LowerPeaceMovement_Value ((k_Token_Custom_Base) + 100)
#define k_Token_Building_GoldPerCitizen          ((k_Token_Custom_Base) + 101)
#define k_Token_Building_GoldPerCitizen_Value    ((k_Token_Custom_Base) + 102)
#define k_Token_Building_ProtectFromNukes        ((k_Token_Custom_Base) + 103)
#define k_Token_Building_ProtectFromBioAgents    ((k_Token_Custom_Base) + 104)
#define k_Token_Building_ProtectFromBioAgents_Value ((k_Token_Custom_Base) + 105)
#define k_Token_Building_ProtectFromNanoVirus    ((k_Token_Custom_Base) + 106)
#define k_Token_Building_ProtectFromNanoVirus_Value ((k_Token_Custom_Base) + 107)
#define k_Token_Building_Television              ((k_Token_Custom_Base) + 108)
#define k_Token_Building_CityWalls               ((k_Token_Custom_Base) + 109)
#define k_Token_Building_IsReligious             ((k_Token_Custom_Base) + 110)
#define k_Token_Building_ForceField              ((k_Token_Custom_Base) + 111)
#define k_Token_Building_CantBuildInSea          ((k_Token_Custom_Base) + 112)
#define k_Token_Building_CantBuildOnLand         ((k_Token_Custom_Base) + 113)
#define k_Token_Building_Cathedral               ((k_Token_Custom_Base) + 114)
#define k_Token_Building_Brokerage               ((k_Token_Custom_Base) + 115)
#define k_Token_Building_NuclearPlant            ((k_Token_Custom_Base) + 116)
#define k_Token_Building_SciencePerPop           ((k_Token_Custom_Base) + 117)
#define k_Token_Building_SciencePerPop_Value     ((k_Token_Custom_Base) + 118)
#define k_Token_Building_RaiseOvercrowdingLevel  ((k_Token_Custom_Base) + 119)
#define k_Token_Building_RaiseOvercrowdingLevel_Value ((k_Token_Custom_Base) + 120)
#define k_Token_Building_RaiseMaxPopulation      ((k_Token_Custom_Base) + 121)
#define k_Token_Building_RaiseMaxPopulation_Value ((k_Token_Custom_Base) + 122)
#define k_Token_Building_StarvationProtection    ((k_Token_Custom_Base) + 123)
#define k_Token_Building_StarvationProtection_Value ((k_Token_Custom_Base) + 124)
#define k_Token_Building_EmbassiesEverywhereEvenAtWar ((k_Token_Custom_Base) + 125)
#define k_Token_Building_CoastalBuilding         ((k_Token_Custom_Base) + 126)
#define k_Token_Building_OnePerCiv               ((k_Token_Custom_Base) + 127)
#define k_Token_Building_IncreaseHP              ((k_Token_Custom_Base) + 128)
#define k_Token_Building_IncreaseHP_Value        ((k_Token_Custom_Base) + 129)
#define k_Token_Building_EnablesAllVeterans      ((k_Token_Custom_Base) + 130)
#define k_Token_Building_EnablesLandVeterans     ((k_Token_Custom_Base) + 131)
#define k_Token_Building_EnablesSeaVeterans      ((k_Token_Custom_Base) + 132)
#define k_Token_Building_EnablesAirVeterans      ((k_Token_Custom_Base) + 133)
#define k_Token_Building_BuildingFeat            ((k_Token_Custom_Base) + 134)
#define k_Token_Building_BuildingFeat_Value      ((k_Token_Custom_Base) + 135)
#define k_Token_Building_OffenseBonusLand        ((k_Token_Custom_Base) + 136)
#define k_Token_Building_OffenseBonusLand_Value  ((k_Token_Custom_Base) + 137)
#define k_Token_Building_OffenseBonusWater       ((k_Token_Custom_Base) + 138)
#define k_Token_Building_OffenseBonusWater_Value ((k_Token_Custom_Base) + 139)
#define k_Token_Building_OffenseBonusAir         ((k_Token_Custom_Base) + 140)
#define k_Token_Building_OffenseBonusAir_Value   ((k_Token_Custom_Base) + 141)
#define k_Token_Building_PopulationPollutionPercent ((k_Token_Custom_Base) + 142)
#define k_Token_Building_PopulationPollutionPercent_Value ((k_Token_Custom_Base) + 143)
#define k_Token_Building_ProductionPollutionPercent ((k_Token_Custom_Base) + 144)
#define k_Token_Building_ProductionPollutionPercent_Value ((k_Token_Custom_Base) + 145)
#define k_Token_Building_PollutionAmount         ((k_Token_Custom_Base) + 146)
#define k_Token_Building_PollutionAmount_Value   ((k_Token_Custom_Base) + 147)
#define k_Token_Building_ShowAsIcon              ((k_Token_Custom_Base) + 148)
#define k_Token_Building_ShowAsIcon_Value        ((k_Token_Custom_Base) + 149)
#define k_Token_Building_EnergyHunger            ((k_Token_Custom_Base) + 150)
#define k_Token_Building_EnergyHunger_Value      ((k_Token_Custom_Base) + 151)
#define k_Token_Building_ProducesEnergy          ((k_Token_Custom_Base) + 152)
#define k_Token_Building_ProducesEnergy_Value    ((k_Token_Custom_Base) + 153)
#define k_Token_Building_EnergyHungerPerPop      ((k_Token_Custom_Base) + 154)
#define k_Token_Building_EnergyHungerPerPop_Value ((k_Token_Custom_Base) + 155)
#define k_Token_Building_ProducesEnergyPerPop    ((k_Token_Custom_Base) + 156)
#define k_Token_Building_ProducesEnergyPerPop_Value ((k_Token_Custom_Base) + 157)
#define k_Token_Building_GLHidden                ((k_Token_Custom_Base) + 158)
#define k_Token_Building_Max                     ((k_Token_Custom_Base) + 159)


static BitArray s_ParsedTokens(159);
void BuildingRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Building_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Building_ProductionCost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ProductionCost missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Building_Upkeep - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Upkeep missing"));
    }
}

sint32 BuildingRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Building_Tokens, k_Token_Building_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "BUILDING_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Building_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Building_DefaultIcon:
                if (!g_theIconDB->GetRecordFromLexer(lex, m_DefaultIcon)) {
                    done = true; break;
                }
                break;
            case k_Token_Building_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Building_EnableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Building_ObsoleteAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_ObsoleteAdvance, &m_numObsoleteAdvance, k_MAX_ObsoleteAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Building_PrerequisiteBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteBuilding, &m_numPrerequisiteBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CultureOnly, &m_numCultureOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_CityStyleOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CityStyleOnly, &m_numCityStyleOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_NeedsCityGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGood, &m_numNeedsCityGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_NeedsCityGoodAll:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAll, &m_numNeedsCityGoodAll))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_NeedsCityGoodAnyCity:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAnyCity, &m_numNeedsCityGoodAnyCity))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_EnablesGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_EnablesGood, &m_numEnablesGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_CivilisationOnly:
                if(!g_theCivilisationDB->ParseRecordInArray(lex, (sint32 **)&m_CivilisationOnly, &m_numCivilisationOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_NeedsFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsFeatToBuild, &m_numNeedsFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_NeedsAnyPlayerFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsAnyPlayerFeatToBuild, &m_numNeedsAnyPlayerFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ConflictsWithBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_ConflictsWithBuilding, &m_numConflictsWithBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ExcludedByBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByBuilding, &m_numExcludedByBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ExcludedByGovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByGovernmentType, &m_numExcludedByGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_PrerequisiteWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteWonder, &m_numPrerequisiteWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ExcludedByWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByWonder, &m_numExcludedByWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_NeedsPopCountToBuild:
                m_flags0 |= k_Building_NeedsPopCountToBuild_Bit;
                if(!lex->GetIntAssignment(m_NeedsPopCountToBuildValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_PopCountBuildLimit:
                m_flags0 |= k_Building_PopCountBuildLimit_Bit;
                if(!lex->GetIntAssignment(m_PopCountBuildLimitValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_RequiresGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_RequiresGood, &m_numRequiresGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ProducesGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_ProducesGood, &m_numProducesGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_SquaredBorderRadius:
                m_flags0 |= k_Building_SquaredBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_SquaredBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_IntBorderRadius:
                m_flags0 |= k_Building_IntBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_IntBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ShowOnMap:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_ShowOnMap, &m_numShowOnMap))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ShowOnMapRadius:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_ShowOnMapRadius, &m_numShowOnMapRadius))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ShowCityIconTop:
                m_flags0 |= k_Building_ShowCityIconTop_Bit;
                if(!g_theMapIconDB->GetRecordFromLexer(lex, m_ShowCityIconTopValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ShowCityIconBottom:
                m_flags0 |= k_Building_ShowCityIconBottom_Bit;
                if(!g_theMapIconDB->GetRecordFromLexer(lex, m_ShowCityIconBottomValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Building_IsReligionIcon:
                m_flags0 |= k_Building_IsReligionIcon_Bit;
                if(!g_theMapIconDB->GetRecordFromLexer(lex, m_IsReligionIconValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Building_TreasuryInterest:
                m_flags0 |= k_Building_TreasuryInterest_Bit;
                if(!lex->GetFloatAssignment(m_TreasuryInterestValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_CantSell:
                m_flags0 |= k_Building_CantSell_Bit;
                break;
            case k_Token_Building_DisbandsCitySettlerNum:
                m_flags0 |= k_Building_DisbandsCitySettlerNum_Bit;
                if(!lex->GetIntAssignment(m_DisbandsCitySettlerNumValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_CreatesMiltiaUnit:
                m_flags0 |= k_Building_CreatesMiltiaUnit_Bit;
                break;
            case k_Token_Building_ActualBuildingEverywhere:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_ActualBuildingEverywhere, &m_numActualBuildingEverywhere))
                {
                    done = true; break;
                }
                break;
            case k_Token_Building_ProductionCost:
                if(!lex->GetIntAssignment(m_ProductionCost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_Upkeep:
                if(!lex->GetIntAssignment(m_Upkeep)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_GoldPerCity:
                m_flags0 |= k_Building_GoldPerCity_Bit;
                if(!lex->GetIntAssignment(m_GoldPerCityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_GoldPerUnit:
                m_flags0 |= k_Building_GoldPerUnit_Bit;
                if(!lex->GetIntAssignment(m_GoldPerUnitValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_GoldPerUnitSupport:
                m_flags0 |= k_Building_GoldPerUnitSupport_Bit;
                if(!lex->GetIntAssignment(m_GoldPerUnitSupportValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_GoldPerUnitReadiness:
                m_flags0 |= k_Building_GoldPerUnitReadiness_Bit;
                if(!lex->GetIntAssignment(m_GoldPerUnitReadinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_UpkeepPerUnit:
                m_flags0 |= k_Building_UpkeepPerUnit_Bit;
                if(!lex->GetIntAssignment(m_UpkeepPerUnitValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_UpkeepPerUnitWagesReadiness:
                m_flags0 |= k_Building_UpkeepPerUnitWagesReadiness_Bit;
                if(!lex->GetIntAssignment(m_UpkeepPerUnitWagesReadinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_UpkeepPerCity:
                m_flags0 |= k_Building_UpkeepPerCity_Bit;
                if(!lex->GetIntAssignment(m_UpkeepPerCityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_UpkeepPerCitySq:
                m_flags0 |= k_Building_UpkeepPerCitySq_Bit;
                if(!lex->GetIntAssignment(m_UpkeepPerCitySqValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_NewPopLimit:
                m_flags0 |= k_Building_NewPopLimit_Bit;
                if(!lex->GetIntAssignment(m_NewPopLimitValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_UpkeepPerUnitSupport:
                m_flags0 |= k_Building_UpkeepPerUnitSupport_Bit;
                if(!lex->GetIntAssignment(m_UpkeepPerUnitSupportValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ProductionCostPopModifier:
                m_flags0 |= k_Building_ProductionCostPopModifier_Bit;
                break;
            case k_Token_Building_Capitol:
                m_flags0 |= k_Building_Capitol_Bit;
                break;
            case k_Token_Building_DefendersPercent:
                m_flags0 |= k_Building_DefendersPercent_Bit;
                if(!lex->GetFloatAssignment(m_DefendersPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_HappyInc:
                m_flags0 |= k_Building_HappyInc_Bit;
                if(!lex->GetIntAssignment(m_HappyIncValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_DoubleTelevangelists:
                m_flags0 |= k_Building_DoubleTelevangelists_Bit;
                break;
            case k_Token_Building_ProductionPercent:
                m_flags0 |= k_Building_ProductionPercent_Bit;
                if(!lex->GetFloatAssignment(m_ProductionPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_FoodPercent:
                m_flags0 |= k_Building_FoodPercent_Bit;
                if(!lex->GetFloatAssignment(m_FoodPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_CommercePercent:
                m_flags0 |= k_Building_CommercePercent_Bit;
                if(!lex->GetFloatAssignment(m_CommercePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_SciencePercent:
                m_flags0 |= k_Building_SciencePercent_Bit;
                if(!lex->GetFloatAssignment(m_SciencePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_IncreaseBaseOvercrowding:
                m_flags0 |= k_Building_IncreaseBaseOvercrowding_Bit;
                if(!lex->GetIntAssignment(m_IncreaseBaseOvercrowdingValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_IncreaseMaxPopulation:
                m_flags0 |= k_Building_IncreaseMaxPopulation_Bit;
                if(!lex->GetIntAssignment(m_IncreaseMaxPopulationValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_FoodVat:
                m_flags1 |= k_Building_FoodVat_Bit;
                if(!lex->GetFloatAssignment(m_FoodVatValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_Airport:
                m_flags1 |= k_Building_Airport_Bit;
                break;
            case k_Token_Building_NoUnhappyPeople:
                m_flags1 |= k_Building_NoUnhappyPeople_Bit;
                break;
            case k_Token_Building_NoRushBuyPenalty:
                m_flags1 |= k_Building_NoRushBuyPenalty_Bit;
                break;
            case k_Token_Building_LowerCrime:
                m_flags1 |= k_Building_LowerCrime_Bit;
                if(!lex->GetFloatAssignment(m_LowerCrimeValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_PreventConversion:
                m_flags1 |= k_Building_PreventConversion_Bit;
                if(!lex->GetFloatAssignment(m_PreventConversionValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_PreventSlavery:
                m_flags1 |= k_Building_PreventSlavery_Bit;
                if(!lex->GetFloatAssignment(m_PreventSlaveryValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_AllowGrunts:
                m_flags1 |= k_Building_AllowGrunts_Bit;
                break;
            case k_Token_Building_LowerPeaceMovement:
                m_flags1 |= k_Building_LowerPeaceMovement_Bit;
                if(!lex->GetFloatAssignment(m_LowerPeaceMovementValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_GoldPerCitizen:
                m_flags1 |= k_Building_GoldPerCitizen_Bit;
                if(!lex->GetIntAssignment(m_GoldPerCitizenValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ProtectFromNukes:
                m_flags1 |= k_Building_ProtectFromNukes_Bit;
                break;
            case k_Token_Building_ProtectFromBioAgents:
                m_flags1 |= k_Building_ProtectFromBioAgents_Bit;
                if(!lex->GetFloatAssignment(m_ProtectFromBioAgentsValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ProtectFromNanoVirus:
                m_flags1 |= k_Building_ProtectFromNanoVirus_Bit;
                if(!lex->GetFloatAssignment(m_ProtectFromNanoVirusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_Television:
                m_flags1 |= k_Building_Television_Bit;
                break;
            case k_Token_Building_CityWalls:
                m_flags1 |= k_Building_CityWalls_Bit;
                break;
            case k_Token_Building_IsReligious:
                m_flags1 |= k_Building_IsReligious_Bit;
                break;
            case k_Token_Building_ForceField:
                m_flags1 |= k_Building_ForceField_Bit;
                break;
            case k_Token_Building_CantBuildInSea:
                m_flags1 |= k_Building_CantBuildInSea_Bit;
                break;
            case k_Token_Building_CantBuildOnLand:
                m_flags1 |= k_Building_CantBuildOnLand_Bit;
                break;
            case k_Token_Building_Cathedral:
                m_flags1 |= k_Building_Cathedral_Bit;
                break;
            case k_Token_Building_Brokerage:
                m_flags1 |= k_Building_Brokerage_Bit;
                break;
            case k_Token_Building_NuclearPlant:
                m_flags1 |= k_Building_NuclearPlant_Bit;
                break;
            case k_Token_Building_SciencePerPop:
                m_flags1 |= k_Building_SciencePerPop_Bit;
                if(!lex->GetFloatAssignment(m_SciencePerPopValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_RaiseOvercrowdingLevel:
                m_flags1 |= k_Building_RaiseOvercrowdingLevel_Bit;
                if(!lex->GetIntAssignment(m_RaiseOvercrowdingLevelValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_RaiseMaxPopulation:
                m_flags1 |= k_Building_RaiseMaxPopulation_Bit;
                if(!lex->GetIntAssignment(m_RaiseMaxPopulationValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_StarvationProtection:
                m_flags1 |= k_Building_StarvationProtection_Bit;
                if(!lex->GetIntAssignment(m_StarvationProtectionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_EmbassiesEverywhereEvenAtWar:
                m_flags1 |= k_Building_EmbassiesEverywhereEvenAtWar_Bit;
                break;
            case k_Token_Building_CoastalBuilding:
                m_flags1 |= k_Building_CoastalBuilding_Bit;
                break;
            case k_Token_Building_OnePerCiv:
                m_flags1 |= k_Building_OnePerCiv_Bit;
                break;
            case k_Token_Building_IncreaseHP:
                m_flags1 |= k_Building_IncreaseHP_Bit;
                if(!lex->GetIntAssignment(m_IncreaseHPValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_EnablesAllVeterans:
                m_flags1 |= k_Building_EnablesAllVeterans_Bit;
                break;
            case k_Token_Building_EnablesLandVeterans:
                m_flags1 |= k_Building_EnablesLandVeterans_Bit;
                break;
            case k_Token_Building_EnablesSeaVeterans:
                m_flags2 |= k_Building_EnablesSeaVeterans_Bit;
                break;
            case k_Token_Building_EnablesAirVeterans:
                m_flags2 |= k_Building_EnablesAirVeterans_Bit;
                break;
            case k_Token_Building_BuildingFeat:
                m_flags2 |= k_Building_BuildingFeat_Bit;
                if(!m_BuildingFeatValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Building_OffenseBonusLand:
                m_flags2 |= k_Building_OffenseBonusLand_Bit;
                if(!lex->GetFloatAssignment(m_OffenseBonusLandValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_OffenseBonusWater:
                m_flags2 |= k_Building_OffenseBonusWater_Bit;
                if(!lex->GetFloatAssignment(m_OffenseBonusWaterValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_OffenseBonusAir:
                m_flags2 |= k_Building_OffenseBonusAir_Bit;
                if(!lex->GetFloatAssignment(m_OffenseBonusAirValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_PopulationPollutionPercent:
                m_flags2 |= k_Building_PopulationPollutionPercent_Bit;
                if(!lex->GetFloatAssignment(m_PopulationPollutionPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ProductionPollutionPercent:
                m_flags2 |= k_Building_ProductionPollutionPercent_Bit;
                if(!lex->GetFloatAssignment(m_ProductionPollutionPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_PollutionAmount:
                m_flags2 |= k_Building_PollutionAmount_Bit;
                if(!lex->GetFloatAssignment(m_PollutionAmountValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ShowAsIcon:
                m_flags2 |= k_Building_ShowAsIcon_Bit;
                if(!lex->GetFileAssignment(m_ShowAsIconValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Building_EnergyHunger:
                m_flags2 |= k_Building_EnergyHunger_Bit;
                if(!lex->GetIntAssignment(m_EnergyHungerValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ProducesEnergy:
                m_flags2 |= k_Building_ProducesEnergy_Bit;
                if(!lex->GetIntAssignment(m_ProducesEnergyValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_EnergyHungerPerPop:
                m_flags2 |= k_Building_EnergyHungerPerPop_Bit;
                if(!lex->GetIntAssignment(m_EnergyHungerPerPopValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_ProducesEnergyPerPop:
                m_flags2 |= k_Building_ProducesEnergyPerPop_Bit;
                if(!lex->GetIntAssignment(m_ProducesEnergyPerPopValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_GLHidden:
                m_flags2 |= k_Building_GLHidden_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theIconDB->GetCurrentRecordFromLexer(lex, m_DefaultIcon)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void BuildingRecord::ResolveDBReferences()
{
    if(m_DefaultIcon & 0x80000000) {
        sint32 id = m_DefaultIcon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_DefaultIcon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultIcon == 0x7fffffff) {
        m_DefaultIcon = -1;
    }
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteAdvance; i++) {
            if(m_ObsoleteAdvance[i] & 0x80000000) {
                sint32 id = m_ObsoleteAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ObsoleteAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteAdvance[i] == 0x7fffffff){
                m_ObsoleteAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteBuilding; i++) {
            if(m_PrerequisiteBuilding[i] & 0x80000000) {
                sint32 id = m_PrerequisiteBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_PrerequisiteBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteBuilding[i] == 0x7fffffff){
                m_PrerequisiteBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCityStyleOnly; i++) {
            if(m_CityStyleOnly[i] & 0x80000000) {
                sint32 id = m_CityStyleOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CityStyleOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CityStyleOnly[i] == 0x7fffffff){
                m_CityStyleOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGood; i++) {
            if(m_NeedsCityGood[i] & 0x80000000) {
                sint32 id = m_NeedsCityGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGood[i] == 0x7fffffff){
                m_NeedsCityGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAll; i++) {
            if(m_NeedsCityGoodAll[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAll[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAll[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAll[i] == 0x7fffffff){
                m_NeedsCityGoodAll[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAnyCity; i++) {
            if(m_NeedsCityGoodAnyCity[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAnyCity[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAnyCity[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAnyCity[i] == 0x7fffffff){
                m_NeedsCityGoodAnyCity[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numEnablesGood; i++) {
            if(m_EnablesGood[i] & 0x80000000) {
                sint32 id = m_EnablesGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_EnablesGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_EnablesGood[i] == 0x7fffffff){
                m_EnablesGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCivilisationOnly; i++) {
            if(m_CivilisationOnly[i] & 0x80000000) {
                sint32 id = m_CivilisationOnly[i] & 0x7fffffff;
                if(!g_theCivilisationDB->GetNamedItem(id, m_CivilisationOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Civilisation database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CivilisationOnly[i] == 0x7fffffff){
                m_CivilisationOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsFeatToBuild; i++) {
            if(m_NeedsFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsFeatToBuild[i] == 0x7fffffff){
                m_NeedsFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsAnyPlayerFeatToBuild; i++) {
            if(m_NeedsAnyPlayerFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsAnyPlayerFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsAnyPlayerFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsAnyPlayerFeatToBuild[i] == 0x7fffffff){
                m_NeedsAnyPlayerFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numConflictsWithBuilding; i++) {
            if(m_ConflictsWithBuilding[i] & 0x80000000) {
                sint32 id = m_ConflictsWithBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_ConflictsWithBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ConflictsWithBuilding[i] == 0x7fffffff){
                m_ConflictsWithBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByBuilding; i++) {
            if(m_ExcludedByBuilding[i] & 0x80000000) {
                sint32 id = m_ExcludedByBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_ExcludedByBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByBuilding[i] == 0x7fffffff){
                m_ExcludedByBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByGovernmentType; i++) {
            if(m_ExcludedByGovernmentType[i] & 0x80000000) {
                sint32 id = m_ExcludedByGovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_ExcludedByGovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByGovernmentType[i] == 0x7fffffff){
                m_ExcludedByGovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteWonder; i++) {
            if(m_PrerequisiteWonder[i] & 0x80000000) {
                sint32 id = m_PrerequisiteWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_PrerequisiteWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteWonder[i] == 0x7fffffff){
                m_PrerequisiteWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByWonder; i++) {
            if(m_ExcludedByWonder[i] & 0x80000000) {
                sint32 id = m_ExcludedByWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_ExcludedByWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByWonder[i] == 0x7fffffff){
                m_ExcludedByWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numRequiresGood; i++) {
            if(m_RequiresGood[i] & 0x80000000) {
                sint32 id = m_RequiresGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_RequiresGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_RequiresGood[i] == 0x7fffffff){
                m_RequiresGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numProducesGood; i++) {
            if(m_ProducesGood[i] & 0x80000000) {
                sint32 id = m_ProducesGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_ProducesGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ProducesGood[i] == 0x7fffffff){
                m_ProducesGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numShowOnMap; i++) {
            if(m_ShowOnMap[i] & 0x80000000) {
                sint32 id = m_ShowOnMap[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_ShowOnMap[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ShowOnMap[i] == 0x7fffffff){
                m_ShowOnMap[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numShowOnMapRadius; i++) {
            if(m_ShowOnMapRadius[i] & 0x80000000) {
                sint32 id = m_ShowOnMapRadius[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_ShowOnMapRadius[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ShowOnMapRadius[i] == 0x7fffffff){
                m_ShowOnMapRadius[i] = -1;
            }
        }
    }
    if(m_ShowCityIconTopValue & 0x80000000) {
        sint32 id = m_ShowCityIconTopValue & 0x7fffffff;
        if(!g_theMapIconDB->GetNamedItem(id, m_ShowCityIconTopValue)) {
            c3errors_ErrorDialog("DB", "%s not found in MapIcon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ShowCityIconTopValue == 0x7fffffff) {
        m_ShowCityIconTopValue = -1;
    }
    if(m_ShowCityIconBottomValue & 0x80000000) {
        sint32 id = m_ShowCityIconBottomValue & 0x7fffffff;
        if(!g_theMapIconDB->GetNamedItem(id, m_ShowCityIconBottomValue)) {
            c3errors_ErrorDialog("DB", "%s not found in MapIcon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ShowCityIconBottomValue == 0x7fffffff) {
        m_ShowCityIconBottomValue = -1;
    }
    if(m_IsReligionIconValue & 0x80000000) {
        sint32 id = m_IsReligionIconValue & 0x7fffffff;
        if(!g_theMapIconDB->GetNamedItem(id, m_IsReligionIconValue)) {
            c3errors_ErrorDialog("DB", "%s not found in MapIcon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_IsReligionIconValue == 0x7fffffff) {
        m_IsReligionIconValue = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numActualBuildingEverywhere; i++) {
            if(m_ActualBuildingEverywhere[i] & 0x80000000) {
                sint32 id = m_ActualBuildingEverywhere[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_ActualBuildingEverywhere[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ActualBuildingEverywhere[i] == 0x7fffffff){
                m_ActualBuildingEverywhere[i] = -1;
            }
        }
    }
    m_BuildingFeatValue.ResolveDBReferences();
}

BuildingRecord::BuildingFeat::BuildingFeat()
{
    m_flags0 = 0;
    m_Building = 0x7fffffff;
    m_NumValue = 0;
    m_PercentCitiesValue = 0;
}

BuildingRecord::BuildingFeat::~BuildingFeat()
{
}

BuildingRecord::BuildingFeat const & BuildingRecord::BuildingFeat::operator = (BuildingFeat const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_Building = rval.m_Building;

        m_NumValue = rval.m_NumValue;

        m_PercentCitiesValue = rval.m_PercentCitiesValue;

    }

    return *this;
}

void BuildingRecord::BuildingFeat::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_Building;
        archive << m_NumValue;
        archive << m_PercentCitiesValue;
    } else {
        archive >> m_flags0;
        archive >> m_Building;
        archive >> m_NumValue;
        archive >> m_PercentCitiesValue;
    }
}

static const char *s_Building_BuildingFeat_Tokens[] = {
    "Building",
    "Num",
    "PercentCities",
};
#define k_Token_Building_BuildingFeat_Building   ((k_Token_Custom_Base) + 0)
#define k_Token_Building_BuildingFeat_Num        ((k_Token_Custom_Base) + 1)
#define k_Token_Building_BuildingFeat_PercentCities ((k_Token_Custom_Base) + 2)
#define k_Token_Building_BuildingFeat_Max ((k_Token_Custom_Base) + 3)
sint32 BuildingRecord::BuildingFeat::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for BuildingFeat"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Building_BuildingFeat_Tokens, k_Token_Building_BuildingFeat_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Building_BuildingFeat_Building:
                if (!g_theBuildingDB->GetRecordFromLexer(lex, m_Building)) {
                    done = true; break;
                }
                break;
            case k_Token_Building_BuildingFeat_Num:
                m_flags0 |= k_BuildingFeat_Num_Bit;
                if(!lex->GetIntAssignment(m_NumValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Building_BuildingFeat_PercentCities:
                m_flags0 |= k_BuildingFeat_PercentCities_Bit;
                if(!lex->GetIntAssignment(m_PercentCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theBuildingDB->GetCurrentRecordFromLexer(lex, m_Building)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 BuildingRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildingFeat *oldArray = *array;
        *array = new BuildingFeat[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildingFeat[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 BuildingRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void BuildingRecord::BuildingFeat::ResolveDBReferences()
{
    if(m_Building & 0x80000000) {
        sint32 id = m_Building & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_Building)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Building == 0x7fffffff) {
        m_Building = -1;
    }
}

void BuildingRecord::Merge(const BuildingRecord & rval){
    if (rval.m_numObsoleteAdvance > 0)
        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

    // resize m_PrerequisiteBuilding if necessary
    if (rval.m_numPrerequisiteBuilding > m_numPrerequisiteBuilding)
    {
        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;
    }
    if (rval.m_numPrerequisiteBuilding > 0)
        std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);

    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

    // resize m_CultureOnly if necessary
    if (rval.m_numCultureOnly > m_numCultureOnly)
    {
        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
        m_numCultureOnly = rval.m_numCultureOnly;
    }
    if (rval.m_numCultureOnly > 0)
        std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);

    // resize m_CityStyleOnly if necessary
    if (rval.m_numCityStyleOnly > m_numCityStyleOnly)
    {
        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
        m_numCityStyleOnly = rval.m_numCityStyleOnly;
    }
    if (rval.m_numCityStyleOnly > 0)
        std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);

    // resize m_GovernmentType if necessary
    if (rval.m_numGovernmentType > m_numGovernmentType)
    {
        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
        m_numGovernmentType = rval.m_numGovernmentType;
    }
    if (rval.m_numGovernmentType > 0)
        std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);

    // resize m_NeedsCityGood if necessary
    if (rval.m_numNeedsCityGood > m_numNeedsCityGood)
    {
        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
        m_numNeedsCityGood = rval.m_numNeedsCityGood;
    }
    if (rval.m_numNeedsCityGood > 0)
        std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);

    // resize m_NeedsCityGoodAll if necessary
    if (rval.m_numNeedsCityGoodAll > m_numNeedsCityGoodAll)
    {
        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;
    }
    if (rval.m_numNeedsCityGoodAll > 0)
        std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);

    // resize m_NeedsCityGoodAnyCity if necessary
    if (rval.m_numNeedsCityGoodAnyCity > m_numNeedsCityGoodAnyCity)
    {
        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;
    }
    if (rval.m_numNeedsCityGoodAnyCity > 0)
        std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);

    // resize m_EnablesGood if necessary
    if (rval.m_numEnablesGood > m_numEnablesGood)
    {
        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
        m_numEnablesGood = rval.m_numEnablesGood;
    }
    if (rval.m_numEnablesGood > 0)
        std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);

    // resize m_CivilisationOnly if necessary
    if (rval.m_numCivilisationOnly > m_numCivilisationOnly)
    {
        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
        m_numCivilisationOnly = rval.m_numCivilisationOnly;
    }
    if (rval.m_numCivilisationOnly > 0)
        std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);

    // resize m_NeedsFeatToBuild if necessary
    if (rval.m_numNeedsFeatToBuild > m_numNeedsFeatToBuild)
    {
        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;
    }
    if (rval.m_numNeedsFeatToBuild > 0)
        std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);

    // resize m_NeedsAnyPlayerFeatToBuild if necessary
    if (rval.m_numNeedsAnyPlayerFeatToBuild > m_numNeedsAnyPlayerFeatToBuild)
    {
        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;
    }
    if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);

    // resize m_ConflictsWithBuilding if necessary
    if (rval.m_numConflictsWithBuilding > m_numConflictsWithBuilding)
    {
        delete [] m_ConflictsWithBuilding;
        m_ConflictsWithBuilding = NULL;
        if (rval.m_numConflictsWithBuilding > 0)
            m_ConflictsWithBuilding = new sint32 [rval.m_numConflictsWithBuilding];
        m_numConflictsWithBuilding = rval.m_numConflictsWithBuilding;
    }
    if (rval.m_numConflictsWithBuilding > 0)
        std::copy(rval.m_ConflictsWithBuilding, rval.m_ConflictsWithBuilding + rval.m_numConflictsWithBuilding, m_ConflictsWithBuilding);

    // resize m_ExcludedByBuilding if necessary
    if (rval.m_numExcludedByBuilding > m_numExcludedByBuilding)
    {
        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;
    }
    if (rval.m_numExcludedByBuilding > 0)
        std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);

    // resize m_ExcludedByGovernmentType if necessary
    if (rval.m_numExcludedByGovernmentType > m_numExcludedByGovernmentType)
    {
        delete [] m_ExcludedByGovernmentType;
        m_ExcludedByGovernmentType = NULL;
        if (rval.m_numExcludedByGovernmentType > 0)
            m_ExcludedByGovernmentType = new sint32 [rval.m_numExcludedByGovernmentType];
        m_numExcludedByGovernmentType = rval.m_numExcludedByGovernmentType;
    }
    if (rval.m_numExcludedByGovernmentType > 0)
        std::copy(rval.m_ExcludedByGovernmentType, rval.m_ExcludedByGovernmentType + rval.m_numExcludedByGovernmentType, m_ExcludedByGovernmentType);

    // resize m_PrerequisiteWonder if necessary
    if (rval.m_numPrerequisiteWonder > m_numPrerequisiteWonder)
    {
        delete [] m_PrerequisiteWonder;
        m_PrerequisiteWonder = NULL;
        if (rval.m_numPrerequisiteWonder > 0)
            m_PrerequisiteWonder = new sint32 [rval.m_numPrerequisiteWonder];
        m_numPrerequisiteWonder = rval.m_numPrerequisiteWonder;
    }
    if (rval.m_numPrerequisiteWonder > 0)
        std::copy(rval.m_PrerequisiteWonder, rval.m_PrerequisiteWonder + rval.m_numPrerequisiteWonder, m_PrerequisiteWonder);

    // resize m_ExcludedByWonder if necessary
    if (rval.m_numExcludedByWonder > m_numExcludedByWonder)
    {
        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
        m_numExcludedByWonder = rval.m_numExcludedByWonder;
    }
    if (rval.m_numExcludedByWonder > 0)
        std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_NeedsPopCountToBuild_Bit)
    {
        m_NeedsPopCountToBuildValue = rval.m_NeedsPopCountToBuildValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_PopCountBuildLimit_Bit)
    {
        m_PopCountBuildLimitValue = rval.m_PopCountBuildLimitValue;
    }

    // resize m_RequiresGood if necessary
    if (rval.m_numRequiresGood > m_numRequiresGood)
    {
        delete [] m_RequiresGood;
        m_RequiresGood = NULL;
        if (rval.m_numRequiresGood > 0)
            m_RequiresGood = new sint32 [rval.m_numRequiresGood];
        m_numRequiresGood = rval.m_numRequiresGood;
    }
    if (rval.m_numRequiresGood > 0)
        std::copy(rval.m_RequiresGood, rval.m_RequiresGood + rval.m_numRequiresGood, m_RequiresGood);

    // resize m_ProducesGood if necessary
    if (rval.m_numProducesGood > m_numProducesGood)
    {
        delete [] m_ProducesGood;
        m_ProducesGood = NULL;
        if (rval.m_numProducesGood > 0)
            m_ProducesGood = new sint32 [rval.m_numProducesGood];
        m_numProducesGood = rval.m_numProducesGood;
    }
    if (rval.m_numProducesGood > 0)
        std::copy(rval.m_ProducesGood, rval.m_ProducesGood + rval.m_numProducesGood, m_ProducesGood);

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_SquaredBorderRadius_Bit)
    {
        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_IntBorderRadius_Bit)
    {
        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;
    }

    // resize m_ShowOnMap if necessary
    if (rval.m_numShowOnMap > m_numShowOnMap)
    {
        delete [] m_ShowOnMap;
        m_ShowOnMap = NULL;
        if (rval.m_numShowOnMap > 0)
            m_ShowOnMap = new sint32 [rval.m_numShowOnMap];
        m_numShowOnMap = rval.m_numShowOnMap;
    }
    if (rval.m_numShowOnMap > 0)
        std::copy(rval.m_ShowOnMap, rval.m_ShowOnMap + rval.m_numShowOnMap, m_ShowOnMap);

    // resize m_ShowOnMapRadius if necessary
    if (rval.m_numShowOnMapRadius > m_numShowOnMapRadius)
    {
        delete [] m_ShowOnMapRadius;
        m_ShowOnMapRadius = NULL;
        if (rval.m_numShowOnMapRadius > 0)
            m_ShowOnMapRadius = new sint32 [rval.m_numShowOnMapRadius];
        m_numShowOnMapRadius = rval.m_numShowOnMapRadius;
    }
    if (rval.m_numShowOnMapRadius > 0)
        std::copy(rval.m_ShowOnMapRadius, rval.m_ShowOnMapRadius + rval.m_numShowOnMapRadius, m_ShowOnMapRadius);

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_ShowCityIconTop_Bit)
    {
        m_ShowCityIconTopValue = rval.m_ShowCityIconTopValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_ShowCityIconBottom_Bit)
    {
        m_ShowCityIconBottomValue = rval.m_ShowCityIconBottomValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_IsReligionIcon_Bit)
    {
        m_IsReligionIconValue = rval.m_IsReligionIconValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_TreasuryInterest_Bit)
    {
        m_TreasuryInterestValue = rval.m_TreasuryInterestValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_DisbandsCitySettlerNum_Bit)
    {
        m_DisbandsCitySettlerNumValue = rval.m_DisbandsCitySettlerNumValue;
    }

    // resize m_ActualBuildingEverywhere if necessary
    if (rval.m_numActualBuildingEverywhere > m_numActualBuildingEverywhere)
    {
        delete [] m_ActualBuildingEverywhere;
        m_ActualBuildingEverywhere = NULL;
        if (rval.m_numActualBuildingEverywhere > 0)
            m_ActualBuildingEverywhere = new sint32 [rval.m_numActualBuildingEverywhere];
        m_numActualBuildingEverywhere = rval.m_numActualBuildingEverywhere;
    }
    if (rval.m_numActualBuildingEverywhere > 0)
        std::copy(rval.m_ActualBuildingEverywhere, rval.m_ActualBuildingEverywhere + rval.m_numActualBuildingEverywhere, m_ActualBuildingEverywhere);

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_GoldPerCity_Bit)
    {
        m_GoldPerCityValue = rval.m_GoldPerCityValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_GoldPerUnit_Bit)
    {
        m_GoldPerUnitValue = rval.m_GoldPerUnitValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_GoldPerUnitSupport_Bit)
    {
        m_GoldPerUnitSupportValue = rval.m_GoldPerUnitSupportValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_GoldPerUnitReadiness_Bit)
    {
        m_GoldPerUnitReadinessValue = rval.m_GoldPerUnitReadinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_UpkeepPerUnit_Bit)
    {
        m_UpkeepPerUnitValue = rval.m_UpkeepPerUnitValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_UpkeepPerUnitWagesReadiness_Bit)
    {
        m_UpkeepPerUnitWagesReadinessValue = rval.m_UpkeepPerUnitWagesReadinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_UpkeepPerCity_Bit)
    {
        m_UpkeepPerCityValue = rval.m_UpkeepPerCityValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_UpkeepPerCitySq_Bit)
    {
        m_UpkeepPerCitySqValue = rval.m_UpkeepPerCitySqValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_NewPopLimit_Bit)
    {
        m_NewPopLimitValue = rval.m_NewPopLimitValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_UpkeepPerUnitSupport_Bit)
    {
        m_UpkeepPerUnitSupportValue = rval.m_UpkeepPerUnitSupportValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_DefendersPercent_Bit)
    {
        m_DefendersPercentValue = rval.m_DefendersPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_HappyInc_Bit)
    {
        m_HappyIncValue = rval.m_HappyIncValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_ProductionPercent_Bit)
    {
        m_ProductionPercentValue = rval.m_ProductionPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_FoodPercent_Bit)
    {
        m_FoodPercentValue = rval.m_FoodPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_CommercePercent_Bit)
    {
        m_CommercePercentValue = rval.m_CommercePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_SciencePercent_Bit)
    {
        m_SciencePercentValue = rval.m_SciencePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_IncreaseBaseOvercrowding_Bit)
    {
        m_IncreaseBaseOvercrowdingValue = rval.m_IncreaseBaseOvercrowdingValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Building_IncreaseMaxPopulation_Bit)
    {
        m_IncreaseMaxPopulationValue = rval.m_IncreaseMaxPopulationValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_FoodVat_Bit)
    {
        m_FoodVatValue = rval.m_FoodVatValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_LowerCrime_Bit)
    {
        m_LowerCrimeValue = rval.m_LowerCrimeValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_PreventConversion_Bit)
    {
        m_PreventConversionValue = rval.m_PreventConversionValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_PreventSlavery_Bit)
    {
        m_PreventSlaveryValue = rval.m_PreventSlaveryValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_LowerPeaceMovement_Bit)
    {
        m_LowerPeaceMovementValue = rval.m_LowerPeaceMovementValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_GoldPerCitizen_Bit)
    {
        m_GoldPerCitizenValue = rval.m_GoldPerCitizenValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_ProtectFromBioAgents_Bit)
    {
        m_ProtectFromBioAgentsValue = rval.m_ProtectFromBioAgentsValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_ProtectFromNanoVirus_Bit)
    {
        m_ProtectFromNanoVirusValue = rval.m_ProtectFromNanoVirusValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_SciencePerPop_Bit)
    {
        m_SciencePerPopValue = rval.m_SciencePerPopValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_RaiseOvercrowdingLevel_Bit)
    {
        m_RaiseOvercrowdingLevelValue = rval.m_RaiseOvercrowdingLevelValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_RaiseMaxPopulation_Bit)
    {
        m_RaiseMaxPopulationValue = rval.m_RaiseMaxPopulationValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_StarvationProtection_Bit)
    {
        m_StarvationProtectionValue = rval.m_StarvationProtectionValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Building_IncreaseHP_Bit)
    {
        m_IncreaseHPValue = rval.m_IncreaseHPValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_BuildingFeat_Bit)
    {
        m_BuildingFeatValue = rval.m_BuildingFeatValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_OffenseBonusLand_Bit)
    {
        m_OffenseBonusLandValue = rval.m_OffenseBonusLandValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_OffenseBonusWater_Bit)
    {
        m_OffenseBonusWaterValue = rval.m_OffenseBonusWaterValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_OffenseBonusAir_Bit)
    {
        m_OffenseBonusAirValue = rval.m_OffenseBonusAirValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_PopulationPollutionPercent_Bit)
    {
        m_PopulationPollutionPercentValue = rval.m_PopulationPollutionPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_ProductionPollutionPercent_Bit)
    {
        m_ProductionPollutionPercentValue = rval.m_ProductionPollutionPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_PollutionAmount_Bit)
    {
        m_PollutionAmountValue = rval.m_PollutionAmountValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_ShowAsIcon_Bit)
    {
        delete m_ShowAsIconValue;
        m_ShowAsIconValue = new char[strlen(rval.m_ShowAsIconValue)+1];
        strcpy(m_ShowAsIconValue, rval.m_ShowAsIconValue);
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_EnergyHunger_Bit)
    {
        m_EnergyHungerValue = rval.m_EnergyHungerValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_ProducesEnergy_Bit)
    {
        m_ProducesEnergyValue = rval.m_ProducesEnergyValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_EnergyHungerPerPop_Bit)
    {
        m_EnergyHungerPerPopValue = rval.m_EnergyHungerPerPopValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Building_ProducesEnergyPerPop_Bit)
    {
        m_ProducesEnergyPerPopValue = rval.m_ProducesEnergyPerPopValue;
    }

}

IconRecord const * BuildingRecord::GetDefaultIcon() const
{
    return g_theIconDB->Get(m_DefaultIcon);
}

AdvanceRecord const * BuildingRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 BuildingRecord::GetObsoleteAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return m_ObsoleteAdvance[index];
}

AdvanceRecord const * BuildingRecord::GetObsoleteAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ObsoleteAdvance[index]);
}

sint32 BuildingRecord::GetPrerequisiteBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return m_PrerequisiteBuilding[index];
}

BuildingRecord const * BuildingRecord::GetPrerequisiteBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_PrerequisiteBuilding[index]);
}

sint32 BuildingRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * BuildingRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

sint32 BuildingRecord::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

CityStyleRecord const * BuildingRecord::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

sint32 BuildingRecord::GetCityStyleOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return m_CityStyleOnly[index];
}

CityStyleRecord const * BuildingRecord::GetCityStyleOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CityStyleOnly[index]);
}

sint32 BuildingRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

GovernmentRecord const * BuildingRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

sint32 BuildingRecord::GetNeedsCityGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return m_NeedsCityGood[index];
}

ResourceRecord const * BuildingRecord::GetNeedsCityGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGood[index]);
}

sint32 BuildingRecord::GetNeedsCityGoodAllIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return m_NeedsCityGoodAll[index];
}

ResourceRecord const * BuildingRecord::GetNeedsCityGoodAll(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAll[index]);
}

sint32 BuildingRecord::GetNeedsCityGoodAnyCityIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return m_NeedsCityGoodAnyCity[index];
}

ResourceRecord const * BuildingRecord::GetNeedsCityGoodAnyCity(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAnyCity[index]);
}

sint32 BuildingRecord::GetEnablesGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return m_EnablesGood[index];
}

ResourceRecord const * BuildingRecord::GetEnablesGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_EnablesGood[index]);
}

sint32 BuildingRecord::GetCivilisationOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return m_CivilisationOnly[index];
}

CivilisationRecord const * BuildingRecord::GetCivilisationOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return g_theCivilisationDB->Get(m_CivilisationOnly[index]);
}

sint32 BuildingRecord::GetNeedsFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return m_NeedsFeatToBuild[index];
}

FeatRecord const * BuildingRecord::GetNeedsFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsFeatToBuild[index]);
}

sint32 BuildingRecord::GetNeedsAnyPlayerFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return m_NeedsAnyPlayerFeatToBuild[index];
}

FeatRecord const * BuildingRecord::GetNeedsAnyPlayerFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsAnyPlayerFeatToBuild[index]);
}

sint32 BuildingRecord::GetConflictsWithBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numConflictsWithBuilding);
    if((index < 0) || (index >= m_numConflictsWithBuilding)) {
        return 0;
    }
    return m_ConflictsWithBuilding[index];
}

BuildingRecord const * BuildingRecord::GetConflictsWithBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numConflictsWithBuilding);
    if((index < 0) || (index >= m_numConflictsWithBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_ConflictsWithBuilding[index]);
}

sint32 BuildingRecord::GetExcludedByBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return m_ExcludedByBuilding[index];
}

BuildingRecord const * BuildingRecord::GetExcludedByBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_ExcludedByBuilding[index]);
}

sint32 BuildingRecord::GetExcludedByGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByGovernmentType);
    if((index < 0) || (index >= m_numExcludedByGovernmentType)) {
        return 0;
    }
    return m_ExcludedByGovernmentType[index];
}

GovernmentRecord const * BuildingRecord::GetExcludedByGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByGovernmentType);
    if((index < 0) || (index >= m_numExcludedByGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_ExcludedByGovernmentType[index]);
}

sint32 BuildingRecord::GetPrerequisiteWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteWonder);
    if((index < 0) || (index >= m_numPrerequisiteWonder)) {
        return 0;
    }
    return m_PrerequisiteWonder[index];
}

WonderRecord const * BuildingRecord::GetPrerequisiteWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteWonder);
    if((index < 0) || (index >= m_numPrerequisiteWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_PrerequisiteWonder[index]);
}

sint32 BuildingRecord::GetExcludedByWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return m_ExcludedByWonder[index];
}

WonderRecord const * BuildingRecord::GetExcludedByWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_ExcludedByWonder[index]);
}

sint32 BuildingRecord::GetRequiresGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numRequiresGood);
    if((index < 0) || (index >= m_numRequiresGood)) {
        return 0;
    }
    return m_RequiresGood[index];
}

ResourceRecord const * BuildingRecord::GetRequiresGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numRequiresGood);
    if((index < 0) || (index >= m_numRequiresGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_RequiresGood[index]);
}

sint32 BuildingRecord::GetProducesGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numProducesGood);
    if((index < 0) || (index >= m_numProducesGood)) {
        return 0;
    }
    return m_ProducesGood[index];
}

ResourceRecord const * BuildingRecord::GetProducesGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numProducesGood);
    if((index < 0) || (index >= m_numProducesGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_ProducesGood[index]);
}

sint32 BuildingRecord::GetShowOnMapIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMap);
    if((index < 0) || (index >= m_numShowOnMap)) {
        return 0;
    }
    return m_ShowOnMap[index];
}

TerrainImprovementRecord const * BuildingRecord::GetShowOnMap(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMap);
    if((index < 0) || (index >= m_numShowOnMap)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_ShowOnMap[index]);
}

sint32 BuildingRecord::GetShowOnMapRadiusIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMapRadius);
    if((index < 0) || (index >= m_numShowOnMapRadius)) {
        return 0;
    }
    return m_ShowOnMapRadius[index];
}

TerrainImprovementRecord const * BuildingRecord::GetShowOnMapRadius(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numShowOnMapRadius);
    if((index < 0) || (index >= m_numShowOnMapRadius)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_ShowOnMapRadius[index]);
}

MapIconRecord const * BuildingRecord::GetShowCityIconTopPtr() const
{
    return g_theMapIconDB->Get(m_ShowCityIconTopValue);
}

MapIconRecord const * BuildingRecord::GetShowCityIconBottomPtr() const
{
    return g_theMapIconDB->Get(m_ShowCityIconBottomValue);
}

MapIconRecord const * BuildingRecord::GetIsReligionIconPtr() const
{
    return g_theMapIconDB->Get(m_IsReligionIconValue);
}

sint32 BuildingRecord::GetActualBuildingEverywhereIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numActualBuildingEverywhere);
    if((index < 0) || (index >= m_numActualBuildingEverywhere)) {
        return 0;
    }
    return m_ActualBuildingEverywhere[index];
}

BuildingRecord const * BuildingRecord::GetActualBuildingEverywhere(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numActualBuildingEverywhere);
    if((index < 0) || (index >= m_numActualBuildingEverywhere)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_ActualBuildingEverywhere[index]);
}

const BuildingRecord *BuildingRecord::BuildingFeat::GetBuilding() const
{
    return g_theBuildingDB->Get(m_Building);
}

