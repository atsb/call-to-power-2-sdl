
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "CitySizeRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"


CTPDatabase<CitySizeRecord> *g_theCitySizeDB = NULL;

void CitySizeRecord::Init()
{
    m_Population = 0;
    m_SquaredRadius = 0;
    m_IntRadius = 0;
    m_VisionRadius = 0.000000;
    m_MaxWorkers = 0;
    m_GrowthRate = 0;
    m_MinGrowthRate = 0;
    m_MaxSurplusFood = 0;
    m_BaseOvercrowding = 0;
    m_BaseMaxPop = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void CitySizeRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_Population;
        archive << m_SquaredRadius;
        archive << m_IntRadius;
        archive << m_VisionRadius;
        archive << m_MaxWorkers;
        archive << m_GrowthRate;
        archive << m_MinGrowthRate;
        archive << m_MaxSurplusFood;
        archive << m_BaseOvercrowding;
        archive << m_BaseMaxPop;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_Population;
        archive >> m_SquaredRadius;
        archive >> m_IntRadius;
        archive >> m_VisionRadius;
        archive >> m_MaxWorkers;
        archive >> m_GrowthRate;
        archive >> m_MinGrowthRate;
        archive >> m_MaxSurplusFood;
        archive >> m_BaseOvercrowding;
        archive >> m_BaseMaxPop;
    }
}

CitySizeRecord::~CitySizeRecord()
{
}

CitySizeRecord const & CitySizeRecord::operator = (CitySizeRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_Population = rval.m_Population;

        m_SquaredRadius = rval.m_SquaredRadius;

        m_IntRadius = rval.m_IntRadius;

        m_VisionRadius = rval.m_VisionRadius;

        m_MaxWorkers = rval.m_MaxWorkers;

        m_GrowthRate = rval.m_GrowthRate;

        m_MinGrowthRate = rval.m_MinGrowthRate;

        m_MaxSurplusFood = rval.m_MaxSurplusFood;

        m_BaseOvercrowding = rval.m_BaseOvercrowding;

        m_BaseMaxPop = rval.m_BaseMaxPop;

    }

    return *this;
}

const char *g_CitySize_Tokens[] =
{
    "Population",
    "SquaredRadius",
    "IntRadius",
    "VisionRadius",
    "MaxWorkers",
    "GrowthRate",
    "MinGrowthRate",
    "MaxSurplusFood",
    "BaseOvercrowding",
    "BaseMaxPop",
};

CitySizeRecordAccessorInfo g_CitySizeRecord_Accessors[] =
{
    { &CitySizeRecord::GetPopulation, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetSquaredRadius, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetIntRadius, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &CitySizeRecord::GetVisionRadius, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetMaxWorkers, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetGrowthRate, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetMinGrowthRate, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetMaxSurplusFood, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetBaseOvercrowding, NULL, NULL, NULL, NULL, NULL, NULL },
    { &CitySizeRecord::GetBaseMaxPop, NULL, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_CitySize_Population              ((k_Token_Custom_Base) + 0)
#define k_Token_CitySize_SquaredRadius           ((k_Token_Custom_Base) + 1)
#define k_Token_CitySize_IntRadius               ((k_Token_Custom_Base) + 2)
#define k_Token_CitySize_VisionRadius            ((k_Token_Custom_Base) + 3)
#define k_Token_CitySize_MaxWorkers              ((k_Token_Custom_Base) + 4)
#define k_Token_CitySize_GrowthRate              ((k_Token_Custom_Base) + 5)
#define k_Token_CitySize_MinGrowthRate           ((k_Token_Custom_Base) + 6)
#define k_Token_CitySize_MaxSurplusFood          ((k_Token_Custom_Base) + 7)
#define k_Token_CitySize_BaseOvercrowding        ((k_Token_Custom_Base) + 8)
#define k_Token_CitySize_BaseMaxPop              ((k_Token_Custom_Base) + 9)
#define k_Token_CitySize_Max                     ((k_Token_Custom_Base) + 10)


static BitArray s_ParsedTokens(10);
void CitySizeRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_CitySize_Population - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Population missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_SquaredRadius - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field SquaredRadius missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_IntRadius - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field IntRadius missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_VisionRadius - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field VisionRadius missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_MaxWorkers - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxWorkers missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_GrowthRate - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field GrowthRate missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_MinGrowthRate - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MinGrowthRate missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_MaxSurplusFood - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxSurplusFood missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_BaseOvercrowding - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field BaseOvercrowding missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_CitySize_BaseMaxPop - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field BaseMaxPop missing"));
    }
}

sint32 CitySizeRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_CitySize_Tokens, k_Token_CitySize_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "CITYSIZE_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_CitySize_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_CitySize_Population:
                if(!lex->GetIntAssignment(m_Population)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_SquaredRadius:
                if(!lex->GetIntAssignment(m_SquaredRadius)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_IntRadius:
                if(!lex->GetIntAssignment(m_IntRadius)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_VisionRadius:
                if(!lex->GetFloatAssignment(m_VisionRadius)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_MaxWorkers:
                if(!lex->GetIntAssignment(m_MaxWorkers)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_GrowthRate:
                if(!lex->GetIntAssignment(m_GrowthRate)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_MinGrowthRate:
                if(!lex->GetIntAssignment(m_MinGrowthRate)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_MaxSurplusFood:
                if(!lex->GetIntAssignment(m_MaxSurplusFood)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_BaseOvercrowding:
                if(!lex->GetIntAssignment(m_BaseOvercrowding)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CitySize_BaseMaxPop:
                if(!lex->GetIntAssignment(m_BaseMaxPop)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Population)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void CitySizeRecord::ResolveDBReferences()
{
}

void CitySizeRecord::Merge(const CitySizeRecord & rval){
}

