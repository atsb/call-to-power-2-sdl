
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "ResourceRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "SoundRecord.h"
#include "IconRecord.h"
#include "GovernmentRecord.h"

CTPDatabase<ResourceRecord> *g_theResourceDB = NULL;

void ResourceRecord::Init()
{
    m_flags0 = 0;
    m_Gold = 0;
    m_Food = 0;
    m_Production = 0;
    m_SpriteID = 0;
    m_Probability = 0.000000;
    m_VisibleAdvance = 0x7fffffff;
    m_AvailableAdvance = 0x7fffffff;
    m_VanishAdvance = 0x7fffffff;
    m_Sound = 0x7fffffff;
    m_Icon = 0x7fffffff;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_ProductionPercentValue = 0.000000;
    m_FoodPercentValue = 0.000000;
    m_CommercePercentValue = 0.000000;
    m_SciencePercentValue = 0.000000;
    m_EfficiencyOrCrimeValue = 0.000000;
    m_HappyInc = 0;
    m_TradeGold = 0;
    m_TradeFood = 0;
    m_TradeProduction = 0;
    m_TradeScience = 0;
    m_AddPopulation = 0;
    m_AddSlave = 0;
    m_EnergyHunger = 0;
    m_ProducesEnergy = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void ResourceRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_Gold;
        archive << m_Food;
        archive << m_Production;
        archive << m_SpriteID;
        archive << m_Probability;
        archive << m_VisibleAdvance;
        archive << m_AvailableAdvance;
        archive << m_VanishAdvance;
        archive << m_Sound;
        archive << m_Icon;
        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_ProductionPercentValue;
        archive << m_FoodPercentValue;
        archive << m_CommercePercentValue;
        archive << m_SciencePercentValue;
        archive << m_EfficiencyOrCrimeValue;
        archive << m_HappyInc;
        archive << m_TradeGold;
        archive << m_TradeFood;
        archive << m_TradeProduction;
        archive << m_TradeScience;
        archive << m_AddPopulation;
        archive << m_AddSlave;
        archive << m_EnergyHunger;
        archive << m_ProducesEnergy;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_Gold;
        archive >> m_Food;
        archive >> m_Production;
        archive >> m_SpriteID;
        archive >> m_Probability;
        archive >> m_VisibleAdvance;
        archive >> m_AvailableAdvance;
        archive >> m_VanishAdvance;
        archive >> m_Sound;
        archive >> m_Icon;
        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive >> m_ProductionPercentValue;
        archive >> m_FoodPercentValue;
        archive >> m_CommercePercentValue;
        archive >> m_SciencePercentValue;
        archive >> m_EfficiencyOrCrimeValue;
        archive >> m_HappyInc;
        archive >> m_TradeGold;
        archive >> m_TradeFood;
        archive >> m_TradeProduction;
        archive >> m_TradeScience;
        archive >> m_AddPopulation;
        archive >> m_AddSlave;
        archive >> m_EnergyHunger;
        archive >> m_ProducesEnergy;
    }
}

ResourceRecord::~ResourceRecord()
{
    delete [] m_GovernmentsModified;
}

ResourceRecord const & ResourceRecord::operator = (ResourceRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_Gold = rval.m_Gold;

        m_Food = rval.m_Food;

        m_Production = rval.m_Production;

        m_SpriteID = rval.m_SpriteID;

        m_Probability = rval.m_Probability;

        m_VisibleAdvance = rval.m_VisibleAdvance;

        m_AvailableAdvance = rval.m_AvailableAdvance;

        m_VanishAdvance = rval.m_VanishAdvance;

        m_Sound = rval.m_Sound;

        m_Icon = rval.m_Icon;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        m_ProductionPercentValue = rval.m_ProductionPercentValue;

        m_FoodPercentValue = rval.m_FoodPercentValue;

        m_CommercePercentValue = rval.m_CommercePercentValue;

        m_SciencePercentValue = rval.m_SciencePercentValue;

        m_EfficiencyOrCrimeValue = rval.m_EfficiencyOrCrimeValue;

        m_HappyInc = rval.m_HappyInc;

        m_TradeGold = rval.m_TradeGold;

        m_TradeFood = rval.m_TradeFood;

        m_TradeProduction = rval.m_TradeProduction;

        m_TradeScience = rval.m_TradeScience;

        m_AddPopulation = rval.m_AddPopulation;

        m_AddSlave = rval.m_AddSlave;

        m_EnergyHunger = rval.m_EnergyHunger;

        m_ProducesEnergy = rval.m_ProducesEnergy;

    }

    return *this;
}

const char *g_Resource_Tokens[] =
{
    "Gold",
    "Food",
    "Production",
    "SpriteID",
    "Probability",
    "CantTrade",
    "VisibleAdvance",
    "AvailableAdvance",
    "VanishAdvance",
    "Sound",
    "Icon",
    "GovernmentsModified",
    "ProductionPercent",
    "ProductionPercentValue",
    "FoodPercent",
    "FoodPercentValue",
    "CommercePercent",
    "CommercePercentValue",
    "SciencePercent",
    "SciencePercentValue",
    "EfficiencyOrCrime",
    "EfficiencyOrCrimeValue",
    "HappyInc",
    "TradeGold",
    "TradeFood",
    "TradeProduction",
    "TradeScience",
    "AddPopulation",
    "AddSlave",
    "IsBonusGood",
    "IsStrategicGood",
    "IsLuxuryGood",
    "AddsASlave",
    "EnergyHunger",
    "ProducesEnergy",
    "GLHidden",
    "CanUpgrade",
};

ResourceRecordAccessorInfo g_ResourceRecord_Accessors[] =
{
    { &ResourceRecord::GetGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetFood, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetProduction, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetSpriteID, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &ResourceRecord::GetProbability, NULL, NULL, NULL, NULL },
    { NULL, &ResourceRecord::GetCantTrade, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetVisibleAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetAvailableAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetVanishAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetSoundIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetIconIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &ResourceRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { NULL, NULL, NULL, NULL, &ResourceRecord::GetProductionPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProductionPercent */
    { NULL, NULL, NULL, NULL, &ResourceRecord::GetFoodPercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FoodPercent */
    { NULL, NULL, NULL, NULL, &ResourceRecord::GetCommercePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CommercePercent */
    { NULL, NULL, NULL, NULL, &ResourceRecord::GetSciencePercent, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SciencePercent */
    { NULL, NULL, NULL, NULL, &ResourceRecord::GetEfficiencyOrCrime, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* EfficiencyOrCrime */
    { &ResourceRecord::GetHappyInc, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetTradeGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetTradeFood, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetTradeProduction, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetTradeScience, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetAddPopulation, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetAddSlave, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, &ResourceRecord::GetIsBonusGood, NULL, NULL, NULL, NULL, NULL },
    { NULL, &ResourceRecord::GetIsStrategicGood, NULL, NULL, NULL, NULL, NULL },
    { NULL, &ResourceRecord::GetIsLuxuryGood, NULL, NULL, NULL, NULL, NULL },
    { NULL, &ResourceRecord::GetAddsASlave, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetEnergyHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &ResourceRecord::GetProducesEnergy, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, &ResourceRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
    { NULL, &ResourceRecord::GetCanUpgrade, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_Resource_Gold                    ((k_Token_Custom_Base) + 0)
#define k_Token_Resource_Food                    ((k_Token_Custom_Base) + 1)
#define k_Token_Resource_Production              ((k_Token_Custom_Base) + 2)
#define k_Token_Resource_SpriteID                ((k_Token_Custom_Base) + 3)
#define k_Token_Resource_Probability             ((k_Token_Custom_Base) + 4)
#define k_Token_Resource_CantTrade               ((k_Token_Custom_Base) + 5)
#define k_Token_Resource_VisibleAdvance          ((k_Token_Custom_Base) + 6)
#define k_Token_Resource_AvailableAdvance        ((k_Token_Custom_Base) + 7)
#define k_Token_Resource_VanishAdvance           ((k_Token_Custom_Base) + 8)
#define k_Token_Resource_Sound                   ((k_Token_Custom_Base) + 9)
#define k_Token_Resource_Icon                    ((k_Token_Custom_Base) + 10)
#define k_Token_Resource_GovernmentsModified     ((k_Token_Custom_Base) + 11)
#define k_Token_Resource_ProductionPercent       ((k_Token_Custom_Base) + 12)
#define k_Token_Resource_ProductionPercent_Value ((k_Token_Custom_Base) + 13)
#define k_Token_Resource_FoodPercent             ((k_Token_Custom_Base) + 14)
#define k_Token_Resource_FoodPercent_Value       ((k_Token_Custom_Base) + 15)
#define k_Token_Resource_CommercePercent         ((k_Token_Custom_Base) + 16)
#define k_Token_Resource_CommercePercent_Value   ((k_Token_Custom_Base) + 17)
#define k_Token_Resource_SciencePercent          ((k_Token_Custom_Base) + 18)
#define k_Token_Resource_SciencePercent_Value    ((k_Token_Custom_Base) + 19)
#define k_Token_Resource_EfficiencyOrCrime       ((k_Token_Custom_Base) + 20)
#define k_Token_Resource_EfficiencyOrCrime_Value ((k_Token_Custom_Base) + 21)
#define k_Token_Resource_HappyInc                ((k_Token_Custom_Base) + 22)
#define k_Token_Resource_TradeGold               ((k_Token_Custom_Base) + 23)
#define k_Token_Resource_TradeFood               ((k_Token_Custom_Base) + 24)
#define k_Token_Resource_TradeProduction         ((k_Token_Custom_Base) + 25)
#define k_Token_Resource_TradeScience            ((k_Token_Custom_Base) + 26)
#define k_Token_Resource_AddPopulation           ((k_Token_Custom_Base) + 27)
#define k_Token_Resource_AddSlave                ((k_Token_Custom_Base) + 28)
#define k_Token_Resource_IsBonusGood             ((k_Token_Custom_Base) + 29)
#define k_Token_Resource_IsStrategicGood         ((k_Token_Custom_Base) + 30)
#define k_Token_Resource_IsLuxuryGood            ((k_Token_Custom_Base) + 31)
#define k_Token_Resource_AddsASlave              ((k_Token_Custom_Base) + 32)
#define k_Token_Resource_EnergyHunger            ((k_Token_Custom_Base) + 33)
#define k_Token_Resource_ProducesEnergy          ((k_Token_Custom_Base) + 34)
#define k_Token_Resource_GLHidden                ((k_Token_Custom_Base) + 35)
#define k_Token_Resource_CanUpgrade              ((k_Token_Custom_Base) + 36)
#define k_Token_Resource_Max                     ((k_Token_Custom_Base) + 37)


static BitArray s_ParsedTokens(37);
void ResourceRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Resource_Gold - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Gold missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Resource_SpriteID - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field SpriteID missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Resource_Probability - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Probability missing"));
    }
}

sint32 ResourceRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Resource_Tokens, k_Token_Resource_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "RESOURCE_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Resource_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Resource_Gold:
                if(!lex->GetIntAssignment(m_Gold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_Food:
                if(!lex->GetIntAssignment(m_Food)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_Production:
                if(!lex->GetIntAssignment(m_Production)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_SpriteID:
                if(!lex->GetIntAssignment(m_SpriteID)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_Probability:
                if(!lex->GetFloatAssignment(m_Probability)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_CantTrade:
                m_flags0 |= k_Resource_CantTrade_Bit;
                break;
            case k_Token_Resource_VisibleAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_VisibleAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Resource_AvailableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_AvailableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Resource_VanishAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_VanishAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Resource_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Resource_Icon:
                if (!g_theIconDB->GetRecordFromLexer(lex, m_Icon)) {
                    done = true; break;
                }
                break;
            case k_Token_Resource_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_Resource_ProductionPercent:
                m_flags0 |= k_Resource_ProductionPercent_Bit;
                if(!lex->GetFloatAssignment(m_ProductionPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_FoodPercent:
                m_flags0 |= k_Resource_FoodPercent_Bit;
                if(!lex->GetFloatAssignment(m_FoodPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_CommercePercent:
                m_flags0 |= k_Resource_CommercePercent_Bit;
                if(!lex->GetFloatAssignment(m_CommercePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_SciencePercent:
                m_flags0 |= k_Resource_SciencePercent_Bit;
                if(!lex->GetFloatAssignment(m_SciencePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_EfficiencyOrCrime:
                m_flags0 |= k_Resource_EfficiencyOrCrime_Bit;
                if(!lex->GetFloatAssignment(m_EfficiencyOrCrimeValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_HappyInc:
                if(!lex->GetIntAssignment(m_HappyInc)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_TradeGold:
                if(!lex->GetIntAssignment(m_TradeGold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_TradeFood:
                if(!lex->GetIntAssignment(m_TradeFood)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_TradeProduction:
                if(!lex->GetIntAssignment(m_TradeProduction)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_TradeScience:
                if(!lex->GetIntAssignment(m_TradeScience)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_AddPopulation:
                if(!lex->GetIntAssignment(m_AddPopulation)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_AddSlave:
                if(!lex->GetIntAssignment(m_AddSlave)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_IsBonusGood:
                m_flags0 |= k_Resource_IsBonusGood_Bit;
                break;
            case k_Token_Resource_IsStrategicGood:
                m_flags0 |= k_Resource_IsStrategicGood_Bit;
                break;
            case k_Token_Resource_IsLuxuryGood:
                m_flags0 |= k_Resource_IsLuxuryGood_Bit;
                break;
            case k_Token_Resource_AddsASlave:
                m_flags0 |= k_Resource_AddsASlave_Bit;
                break;
            case k_Token_Resource_EnergyHunger:
                if(!lex->GetIntAssignment(m_EnergyHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_ProducesEnergy:
                if(!lex->GetIntAssignment(m_ProducesEnergy)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Resource_GLHidden:
                m_flags0 |= k_Resource_GLHidden_Bit;
                break;
            case k_Token_Resource_CanUpgrade:
                m_flags0 |= k_Resource_CanUpgrade_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Gold)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void ResourceRecord::ResolveDBReferences()
{
    if(m_VisibleAdvance & 0x80000000) {
        sint32 id = m_VisibleAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_VisibleAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_VisibleAdvance == 0x7fffffff) {
        m_VisibleAdvance = -1;
    }
    if(m_AvailableAdvance & 0x80000000) {
        sint32 id = m_AvailableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_AvailableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_AvailableAdvance == 0x7fffffff) {
        m_AvailableAdvance = -1;
    }
    if(m_VanishAdvance & 0x80000000) {
        sint32 id = m_VanishAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_VanishAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_VanishAdvance == 0x7fffffff) {
        m_VanishAdvance = -1;
    }
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Icon & 0x80000000) {
        sint32 id = m_Icon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_Icon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Icon == 0x7fffffff) {
        m_Icon = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
}

void ResourceRecord::Merge(const ResourceRecord & rval){
    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

    // only replace values that have been set
    if (rval.m_flags0 & k_Resource_ProductionPercent_Bit)
    {
        m_ProductionPercentValue = rval.m_ProductionPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Resource_FoodPercent_Bit)
    {
        m_FoodPercentValue = rval.m_FoodPercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Resource_CommercePercent_Bit)
    {
        m_CommercePercentValue = rval.m_CommercePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Resource_SciencePercent_Bit)
    {
        m_SciencePercentValue = rval.m_SciencePercentValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Resource_EfficiencyOrCrime_Bit)
    {
        m_EfficiencyOrCrimeValue = rval.m_EfficiencyOrCrimeValue;
    }

}

AdvanceRecord const * ResourceRecord::GetVisibleAdvance() const
{
    return g_theAdvanceDB->Get(m_VisibleAdvance);
}

AdvanceRecord const * ResourceRecord::GetAvailableAdvance() const
{
    return g_theAdvanceDB->Get(m_AvailableAdvance);
}

AdvanceRecord const * ResourceRecord::GetVanishAdvance() const
{
    return g_theAdvanceDB->Get(m_VanishAdvance);
}

SoundRecord const * ResourceRecord::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

IconRecord const * ResourceRecord::GetIcon() const
{
    return g_theIconDB->Get(m_Icon);
}

sint32 ResourceRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * ResourceRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

