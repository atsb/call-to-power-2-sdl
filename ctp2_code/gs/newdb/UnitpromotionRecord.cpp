
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "UnitpromotionRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "UnitRecord.h"
#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "GovernmentRecord.h"
#include "UnitRecord.h"
#include "UnitRecord.h"
#include "CityStyleRecord.h"
#include "CityStyleRecord.h"
#include "CivilisationRecord.h"
#include "GovernmentRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "FeatRecord.h"
#include "FeatRecord.h"
#include "WonderRecord.h"
#include "WonderRecord.h"
#include "TerrainImprovementRecord.h"
#include "UnitRecord.h"
#include "UnitRecord.h"
#include "BuildingRecord.h"
#include "GovernmentRecord.h"
#include "SpriteRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SpecialAttackInfoRecord.h"
#include "IconRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"

CTPDatabase<UnitpromotionRecord> *g_theUnitpromotionDB = NULL;

void UnitpromotionRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    m_flags3 = 0;
    m_flags4 = 0;
    m_flags5 = 0;
    m_flags6 = 0;
    m_MovementType = 0;
    m_CanCarry = 0;
    m_AvailableUnit = 0x7fffffff;
    m_EnableAdvance = 0x7fffffff;
    memset(m_ObsoleteAdvance, 0, sizeof(m_ObsoleteAdvance));
    m_numObsoleteAdvance = 0;
    m_PrerequisiteBuilding = NULL;
    m_numPrerequisiteBuilding = 0;
    m_ExcludedByBuilding = NULL;
    m_numExcludedByBuilding = 0;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_UpgradeToPromotion = NULL;
    m_numUpgradeToPromotion = 0;
    m_ObsoletePromotion = NULL;
    m_numObsoletePromotion = 0;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_CityStyleOnly = NULL;
    m_numCityStyleOnly = 0;
    m_CivilisationOnly = NULL;
    m_numCivilisationOnly = 0;
    m_GovernmentOnly = NULL;
    m_numGovernmentOnly = 0;
    m_NeedsCityGood = NULL;
    m_numNeedsCityGood = 0;
    m_NeedsCityGoodAll = NULL;
    m_numNeedsCityGoodAll = 0;
    m_NeedsCityGoodAnyCity = NULL;
    m_numNeedsCityGoodAnyCity = 0;
    m_NeedsFeatToBuild = NULL;
    m_numNeedsFeatToBuild = 0;
    m_NeedsAnyPlayerFeatToBuild = NULL;
    m_numNeedsAnyPlayerFeatToBuild = 0;
    m_PrerequisiteWonder = NULL;
    m_numPrerequisiteWonder = 0;
    m_ExcludedByWonder = NULL;
    m_numExcludedByWonder = 0;
    m_MoveBonusValue = 0;
    m_PWMoveCostValue = 0;
    m_MerchantGoldValue = 0;
    m_AllTerrainAsImprovement = NULL;
    m_numAllTerrainAsImprovement = 0;
    m_ObsoleteByUnit = NULL;
    m_numObsoleteByUnit = 0;
    m_Size = 0;
    m_CanBombard = 0;
    m_Settle = 0;
    m_SettleCityType = 0x7fffffff;
    m_SettleSize = 1;
    m_SettleBuilding = NULL;
    m_numSettleBuilding = 0;
    m_SpaceLaunchValue = 0;
    m_Defend = 0;
    m_DefendAgainstSpiesValue = 0.000000;
    m_ReplaceWithCargoModuleValue = 0;
    memset(&m_NuclearAttackValue, 0, sizeof(m_NuclearAttackValue));
    memset(&m_StealTechnologyValue, 0, sizeof(m_StealTechnologyValue));
    memset(&m_InciteRevolutionValue, 0, sizeof(m_InciteRevolutionValue));
    memset(&m_AssasinateRulerValue, 0, sizeof(m_AssasinateRulerValue));
    memset(&m_InvestigateReadinessValue, 0, sizeof(m_InvestigateReadinessValue));
    memset(&m_CreateFranchiseValue, 0, sizeof(m_CreateFranchiseValue));
    memset(&m_CauseUnhappinessValue, 0, sizeof(m_CauseUnhappinessValue));
    memset(&m_ConductHitsValue, 0, sizeof(m_ConductHitsValue));
    memset(&m_BioTerrorValue, 0, sizeof(m_BioTerrorValue));
    memset(&m_NanoTerrorValue, 0, sizeof(m_NanoTerrorValue));
    memset(&m_PlagueValue, 0, sizeof(m_PlagueValue));
    memset(&m_SlaveRaidsValue, 0, sizeof(m_SlaveRaidsValue));
    memset(&m_SettlerSlaveRaidsValue, 0, sizeof(m_SettlerSlaveRaidsValue));
    memset(&m_SlaveUprisingValue, 0, sizeof(m_SlaveUprisingValue));
    memset(&m_UndergroundRailwayValue, 0, sizeof(m_UndergroundRailwayValue));
    m_VictoryEnslavementChanceValue = 0.000000;
    memset(&m_IndulgenceSalesValue, 0, sizeof(m_IndulgenceSalesValue));
    memset(&m_ConvertCitiesValue, 0, sizeof(m_ConvertCitiesValue));
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    memset(&m_PlantNukeValue, 0, sizeof(m_PlantNukeValue));
    memset(&m_CanSoothsayValue, 0, sizeof(m_CanSoothsayValue));
    memset(&m_CreateParksValue, 0, sizeof(m_CreateParksValue));
    memset(&m_CanInjoinValue, 0, sizeof(m_CanInjoinValue));
    m_PopCostsToBuildValue = 0;
    memset(&m_CanReformValue, 0, sizeof(m_CanReformValue));
    m_ReducesDefensesBonus = 0;
    m_VisionClass = 0;
    m_CanSee = 0;
    m_CanAttack = 0;
    memset(&m_CargoDataValue, 0, sizeof(m_CargoDataValue));
    m_ShieldCost = 0;
    m_PowerPoints = 0;
    m_MaxHP = 0;
    m_MaxHPr = 1.000000;
    m_Attack = 0.000000;
    m_Defense = 0.000000;
    m_Firepower = 0;
    m_ZBRangeAttack = 0;
    m_Armor = 0.000000;
    m_BRangeValue = 0;
    m_BRadiusValue = 0;
    m_VisionRange = 0;
    m_ActiveDefenseRange = 0;
    m_ElectronicCombatFactorValue = 0;
    m_MaxMovePoints = 0.000000;
    m_MaxFuel = 0;
    m_TransTypeValue = 0;
    m_ProbOfBombHitValue = 0;
    m_BombRoundsValue = 0;
    m_ShieldHunger = 0;
    m_FoodHunger = 0;
    m_GoldHunger = 0;
    m_DefaultSprite = 0x7fffffff;
    m_LaunchPollutionValue = 0;
    m_DeathPollutionValue = 0;
    m_MountedBonusValue = 0.000000;
    m_AirBonusValue = 0.000000;
    m_WoodenShipBonusValue = 0.000000;
    m_AttackCityBonusValue = 0.000000;
    m_AttackBonusSubmarineValue = 0.000000;
    m_FootBonusValue = 0.000000;
    m_SiegeBonusValue = 0.000000;
    m_WheeledBonusValue = 0.000000;
    m_MechanizedBonusValue = 0.000000;
    m_HelicopterBonusValue = 0.000000;
    m_SpecialForcesBonusValue = 0.000000;
    m_CivilianBonusValue = 0.000000;
    m_GuerrillaBonusValue = 0.000000;
    m_AgainstMountedBonusValue = 0.000000;
    m_AirDefenseBonusValue = 0.000000;
    m_CargoModuleValue = 0;
    m_SpyVsSpyValue = 0.000000;
    memset(&m_InvestigateCityValue, 0, sizeof(m_InvestigateCityValue));
    m_BonusFoodValue = 0;
    m_BombardRangeValue = 0;
    memset(&m_RevolutionValue, 0, sizeof(m_RevolutionValue));
    m_SoundSelect1 = 0x7fffffff;
    m_SoundSelect2 = 0x7fffffff;
    m_SoundMove = 0x7fffffff;
    m_SoundAcknowledge = 0x7fffffff;
    m_SoundCantMove = 0x7fffffff;
    m_SoundAttack = 0x7fffffff;
    m_SoundWork = 0x7fffffff;
    m_SoundVictory = 0x7fffffff;
    m_SoundDeath = 0x7fffffff;
    m_SoundLoad = 0x7fffffff;
    m_SoundUnload = 0x7fffffff;
    memset(m_SpecialAttacks, 0, sizeof(m_SpecialAttacks));
    m_numSpecialAttacks = 0;
    m_CityGrowthCoefficientValue = 0.000000;
    m_UserFlags = 0;
    m_DefaultIcon = 0x7fffffff;
    m_CheatIndexValue = 0;
    m_Description = 0;
    m_AdviceValue = 0;
    m_Category = 0;
    m_ArmyMountedBonusValue = 0.000000;
    m_ArmyAirBonusValue = 0.000000;
    m_ArmyWoodenShipBonusValue = 0.000000;
    m_ArmyAttackCityBonusValue = 0.000000;
    m_ArmyAttackBonusSubmarineValue = 0.000000;
    m_ArmyFootBonusValue = 0.000000;
    m_ArmySiegeBonusValue = 0.000000;
    m_ArmyWheeledBonusValue = 0.000000;
    m_ArmyMechanizedBonusValue = 0.000000;
    m_ArmyHelicopterBonusValue = 0.000000;
    m_ArmySpecialForcesBonusValue = 0.000000;
    m_ArmyCivilianBonusValue = 0.000000;
    m_ArmyGuerrillaBonusValue = 0.000000;
    m_ArmyAgainstMountedBonusValue = 0.000000;
    m_ArmyAirDefenseBonusValue = 0.000000;
    m_EnergyHunger = 0;
    m_ProducesEnergy = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void UnitpromotionRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_flags1;
        archive << m_flags2;
        archive << m_flags3;
        archive << m_flags4;
        archive << m_flags5;
        archive << m_flags6;
        archive << m_MovementType;
        archive << m_CanCarry;
        archive << m_AvailableUnit;
        archive << m_EnableAdvance;
        archive << m_numObsoleteAdvance;
        archive.Store((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive << m_numPrerequisiteBuilding;
        archive.Store((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive << m_numExcludedByBuilding;
        archive.Store((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_numUpgradeToPromotion;
        archive.Store((uint8*)m_UpgradeToPromotion, m_numUpgradeToPromotion * sizeof(sint32));

        archive << m_numObsoletePromotion;
        archive.Store((uint8*)m_ObsoletePromotion, m_numObsoletePromotion * sizeof(sint32));

        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_numCityStyleOnly;
        archive.Store((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive << m_numCivilisationOnly;
        archive.Store((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive << m_numGovernmentOnly;
        archive.Store((uint8*)m_GovernmentOnly, m_numGovernmentOnly * sizeof(sint32));

        archive << m_numNeedsCityGood;
        archive.Store((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive << m_numNeedsCityGoodAll;
        archive.Store((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive << m_numNeedsCityGoodAnyCity;
        archive.Store((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive << m_numNeedsFeatToBuild;
        archive.Store((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive << m_numNeedsAnyPlayerFeatToBuild;
        archive.Store((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive << m_numPrerequisiteWonder;
        archive.Store((uint8*)m_PrerequisiteWonder, m_numPrerequisiteWonder * sizeof(sint32));

        archive << m_numExcludedByWonder;
        archive.Store((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive << m_MoveBonusValue;
        archive << m_PWMoveCostValue;
        archive << m_MerchantGoldValue;
        archive << m_numAllTerrainAsImprovement;
        archive.Store((uint8*)m_AllTerrainAsImprovement, m_numAllTerrainAsImprovement * sizeof(sint32));

        archive << m_numObsoleteByUnit;
        archive.Store((uint8*)m_ObsoleteByUnit, m_numObsoleteByUnit * sizeof(sint32));

        archive << m_Size;
        archive << m_CanBombard;
        archive << m_Settle;
        archive << m_SettleCityType;
        archive << m_SettleSize;
        archive << m_numSettleBuilding;
        archive.Store((uint8*)m_SettleBuilding, m_numSettleBuilding * sizeof(sint32));

        archive << m_SpaceLaunchValue;
        archive << m_Defend;
        archive << m_DefendAgainstSpiesValue;
        archive << m_ReplaceWithCargoModuleValue;
        m_NuclearAttackValue.Serialize(archive);
        m_StealTechnologyValue.Serialize(archive);
        m_InciteRevolutionValue.Serialize(archive);
        m_AssasinateRulerValue.Serialize(archive);
        m_InvestigateReadinessValue.Serialize(archive);
        m_CreateFranchiseValue.Serialize(archive);
        m_CauseUnhappinessValue.Serialize(archive);
        m_ConductHitsValue.Serialize(archive);
        m_BioTerrorValue.Serialize(archive);
        m_NanoTerrorValue.Serialize(archive);
        m_PlagueValue.Serialize(archive);
        m_SlaveRaidsValue.Serialize(archive);
        m_SettlerSlaveRaidsValue.Serialize(archive);
        m_SlaveUprisingValue.Serialize(archive);
        m_UndergroundRailwayValue.Serialize(archive);
        archive << m_VictoryEnslavementChanceValue;
        m_IndulgenceSalesValue.Serialize(archive);
        m_ConvertCitiesValue.Serialize(archive);
        archive << m_numGovernmentType;
        archive.Store((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        m_PlantNukeValue.Serialize(archive);
        m_CanSoothsayValue.Serialize(archive);
        m_CreateParksValue.Serialize(archive);
        m_CanInjoinValue.Serialize(archive);
        archive << m_PopCostsToBuildValue;
        m_CanReformValue.Serialize(archive);
        archive << m_ReducesDefensesBonus;
        archive << m_VisionClass;
        archive << m_CanSee;
        archive << m_CanAttack;
        m_CargoDataValue.Serialize(archive);
        archive << m_ShieldCost;
        archive << m_PowerPoints;
        archive << m_MaxHP;
        archive << m_MaxHPr;
        archive << m_Attack;
        archive << m_Defense;
        archive << m_Firepower;
        archive << m_ZBRangeAttack;
        archive << m_Armor;
        archive << m_BRangeValue;
        archive << m_BRadiusValue;
        archive << m_VisionRange;
        archive << m_ActiveDefenseRange;
        archive << m_ElectronicCombatFactorValue;
        archive << m_MaxMovePoints;
        archive << m_MaxFuel;
        archive << m_TransTypeValue;
        archive << m_ProbOfBombHitValue;
        archive << m_BombRoundsValue;
        archive << m_ShieldHunger;
        archive << m_FoodHunger;
        archive << m_GoldHunger;
        archive << m_DefaultSprite;
        archive << m_LaunchPollutionValue;
        archive << m_DeathPollutionValue;
        archive << m_MountedBonusValue;
        archive << m_AirBonusValue;
        archive << m_WoodenShipBonusValue;
        archive << m_AttackCityBonusValue;
        archive << m_AttackBonusSubmarineValue;
        archive << m_FootBonusValue;
        archive << m_SiegeBonusValue;
        archive << m_WheeledBonusValue;
        archive << m_MechanizedBonusValue;
        archive << m_HelicopterBonusValue;
        archive << m_SpecialForcesBonusValue;
        archive << m_CivilianBonusValue;
        archive << m_GuerrillaBonusValue;
        archive << m_AgainstMountedBonusValue;
        archive << m_AirDefenseBonusValue;
        archive << m_CargoModuleValue;
        archive << m_SpyVsSpyValue;
        m_InvestigateCityValue.Serialize(archive);
        archive << m_BonusFoodValue;
        archive << m_BombardRangeValue;
        m_RevolutionValue.Serialize(archive);
        archive << m_SoundSelect1;
        archive << m_SoundSelect2;
        archive << m_SoundMove;
        archive << m_SoundAcknowledge;
        archive << m_SoundCantMove;
        archive << m_SoundAttack;
        archive << m_SoundWork;
        archive << m_SoundVictory;
        archive << m_SoundDeath;
        archive << m_SoundLoad;
        archive << m_SoundUnload;
        archive << m_numSpecialAttacks;
        archive.Store((uint8*)&m_SpecialAttacks, sizeof(m_SpecialAttacks));
        archive << m_CityGrowthCoefficientValue;
        archive << m_UserFlags;
        archive << m_DefaultIcon;
        archive << m_CheatIndexValue;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Description);
            archive << tmpString;
        }

        if (HasAdvice()){
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_AdviceValue);
            archive << tmpString;
        }

        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Category);
            archive << tmpString;
        }

        archive << m_ArmyMountedBonusValue;
        archive << m_ArmyAirBonusValue;
        archive << m_ArmyWoodenShipBonusValue;
        archive << m_ArmyAttackCityBonusValue;
        archive << m_ArmyAttackBonusSubmarineValue;
        archive << m_ArmyFootBonusValue;
        archive << m_ArmySiegeBonusValue;
        archive << m_ArmyWheeledBonusValue;
        archive << m_ArmyMechanizedBonusValue;
        archive << m_ArmyHelicopterBonusValue;
        archive << m_ArmySpecialForcesBonusValue;
        archive << m_ArmyCivilianBonusValue;
        archive << m_ArmyGuerrillaBonusValue;
        archive << m_ArmyAgainstMountedBonusValue;
        archive << m_ArmyAirDefenseBonusValue;
        archive << m_EnergyHunger;
        archive << m_ProducesEnergy;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_flags2;
        archive >> m_flags3;
        archive >> m_flags4;
        archive >> m_flags5;
        archive >> m_flags6;
        archive >> m_MovementType;
        archive >> m_CanCarry;
        archive >> m_AvailableUnit;
        archive >> m_EnableAdvance;
        archive >> m_numObsoleteAdvance;
        archive.Load((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive >> m_numPrerequisiteBuilding;
        archive.Load((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive >> m_numExcludedByBuilding;
        archive.Load((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive >> m_numUpgradeToPromotion;
        archive.Load((uint8*)m_UpgradeToPromotion, m_numUpgradeToPromotion * sizeof(sint32));

        archive >> m_numObsoletePromotion;
        archive.Load((uint8*)m_ObsoletePromotion, m_numObsoletePromotion * sizeof(sint32));

        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_numCityStyleOnly;
        archive.Load((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive >> m_numCivilisationOnly;
        archive.Load((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive >> m_numGovernmentOnly;
        archive.Load((uint8*)m_GovernmentOnly, m_numGovernmentOnly * sizeof(sint32));

        archive >> m_numNeedsCityGood;
        archive.Load((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive >> m_numNeedsCityGoodAll;
        archive.Load((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive >> m_numNeedsCityGoodAnyCity;
        archive.Load((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive >> m_numNeedsFeatToBuild;
        archive.Load((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive >> m_numNeedsAnyPlayerFeatToBuild;
        archive.Load((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive >> m_numPrerequisiteWonder;
        archive.Load((uint8*)m_PrerequisiteWonder, m_numPrerequisiteWonder * sizeof(sint32));

        archive >> m_numExcludedByWonder;
        archive.Load((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive >> m_MoveBonusValue;
        archive >> m_PWMoveCostValue;
        archive >> m_MerchantGoldValue;
        archive >> m_numAllTerrainAsImprovement;
        archive.Load((uint8*)m_AllTerrainAsImprovement, m_numAllTerrainAsImprovement * sizeof(sint32));

        archive >> m_numObsoleteByUnit;
        archive.Load((uint8*)m_ObsoleteByUnit, m_numObsoleteByUnit * sizeof(sint32));

        archive >> m_Size;
        archive >> m_CanBombard;
        archive >> m_Settle;
        archive >> m_SettleCityType;
        archive >> m_SettleSize;
        archive >> m_numSettleBuilding;
        archive.Load((uint8*)m_SettleBuilding, m_numSettleBuilding * sizeof(sint32));

        archive >> m_SpaceLaunchValue;
        archive >> m_Defend;
        archive >> m_DefendAgainstSpiesValue;
        archive >> m_ReplaceWithCargoModuleValue;
        memset((uint8*)&m_NuclearAttackValue, 0, sizeof(m_NuclearAttackValue));
        m_NuclearAttackValue.Serialize(archive);
        memset((uint8*)&m_StealTechnologyValue, 0, sizeof(m_StealTechnologyValue));
        m_StealTechnologyValue.Serialize(archive);
        memset((uint8*)&m_InciteRevolutionValue, 0, sizeof(m_InciteRevolutionValue));
        m_InciteRevolutionValue.Serialize(archive);
        memset((uint8*)&m_AssasinateRulerValue, 0, sizeof(m_AssasinateRulerValue));
        m_AssasinateRulerValue.Serialize(archive);
        memset((uint8*)&m_InvestigateReadinessValue, 0, sizeof(m_InvestigateReadinessValue));
        m_InvestigateReadinessValue.Serialize(archive);
        memset((uint8*)&m_CreateFranchiseValue, 0, sizeof(m_CreateFranchiseValue));
        m_CreateFranchiseValue.Serialize(archive);
        memset((uint8*)&m_CauseUnhappinessValue, 0, sizeof(m_CauseUnhappinessValue));
        m_CauseUnhappinessValue.Serialize(archive);
        memset((uint8*)&m_ConductHitsValue, 0, sizeof(m_ConductHitsValue));
        m_ConductHitsValue.Serialize(archive);
        memset((uint8*)&m_BioTerrorValue, 0, sizeof(m_BioTerrorValue));
        m_BioTerrorValue.Serialize(archive);
        memset((uint8*)&m_NanoTerrorValue, 0, sizeof(m_NanoTerrorValue));
        m_NanoTerrorValue.Serialize(archive);
        memset((uint8*)&m_PlagueValue, 0, sizeof(m_PlagueValue));
        m_PlagueValue.Serialize(archive);
        memset((uint8*)&m_SlaveRaidsValue, 0, sizeof(m_SlaveRaidsValue));
        m_SlaveRaidsValue.Serialize(archive);
        memset((uint8*)&m_SettlerSlaveRaidsValue, 0, sizeof(m_SettlerSlaveRaidsValue));
        m_SettlerSlaveRaidsValue.Serialize(archive);
        memset((uint8*)&m_SlaveUprisingValue, 0, sizeof(m_SlaveUprisingValue));
        m_SlaveUprisingValue.Serialize(archive);
        memset((uint8*)&m_UndergroundRailwayValue, 0, sizeof(m_UndergroundRailwayValue));
        m_UndergroundRailwayValue.Serialize(archive);
        archive >> m_VictoryEnslavementChanceValue;
        memset((uint8*)&m_IndulgenceSalesValue, 0, sizeof(m_IndulgenceSalesValue));
        m_IndulgenceSalesValue.Serialize(archive);
        memset((uint8*)&m_ConvertCitiesValue, 0, sizeof(m_ConvertCitiesValue));
        m_ConvertCitiesValue.Serialize(archive);
        archive >> m_numGovernmentType;
        archive.Load((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        memset((uint8*)&m_PlantNukeValue, 0, sizeof(m_PlantNukeValue));
        m_PlantNukeValue.Serialize(archive);
        memset((uint8*)&m_CanSoothsayValue, 0, sizeof(m_CanSoothsayValue));
        m_CanSoothsayValue.Serialize(archive);
        memset((uint8*)&m_CreateParksValue, 0, sizeof(m_CreateParksValue));
        m_CreateParksValue.Serialize(archive);
        memset((uint8*)&m_CanInjoinValue, 0, sizeof(m_CanInjoinValue));
        m_CanInjoinValue.Serialize(archive);
        archive >> m_PopCostsToBuildValue;
        memset((uint8*)&m_CanReformValue, 0, sizeof(m_CanReformValue));
        m_CanReformValue.Serialize(archive);
        archive >> m_ReducesDefensesBonus;
        archive >> m_VisionClass;
        archive >> m_CanSee;
        archive >> m_CanAttack;
        memset((uint8*)&m_CargoDataValue, 0, sizeof(m_CargoDataValue));
        m_CargoDataValue.Serialize(archive);
        archive >> m_ShieldCost;
        archive >> m_PowerPoints;
        archive >> m_MaxHP;
        archive >> m_MaxHPr;
        archive >> m_Attack;
        archive >> m_Defense;
        archive >> m_Firepower;
        archive >> m_ZBRangeAttack;
        archive >> m_Armor;
        archive >> m_BRangeValue;
        archive >> m_BRadiusValue;
        archive >> m_VisionRange;
        archive >> m_ActiveDefenseRange;
        archive >> m_ElectronicCombatFactorValue;
        archive >> m_MaxMovePoints;
        archive >> m_MaxFuel;
        archive >> m_TransTypeValue;
        archive >> m_ProbOfBombHitValue;
        archive >> m_BombRoundsValue;
        archive >> m_ShieldHunger;
        archive >> m_FoodHunger;
        archive >> m_GoldHunger;
        archive >> m_DefaultSprite;
        archive >> m_LaunchPollutionValue;
        archive >> m_DeathPollutionValue;
        archive >> m_MountedBonusValue;
        archive >> m_AirBonusValue;
        archive >> m_WoodenShipBonusValue;
        archive >> m_AttackCityBonusValue;
        archive >> m_AttackBonusSubmarineValue;
        archive >> m_FootBonusValue;
        archive >> m_SiegeBonusValue;
        archive >> m_WheeledBonusValue;
        archive >> m_MechanizedBonusValue;
        archive >> m_HelicopterBonusValue;
        archive >> m_SpecialForcesBonusValue;
        archive >> m_CivilianBonusValue;
        archive >> m_GuerrillaBonusValue;
        archive >> m_AgainstMountedBonusValue;
        archive >> m_AirDefenseBonusValue;
        archive >> m_CargoModuleValue;
        archive >> m_SpyVsSpyValue;
        memset((uint8*)&m_InvestigateCityValue, 0, sizeof(m_InvestigateCityValue));
        m_InvestigateCityValue.Serialize(archive);
        archive >> m_BonusFoodValue;
        archive >> m_BombardRangeValue;
        memset((uint8*)&m_RevolutionValue, 0, sizeof(m_RevolutionValue));
        m_RevolutionValue.Serialize(archive);
        archive >> m_SoundSelect1;
        archive >> m_SoundSelect2;
        archive >> m_SoundMove;
        archive >> m_SoundAcknowledge;
        archive >> m_SoundCantMove;
        archive >> m_SoundAttack;
        archive >> m_SoundWork;
        archive >> m_SoundVictory;
        archive >> m_SoundDeath;
        archive >> m_SoundLoad;
        archive >> m_SoundUnload;
        archive >> m_numSpecialAttacks;
        archive.Load((uint8*)&m_SpecialAttacks, sizeof(m_SpecialAttacks));
        archive >> m_CityGrowthCoefficientValue;
        archive >> m_UserFlags;
        archive >> m_DefaultIcon;
        archive >> m_CheatIndexValue;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Description);
            delete[] tmpString;
        }

        {
            if (HasAdvice()){
                MBCHAR* tmpString = NULL;
                archive >> tmpString;
                g_theStringDB->GetStringID(tmpString, m_AdviceValue);
                delete[] tmpString;
            }
        }

        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Category);
            delete[] tmpString;
        }

        archive >> m_ArmyMountedBonusValue;
        archive >> m_ArmyAirBonusValue;
        archive >> m_ArmyWoodenShipBonusValue;
        archive >> m_ArmyAttackCityBonusValue;
        archive >> m_ArmyAttackBonusSubmarineValue;
        archive >> m_ArmyFootBonusValue;
        archive >> m_ArmySiegeBonusValue;
        archive >> m_ArmyWheeledBonusValue;
        archive >> m_ArmyMechanizedBonusValue;
        archive >> m_ArmyHelicopterBonusValue;
        archive >> m_ArmySpecialForcesBonusValue;
        archive >> m_ArmyCivilianBonusValue;
        archive >> m_ArmyGuerrillaBonusValue;
        archive >> m_ArmyAgainstMountedBonusValue;
        archive >> m_ArmyAirDefenseBonusValue;
        archive >> m_EnergyHunger;
        archive >> m_ProducesEnergy;
    }
}

UnitpromotionRecord::~UnitpromotionRecord()
{
    delete [] m_PrerequisiteBuilding;
    delete [] m_ExcludedByBuilding;
    delete [] m_GovernmentsModified;
    delete [] m_UpgradeToPromotion;
    delete [] m_ObsoletePromotion;
    delete [] m_CultureOnly;
    delete [] m_CityStyleOnly;
    delete [] m_CivilisationOnly;
    delete [] m_GovernmentOnly;
    delete [] m_NeedsCityGood;
    delete [] m_NeedsCityGoodAll;
    delete [] m_NeedsCityGoodAnyCity;
    delete [] m_NeedsFeatToBuild;
    delete [] m_NeedsAnyPlayerFeatToBuild;
    delete [] m_PrerequisiteWonder;
    delete [] m_ExcludedByWonder;
    delete [] m_AllTerrainAsImprovement;
    delete [] m_ObsoleteByUnit;
    delete [] m_SettleBuilding;
    delete [] m_GovernmentType;
}

UnitpromotionRecord const & UnitpromotionRecord::operator = (UnitpromotionRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;
        m_flags2 = rval.m_flags2;
        m_flags3 = rval.m_flags3;
        m_flags4 = rval.m_flags4;
        m_flags5 = rval.m_flags5;
        m_flags6 = rval.m_flags6;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_MovementType = rval.m_MovementType;

        m_CanCarry = rval.m_CanCarry;

        m_AvailableUnit = rval.m_AvailableUnit;

        m_EnableAdvance = rval.m_EnableAdvance;

        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
        {
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
            std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);
        }
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;

        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
        {
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
            std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);
        }
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        delete [] m_UpgradeToPromotion;
        m_UpgradeToPromotion = NULL;
        if (rval.m_numUpgradeToPromotion > 0)
        {
            m_UpgradeToPromotion = new sint32 [rval.m_numUpgradeToPromotion];
            std::copy(rval.m_UpgradeToPromotion, rval.m_UpgradeToPromotion + rval.m_numUpgradeToPromotion, m_UpgradeToPromotion);
        }
        m_numUpgradeToPromotion = rval.m_numUpgradeToPromotion;

        delete [] m_ObsoletePromotion;
        m_ObsoletePromotion = NULL;
        if (rval.m_numObsoletePromotion > 0)
        {
            m_ObsoletePromotion = new sint32 [rval.m_numObsoletePromotion];
            std::copy(rval.m_ObsoletePromotion, rval.m_ObsoletePromotion + rval.m_numObsoletePromotion, m_ObsoletePromotion);
        }
        m_numObsoletePromotion = rval.m_numObsoletePromotion;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
        {
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
            std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);
        }
        m_numCityStyleOnly = rval.m_numCityStyleOnly;

        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
        {
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
            std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);
        }
        m_numCivilisationOnly = rval.m_numCivilisationOnly;

        delete [] m_GovernmentOnly;
        m_GovernmentOnly = NULL;
        if (rval.m_numGovernmentOnly > 0)
        {
            m_GovernmentOnly = new sint32 [rval.m_numGovernmentOnly];
            std::copy(rval.m_GovernmentOnly, rval.m_GovernmentOnly + rval.m_numGovernmentOnly, m_GovernmentOnly);
        }
        m_numGovernmentOnly = rval.m_numGovernmentOnly;

        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
        {
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
            std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);
        }
        m_numNeedsCityGood = rval.m_numNeedsCityGood;

        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
        {
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
            std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);
        }
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;

        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
        {
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
            std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);
        }
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;

        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
        {
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
            std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);
        }
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;

        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        {
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
            std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);
        }
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;

        delete [] m_PrerequisiteWonder;
        m_PrerequisiteWonder = NULL;
        if (rval.m_numPrerequisiteWonder > 0)
        {
            m_PrerequisiteWonder = new sint32 [rval.m_numPrerequisiteWonder];
            std::copy(rval.m_PrerequisiteWonder, rval.m_PrerequisiteWonder + rval.m_numPrerequisiteWonder, m_PrerequisiteWonder);
        }
        m_numPrerequisiteWonder = rval.m_numPrerequisiteWonder;

        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
        {
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
            std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);
        }
        m_numExcludedByWonder = rval.m_numExcludedByWonder;

        m_MoveBonusValue = rval.m_MoveBonusValue;

        m_PWMoveCostValue = rval.m_PWMoveCostValue;

        m_MerchantGoldValue = rval.m_MerchantGoldValue;

        delete [] m_AllTerrainAsImprovement;
        m_AllTerrainAsImprovement = NULL;
        if (rval.m_numAllTerrainAsImprovement > 0)
        {
            m_AllTerrainAsImprovement = new sint32 [rval.m_numAllTerrainAsImprovement];
            std::copy(rval.m_AllTerrainAsImprovement, rval.m_AllTerrainAsImprovement + rval.m_numAllTerrainAsImprovement, m_AllTerrainAsImprovement);
        }
        m_numAllTerrainAsImprovement = rval.m_numAllTerrainAsImprovement;

        delete [] m_ObsoleteByUnit;
        m_ObsoleteByUnit = NULL;
        if (rval.m_numObsoleteByUnit > 0)
        {
            m_ObsoleteByUnit = new sint32 [rval.m_numObsoleteByUnit];
            std::copy(rval.m_ObsoleteByUnit, rval.m_ObsoleteByUnit + rval.m_numObsoleteByUnit, m_ObsoleteByUnit);
        }
        m_numObsoleteByUnit = rval.m_numObsoleteByUnit;

        m_Size = rval.m_Size;

        m_CanBombard = rval.m_CanBombard;

        m_Settle = rval.m_Settle;

        m_SettleCityType = rval.m_SettleCityType;

        m_SettleSize = rval.m_SettleSize;

        delete [] m_SettleBuilding;
        m_SettleBuilding = NULL;
        if (rval.m_numSettleBuilding > 0)
        {
            m_SettleBuilding = new sint32 [rval.m_numSettleBuilding];
            std::copy(rval.m_SettleBuilding, rval.m_SettleBuilding + rval.m_numSettleBuilding, m_SettleBuilding);
        }
        m_numSettleBuilding = rval.m_numSettleBuilding;

        m_SpaceLaunchValue = rval.m_SpaceLaunchValue;

        m_Defend = rval.m_Defend;

        m_DefendAgainstSpiesValue = rval.m_DefendAgainstSpiesValue;

        m_ReplaceWithCargoModuleValue = rval.m_ReplaceWithCargoModuleValue;

        m_NuclearAttackValue = rval.m_NuclearAttackValue;

        m_StealTechnologyValue = rval.m_StealTechnologyValue;

        m_InciteRevolutionValue = rval.m_InciteRevolutionValue;

        m_AssasinateRulerValue = rval.m_AssasinateRulerValue;

        m_InvestigateReadinessValue = rval.m_InvestigateReadinessValue;

        m_CreateFranchiseValue = rval.m_CreateFranchiseValue;

        m_CauseUnhappinessValue = rval.m_CauseUnhappinessValue;

        m_ConductHitsValue = rval.m_ConductHitsValue;

        m_BioTerrorValue = rval.m_BioTerrorValue;

        m_NanoTerrorValue = rval.m_NanoTerrorValue;

        m_PlagueValue = rval.m_PlagueValue;

        m_SlaveRaidsValue = rval.m_SlaveRaidsValue;

        m_SettlerSlaveRaidsValue = rval.m_SettlerSlaveRaidsValue;

        m_SlaveUprisingValue = rval.m_SlaveUprisingValue;

        m_UndergroundRailwayValue = rval.m_UndergroundRailwayValue;

        m_VictoryEnslavementChanceValue = rval.m_VictoryEnslavementChanceValue;

        m_IndulgenceSalesValue = rval.m_IndulgenceSalesValue;

        m_ConvertCitiesValue = rval.m_ConvertCitiesValue;

        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
        {
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
            std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);
        }
        m_numGovernmentType = rval.m_numGovernmentType;

        m_PlantNukeValue = rval.m_PlantNukeValue;

        m_CanSoothsayValue = rval.m_CanSoothsayValue;

        m_CreateParksValue = rval.m_CreateParksValue;

        m_CanInjoinValue = rval.m_CanInjoinValue;

        m_PopCostsToBuildValue = rval.m_PopCostsToBuildValue;

        m_CanReformValue = rval.m_CanReformValue;

        m_ReducesDefensesBonus = rval.m_ReducesDefensesBonus;

        m_VisionClass = rval.m_VisionClass;

        m_CanSee = rval.m_CanSee;

        m_CanAttack = rval.m_CanAttack;

        m_CargoDataValue = rval.m_CargoDataValue;

        m_ShieldCost = rval.m_ShieldCost;

        m_PowerPoints = rval.m_PowerPoints;

        m_MaxHP = rval.m_MaxHP;

        m_MaxHPr = rval.m_MaxHPr;

        m_Attack = rval.m_Attack;

        m_Defense = rval.m_Defense;

        m_Firepower = rval.m_Firepower;

        m_ZBRangeAttack = rval.m_ZBRangeAttack;

        m_Armor = rval.m_Armor;

        m_BRangeValue = rval.m_BRangeValue;

        m_BRadiusValue = rval.m_BRadiusValue;

        m_VisionRange = rval.m_VisionRange;

        m_ActiveDefenseRange = rval.m_ActiveDefenseRange;

        m_ElectronicCombatFactorValue = rval.m_ElectronicCombatFactorValue;

        m_MaxMovePoints = rval.m_MaxMovePoints;

        m_MaxFuel = rval.m_MaxFuel;

        m_TransTypeValue = rval.m_TransTypeValue;

        m_ProbOfBombHitValue = rval.m_ProbOfBombHitValue;

        m_BombRoundsValue = rval.m_BombRoundsValue;

        m_ShieldHunger = rval.m_ShieldHunger;

        m_FoodHunger = rval.m_FoodHunger;

        m_GoldHunger = rval.m_GoldHunger;

        m_DefaultSprite = rval.m_DefaultSprite;

        m_LaunchPollutionValue = rval.m_LaunchPollutionValue;

        m_DeathPollutionValue = rval.m_DeathPollutionValue;

        m_MountedBonusValue = rval.m_MountedBonusValue;

        m_AirBonusValue = rval.m_AirBonusValue;

        m_WoodenShipBonusValue = rval.m_WoodenShipBonusValue;

        m_AttackCityBonusValue = rval.m_AttackCityBonusValue;

        m_AttackBonusSubmarineValue = rval.m_AttackBonusSubmarineValue;

        m_FootBonusValue = rval.m_FootBonusValue;

        m_SiegeBonusValue = rval.m_SiegeBonusValue;

        m_WheeledBonusValue = rval.m_WheeledBonusValue;

        m_MechanizedBonusValue = rval.m_MechanizedBonusValue;

        m_HelicopterBonusValue = rval.m_HelicopterBonusValue;

        m_SpecialForcesBonusValue = rval.m_SpecialForcesBonusValue;

        m_CivilianBonusValue = rval.m_CivilianBonusValue;

        m_GuerrillaBonusValue = rval.m_GuerrillaBonusValue;

        m_AgainstMountedBonusValue = rval.m_AgainstMountedBonusValue;

        m_AirDefenseBonusValue = rval.m_AirDefenseBonusValue;

        m_CargoModuleValue = rval.m_CargoModuleValue;

        m_SpyVsSpyValue = rval.m_SpyVsSpyValue;

        m_InvestigateCityValue = rval.m_InvestigateCityValue;

        m_BonusFoodValue = rval.m_BonusFoodValue;

        m_BombardRangeValue = rval.m_BombardRangeValue;

        m_RevolutionValue = rval.m_RevolutionValue;

        m_SoundSelect1 = rval.m_SoundSelect1;

        m_SoundSelect2 = rval.m_SoundSelect2;

        m_SoundMove = rval.m_SoundMove;

        m_SoundAcknowledge = rval.m_SoundAcknowledge;

        m_SoundCantMove = rval.m_SoundCantMove;

        m_SoundAttack = rval.m_SoundAttack;

        m_SoundWork = rval.m_SoundWork;

        m_SoundVictory = rval.m_SoundVictory;

        m_SoundDeath = rval.m_SoundDeath;

        m_SoundLoad = rval.m_SoundLoad;

        m_SoundUnload = rval.m_SoundUnload;

        std::copy(rval.m_SpecialAttacks, rval.m_SpecialAttacks + rval.m_numSpecialAttacks, m_SpecialAttacks);

        m_CityGrowthCoefficientValue = rval.m_CityGrowthCoefficientValue;

        m_UserFlags = rval.m_UserFlags;

        m_DefaultIcon = rval.m_DefaultIcon;

        m_CheatIndexValue = rval.m_CheatIndexValue;

        m_Description = rval.m_Description;

        m_AdviceValue = rval.m_AdviceValue;

        m_Category = rval.m_Category;

        m_ArmyMountedBonusValue = rval.m_ArmyMountedBonusValue;

        m_ArmyAirBonusValue = rval.m_ArmyAirBonusValue;

        m_ArmyWoodenShipBonusValue = rval.m_ArmyWoodenShipBonusValue;

        m_ArmyAttackCityBonusValue = rval.m_ArmyAttackCityBonusValue;

        m_ArmyAttackBonusSubmarineValue = rval.m_ArmyAttackBonusSubmarineValue;

        m_ArmyFootBonusValue = rval.m_ArmyFootBonusValue;

        m_ArmySiegeBonusValue = rval.m_ArmySiegeBonusValue;

        m_ArmyWheeledBonusValue = rval.m_ArmyWheeledBonusValue;

        m_ArmyMechanizedBonusValue = rval.m_ArmyMechanizedBonusValue;

        m_ArmyHelicopterBonusValue = rval.m_ArmyHelicopterBonusValue;

        m_ArmySpecialForcesBonusValue = rval.m_ArmySpecialForcesBonusValue;

        m_ArmyCivilianBonusValue = rval.m_ArmyCivilianBonusValue;

        m_ArmyGuerrillaBonusValue = rval.m_ArmyGuerrillaBonusValue;

        m_ArmyAgainstMountedBonusValue = rval.m_ArmyAgainstMountedBonusValue;

        m_ArmyAirDefenseBonusValue = rval.m_ArmyAirDefenseBonusValue;

        m_EnergyHunger = rval.m_EnergyHunger;

        m_ProducesEnergy = rval.m_ProducesEnergy;

    }

    return *this;
}

const char *g_Unitpromotion_Tokens[] =
{
    "MovementType",
    "CanCarry",
    "AvailableUnit",
    "EnableAdvance",
    "ObsoleteAdvance",
    "PrerequisiteBuilding",
    "ExcludedByBuilding",
    "GovernmentsModified",
    "UpgradeToPromotion",
    "ObsoletePromotion",
    "CultureOnly",
    "CityStyleOnly",
    "CivilisationOnly",
    "GovernmentOnly",
    "NeedsCityGood",
    "NeedsCityGoodAll",
    "NeedsCityGoodAnyCity",
    "NeedsFeatToBuild",
    "NeedsAnyPlayerFeatToBuild",
    "PrerequisiteWonder",
    "ExcludedByWonder",
    "MoveBonus",
    "MoveBonusValue",
    "PWMoveCost",
    "PWMoveCostValue",
    "MerchantGold",
    "MerchantGoldValue",
    "IsGreatBuilder",
    "IsGreatArtist",
    "AllTerrainAsImprovement",
    "ObsoleteByUnit",
    "NonLethalBombard",
    "CanBombardTiles",
    "CollateralTileDamage",
    "PrecisionStrike",
    "TargetsCivilians",
    "ImmuneToHostileTerrain",
    "CanRebase",
    "MultipleAttacks",
    "CanBeGifted",
    "UpgradeAnywhere",
    "UpgradeDoesNotHeal",
    "Size",
    "LossMoveToDmgNone",
    "LossMoveToDmgTwo",
    "NoFuelThenCrash",
    "TransformPartial",
    "IgnoreZOC",
    "NoZoc",
    "CanBombard",
    "CanCounterBombard",
    "CanLiftOff",
    "Settle",
    "SettleCityType",
    "SettleSize",
    "SettleBuilding",
    "SpaceLaunch",
    "SpaceLaunchValue",
    "SpaceLand",
    "CantCaptureCity",
    "HasPopAndCanBuild",
    "IsTrader",
    "ExertsMartialLaw",
    "CanEntrench",
    "CanPatrol",
    "NeedsNoSupport",
    "CanExpelPop",
    "IsFlanker",
    "CanBeachAssault",
    "Defend",
    "DefendAgainstSpies",
    "DefendAgainstSpiesValue",
    "CanBeExpelled",
    "CanBeSued",
    "AttackFromSpaceship",
    "CantBeAttacked",
    "CargoPod",
    "IsFoot",
    "IsMounted",
    "IsSiege",
    "IsWheeled",
    "IsMechanized",
    "IsHelicopter",
    "IsSubmarine",
    "IgnoreCityWalls",
    "NoLandAttack",
    "NoSeaAttack",
    "NoAirAttack",
    "NoSpaceAttack",
    "NoUnderwaterAttack",
    "NoMountainAttack",
    "NoShallowWaterAttack",
    "Paratrooper",
    "AssistedDrops",
    "BonusAgainstFoot",
    "BonusAgainstMounted",
    "BonusAgainstSiege",
    "BonusAgainstWheeled",
    "BonusAgainstMechanized",
    "BonusAgainstHelicopter",
    "BonusAgainstGuerrilla",
    "BonusAgainstSpecialForces",
    "BonusAgainstSubmarine",
    "SingleUse",
    "BonusAirDefense",
    "WoodenShip",
    "AttackFootBonus",
    "AttackMountedBonus",
    "AttackSiegeBonus",
    "AttackWheeledBonus",
    "AttackMechanizedBonus",
    "AttackHelicopterBonus",
    "AttackSpecialForcesBonus",
    "AttackCivilianBonus",
    "AttackGuerrillaBonus",
    "AttackWoodenShipBonus",
    "HasAttackCityBonus",
    "HasAttackBonusSubmarine",
    "ReplaceWithCargoModule",
    "ReplaceWithCargoModuleValue",
    "VisibileAttacking",
    "NuclearAttack",
    "NuclearAttackValue",
    "CanSue",
    "IsStealthy",
    "SeeSurfaceFromSpace",
    "EstablishEmbassy",
    "ThrowParty",
    "HearGossip",
    "StealTechnology",
    "StealTechnologyValue",
    "InciteRevolution",
    "InciteRevolutionValue",
    "AssasinateRuler",
    "AssasinateRulerValue",
    "InvestigateReadiness",
    "InvestigateReadinessValue",
    "NullifyCityWalls",
    "CreateFranchise",
    "CreateFranchiseValue",
    "CauseUnhappiness",
    "CauseUnhappinessValue",
    "ConductHits",
    "ConductHitsValue",
    "BioTerror",
    "BioTerrorValue",
    "NanoTerror",
    "NanoTerrorValue",
    "Plague",
    "PlagueValue",
    "SlaveRaids",
    "SlaveRaidsValue",
    "SettlerSlaveRaids",
    "SettlerSlaveRaidsValue",
    "SlaveUprising",
    "SlaveUprisingValue",
    "UndergroundRailway",
    "UndergroundRailwayValue",
    "VictoryEnslavement",
    "VictoryEnslavementChance",
    "VictoryEnslavementChanceValue",
    "VictoryEnslavementStacks",
    "DefuseLandMines",
    "DefuseSeaMines",
    "DefuseXrayMines",
    "IndulgenceSales",
    "IndulgenceSalesValue",
    "ConvertCities",
    "ConvertCitiesValue",
    "BuildXrayMines",
    "BuildWonder",
    "GovernmentType",
    "NoSlaves",
    "CreateRift",
    "CanCloak",
    "HiddenNationality",
    "SneakAttack",
    "SneakPillage",
    "SneakBombard",
    "ParatrooperTransport",
    "CantBuild",
    "PlantNuke",
    "PlantNukeValue",
    "IsTelevangelist",
    "CanSoothsay",
    "CanSoothsayValue",
    "CanBeRustled",
    "CreateParks",
    "CreateParksValue",
    "CanInjoin",
    "CanInjoinValue",
    "WormholeProbe",
    "HasBonusFood",
    "LandCityCanBuild",
    "SeaCityCanBuild",
    "SpaceCityCanBuild",
    "IsSpecialForces",
    "IsPeaceKeeper",
    "IsGuerrilla",
    "IsWorker",
    "NotAffectedByLandMines",
    "InternalReserved",
    "DeathEffectsHappy",
    "EnableCarrierDefenses",
    "ActiveDefenseOnlyWhenCarryingEnablers",
    "BuildingRemovesAPop",
    "PopCostsToBuild",
    "PopCostsToBuildValue",
    "Explodes",
    "Advertise",
    "CanRustle",
    "OnlyBuildOne",
    "CanExpel",
    "CanReform",
    "CanReformValue",
    "CanPillage",
    "CanPirate",
    "CanCaptureTile",
    "ReducesDefensesBonus",
    "VisionClass",
    "CanSee",
    "CanAttack",
    "CargoData",
    "CargoDataValue",
    "ShieldCost",
    "PowerPoints",
    "MaxHP",
    "MaxHPr",
    "Attack",
    "Defense",
    "Firepower",
    "ZBRangeAttack",
    "Armor",
    "BRange",
    "BRangeValue",
    "BRadius",
    "BRadiusValue",
    "VisionRange",
    "ActiveDefenseRange",
    "ElectronicCombatFactor",
    "ElectronicCombatFactorValue",
    "MaxMovePoints",
    "MaxFuel",
    "TransType",
    "TransTypeValue",
    "ProbOfBombHit",
    "ProbOfBombHitValue",
    "BombRounds",
    "BombRoundsValue",
    "ShieldHunger",
    "FoodHunger",
    "GoldHunger",
    "DefaultSprite",
    "LaunchPollution",
    "LaunchPollutionValue",
    "DeathPollution",
    "DeathPollutionValue",
    "MountedBonus",
    "MountedBonusValue",
    "AirBonus",
    "AirBonusValue",
    "WoodenShipBonus",
    "WoodenShipBonusValue",
    "AttackCityBonus",
    "AttackCityBonusValue",
    "AttackBonusSubmarine",
    "AttackBonusSubmarineValue",
    "FootBonus",
    "FootBonusValue",
    "SiegeBonus",
    "SiegeBonusValue",
    "WheeledBonus",
    "WheeledBonusValue",
    "MechanizedBonus",
    "MechanizedBonusValue",
    "HelicopterBonus",
    "HelicopterBonusValue",
    "SpecialForcesBonus",
    "SpecialForcesBonusValue",
    "CivilianBonus",
    "CivilianBonusValue",
    "GuerrillaBonus",
    "GuerrillaBonusValue",
    "AgainstMountedBonus",
    "AgainstMountedBonusValue",
    "AirDefenseBonus",
    "AirDefenseBonusValue",
    "CargoModule",
    "CargoModuleValue",
    "SpyVsSpy",
    "SpyVsSpyValue",
    "InvestigateCity",
    "InvestigateCityValue",
    "BonusFood",
    "BonusFoodValue",
    "BombardRange",
    "BombardRangeValue",
    "Revolution",
    "RevolutionValue",
    "SoundSelect1",
    "SoundSelect2",
    "SoundMove",
    "SoundAcknowledge",
    "SoundCantMove",
    "SoundAttack",
    "SoundWork",
    "SoundVictory",
    "SoundDeath",
    "SoundLoad",
    "SoundUnload",
    "SpecialAttacks",
    "CityGrowthCoefficient",
    "CityGrowthCoefficientValue",
    "UserFlags",
    "DefaultIcon",
    "NoIndex",
    "CheatIndex",
    "CheatIndexValue",
    "Description",
    "Advice",
    "AdviceValue",
    "Category",
    "GLHidden",
    "CantMove",
    "Civilian",
    "NoBarbarian",
    "GoodyHutExcluded",
    "CanHarvest",
    "CantGroup",
    "SpawnsBarbarians",
    "CanSinkInSea",
    "Leader",
    "ArmyMountedBonus",
    "ArmyMountedBonusValue",
    "ArmyAirBonus",
    "ArmyAirBonusValue",
    "ArmyWoodenShipBonus",
    "ArmyWoodenShipBonusValue",
    "ArmyAttackCityBonus",
    "ArmyAttackCityBonusValue",
    "ArmyAttackBonusSubmarine",
    "ArmyAttackBonusSubmarineValue",
    "ArmyFootBonus",
    "ArmyFootBonusValue",
    "ArmySiegeBonus",
    "ArmySiegeBonusValue",
    "ArmyWheeledBonus",
    "ArmyWheeledBonusValue",
    "ArmyMechanizedBonus",
    "ArmyMechanizedBonusValue",
    "ArmyHelicopterBonus",
    "ArmyHelicopterBonusValue",
    "ArmySpecialForcesBonus",
    "ArmySpecialForcesBonusValue",
    "ArmyCivilianBonus",
    "ArmyCivilianBonusValue",
    "ArmyGuerrillaBonus",
    "ArmyGuerrillaBonusValue",
    "ArmyAgainstMountedBonus",
    "ArmyAgainstMountedBonusValue",
    "ArmyAirDefenseBonus",
    "ArmyAirDefenseBonusValue",
    "EnergyHunger",
    "ProducesEnergy",
};

UnitpromotionRecordAccessorInfo g_UnitpromotionRecord_Accessors[] =
{
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MovementType */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanCarry */
    { &UnitpromotionRecord::GetAvailableUnitIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetNumObsoleteAdvance, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetObsoleteAdvanceIndex, NULL}, /* ObsoleteAdvance (array) */
    { &UnitpromotionRecord::GetNumPrerequisiteBuilding, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetPrerequisiteBuildingIndex, NULL}, /* PrerequisiteBuilding (array) */
    { &UnitpromotionRecord::GetNumExcludedByBuilding, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetExcludedByBuildingIndex, NULL}, /* ExcludedByBuilding (array) */
    { &UnitpromotionRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { &UnitpromotionRecord::GetNumUpgradeToPromotion, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetUpgradeToPromotionIndex, NULL}, /* UpgradeToPromotion (array) */
    { &UnitpromotionRecord::GetNumObsoletePromotion, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetObsoletePromotionIndex, NULL}, /* ObsoletePromotion (array) */
    { &UnitpromotionRecord::GetNumCultureOnly, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetCultureOnlyIndex, NULL}, /* CultureOnly (array) */
    { &UnitpromotionRecord::GetNumCityStyleOnly, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetCityStyleOnlyIndex, NULL}, /* CityStyleOnly (array) */
    { &UnitpromotionRecord::GetNumCivilisationOnly, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetCivilisationOnlyIndex, NULL}, /* CivilisationOnly (array) */
    { &UnitpromotionRecord::GetNumGovernmentOnly, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetGovernmentOnlyIndex, NULL}, /* GovernmentOnly (array) */
    { &UnitpromotionRecord::GetNumNeedsCityGood, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetNeedsCityGoodIndex, NULL}, /* NeedsCityGood (array) */
    { &UnitpromotionRecord::GetNumNeedsCityGoodAll, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetNeedsCityGoodAllIndex, NULL}, /* NeedsCityGoodAll (array) */
    { &UnitpromotionRecord::GetNumNeedsCityGoodAnyCity, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetNeedsCityGoodAnyCityIndex, NULL}, /* NeedsCityGoodAnyCity (array) */
    { &UnitpromotionRecord::GetNumNeedsFeatToBuild, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetNeedsFeatToBuildIndex, NULL}, /* NeedsFeatToBuild (array) */
    { &UnitpromotionRecord::GetNumNeedsAnyPlayerFeatToBuild, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetNeedsAnyPlayerFeatToBuildIndex, NULL}, /* NeedsAnyPlayerFeatToBuild (array) */
    { &UnitpromotionRecord::GetNumPrerequisiteWonder, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetPrerequisiteWonderIndex, NULL}, /* PrerequisiteWonder (array) */
    { &UnitpromotionRecord::GetNumExcludedByWonder, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetExcludedByWonderIndex, NULL}, /* ExcludedByWonder (array) */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetMoveBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MoveBonus */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetPWMoveCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PWMoveCost */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetMerchantGold, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MerchantGold */
    { NULL, &UnitpromotionRecord::GetIsGreatBuilder, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsGreatArtist, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetNumAllTerrainAsImprovement, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetAllTerrainAsImprovementIndex, NULL}, /* AllTerrainAsImprovement (array) */
    { &UnitpromotionRecord::GetNumObsoleteByUnit, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetObsoleteByUnitIndex, NULL}, /* ObsoleteByUnit (array) */
    { NULL, &UnitpromotionRecord::GetNonLethalBombard, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanBombardTiles, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCollateralTileDamage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetPrecisionStrike, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetTargetsCivilians, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetImmuneToHostileTerrain, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanRebase, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetMultipleAttacks, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanBeGifted, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetUpgradeAnywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetUpgradeDoesNotHeal, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Size */
    { NULL, &UnitpromotionRecord::GetLossMoveToDmgNone, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetLossMoveToDmgTwo, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoFuelThenCrash, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetTransformPartial, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIgnoreZOC, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoZoc, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanBombard */
    { NULL, &UnitpromotionRecord::GetCanCounterBombard, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanLiftOff, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Settle */
    { &UnitpromotionRecord::GetSettleCityTypeIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSettleSize, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetNumSettleBuilding, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetSettleBuildingIndex, NULL}, /* SettleBuilding (array) */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetSpaceLaunch, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpaceLaunch */
    { NULL, &UnitpromotionRecord::GetSpaceLand, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCantCaptureCity, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetHasPopAndCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsTrader, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetExertsMartialLaw, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanEntrench, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanPatrol, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNeedsNoSupport, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanExpelPop, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsFlanker, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanBeachAssault, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Defend */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetDefendAgainstSpies, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendAgainstSpies */
    { NULL, &UnitpromotionRecord::GetCanBeExpelled, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanBeSued, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackFromSpaceship, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCantBeAttacked, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCargoPod, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsFoot, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsMounted, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsSiege, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsWheeled, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsMechanized, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsHelicopter, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsSubmarine, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIgnoreCityWalls, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoLandAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoSeaAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoAirAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoSpaceAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoUnderwaterAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoMountainAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoShallowWaterAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetParatrooper, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAssistedDrops, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstFoot, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstMounted, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstSiege, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstWheeled, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstMechanized, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstHelicopter, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstGuerrilla, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstSpecialForces, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAgainstSubmarine, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSingleUse, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBonusAirDefense, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetWoodenShip, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackFootBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackMountedBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackSiegeBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackWheeledBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackMechanizedBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackHelicopterBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackSpecialForcesBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackCivilianBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackGuerrillaBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAttackWoodenShipBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetHasAttackCityBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetHasAttackBonusSubmarine, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitpromotionRecord::GetReplaceWithCargoModule, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ReplaceWithCargoModule */
    { NULL, &UnitpromotionRecord::GetVisibileAttacking, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearAttack */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearAttack */
    { NULL, &UnitpromotionRecord::GetCanSue, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsStealthy, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSeeSurfaceFromSpace, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetEstablishEmbassy, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetThrowParty, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetHearGossip, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StealTechnology */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StealTechnology */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InciteRevolution */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InciteRevolution */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AssasinateRuler */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AssasinateRuler */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateReadiness */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateReadiness */
    { NULL, &UnitpromotionRecord::GetNullifyCityWalls, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateFranchise */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateFranchise */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CauseUnhappiness */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CauseUnhappiness */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConductHits */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConductHits */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BioTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BioTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NanoTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NanoTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Plague */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Plague */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SettlerSlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SettlerSlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveUprising */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveUprising */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UndergroundRailway */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UndergroundRailway */
    { NULL, &UnitpromotionRecord::GetVictoryEnslavement, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetVictoryEnslavementChance, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* VictoryEnslavementChance */
    { NULL, &UnitpromotionRecord::GetVictoryEnslavementStacks, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetDefuseLandMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetDefuseSeaMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetDefuseXrayMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IndulgenceSales */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IndulgenceSales */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConvertCities */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConvertCities */
    { NULL, &UnitpromotionRecord::GetBuildXrayMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBuildWonder, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetNumGovernmentType, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetGovernmentTypeIndex, NULL}, /* GovernmentType (array) */
    { NULL, &UnitpromotionRecord::GetNoSlaves, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCreateRift, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanCloak, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetHiddenNationality, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSneakAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSneakPillage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSneakBombard, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetParatrooperTransport, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCantBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PlantNuke */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PlantNuke */
    { NULL, &UnitpromotionRecord::GetIsTelevangelist, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanSoothsay */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanSoothsay */
    { NULL, &UnitpromotionRecord::GetCanBeRustled, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateParks */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateParks */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanInjoin */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanInjoin */
    { NULL, &UnitpromotionRecord::GetWormholeProbe, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetHasBonusFood, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetLandCityCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSeaCityCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSpaceCityCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsSpecialForces, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsPeaceKeeper, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsGuerrilla, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetIsWorker, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNotAffectedByLandMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetInternalReserved, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetDeathEffectsHappy, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetEnableCarrierDefenses, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetActiveDefenseOnlyWhenCarryingEnablers, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetBuildingRemovesAPop, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitpromotionRecord::GetPopCostsToBuild, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PopCostsToBuild */
    { NULL, &UnitpromotionRecord::GetExplodes, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetAdvertise, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanRustle, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetOnlyBuildOne, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanExpel, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanReform */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanReform */
    { NULL, &UnitpromotionRecord::GetCanPillage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanPirate, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanCaptureTile, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetReducesDefensesBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* VisionClass */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanSee */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanAttack */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CargoData */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CargoData */
    { &UnitpromotionRecord::GetShieldCost, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetPowerPoints, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetMaxHP, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitpromotionRecord::GetMaxHPr, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitpromotionRecord::GetAttack, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitpromotionRecord::GetDefense, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetFirepower, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetZBRangeAttack, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitpromotionRecord::GetArmor, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitpromotionRecord::GetBRange, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BRange */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetBRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BRadius */
    { &UnitpromotionRecord::GetVisionRange, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetActiveDefenseRange, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitpromotionRecord::GetElectronicCombatFactor, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ElectronicCombatFactor */
    { NULL, NULL, &UnitpromotionRecord::GetMaxMovePoints, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetMaxFuel, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitpromotionRecord::GetTransType, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TransType */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetProbOfBombHit, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProbOfBombHit */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetBombRounds, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BombRounds */
    { &UnitpromotionRecord::GetShieldHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetFoodHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetGoldHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetDefaultSpriteIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitpromotionRecord::GetLaunchPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LaunchPollution */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetDeathPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DeathPollution */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MountedBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetAirBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetWoodenShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* WoodenShipBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetAttackCityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackCityBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetAttackBonusSubmarine, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackBonusSubmarine */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetFootBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FootBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetSiegeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SiegeBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetWheeledBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* WheeledBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetMechanizedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MechanizedBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetHelicopterBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* HelicopterBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetSpecialForcesBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpecialForcesBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetCivilianBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CivilianBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetGuerrillaBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GuerrillaBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetAgainstMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AgainstMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetAirDefenseBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirDefenseBonus */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetCargoModule, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CargoModule */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetSpyVsSpy, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpyVsSpy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateCity */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateCity */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetBonusFood, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BonusFood */
    { NULL, NULL, NULL, &UnitpromotionRecord::GetBombardRange, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BombardRange */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Revolution */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Revolution */
    { &UnitpromotionRecord::GetSoundSelect1Index, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundSelect2Index, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundMoveIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundAcknowledgeIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundCantMoveIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundAttackIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundWorkIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundVictoryIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundDeathIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundLoadIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetSoundUnloadIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetNumSpecialAttacks, NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetSpecialAttacksIndex, NULL}, /* SpecialAttacks (array) */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetCityGrowthCoefficient, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CityGrowthCoefficient */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UserFlags */
    { &UnitpromotionRecord::GetDefaultIconIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoIndex, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitpromotionRecord::GetCheatIndex, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CheatIndex */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Description */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Advice */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Advice */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Category */
    { NULL, &UnitpromotionRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCantMove, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCivilian, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetNoBarbarian, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetGoodyHutExcluded, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanHarvest, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCantGroup, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetSpawnsBarbarians, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetCanSinkInSea, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitpromotionRecord::GetLeader, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyAirBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAirBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyWoodenShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyWoodenShipBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyAttackCityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAttackCityBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyAttackBonusSubmarine, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAttackBonusSubmarine */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyFootBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyFootBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmySiegeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmySiegeBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyWheeledBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyWheeledBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyMechanizedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyMechanizedBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyHelicopterBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyHelicopterBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmySpecialForcesBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmySpecialForcesBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyCivilianBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyCivilianBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyGuerrillaBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyGuerrillaBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyAgainstMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAgainstMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitpromotionRecord::GetArmyAirDefenseBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAirDefenseBonus */
    { &UnitpromotionRecord::GetEnergyHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitpromotionRecord::GetProducesEnergy, NULL, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_Unitpromotion_MovementType       ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_CanCarry           ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_AvailableUnit      ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_EnableAdvance      ((k_Token_Custom_Base) + 3)
#define k_Token_Unitpromotion_ObsoleteAdvance    ((k_Token_Custom_Base) + 4)
#define k_Token_Unitpromotion_PrerequisiteBuilding ((k_Token_Custom_Base) + 5)
#define k_Token_Unitpromotion_ExcludedByBuilding ((k_Token_Custom_Base) + 6)
#define k_Token_Unitpromotion_GovernmentsModified ((k_Token_Custom_Base) + 7)
#define k_Token_Unitpromotion_UpgradeToPromotion ((k_Token_Custom_Base) + 8)
#define k_Token_Unitpromotion_ObsoletePromotion  ((k_Token_Custom_Base) + 9)
#define k_Token_Unitpromotion_CultureOnly        ((k_Token_Custom_Base) + 10)
#define k_Token_Unitpromotion_CityStyleOnly      ((k_Token_Custom_Base) + 11)
#define k_Token_Unitpromotion_CivilisationOnly   ((k_Token_Custom_Base) + 12)
#define k_Token_Unitpromotion_GovernmentOnly     ((k_Token_Custom_Base) + 13)
#define k_Token_Unitpromotion_NeedsCityGood      ((k_Token_Custom_Base) + 14)
#define k_Token_Unitpromotion_NeedsCityGoodAll   ((k_Token_Custom_Base) + 15)
#define k_Token_Unitpromotion_NeedsCityGoodAnyCity ((k_Token_Custom_Base) + 16)
#define k_Token_Unitpromotion_NeedsFeatToBuild   ((k_Token_Custom_Base) + 17)
#define k_Token_Unitpromotion_NeedsAnyPlayerFeatToBuild ((k_Token_Custom_Base) + 18)
#define k_Token_Unitpromotion_PrerequisiteWonder ((k_Token_Custom_Base) + 19)
#define k_Token_Unitpromotion_ExcludedByWonder   ((k_Token_Custom_Base) + 20)
#define k_Token_Unitpromotion_MoveBonus          ((k_Token_Custom_Base) + 21)
#define k_Token_Unitpromotion_MoveBonus_Value    ((k_Token_Custom_Base) + 22)
#define k_Token_Unitpromotion_PWMoveCost         ((k_Token_Custom_Base) + 23)
#define k_Token_Unitpromotion_PWMoveCost_Value   ((k_Token_Custom_Base) + 24)
#define k_Token_Unitpromotion_MerchantGold       ((k_Token_Custom_Base) + 25)
#define k_Token_Unitpromotion_MerchantGold_Value ((k_Token_Custom_Base) + 26)
#define k_Token_Unitpromotion_IsGreatBuilder     ((k_Token_Custom_Base) + 27)
#define k_Token_Unitpromotion_IsGreatArtist      ((k_Token_Custom_Base) + 28)
#define k_Token_Unitpromotion_AllTerrainAsImprovement ((k_Token_Custom_Base) + 29)
#define k_Token_Unitpromotion_ObsoleteByUnit     ((k_Token_Custom_Base) + 30)
#define k_Token_Unitpromotion_NonLethalBombard   ((k_Token_Custom_Base) + 31)
#define k_Token_Unitpromotion_CanBombardTiles    ((k_Token_Custom_Base) + 32)
#define k_Token_Unitpromotion_CollateralTileDamage ((k_Token_Custom_Base) + 33)
#define k_Token_Unitpromotion_PrecisionStrike    ((k_Token_Custom_Base) + 34)
#define k_Token_Unitpromotion_TargetsCivilians   ((k_Token_Custom_Base) + 35)
#define k_Token_Unitpromotion_ImmuneToHostileTerrain ((k_Token_Custom_Base) + 36)
#define k_Token_Unitpromotion_CanRebase          ((k_Token_Custom_Base) + 37)
#define k_Token_Unitpromotion_MultipleAttacks    ((k_Token_Custom_Base) + 38)
#define k_Token_Unitpromotion_CanBeGifted        ((k_Token_Custom_Base) + 39)
#define k_Token_Unitpromotion_UpgradeAnywhere    ((k_Token_Custom_Base) + 40)
#define k_Token_Unitpromotion_UpgradeDoesNotHeal ((k_Token_Custom_Base) + 41)
#define k_Token_Unitpromotion_Size               ((k_Token_Custom_Base) + 42)
#define k_Token_Unitpromotion_LossMoveToDmgNone  ((k_Token_Custom_Base) + 43)
#define k_Token_Unitpromotion_LossMoveToDmgTwo   ((k_Token_Custom_Base) + 44)
#define k_Token_Unitpromotion_NoFuelThenCrash    ((k_Token_Custom_Base) + 45)
#define k_Token_Unitpromotion_TransformPartial   ((k_Token_Custom_Base) + 46)
#define k_Token_Unitpromotion_IgnoreZOC          ((k_Token_Custom_Base) + 47)
#define k_Token_Unitpromotion_NoZoc              ((k_Token_Custom_Base) + 48)
#define k_Token_Unitpromotion_CanBombard         ((k_Token_Custom_Base) + 49)
#define k_Token_Unitpromotion_CanCounterBombard  ((k_Token_Custom_Base) + 50)
#define k_Token_Unitpromotion_CanLiftOff         ((k_Token_Custom_Base) + 51)
#define k_Token_Unitpromotion_Settle             ((k_Token_Custom_Base) + 52)
#define k_Token_Unitpromotion_SettleCityType     ((k_Token_Custom_Base) + 53)
#define k_Token_Unitpromotion_SettleSize         ((k_Token_Custom_Base) + 54)
#define k_Token_Unitpromotion_SettleBuilding     ((k_Token_Custom_Base) + 55)
#define k_Token_Unitpromotion_SpaceLaunch        ((k_Token_Custom_Base) + 56)
#define k_Token_Unitpromotion_SpaceLaunch_Value  ((k_Token_Custom_Base) + 57)
#define k_Token_Unitpromotion_SpaceLand          ((k_Token_Custom_Base) + 58)
#define k_Token_Unitpromotion_CantCaptureCity    ((k_Token_Custom_Base) + 59)
#define k_Token_Unitpromotion_HasPopAndCanBuild  ((k_Token_Custom_Base) + 60)
#define k_Token_Unitpromotion_IsTrader           ((k_Token_Custom_Base) + 61)
#define k_Token_Unitpromotion_ExertsMartialLaw   ((k_Token_Custom_Base) + 62)
#define k_Token_Unitpromotion_CanEntrench        ((k_Token_Custom_Base) + 63)
#define k_Token_Unitpromotion_CanPatrol          ((k_Token_Custom_Base) + 64)
#define k_Token_Unitpromotion_NeedsNoSupport     ((k_Token_Custom_Base) + 65)
#define k_Token_Unitpromotion_CanExpelPop        ((k_Token_Custom_Base) + 66)
#define k_Token_Unitpromotion_IsFlanker          ((k_Token_Custom_Base) + 67)
#define k_Token_Unitpromotion_CanBeachAssault    ((k_Token_Custom_Base) + 68)
#define k_Token_Unitpromotion_Defend             ((k_Token_Custom_Base) + 69)
#define k_Token_Unitpromotion_DefendAgainstSpies ((k_Token_Custom_Base) + 70)
#define k_Token_Unitpromotion_DefendAgainstSpies_Value ((k_Token_Custom_Base) + 71)
#define k_Token_Unitpromotion_CanBeExpelled      ((k_Token_Custom_Base) + 72)
#define k_Token_Unitpromotion_CanBeSued          ((k_Token_Custom_Base) + 73)
#define k_Token_Unitpromotion_AttackFromSpaceship ((k_Token_Custom_Base) + 74)
#define k_Token_Unitpromotion_CantBeAttacked     ((k_Token_Custom_Base) + 75)
#define k_Token_Unitpromotion_CargoPod           ((k_Token_Custom_Base) + 76)
#define k_Token_Unitpromotion_IsFoot             ((k_Token_Custom_Base) + 77)
#define k_Token_Unitpromotion_IsMounted          ((k_Token_Custom_Base) + 78)
#define k_Token_Unitpromotion_IsSiege            ((k_Token_Custom_Base) + 79)
#define k_Token_Unitpromotion_IsWheeled          ((k_Token_Custom_Base) + 80)
#define k_Token_Unitpromotion_IsMechanized       ((k_Token_Custom_Base) + 81)
#define k_Token_Unitpromotion_IsHelicopter       ((k_Token_Custom_Base) + 82)
#define k_Token_Unitpromotion_IsSubmarine        ((k_Token_Custom_Base) + 83)
#define k_Token_Unitpromotion_IgnoreCityWalls    ((k_Token_Custom_Base) + 84)
#define k_Token_Unitpromotion_NoLandAttack       ((k_Token_Custom_Base) + 85)
#define k_Token_Unitpromotion_NoSeaAttack        ((k_Token_Custom_Base) + 86)
#define k_Token_Unitpromotion_NoAirAttack        ((k_Token_Custom_Base) + 87)
#define k_Token_Unitpromotion_NoSpaceAttack      ((k_Token_Custom_Base) + 88)
#define k_Token_Unitpromotion_NoUnderwaterAttack ((k_Token_Custom_Base) + 89)
#define k_Token_Unitpromotion_NoMountainAttack   ((k_Token_Custom_Base) + 90)
#define k_Token_Unitpromotion_NoShallowWaterAttack ((k_Token_Custom_Base) + 91)
#define k_Token_Unitpromotion_Paratrooper        ((k_Token_Custom_Base) + 92)
#define k_Token_Unitpromotion_AssistedDrops      ((k_Token_Custom_Base) + 93)
#define k_Token_Unitpromotion_BonusAgainstFoot   ((k_Token_Custom_Base) + 94)
#define k_Token_Unitpromotion_BonusAgainstMounted ((k_Token_Custom_Base) + 95)
#define k_Token_Unitpromotion_BonusAgainstSiege  ((k_Token_Custom_Base) + 96)
#define k_Token_Unitpromotion_BonusAgainstWheeled ((k_Token_Custom_Base) + 97)
#define k_Token_Unitpromotion_BonusAgainstMechanized ((k_Token_Custom_Base) + 98)
#define k_Token_Unitpromotion_BonusAgainstHelicopter ((k_Token_Custom_Base) + 99)
#define k_Token_Unitpromotion_BonusAgainstGuerrilla ((k_Token_Custom_Base) + 100)
#define k_Token_Unitpromotion_BonusAgainstSpecialForces ((k_Token_Custom_Base) + 101)
#define k_Token_Unitpromotion_BonusAgainstSubmarine ((k_Token_Custom_Base) + 102)
#define k_Token_Unitpromotion_SingleUse          ((k_Token_Custom_Base) + 103)
#define k_Token_Unitpromotion_BonusAirDefense    ((k_Token_Custom_Base) + 104)
#define k_Token_Unitpromotion_WoodenShip         ((k_Token_Custom_Base) + 105)
#define k_Token_Unitpromotion_AttackFootBonus    ((k_Token_Custom_Base) + 106)
#define k_Token_Unitpromotion_AttackMountedBonus ((k_Token_Custom_Base) + 107)
#define k_Token_Unitpromotion_AttackSiegeBonus   ((k_Token_Custom_Base) + 108)
#define k_Token_Unitpromotion_AttackWheeledBonus ((k_Token_Custom_Base) + 109)
#define k_Token_Unitpromotion_AttackMechanizedBonus ((k_Token_Custom_Base) + 110)
#define k_Token_Unitpromotion_AttackHelicopterBonus ((k_Token_Custom_Base) + 111)
#define k_Token_Unitpromotion_AttackSpecialForcesBonus ((k_Token_Custom_Base) + 112)
#define k_Token_Unitpromotion_AttackCivilianBonus ((k_Token_Custom_Base) + 113)
#define k_Token_Unitpromotion_AttackGuerrillaBonus ((k_Token_Custom_Base) + 114)
#define k_Token_Unitpromotion_AttackWoodenShipBonus ((k_Token_Custom_Base) + 115)
#define k_Token_Unitpromotion_HasAttackCityBonus ((k_Token_Custom_Base) + 116)
#define k_Token_Unitpromotion_HasAttackBonusSubmarine ((k_Token_Custom_Base) + 117)
#define k_Token_Unitpromotion_ReplaceWithCargoModule ((k_Token_Custom_Base) + 118)
#define k_Token_Unitpromotion_ReplaceWithCargoModule_Value ((k_Token_Custom_Base) + 119)
#define k_Token_Unitpromotion_VisibileAttacking  ((k_Token_Custom_Base) + 120)
#define k_Token_Unitpromotion_NuclearAttack      ((k_Token_Custom_Base) + 121)
#define k_Token_Unitpromotion_NuclearAttack_Value ((k_Token_Custom_Base) + 122)
#define k_Token_Unitpromotion_CanSue             ((k_Token_Custom_Base) + 123)
#define k_Token_Unitpromotion_IsStealthy         ((k_Token_Custom_Base) + 124)
#define k_Token_Unitpromotion_SeeSurfaceFromSpace ((k_Token_Custom_Base) + 125)
#define k_Token_Unitpromotion_EstablishEmbassy   ((k_Token_Custom_Base) + 126)
#define k_Token_Unitpromotion_ThrowParty         ((k_Token_Custom_Base) + 127)
#define k_Token_Unitpromotion_HearGossip         ((k_Token_Custom_Base) + 128)
#define k_Token_Unitpromotion_StealTechnology    ((k_Token_Custom_Base) + 129)
#define k_Token_Unitpromotion_StealTechnology_Value ((k_Token_Custom_Base) + 130)
#define k_Token_Unitpromotion_InciteRevolution   ((k_Token_Custom_Base) + 131)
#define k_Token_Unitpromotion_InciteRevolution_Value ((k_Token_Custom_Base) + 132)
#define k_Token_Unitpromotion_AssasinateRuler    ((k_Token_Custom_Base) + 133)
#define k_Token_Unitpromotion_AssasinateRuler_Value ((k_Token_Custom_Base) + 134)
#define k_Token_Unitpromotion_InvestigateReadiness ((k_Token_Custom_Base) + 135)
#define k_Token_Unitpromotion_InvestigateReadiness_Value ((k_Token_Custom_Base) + 136)
#define k_Token_Unitpromotion_NullifyCityWalls   ((k_Token_Custom_Base) + 137)
#define k_Token_Unitpromotion_CreateFranchise    ((k_Token_Custom_Base) + 138)
#define k_Token_Unitpromotion_CreateFranchise_Value ((k_Token_Custom_Base) + 139)
#define k_Token_Unitpromotion_CauseUnhappiness   ((k_Token_Custom_Base) + 140)
#define k_Token_Unitpromotion_CauseUnhappiness_Value ((k_Token_Custom_Base) + 141)
#define k_Token_Unitpromotion_ConductHits        ((k_Token_Custom_Base) + 142)
#define k_Token_Unitpromotion_ConductHits_Value  ((k_Token_Custom_Base) + 143)
#define k_Token_Unitpromotion_BioTerror          ((k_Token_Custom_Base) + 144)
#define k_Token_Unitpromotion_BioTerror_Value    ((k_Token_Custom_Base) + 145)
#define k_Token_Unitpromotion_NanoTerror         ((k_Token_Custom_Base) + 146)
#define k_Token_Unitpromotion_NanoTerror_Value   ((k_Token_Custom_Base) + 147)
#define k_Token_Unitpromotion_Plague             ((k_Token_Custom_Base) + 148)
#define k_Token_Unitpromotion_Plague_Value       ((k_Token_Custom_Base) + 149)
#define k_Token_Unitpromotion_SlaveRaids         ((k_Token_Custom_Base) + 150)
#define k_Token_Unitpromotion_SlaveRaids_Value   ((k_Token_Custom_Base) + 151)
#define k_Token_Unitpromotion_SettlerSlaveRaids  ((k_Token_Custom_Base) + 152)
#define k_Token_Unitpromotion_SettlerSlaveRaids_Value ((k_Token_Custom_Base) + 153)
#define k_Token_Unitpromotion_SlaveUprising      ((k_Token_Custom_Base) + 154)
#define k_Token_Unitpromotion_SlaveUprising_Value ((k_Token_Custom_Base) + 155)
#define k_Token_Unitpromotion_UndergroundRailway ((k_Token_Custom_Base) + 156)
#define k_Token_Unitpromotion_UndergroundRailway_Value ((k_Token_Custom_Base) + 157)
#define k_Token_Unitpromotion_VictoryEnslavement ((k_Token_Custom_Base) + 158)
#define k_Token_Unitpromotion_VictoryEnslavementChance ((k_Token_Custom_Base) + 159)
#define k_Token_Unitpromotion_VictoryEnslavementChance_Value ((k_Token_Custom_Base) + 160)
#define k_Token_Unitpromotion_VictoryEnslavementStacks ((k_Token_Custom_Base) + 161)
#define k_Token_Unitpromotion_DefuseLandMines    ((k_Token_Custom_Base) + 162)
#define k_Token_Unitpromotion_DefuseSeaMines     ((k_Token_Custom_Base) + 163)
#define k_Token_Unitpromotion_DefuseXrayMines    ((k_Token_Custom_Base) + 164)
#define k_Token_Unitpromotion_IndulgenceSales    ((k_Token_Custom_Base) + 165)
#define k_Token_Unitpromotion_IndulgenceSales_Value ((k_Token_Custom_Base) + 166)
#define k_Token_Unitpromotion_ConvertCities      ((k_Token_Custom_Base) + 167)
#define k_Token_Unitpromotion_ConvertCities_Value ((k_Token_Custom_Base) + 168)
#define k_Token_Unitpromotion_BuildXrayMines     ((k_Token_Custom_Base) + 169)
#define k_Token_Unitpromotion_BuildWonder        ((k_Token_Custom_Base) + 170)
#define k_Token_Unitpromotion_GovernmentType     ((k_Token_Custom_Base) + 171)
#define k_Token_Unitpromotion_NoSlaves           ((k_Token_Custom_Base) + 172)
#define k_Token_Unitpromotion_CreateRift         ((k_Token_Custom_Base) + 173)
#define k_Token_Unitpromotion_CanCloak           ((k_Token_Custom_Base) + 174)
#define k_Token_Unitpromotion_HiddenNationality  ((k_Token_Custom_Base) + 175)
#define k_Token_Unitpromotion_SneakAttack        ((k_Token_Custom_Base) + 176)
#define k_Token_Unitpromotion_SneakPillage       ((k_Token_Custom_Base) + 177)
#define k_Token_Unitpromotion_SneakBombard       ((k_Token_Custom_Base) + 178)
#define k_Token_Unitpromotion_ParatrooperTransport ((k_Token_Custom_Base) + 179)
#define k_Token_Unitpromotion_CantBuild          ((k_Token_Custom_Base) + 180)
#define k_Token_Unitpromotion_PlantNuke          ((k_Token_Custom_Base) + 181)
#define k_Token_Unitpromotion_PlantNuke_Value    ((k_Token_Custom_Base) + 182)
#define k_Token_Unitpromotion_IsTelevangelist    ((k_Token_Custom_Base) + 183)
#define k_Token_Unitpromotion_CanSoothsay        ((k_Token_Custom_Base) + 184)
#define k_Token_Unitpromotion_CanSoothsay_Value  ((k_Token_Custom_Base) + 185)
#define k_Token_Unitpromotion_CanBeRustled       ((k_Token_Custom_Base) + 186)
#define k_Token_Unitpromotion_CreateParks        ((k_Token_Custom_Base) + 187)
#define k_Token_Unitpromotion_CreateParks_Value  ((k_Token_Custom_Base) + 188)
#define k_Token_Unitpromotion_CanInjoin          ((k_Token_Custom_Base) + 189)
#define k_Token_Unitpromotion_CanInjoin_Value    ((k_Token_Custom_Base) + 190)
#define k_Token_Unitpromotion_WormholeProbe      ((k_Token_Custom_Base) + 191)
#define k_Token_Unitpromotion_HasBonusFood       ((k_Token_Custom_Base) + 192)
#define k_Token_Unitpromotion_LandCityCanBuild   ((k_Token_Custom_Base) + 193)
#define k_Token_Unitpromotion_SeaCityCanBuild    ((k_Token_Custom_Base) + 194)
#define k_Token_Unitpromotion_SpaceCityCanBuild  ((k_Token_Custom_Base) + 195)
#define k_Token_Unitpromotion_IsSpecialForces    ((k_Token_Custom_Base) + 196)
#define k_Token_Unitpromotion_IsPeaceKeeper      ((k_Token_Custom_Base) + 197)
#define k_Token_Unitpromotion_IsGuerrilla        ((k_Token_Custom_Base) + 198)
#define k_Token_Unitpromotion_IsWorker           ((k_Token_Custom_Base) + 199)
#define k_Token_Unitpromotion_NotAffectedByLandMines ((k_Token_Custom_Base) + 200)
#define k_Token_Unitpromotion_InternalReserved   ((k_Token_Custom_Base) + 201)
#define k_Token_Unitpromotion_DeathEffectsHappy  ((k_Token_Custom_Base) + 202)
#define k_Token_Unitpromotion_EnableCarrierDefenses ((k_Token_Custom_Base) + 203)
#define k_Token_Unitpromotion_ActiveDefenseOnlyWhenCarryingEnablers ((k_Token_Custom_Base) + 204)
#define k_Token_Unitpromotion_BuildingRemovesAPop ((k_Token_Custom_Base) + 205)
#define k_Token_Unitpromotion_PopCostsToBuild    ((k_Token_Custom_Base) + 206)
#define k_Token_Unitpromotion_PopCostsToBuild_Value ((k_Token_Custom_Base) + 207)
#define k_Token_Unitpromotion_Explodes           ((k_Token_Custom_Base) + 208)
#define k_Token_Unitpromotion_Advertise          ((k_Token_Custom_Base) + 209)
#define k_Token_Unitpromotion_CanRustle          ((k_Token_Custom_Base) + 210)
#define k_Token_Unitpromotion_OnlyBuildOne       ((k_Token_Custom_Base) + 211)
#define k_Token_Unitpromotion_CanExpel           ((k_Token_Custom_Base) + 212)
#define k_Token_Unitpromotion_CanReform          ((k_Token_Custom_Base) + 213)
#define k_Token_Unitpromotion_CanReform_Value    ((k_Token_Custom_Base) + 214)
#define k_Token_Unitpromotion_CanPillage         ((k_Token_Custom_Base) + 215)
#define k_Token_Unitpromotion_CanPirate          ((k_Token_Custom_Base) + 216)
#define k_Token_Unitpromotion_CanCaptureTile     ((k_Token_Custom_Base) + 217)
#define k_Token_Unitpromotion_ReducesDefensesBonus ((k_Token_Custom_Base) + 218)
#define k_Token_Unitpromotion_VisionClass        ((k_Token_Custom_Base) + 219)
#define k_Token_Unitpromotion_CanSee             ((k_Token_Custom_Base) + 220)
#define k_Token_Unitpromotion_CanAttack          ((k_Token_Custom_Base) + 221)
#define k_Token_Unitpromotion_CargoData          ((k_Token_Custom_Base) + 222)
#define k_Token_Unitpromotion_CargoData_Value    ((k_Token_Custom_Base) + 223)
#define k_Token_Unitpromotion_ShieldCost         ((k_Token_Custom_Base) + 224)
#define k_Token_Unitpromotion_PowerPoints        ((k_Token_Custom_Base) + 225)
#define k_Token_Unitpromotion_MaxHP              ((k_Token_Custom_Base) + 226)
#define k_Token_Unitpromotion_MaxHPr             ((k_Token_Custom_Base) + 227)
#define k_Token_Unitpromotion_Attack             ((k_Token_Custom_Base) + 228)
#define k_Token_Unitpromotion_Defense            ((k_Token_Custom_Base) + 229)
#define k_Token_Unitpromotion_Firepower          ((k_Token_Custom_Base) + 230)
#define k_Token_Unitpromotion_ZBRangeAttack      ((k_Token_Custom_Base) + 231)
#define k_Token_Unitpromotion_Armor              ((k_Token_Custom_Base) + 232)
#define k_Token_Unitpromotion_BRange             ((k_Token_Custom_Base) + 233)
#define k_Token_Unitpromotion_BRange_Value       ((k_Token_Custom_Base) + 234)
#define k_Token_Unitpromotion_BRadius            ((k_Token_Custom_Base) + 235)
#define k_Token_Unitpromotion_BRadius_Value      ((k_Token_Custom_Base) + 236)
#define k_Token_Unitpromotion_VisionRange        ((k_Token_Custom_Base) + 237)
#define k_Token_Unitpromotion_ActiveDefenseRange ((k_Token_Custom_Base) + 238)
#define k_Token_Unitpromotion_ElectronicCombatFactor ((k_Token_Custom_Base) + 239)
#define k_Token_Unitpromotion_ElectronicCombatFactor_Value ((k_Token_Custom_Base) + 240)
#define k_Token_Unitpromotion_MaxMovePoints      ((k_Token_Custom_Base) + 241)
#define k_Token_Unitpromotion_MaxFuel            ((k_Token_Custom_Base) + 242)
#define k_Token_Unitpromotion_TransType          ((k_Token_Custom_Base) + 243)
#define k_Token_Unitpromotion_TransType_Value    ((k_Token_Custom_Base) + 244)
#define k_Token_Unitpromotion_ProbOfBombHit      ((k_Token_Custom_Base) + 245)
#define k_Token_Unitpromotion_ProbOfBombHit_Value ((k_Token_Custom_Base) + 246)
#define k_Token_Unitpromotion_BombRounds         ((k_Token_Custom_Base) + 247)
#define k_Token_Unitpromotion_BombRounds_Value   ((k_Token_Custom_Base) + 248)
#define k_Token_Unitpromotion_ShieldHunger       ((k_Token_Custom_Base) + 249)
#define k_Token_Unitpromotion_FoodHunger         ((k_Token_Custom_Base) + 250)
#define k_Token_Unitpromotion_GoldHunger         ((k_Token_Custom_Base) + 251)
#define k_Token_Unitpromotion_DefaultSprite      ((k_Token_Custom_Base) + 252)
#define k_Token_Unitpromotion_LaunchPollution    ((k_Token_Custom_Base) + 253)
#define k_Token_Unitpromotion_LaunchPollution_Value ((k_Token_Custom_Base) + 254)
#define k_Token_Unitpromotion_DeathPollution     ((k_Token_Custom_Base) + 255)
#define k_Token_Unitpromotion_DeathPollution_Value ((k_Token_Custom_Base) + 256)
#define k_Token_Unitpromotion_MountedBonus       ((k_Token_Custom_Base) + 257)
#define k_Token_Unitpromotion_MountedBonus_Value ((k_Token_Custom_Base) + 258)
#define k_Token_Unitpromotion_AirBonus           ((k_Token_Custom_Base) + 259)
#define k_Token_Unitpromotion_AirBonus_Value     ((k_Token_Custom_Base) + 260)
#define k_Token_Unitpromotion_WoodenShipBonus    ((k_Token_Custom_Base) + 261)
#define k_Token_Unitpromotion_WoodenShipBonus_Value ((k_Token_Custom_Base) + 262)
#define k_Token_Unitpromotion_AttackCityBonus    ((k_Token_Custom_Base) + 263)
#define k_Token_Unitpromotion_AttackCityBonus_Value ((k_Token_Custom_Base) + 264)
#define k_Token_Unitpromotion_AttackBonusSubmarine ((k_Token_Custom_Base) + 265)
#define k_Token_Unitpromotion_AttackBonusSubmarine_Value ((k_Token_Custom_Base) + 266)
#define k_Token_Unitpromotion_FootBonus          ((k_Token_Custom_Base) + 267)
#define k_Token_Unitpromotion_FootBonus_Value    ((k_Token_Custom_Base) + 268)
#define k_Token_Unitpromotion_SiegeBonus         ((k_Token_Custom_Base) + 269)
#define k_Token_Unitpromotion_SiegeBonus_Value   ((k_Token_Custom_Base) + 270)
#define k_Token_Unitpromotion_WheeledBonus       ((k_Token_Custom_Base) + 271)
#define k_Token_Unitpromotion_WheeledBonus_Value ((k_Token_Custom_Base) + 272)
#define k_Token_Unitpromotion_MechanizedBonus    ((k_Token_Custom_Base) + 273)
#define k_Token_Unitpromotion_MechanizedBonus_Value ((k_Token_Custom_Base) + 274)
#define k_Token_Unitpromotion_HelicopterBonus    ((k_Token_Custom_Base) + 275)
#define k_Token_Unitpromotion_HelicopterBonus_Value ((k_Token_Custom_Base) + 276)
#define k_Token_Unitpromotion_SpecialForcesBonus ((k_Token_Custom_Base) + 277)
#define k_Token_Unitpromotion_SpecialForcesBonus_Value ((k_Token_Custom_Base) + 278)
#define k_Token_Unitpromotion_CivilianBonus      ((k_Token_Custom_Base) + 279)
#define k_Token_Unitpromotion_CivilianBonus_Value ((k_Token_Custom_Base) + 280)
#define k_Token_Unitpromotion_GuerrillaBonus     ((k_Token_Custom_Base) + 281)
#define k_Token_Unitpromotion_GuerrillaBonus_Value ((k_Token_Custom_Base) + 282)
#define k_Token_Unitpromotion_AgainstMountedBonus ((k_Token_Custom_Base) + 283)
#define k_Token_Unitpromotion_AgainstMountedBonus_Value ((k_Token_Custom_Base) + 284)
#define k_Token_Unitpromotion_AirDefenseBonus    ((k_Token_Custom_Base) + 285)
#define k_Token_Unitpromotion_AirDefenseBonus_Value ((k_Token_Custom_Base) + 286)
#define k_Token_Unitpromotion_CargoModule        ((k_Token_Custom_Base) + 287)
#define k_Token_Unitpromotion_CargoModule_Value  ((k_Token_Custom_Base) + 288)
#define k_Token_Unitpromotion_SpyVsSpy           ((k_Token_Custom_Base) + 289)
#define k_Token_Unitpromotion_SpyVsSpy_Value     ((k_Token_Custom_Base) + 290)
#define k_Token_Unitpromotion_InvestigateCity    ((k_Token_Custom_Base) + 291)
#define k_Token_Unitpromotion_InvestigateCity_Value ((k_Token_Custom_Base) + 292)
#define k_Token_Unitpromotion_BonusFood          ((k_Token_Custom_Base) + 293)
#define k_Token_Unitpromotion_BonusFood_Value    ((k_Token_Custom_Base) + 294)
#define k_Token_Unitpromotion_BombardRange       ((k_Token_Custom_Base) + 295)
#define k_Token_Unitpromotion_BombardRange_Value ((k_Token_Custom_Base) + 296)
#define k_Token_Unitpromotion_Revolution         ((k_Token_Custom_Base) + 297)
#define k_Token_Unitpromotion_Revolution_Value   ((k_Token_Custom_Base) + 298)
#define k_Token_Unitpromotion_SoundSelect1       ((k_Token_Custom_Base) + 299)
#define k_Token_Unitpromotion_SoundSelect2       ((k_Token_Custom_Base) + 300)
#define k_Token_Unitpromotion_SoundMove          ((k_Token_Custom_Base) + 301)
#define k_Token_Unitpromotion_SoundAcknowledge   ((k_Token_Custom_Base) + 302)
#define k_Token_Unitpromotion_SoundCantMove      ((k_Token_Custom_Base) + 303)
#define k_Token_Unitpromotion_SoundAttack        ((k_Token_Custom_Base) + 304)
#define k_Token_Unitpromotion_SoundWork          ((k_Token_Custom_Base) + 305)
#define k_Token_Unitpromotion_SoundVictory       ((k_Token_Custom_Base) + 306)
#define k_Token_Unitpromotion_SoundDeath         ((k_Token_Custom_Base) + 307)
#define k_Token_Unitpromotion_SoundLoad          ((k_Token_Custom_Base) + 308)
#define k_Token_Unitpromotion_SoundUnload        ((k_Token_Custom_Base) + 309)
#define k_Token_Unitpromotion_SpecialAttacks     ((k_Token_Custom_Base) + 310)
#define k_Token_Unitpromotion_CityGrowthCoefficient ((k_Token_Custom_Base) + 311)
#define k_Token_Unitpromotion_CityGrowthCoefficient_Value ((k_Token_Custom_Base) + 312)
#define k_Token_Unitpromotion_UserFlags          ((k_Token_Custom_Base) + 313)
#define k_Token_Unitpromotion_DefaultIcon        ((k_Token_Custom_Base) + 314)
#define k_Token_Unitpromotion_NoIndex            ((k_Token_Custom_Base) + 315)
#define k_Token_Unitpromotion_CheatIndex         ((k_Token_Custom_Base) + 316)
#define k_Token_Unitpromotion_CheatIndex_Value   ((k_Token_Custom_Base) + 317)
#define k_Token_Unitpromotion_Description        ((k_Token_Custom_Base) + 318)
#define k_Token_Unitpromotion_Advice             ((k_Token_Custom_Base) + 319)
#define k_Token_Unitpromotion_Advice_Value       ((k_Token_Custom_Base) + 320)
#define k_Token_Unitpromotion_Category           ((k_Token_Custom_Base) + 321)
#define k_Token_Unitpromotion_GLHidden           ((k_Token_Custom_Base) + 322)
#define k_Token_Unitpromotion_CantMove           ((k_Token_Custom_Base) + 323)
#define k_Token_Unitpromotion_Civilian           ((k_Token_Custom_Base) + 324)
#define k_Token_Unitpromotion_NoBarbarian        ((k_Token_Custom_Base) + 325)
#define k_Token_Unitpromotion_GoodyHutExcluded   ((k_Token_Custom_Base) + 326)
#define k_Token_Unitpromotion_CanHarvest         ((k_Token_Custom_Base) + 327)
#define k_Token_Unitpromotion_CantGroup          ((k_Token_Custom_Base) + 328)
#define k_Token_Unitpromotion_SpawnsBarbarians   ((k_Token_Custom_Base) + 329)
#define k_Token_Unitpromotion_CanSinkInSea       ((k_Token_Custom_Base) + 330)
#define k_Token_Unitpromotion_Leader             ((k_Token_Custom_Base) + 331)
#define k_Token_Unitpromotion_ArmyMountedBonus   ((k_Token_Custom_Base) + 332)
#define k_Token_Unitpromotion_ArmyMountedBonus_Value ((k_Token_Custom_Base) + 333)
#define k_Token_Unitpromotion_ArmyAirBonus       ((k_Token_Custom_Base) + 334)
#define k_Token_Unitpromotion_ArmyAirBonus_Value ((k_Token_Custom_Base) + 335)
#define k_Token_Unitpromotion_ArmyWoodenShipBonus ((k_Token_Custom_Base) + 336)
#define k_Token_Unitpromotion_ArmyWoodenShipBonus_Value ((k_Token_Custom_Base) + 337)
#define k_Token_Unitpromotion_ArmyAttackCityBonus ((k_Token_Custom_Base) + 338)
#define k_Token_Unitpromotion_ArmyAttackCityBonus_Value ((k_Token_Custom_Base) + 339)
#define k_Token_Unitpromotion_ArmyAttackBonusSubmarine ((k_Token_Custom_Base) + 340)
#define k_Token_Unitpromotion_ArmyAttackBonusSubmarine_Value ((k_Token_Custom_Base) + 341)
#define k_Token_Unitpromotion_ArmyFootBonus      ((k_Token_Custom_Base) + 342)
#define k_Token_Unitpromotion_ArmyFootBonus_Value ((k_Token_Custom_Base) + 343)
#define k_Token_Unitpromotion_ArmySiegeBonus     ((k_Token_Custom_Base) + 344)
#define k_Token_Unitpromotion_ArmySiegeBonus_Value ((k_Token_Custom_Base) + 345)
#define k_Token_Unitpromotion_ArmyWheeledBonus   ((k_Token_Custom_Base) + 346)
#define k_Token_Unitpromotion_ArmyWheeledBonus_Value ((k_Token_Custom_Base) + 347)
#define k_Token_Unitpromotion_ArmyMechanizedBonus ((k_Token_Custom_Base) + 348)
#define k_Token_Unitpromotion_ArmyMechanizedBonus_Value ((k_Token_Custom_Base) + 349)
#define k_Token_Unitpromotion_ArmyHelicopterBonus ((k_Token_Custom_Base) + 350)
#define k_Token_Unitpromotion_ArmyHelicopterBonus_Value ((k_Token_Custom_Base) + 351)
#define k_Token_Unitpromotion_ArmySpecialForcesBonus ((k_Token_Custom_Base) + 352)
#define k_Token_Unitpromotion_ArmySpecialForcesBonus_Value ((k_Token_Custom_Base) + 353)
#define k_Token_Unitpromotion_ArmyCivilianBonus  ((k_Token_Custom_Base) + 354)
#define k_Token_Unitpromotion_ArmyCivilianBonus_Value ((k_Token_Custom_Base) + 355)
#define k_Token_Unitpromotion_ArmyGuerrillaBonus ((k_Token_Custom_Base) + 356)
#define k_Token_Unitpromotion_ArmyGuerrillaBonus_Value ((k_Token_Custom_Base) + 357)
#define k_Token_Unitpromotion_ArmyAgainstMountedBonus ((k_Token_Custom_Base) + 358)
#define k_Token_Unitpromotion_ArmyAgainstMountedBonus_Value ((k_Token_Custom_Base) + 359)
#define k_Token_Unitpromotion_ArmyAirDefenseBonus ((k_Token_Custom_Base) + 360)
#define k_Token_Unitpromotion_ArmyAirDefenseBonus_Value ((k_Token_Custom_Base) + 361)
#define k_Token_Unitpromotion_EnergyHunger       ((k_Token_Custom_Base) + 362)
#define k_Token_Unitpromotion_ProducesEnergy     ((k_Token_Custom_Base) + 363)
#define k_Token_Unitpromotion_Max                ((k_Token_Custom_Base) + 364)


static BitArray s_ParsedTokens(364);
void UnitpromotionRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_ShieldCost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ShieldCost missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_PowerPoints - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field PowerPoints missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_MaxHP - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxHP missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_Attack - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Attack missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_Defense - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Defense missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_Firepower - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Firepower missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_ZBRangeAttack - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ZBRangeAttack missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_Armor - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Armor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_VisionRange - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field VisionRange missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_ActiveDefenseRange - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ActiveDefenseRange missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_MaxMovePoints - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxMovePoints missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_MaxFuel - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxFuel missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_ShieldHunger - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ShieldHunger missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_FoodHunger - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field FoodHunger missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unitpromotion_Category - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Category missing"));
    }
}

sint32 UnitpromotionRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Unitpromotion_Tokens, k_Token_Unitpromotion_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "UNITPROMOTION_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Unitpromotion_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Unitpromotion_MovementType:
                if(!ParseMovementTypeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanCarry:
                if(!ParseCanCarryBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AvailableUnit:
                if (!g_theUnitDB->GetRecordFromLexer(lex, m_AvailableUnit)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_EnableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ObsoleteAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_ObsoleteAdvance, &m_numObsoleteAdvance, k_MAX_ObsoleteAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_PrerequisiteBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteBuilding, &m_numPrerequisiteBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ExcludedByBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByBuilding, &m_numExcludedByBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_UpgradeToPromotion:
                if(!g_theUnitDB->ParseRecordInArray(lex, (sint32 **)&m_UpgradeToPromotion, &m_numUpgradeToPromotion))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ObsoletePromotion:
                if(!g_theUnitDB->ParseRecordInArray(lex, (sint32 **)&m_ObsoletePromotion, &m_numObsoletePromotion))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CultureOnly, &m_numCultureOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CityStyleOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CityStyleOnly, &m_numCityStyleOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CivilisationOnly:
                if(!g_theCivilisationDB->ParseRecordInArray(lex, (sint32 **)&m_CivilisationOnly, &m_numCivilisationOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_GovernmentOnly:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentOnly, &m_numGovernmentOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NeedsCityGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGood, &m_numNeedsCityGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NeedsCityGoodAll:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAll, &m_numNeedsCityGoodAll))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NeedsCityGoodAnyCity:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAnyCity, &m_numNeedsCityGoodAnyCity))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NeedsFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsFeatToBuild, &m_numNeedsFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NeedsAnyPlayerFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsAnyPlayerFeatToBuild, &m_numNeedsAnyPlayerFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_PrerequisiteWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteWonder, &m_numPrerequisiteWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ExcludedByWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByWonder, &m_numExcludedByWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MoveBonus:
                m_flags0 |= k_Unitpromotion_MoveBonus_Bit;
                if(!lex->GetIntAssignment(m_MoveBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_PWMoveCost:
                m_flags0 |= k_Unitpromotion_PWMoveCost_Bit;
                if(!lex->GetIntAssignment(m_PWMoveCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MerchantGold:
                m_flags0 |= k_Unitpromotion_MerchantGold_Bit;
                if(!lex->GetIntAssignment(m_MerchantGoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_IsGreatBuilder:
                m_flags0 |= k_Unitpromotion_IsGreatBuilder_Bit;
                break;
            case k_Token_Unitpromotion_IsGreatArtist:
                m_flags0 |= k_Unitpromotion_IsGreatArtist_Bit;
                break;
            case k_Token_Unitpromotion_AllTerrainAsImprovement:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_AllTerrainAsImprovement, &m_numAllTerrainAsImprovement))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ObsoleteByUnit:
                if(!g_theUnitDB->ParseRecordInArray(lex, (sint32 **)&m_ObsoleteByUnit, &m_numObsoleteByUnit))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NonLethalBombard:
                m_flags0 |= k_Unitpromotion_NonLethalBombard_Bit;
                break;
            case k_Token_Unitpromotion_CanBombardTiles:
                m_flags0 |= k_Unitpromotion_CanBombardTiles_Bit;
                break;
            case k_Token_Unitpromotion_CollateralTileDamage:
                m_flags0 |= k_Unitpromotion_CollateralTileDamage_Bit;
                break;
            case k_Token_Unitpromotion_PrecisionStrike:
                m_flags0 |= k_Unitpromotion_PrecisionStrike_Bit;
                break;
            case k_Token_Unitpromotion_TargetsCivilians:
                m_flags0 |= k_Unitpromotion_TargetsCivilians_Bit;
                break;
            case k_Token_Unitpromotion_ImmuneToHostileTerrain:
                m_flags0 |= k_Unitpromotion_ImmuneToHostileTerrain_Bit;
                break;
            case k_Token_Unitpromotion_CanRebase:
                m_flags0 |= k_Unitpromotion_CanRebase_Bit;
                break;
            case k_Token_Unitpromotion_MultipleAttacks:
                m_flags0 |= k_Unitpromotion_MultipleAttacks_Bit;
                break;
            case k_Token_Unitpromotion_CanBeGifted:
                m_flags0 |= k_Unitpromotion_CanBeGifted_Bit;
                break;
            case k_Token_Unitpromotion_UpgradeAnywhere:
                m_flags0 |= k_Unitpromotion_UpgradeAnywhere_Bit;
                break;
            case k_Token_Unitpromotion_UpgradeDoesNotHeal:
                m_flags0 |= k_Unitpromotion_UpgradeDoesNotHeal_Bit;
                break;
            case k_Token_Unitpromotion_Size:
                if(!ParseSizeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_LossMoveToDmgNone:
                m_flags0 |= k_Unitpromotion_LossMoveToDmgNone_Bit;
                break;
            case k_Token_Unitpromotion_LossMoveToDmgTwo:
                m_flags0 |= k_Unitpromotion_LossMoveToDmgTwo_Bit;
                break;
            case k_Token_Unitpromotion_NoFuelThenCrash:
                m_flags0 |= k_Unitpromotion_NoFuelThenCrash_Bit;
                break;
            case k_Token_Unitpromotion_TransformPartial:
                m_flags0 |= k_Unitpromotion_TransformPartial_Bit;
                break;
            case k_Token_Unitpromotion_IgnoreZOC:
                m_flags0 |= k_Unitpromotion_IgnoreZOC_Bit;
                break;
            case k_Token_Unitpromotion_NoZoc:
                m_flags0 |= k_Unitpromotion_NoZoc_Bit;
                break;
            case k_Token_Unitpromotion_CanBombard:
                if(!ParseCanBombardBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanCounterBombard:
                m_flags0 |= k_Unitpromotion_CanCounterBombard_Bit;
                break;
            case k_Token_Unitpromotion_CanLiftOff:
                m_flags0 |= k_Unitpromotion_CanLiftOff_Bit;
                break;
            case k_Token_Unitpromotion_Settle:
                if(!ParseSettleBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SettleCityType:
                if (!g_theUnitDB->GetRecordFromLexer(lex, m_SettleCityType)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SettleSize:
                if(!lex->GetIntAssignment(m_SettleSize)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SettleBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_SettleBuilding, &m_numSettleBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SpaceLaunch:
                m_flags0 |= k_Unitpromotion_SpaceLaunch_Bit;
                if(!lex->GetIntAssignment(m_SpaceLaunchValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SpaceLand:
                m_flags0 |= k_Unitpromotion_SpaceLand_Bit;
                break;
            case k_Token_Unitpromotion_CantCaptureCity:
                m_flags0 |= k_Unitpromotion_CantCaptureCity_Bit;
                break;
            case k_Token_Unitpromotion_HasPopAndCanBuild:
                m_flags0 |= k_Unitpromotion_HasPopAndCanBuild_Bit;
                break;
            case k_Token_Unitpromotion_IsTrader:
                m_flags0 |= k_Unitpromotion_IsTrader_Bit;
                break;
            case k_Token_Unitpromotion_ExertsMartialLaw:
                m_flags0 |= k_Unitpromotion_ExertsMartialLaw_Bit;
                break;
            case k_Token_Unitpromotion_CanEntrench:
                m_flags0 |= k_Unitpromotion_CanEntrench_Bit;
                break;
            case k_Token_Unitpromotion_CanPatrol:
                m_flags0 |= k_Unitpromotion_CanPatrol_Bit;
                break;
            case k_Token_Unitpromotion_NeedsNoSupport:
                m_flags1 |= k_Unitpromotion_NeedsNoSupport_Bit;
                break;
            case k_Token_Unitpromotion_CanExpelPop:
                m_flags1 |= k_Unitpromotion_CanExpelPop_Bit;
                break;
            case k_Token_Unitpromotion_IsFlanker:
                m_flags1 |= k_Unitpromotion_IsFlanker_Bit;
                break;
            case k_Token_Unitpromotion_CanBeachAssault:
                m_flags1 |= k_Unitpromotion_CanBeachAssault_Bit;
                break;
            case k_Token_Unitpromotion_Defend:
                if(!ParseDefendBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_DefendAgainstSpies:
                m_flags1 |= k_Unitpromotion_DefendAgainstSpies_Bit;
                if(!lex->GetFloatAssignment(m_DefendAgainstSpiesValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanBeExpelled:
                m_flags1 |= k_Unitpromotion_CanBeExpelled_Bit;
                break;
            case k_Token_Unitpromotion_CanBeSued:
                m_flags1 |= k_Unitpromotion_CanBeSued_Bit;
                break;
            case k_Token_Unitpromotion_AttackFromSpaceship:
                m_flags1 |= k_Unitpromotion_AttackFromSpaceship_Bit;
                break;
            case k_Token_Unitpromotion_CantBeAttacked:
                m_flags1 |= k_Unitpromotion_CantBeAttacked_Bit;
                break;
            case k_Token_Unitpromotion_CargoPod:
                m_flags1 |= k_Unitpromotion_CargoPod_Bit;
                break;
            case k_Token_Unitpromotion_IsFoot:
                m_flags1 |= k_Unitpromotion_IsFoot_Bit;
                break;
            case k_Token_Unitpromotion_IsMounted:
                m_flags1 |= k_Unitpromotion_IsMounted_Bit;
                break;
            case k_Token_Unitpromotion_IsSiege:
                m_flags1 |= k_Unitpromotion_IsSiege_Bit;
                break;
            case k_Token_Unitpromotion_IsWheeled:
                m_flags1 |= k_Unitpromotion_IsWheeled_Bit;
                break;
            case k_Token_Unitpromotion_IsMechanized:
                m_flags1 |= k_Unitpromotion_IsMechanized_Bit;
                break;
            case k_Token_Unitpromotion_IsHelicopter:
                m_flags1 |= k_Unitpromotion_IsHelicopter_Bit;
                break;
            case k_Token_Unitpromotion_IsSubmarine:
                m_flags1 |= k_Unitpromotion_IsSubmarine_Bit;
                break;
            case k_Token_Unitpromotion_IgnoreCityWalls:
                m_flags1 |= k_Unitpromotion_IgnoreCityWalls_Bit;
                break;
            case k_Token_Unitpromotion_NoLandAttack:
                m_flags1 |= k_Unitpromotion_NoLandAttack_Bit;
                break;
            case k_Token_Unitpromotion_NoSeaAttack:
                m_flags1 |= k_Unitpromotion_NoSeaAttack_Bit;
                break;
            case k_Token_Unitpromotion_NoAirAttack:
                m_flags1 |= k_Unitpromotion_NoAirAttack_Bit;
                break;
            case k_Token_Unitpromotion_NoSpaceAttack:
                m_flags1 |= k_Unitpromotion_NoSpaceAttack_Bit;
                break;
            case k_Token_Unitpromotion_NoUnderwaterAttack:
                m_flags1 |= k_Unitpromotion_NoUnderwaterAttack_Bit;
                break;
            case k_Token_Unitpromotion_NoMountainAttack:
                m_flags1 |= k_Unitpromotion_NoMountainAttack_Bit;
                break;
            case k_Token_Unitpromotion_NoShallowWaterAttack:
                m_flags1 |= k_Unitpromotion_NoShallowWaterAttack_Bit;
                break;
            case k_Token_Unitpromotion_Paratrooper:
                m_flags1 |= k_Unitpromotion_Paratrooper_Bit;
                break;
            case k_Token_Unitpromotion_AssistedDrops:
                m_flags1 |= k_Unitpromotion_AssistedDrops_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstFoot:
                m_flags1 |= k_Unitpromotion_BonusAgainstFoot_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstMounted:
                m_flags1 |= k_Unitpromotion_BonusAgainstMounted_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstSiege:
                m_flags1 |= k_Unitpromotion_BonusAgainstSiege_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstWheeled:
                m_flags1 |= k_Unitpromotion_BonusAgainstWheeled_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstMechanized:
                m_flags1 |= k_Unitpromotion_BonusAgainstMechanized_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstHelicopter:
                m_flags2 |= k_Unitpromotion_BonusAgainstHelicopter_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstGuerrilla:
                m_flags2 |= k_Unitpromotion_BonusAgainstGuerrilla_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstSpecialForces:
                m_flags2 |= k_Unitpromotion_BonusAgainstSpecialForces_Bit;
                break;
            case k_Token_Unitpromotion_BonusAgainstSubmarine:
                m_flags2 |= k_Unitpromotion_BonusAgainstSubmarine_Bit;
                break;
            case k_Token_Unitpromotion_SingleUse:
                m_flags2 |= k_Unitpromotion_SingleUse_Bit;
                break;
            case k_Token_Unitpromotion_BonusAirDefense:
                m_flags2 |= k_Unitpromotion_BonusAirDefense_Bit;
                break;
            case k_Token_Unitpromotion_WoodenShip:
                m_flags2 |= k_Unitpromotion_WoodenShip_Bit;
                break;
            case k_Token_Unitpromotion_AttackFootBonus:
                m_flags2 |= k_Unitpromotion_AttackFootBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackMountedBonus:
                m_flags2 |= k_Unitpromotion_AttackMountedBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackSiegeBonus:
                m_flags2 |= k_Unitpromotion_AttackSiegeBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackWheeledBonus:
                m_flags2 |= k_Unitpromotion_AttackWheeledBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackMechanizedBonus:
                m_flags2 |= k_Unitpromotion_AttackMechanizedBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackHelicopterBonus:
                m_flags2 |= k_Unitpromotion_AttackHelicopterBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackSpecialForcesBonus:
                m_flags2 |= k_Unitpromotion_AttackSpecialForcesBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackCivilianBonus:
                m_flags2 |= k_Unitpromotion_AttackCivilianBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackGuerrillaBonus:
                m_flags2 |= k_Unitpromotion_AttackGuerrillaBonus_Bit;
                break;
            case k_Token_Unitpromotion_AttackWoodenShipBonus:
                m_flags2 |= k_Unitpromotion_AttackWoodenShipBonus_Bit;
                break;
            case k_Token_Unitpromotion_HasAttackCityBonus:
                m_flags2 |= k_Unitpromotion_HasAttackCityBonus_Bit;
                break;
            case k_Token_Unitpromotion_HasAttackBonusSubmarine:
                m_flags2 |= k_Unitpromotion_HasAttackBonusSubmarine_Bit;
                break;
            case k_Token_Unitpromotion_ReplaceWithCargoModule:
                m_flags2 |= k_Unitpromotion_ReplaceWithCargoModule_Bit;
                if(!lex->GetIntAssignment(m_ReplaceWithCargoModuleValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_VisibileAttacking:
                m_flags2 |= k_Unitpromotion_VisibileAttacking_Bit;
                break;
            case k_Token_Unitpromotion_NuclearAttack:
                m_flags2 |= k_Unitpromotion_NuclearAttack_Bit;
                if(!m_NuclearAttackValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanSue:
                m_flags2 |= k_Unitpromotion_CanSue_Bit;
                break;
            case k_Token_Unitpromotion_IsStealthy:
                m_flags2 |= k_Unitpromotion_IsStealthy_Bit;
                break;
            case k_Token_Unitpromotion_SeeSurfaceFromSpace:
                m_flags2 |= k_Unitpromotion_SeeSurfaceFromSpace_Bit;
                break;
            case k_Token_Unitpromotion_EstablishEmbassy:
                m_flags2 |= k_Unitpromotion_EstablishEmbassy_Bit;
                break;
            case k_Token_Unitpromotion_ThrowParty:
                m_flags2 |= k_Unitpromotion_ThrowParty_Bit;
                break;
            case k_Token_Unitpromotion_HearGossip:
                m_flags2 |= k_Unitpromotion_HearGossip_Bit;
                break;
            case k_Token_Unitpromotion_StealTechnology:
                m_flags2 |= k_Unitpromotion_StealTechnology_Bit;
                if(!m_StealTechnologyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InciteRevolution:
                m_flags2 |= k_Unitpromotion_InciteRevolution_Bit;
                if(!m_InciteRevolutionValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AssasinateRuler:
                m_flags2 |= k_Unitpromotion_AssasinateRuler_Bit;
                if(!m_AssasinateRulerValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InvestigateReadiness:
                m_flags2 |= k_Unitpromotion_InvestigateReadiness_Bit;
                if(!m_InvestigateReadinessValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NullifyCityWalls:
                m_flags3 |= k_Unitpromotion_NullifyCityWalls_Bit;
                break;
            case k_Token_Unitpromotion_CreateFranchise:
                m_flags3 |= k_Unitpromotion_CreateFranchise_Bit;
                if(!m_CreateFranchiseValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CauseUnhappiness:
                m_flags3 |= k_Unitpromotion_CauseUnhappiness_Bit;
                if(!m_CauseUnhappinessValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ConductHits:
                m_flags3 |= k_Unitpromotion_ConductHits_Bit;
                if(!m_ConductHitsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_BioTerror:
                m_flags3 |= k_Unitpromotion_BioTerror_Bit;
                if(!m_BioTerrorValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NanoTerror:
                m_flags3 |= k_Unitpromotion_NanoTerror_Bit;
                if(!m_NanoTerrorValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Plague:
                m_flags3 |= k_Unitpromotion_Plague_Bit;
                if(!m_PlagueValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SlaveRaids:
                m_flags3 |= k_Unitpromotion_SlaveRaids_Bit;
                if(!m_SlaveRaidsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SettlerSlaveRaids:
                m_flags3 |= k_Unitpromotion_SettlerSlaveRaids_Bit;
                if(!m_SettlerSlaveRaidsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SlaveUprising:
                m_flags3 |= k_Unitpromotion_SlaveUprising_Bit;
                if(!m_SlaveUprisingValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_UndergroundRailway:
                m_flags3 |= k_Unitpromotion_UndergroundRailway_Bit;
                if(!m_UndergroundRailwayValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_VictoryEnslavement:
                m_flags3 |= k_Unitpromotion_VictoryEnslavement_Bit;
                break;
            case k_Token_Unitpromotion_VictoryEnslavementChance:
                m_flags3 |= k_Unitpromotion_VictoryEnslavementChance_Bit;
                if(!lex->GetFloatAssignment(m_VictoryEnslavementChanceValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_VictoryEnslavementStacks:
                m_flags3 |= k_Unitpromotion_VictoryEnslavementStacks_Bit;
                break;
            case k_Token_Unitpromotion_DefuseLandMines:
                m_flags3 |= k_Unitpromotion_DefuseLandMines_Bit;
                break;
            case k_Token_Unitpromotion_DefuseSeaMines:
                m_flags3 |= k_Unitpromotion_DefuseSeaMines_Bit;
                break;
            case k_Token_Unitpromotion_DefuseXrayMines:
                m_flags3 |= k_Unitpromotion_DefuseXrayMines_Bit;
                break;
            case k_Token_Unitpromotion_IndulgenceSales:
                m_flags3 |= k_Unitpromotion_IndulgenceSales_Bit;
                if(!m_IndulgenceSalesValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ConvertCities:
                m_flags3 |= k_Unitpromotion_ConvertCities_Bit;
                if(!m_ConvertCitiesValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_BuildXrayMines:
                m_flags3 |= k_Unitpromotion_BuildXrayMines_Bit;
                break;
            case k_Token_Unitpromotion_BuildWonder:
                m_flags3 |= k_Unitpromotion_BuildWonder_Bit;
                break;
            case k_Token_Unitpromotion_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NoSlaves:
                m_flags3 |= k_Unitpromotion_NoSlaves_Bit;
                break;
            case k_Token_Unitpromotion_CreateRift:
                m_flags3 |= k_Unitpromotion_CreateRift_Bit;
                break;
            case k_Token_Unitpromotion_CanCloak:
                m_flags3 |= k_Unitpromotion_CanCloak_Bit;
                break;
            case k_Token_Unitpromotion_HiddenNationality:
                m_flags3 |= k_Unitpromotion_HiddenNationality_Bit;
                break;
            case k_Token_Unitpromotion_SneakAttack:
                m_flags3 |= k_Unitpromotion_SneakAttack_Bit;
                break;
            case k_Token_Unitpromotion_SneakPillage:
                m_flags3 |= k_Unitpromotion_SneakPillage_Bit;
                break;
            case k_Token_Unitpromotion_SneakBombard:
                m_flags3 |= k_Unitpromotion_SneakBombard_Bit;
                break;
            case k_Token_Unitpromotion_ParatrooperTransport:
                m_flags3 |= k_Unitpromotion_ParatrooperTransport_Bit;
                break;
            case k_Token_Unitpromotion_CantBuild:
                m_flags3 |= k_Unitpromotion_CantBuild_Bit;
                break;
            case k_Token_Unitpromotion_PlantNuke:
                m_flags3 |= k_Unitpromotion_PlantNuke_Bit;
                if(!m_PlantNukeValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_IsTelevangelist:
                m_flags3 |= k_Unitpromotion_IsTelevangelist_Bit;
                break;
            case k_Token_Unitpromotion_CanSoothsay:
                m_flags4 |= k_Unitpromotion_CanSoothsay_Bit;
                if(!m_CanSoothsayValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanBeRustled:
                m_flags4 |= k_Unitpromotion_CanBeRustled_Bit;
                break;
            case k_Token_Unitpromotion_CreateParks:
                m_flags4 |= k_Unitpromotion_CreateParks_Bit;
                if(!m_CreateParksValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanInjoin:
                m_flags4 |= k_Unitpromotion_CanInjoin_Bit;
                if(!m_CanInjoinValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_WormholeProbe:
                m_flags4 |= k_Unitpromotion_WormholeProbe_Bit;
                break;
            case k_Token_Unitpromotion_HasBonusFood:
                m_flags4 |= k_Unitpromotion_HasBonusFood_Bit;
                break;
            case k_Token_Unitpromotion_LandCityCanBuild:
                m_flags4 |= k_Unitpromotion_LandCityCanBuild_Bit;
                break;
            case k_Token_Unitpromotion_SeaCityCanBuild:
                m_flags4 |= k_Unitpromotion_SeaCityCanBuild_Bit;
                break;
            case k_Token_Unitpromotion_SpaceCityCanBuild:
                m_flags4 |= k_Unitpromotion_SpaceCityCanBuild_Bit;
                break;
            case k_Token_Unitpromotion_IsSpecialForces:
                m_flags4 |= k_Unitpromotion_IsSpecialForces_Bit;
                break;
            case k_Token_Unitpromotion_IsPeaceKeeper:
                m_flags4 |= k_Unitpromotion_IsPeaceKeeper_Bit;
                break;
            case k_Token_Unitpromotion_IsGuerrilla:
                m_flags4 |= k_Unitpromotion_IsGuerrilla_Bit;
                break;
            case k_Token_Unitpromotion_IsWorker:
                m_flags4 |= k_Unitpromotion_IsWorker_Bit;
                break;
            case k_Token_Unitpromotion_NotAffectedByLandMines:
                m_flags4 |= k_Unitpromotion_NotAffectedByLandMines_Bit;
                break;
            case k_Token_Unitpromotion_InternalReserved:
                m_flags4 |= k_Unitpromotion_InternalReserved_Bit;
                break;
            case k_Token_Unitpromotion_DeathEffectsHappy:
                m_flags4 |= k_Unitpromotion_DeathEffectsHappy_Bit;
                break;
            case k_Token_Unitpromotion_EnableCarrierDefenses:
                m_flags4 |= k_Unitpromotion_EnableCarrierDefenses_Bit;
                break;
            case k_Token_Unitpromotion_ActiveDefenseOnlyWhenCarryingEnablers:
                m_flags4 |= k_Unitpromotion_ActiveDefenseOnlyWhenCarryingEnablers_Bit;
                break;
            case k_Token_Unitpromotion_BuildingRemovesAPop:
                m_flags4 |= k_Unitpromotion_BuildingRemovesAPop_Bit;
                break;
            case k_Token_Unitpromotion_PopCostsToBuild:
                m_flags4 |= k_Unitpromotion_PopCostsToBuild_Bit;
                if(!lex->GetIntAssignment(m_PopCostsToBuildValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Explodes:
                m_flags4 |= k_Unitpromotion_Explodes_Bit;
                break;
            case k_Token_Unitpromotion_Advertise:
                m_flags4 |= k_Unitpromotion_Advertise_Bit;
                break;
            case k_Token_Unitpromotion_CanRustle:
                m_flags4 |= k_Unitpromotion_CanRustle_Bit;
                break;
            case k_Token_Unitpromotion_OnlyBuildOne:
                m_flags4 |= k_Unitpromotion_OnlyBuildOne_Bit;
                break;
            case k_Token_Unitpromotion_CanExpel:
                m_flags4 |= k_Unitpromotion_CanExpel_Bit;
                break;
            case k_Token_Unitpromotion_CanReform:
                m_flags4 |= k_Unitpromotion_CanReform_Bit;
                if(!m_CanReformValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanPillage:
                m_flags4 |= k_Unitpromotion_CanPillage_Bit;
                break;
            case k_Token_Unitpromotion_CanPirate:
                m_flags4 |= k_Unitpromotion_CanPirate_Bit;
                break;
            case k_Token_Unitpromotion_CanCaptureTile:
                m_flags4 |= k_Unitpromotion_CanCaptureTile_Bit;
                break;
            case k_Token_Unitpromotion_ReducesDefensesBonus:
                if(!lex->GetIntAssignment(m_ReducesDefensesBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_VisionClass:
                if(!ParseVisionClassBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanSee:
                if(!ParseCanSeeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CanAttack:
                if(!ParseCanAttackBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CargoData:
                m_flags4 |= k_Unitpromotion_CargoData_Bit;
                if(!m_CargoDataValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ShieldCost:
                if(!lex->GetIntAssignment(m_ShieldCost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_PowerPoints:
                if(!lex->GetIntAssignment(m_PowerPoints)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MaxHP:
                if(!lex->GetIntAssignment(m_MaxHP)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MaxHPr:
                if(!lex->GetFloatAssignment(m_MaxHPr)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Attack:
                if(!lex->GetFloatAssignment(m_Attack)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Defense:
                if(!lex->GetFloatAssignment(m_Defense)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Firepower:
                if(!lex->GetIntAssignment(m_Firepower)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ZBRangeAttack:
                if(!lex->GetIntAssignment(m_ZBRangeAttack)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Armor:
                if(!lex->GetFloatAssignment(m_Armor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_BRange:
                m_flags4 |= k_Unitpromotion_BRange_Bit;
                if(!lex->GetIntAssignment(m_BRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_BRadius:
                m_flags4 |= k_Unitpromotion_BRadius_Bit;
                if(!lex->GetIntAssignment(m_BRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_VisionRange:
                if(!lex->GetIntAssignment(m_VisionRange)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ActiveDefenseRange:
                if(!lex->GetIntAssignment(m_ActiveDefenseRange)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ElectronicCombatFactor:
                m_flags5 |= k_Unitpromotion_ElectronicCombatFactor_Bit;
                if(!lex->GetIntAssignment(m_ElectronicCombatFactorValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MaxMovePoints:
                if(!lex->GetFloatAssignment(m_MaxMovePoints)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MaxFuel:
                if(!lex->GetIntAssignment(m_MaxFuel)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_TransType:
                m_flags5 |= k_Unitpromotion_TransType_Bit;
                if(!lex->GetIntAssignment(m_TransTypeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ProbOfBombHit:
                m_flags5 |= k_Unitpromotion_ProbOfBombHit_Bit;
                if(!lex->GetIntAssignment(m_ProbOfBombHitValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_BombRounds:
                m_flags5 |= k_Unitpromotion_BombRounds_Bit;
                if(!lex->GetIntAssignment(m_BombRoundsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ShieldHunger:
                if(!lex->GetIntAssignment(m_ShieldHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_FoodHunger:
                if(!lex->GetIntAssignment(m_FoodHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_GoldHunger:
                if(!lex->GetIntAssignment(m_GoldHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_DefaultSprite:
                if (!g_theSpriteDB->GetRecordFromLexer(lex, m_DefaultSprite)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_LaunchPollution:
                m_flags5 |= k_Unitpromotion_LaunchPollution_Bit;
                if(!lex->GetIntAssignment(m_LaunchPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_DeathPollution:
                m_flags5 |= k_Unitpromotion_DeathPollution_Bit;
                if(!lex->GetIntAssignment(m_DeathPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MountedBonus:
                m_flags5 |= k_Unitpromotion_MountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_MountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AirBonus:
                m_flags5 |= k_Unitpromotion_AirBonus_Bit;
                if(!lex->GetFloatAssignment(m_AirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_WoodenShipBonus:
                m_flags5 |= k_Unitpromotion_WoodenShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_WoodenShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AttackCityBonus:
                m_flags5 |= k_Unitpromotion_AttackCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AttackBonusSubmarine:
                m_flags5 |= k_Unitpromotion_AttackBonusSubmarine_Bit;
                if(!lex->GetFloatAssignment(m_AttackBonusSubmarineValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_FootBonus:
                m_flags5 |= k_Unitpromotion_FootBonus_Bit;
                if(!lex->GetFloatAssignment(m_FootBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SiegeBonus:
                m_flags5 |= k_Unitpromotion_SiegeBonus_Bit;
                if(!lex->GetFloatAssignment(m_SiegeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_WheeledBonus:
                m_flags5 |= k_Unitpromotion_WheeledBonus_Bit;
                if(!lex->GetFloatAssignment(m_WheeledBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_MechanizedBonus:
                m_flags5 |= k_Unitpromotion_MechanizedBonus_Bit;
                if(!lex->GetFloatAssignment(m_MechanizedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_HelicopterBonus:
                m_flags5 |= k_Unitpromotion_HelicopterBonus_Bit;
                if(!lex->GetFloatAssignment(m_HelicopterBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SpecialForcesBonus:
                m_flags5 |= k_Unitpromotion_SpecialForcesBonus_Bit;
                if(!lex->GetFloatAssignment(m_SpecialForcesBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CivilianBonus:
                m_flags5 |= k_Unitpromotion_CivilianBonus_Bit;
                if(!lex->GetFloatAssignment(m_CivilianBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_GuerrillaBonus:
                m_flags5 |= k_Unitpromotion_GuerrillaBonus_Bit;
                if(!lex->GetFloatAssignment(m_GuerrillaBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AgainstMountedBonus:
                m_flags5 |= k_Unitpromotion_AgainstMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_AgainstMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AirDefenseBonus:
                m_flags5 |= k_Unitpromotion_AirDefenseBonus_Bit;
                if(!lex->GetFloatAssignment(m_AirDefenseBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CargoModule:
                m_flags5 |= k_Unitpromotion_CargoModule_Bit;
                if(!lex->GetIntAssignment(m_CargoModuleValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SpyVsSpy:
                m_flags5 |= k_Unitpromotion_SpyVsSpy_Bit;
                if(!lex->GetFloatAssignment(m_SpyVsSpyValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InvestigateCity:
                m_flags5 |= k_Unitpromotion_InvestigateCity_Bit;
                if(!m_InvestigateCityValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_BonusFood:
                m_flags5 |= k_Unitpromotion_BonusFood_Bit;
                if(!lex->GetIntAssignment(m_BonusFoodValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_BombardRange:
                m_flags5 |= k_Unitpromotion_BombardRange_Bit;
                if(!lex->GetIntAssignment(m_BombardRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Revolution:
                m_flags5 |= k_Unitpromotion_Revolution_Bit;
                if(!m_RevolutionValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundSelect1:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundSelect1)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundSelect2:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundSelect2)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundMove:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundMove)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundAcknowledge:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundAcknowledge)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundCantMove:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundCantMove)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundAttack:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundAttack)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundWork:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundWork)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundVictory:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundVictory)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundDeath:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundDeath)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundLoad:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundLoad)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundUnload:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundUnload)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SpecialAttacks:
                if(!g_theSpecialAttackInfoDB->ParseRecordInArray(lex, (sint32 *)m_SpecialAttacks, &m_numSpecialAttacks, k_MAX_SpecialAttacks)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CityGrowthCoefficient:
                m_flags5 |= k_Unitpromotion_CityGrowthCoefficient_Bit;
                if(!lex->GetFloatAssignment(m_CityGrowthCoefficientValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_UserFlags:
                if(!ParseUserFlagsBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_DefaultIcon:
                if (!g_theIconDB->GetRecordFromLexer(lex, m_DefaultIcon)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_NoIndex:
                m_flags5 |= k_Unitpromotion_NoIndex_Bit;
                break;
            case k_Token_Unitpromotion_CheatIndex:
                m_flags5 |= k_Unitpromotion_CheatIndex_Bit;
                if(!lex->GetIntAssignment(m_CheatIndexValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Advice:
                m_flags5 |= k_Unitpromotion_Advice_Bit;
                if(!lex->GetStringIdAssignment(m_AdviceValue)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_Category:
                if(!lex->GetStringIdAssignment(m_Category)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_GLHidden:
                m_flags5 |= k_Unitpromotion_GLHidden_Bit;
                break;
            case k_Token_Unitpromotion_CantMove:
                m_flags6 |= k_Unitpromotion_CantMove_Bit;
                break;
            case k_Token_Unitpromotion_Civilian:
                m_flags6 |= k_Unitpromotion_Civilian_Bit;
                break;
            case k_Token_Unitpromotion_NoBarbarian:
                m_flags6 |= k_Unitpromotion_NoBarbarian_Bit;
                break;
            case k_Token_Unitpromotion_GoodyHutExcluded:
                m_flags6 |= k_Unitpromotion_GoodyHutExcluded_Bit;
                break;
            case k_Token_Unitpromotion_CanHarvest:
                m_flags6 |= k_Unitpromotion_CanHarvest_Bit;
                break;
            case k_Token_Unitpromotion_CantGroup:
                m_flags6 |= k_Unitpromotion_CantGroup_Bit;
                break;
            case k_Token_Unitpromotion_SpawnsBarbarians:
                m_flags6 |= k_Unitpromotion_SpawnsBarbarians_Bit;
                break;
            case k_Token_Unitpromotion_CanSinkInSea:
                m_flags6 |= k_Unitpromotion_CanSinkInSea_Bit;
                break;
            case k_Token_Unitpromotion_Leader:
                m_flags6 |= k_Unitpromotion_Leader_Bit;
                break;
            case k_Token_Unitpromotion_ArmyMountedBonus:
                m_flags6 |= k_Unitpromotion_ArmyMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyAirBonus:
                m_flags6 |= k_Unitpromotion_ArmyAirBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyWoodenShipBonus:
                m_flags6 |= k_Unitpromotion_ArmyWoodenShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyWoodenShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyAttackCityBonus:
                m_flags6 |= k_Unitpromotion_ArmyAttackCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAttackCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyAttackBonusSubmarine:
                m_flags6 |= k_Unitpromotion_ArmyAttackBonusSubmarine_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAttackBonusSubmarineValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyFootBonus:
                m_flags6 |= k_Unitpromotion_ArmyFootBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyFootBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmySiegeBonus:
                m_flags6 |= k_Unitpromotion_ArmySiegeBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmySiegeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyWheeledBonus:
                m_flags6 |= k_Unitpromotion_ArmyWheeledBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyWheeledBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyMechanizedBonus:
                m_flags6 |= k_Unitpromotion_ArmyMechanizedBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyMechanizedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyHelicopterBonus:
                m_flags6 |= k_Unitpromotion_ArmyHelicopterBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyHelicopterBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmySpecialForcesBonus:
                m_flags6 |= k_Unitpromotion_ArmySpecialForcesBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmySpecialForcesBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyCivilianBonus:
                m_flags6 |= k_Unitpromotion_ArmyCivilianBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyCivilianBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyGuerrillaBonus:
                m_flags6 |= k_Unitpromotion_ArmyGuerrillaBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyGuerrillaBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyAgainstMountedBonus:
                m_flags6 |= k_Unitpromotion_ArmyAgainstMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAgainstMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ArmyAirDefenseBonus:
                m_flags6 |= k_Unitpromotion_ArmyAirDefenseBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAirDefenseBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_EnergyHunger:
                if(!lex->GetIntAssignment(m_EnergyHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ProducesEnergy:
                if(!lex->GetIntAssignment(m_ProducesEnergy)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!ParseMovementTypeBit(lex)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void UnitpromotionRecord::ResolveDBReferences()
{
    if(m_AvailableUnit & 0x80000000) {
        sint32 id = m_AvailableUnit & 0x7fffffff;
        if(!g_theUnitDB->GetNamedItem(id, m_AvailableUnit)) {
            c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_AvailableUnit == 0x7fffffff) {
        m_AvailableUnit = -1;
    }
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteAdvance; i++) {
            if(m_ObsoleteAdvance[i] & 0x80000000) {
                sint32 id = m_ObsoleteAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ObsoleteAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteAdvance[i] == 0x7fffffff){
                m_ObsoleteAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteBuilding; i++) {
            if(m_PrerequisiteBuilding[i] & 0x80000000) {
                sint32 id = m_PrerequisiteBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_PrerequisiteBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteBuilding[i] == 0x7fffffff){
                m_PrerequisiteBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByBuilding; i++) {
            if(m_ExcludedByBuilding[i] & 0x80000000) {
                sint32 id = m_ExcludedByBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_ExcludedByBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByBuilding[i] == 0x7fffffff){
                m_ExcludedByBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numUpgradeToPromotion; i++) {
            if(m_UpgradeToPromotion[i] & 0x80000000) {
                sint32 id = m_UpgradeToPromotion[i] & 0x7fffffff;
                if(!g_theUnitDB->GetNamedItem(id, m_UpgradeToPromotion[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_UpgradeToPromotion[i] == 0x7fffffff){
                m_UpgradeToPromotion[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoletePromotion; i++) {
            if(m_ObsoletePromotion[i] & 0x80000000) {
                sint32 id = m_ObsoletePromotion[i] & 0x7fffffff;
                if(!g_theUnitDB->GetNamedItem(id, m_ObsoletePromotion[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoletePromotion[i] == 0x7fffffff){
                m_ObsoletePromotion[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCityStyleOnly; i++) {
            if(m_CityStyleOnly[i] & 0x80000000) {
                sint32 id = m_CityStyleOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CityStyleOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CityStyleOnly[i] == 0x7fffffff){
                m_CityStyleOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCivilisationOnly; i++) {
            if(m_CivilisationOnly[i] & 0x80000000) {
                sint32 id = m_CivilisationOnly[i] & 0x7fffffff;
                if(!g_theCivilisationDB->GetNamedItem(id, m_CivilisationOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Civilisation database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CivilisationOnly[i] == 0x7fffffff){
                m_CivilisationOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentOnly; i++) {
            if(m_GovernmentOnly[i] & 0x80000000) {
                sint32 id = m_GovernmentOnly[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentOnly[i] == 0x7fffffff){
                m_GovernmentOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGood; i++) {
            if(m_NeedsCityGood[i] & 0x80000000) {
                sint32 id = m_NeedsCityGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGood[i] == 0x7fffffff){
                m_NeedsCityGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAll; i++) {
            if(m_NeedsCityGoodAll[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAll[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAll[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAll[i] == 0x7fffffff){
                m_NeedsCityGoodAll[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAnyCity; i++) {
            if(m_NeedsCityGoodAnyCity[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAnyCity[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAnyCity[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAnyCity[i] == 0x7fffffff){
                m_NeedsCityGoodAnyCity[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsFeatToBuild; i++) {
            if(m_NeedsFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsFeatToBuild[i] == 0x7fffffff){
                m_NeedsFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsAnyPlayerFeatToBuild; i++) {
            if(m_NeedsAnyPlayerFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsAnyPlayerFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsAnyPlayerFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsAnyPlayerFeatToBuild[i] == 0x7fffffff){
                m_NeedsAnyPlayerFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteWonder; i++) {
            if(m_PrerequisiteWonder[i] & 0x80000000) {
                sint32 id = m_PrerequisiteWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_PrerequisiteWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteWonder[i] == 0x7fffffff){
                m_PrerequisiteWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByWonder; i++) {
            if(m_ExcludedByWonder[i] & 0x80000000) {
                sint32 id = m_ExcludedByWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_ExcludedByWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByWonder[i] == 0x7fffffff){
                m_ExcludedByWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numAllTerrainAsImprovement; i++) {
            if(m_AllTerrainAsImprovement[i] & 0x80000000) {
                sint32 id = m_AllTerrainAsImprovement[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_AllTerrainAsImprovement[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_AllTerrainAsImprovement[i] == 0x7fffffff){
                m_AllTerrainAsImprovement[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteByUnit; i++) {
            if(m_ObsoleteByUnit[i] & 0x80000000) {
                sint32 id = m_ObsoleteByUnit[i] & 0x7fffffff;
                if(!g_theUnitDB->GetNamedItem(id, m_ObsoleteByUnit[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteByUnit[i] == 0x7fffffff){
                m_ObsoleteByUnit[i] = -1;
            }
        }
    }
    if(m_SettleCityType & 0x80000000) {
        sint32 id = m_SettleCityType & 0x7fffffff;
        if(!g_theUnitDB->GetNamedItem(id, m_SettleCityType)) {
            c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SettleCityType == 0x7fffffff) {
        m_SettleCityType = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numSettleBuilding; i++) {
            if(m_SettleBuilding[i] & 0x80000000) {
                sint32 id = m_SettleBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_SettleBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_SettleBuilding[i] == 0x7fffffff){
                m_SettleBuilding[i] = -1;
            }
        }
    }
    m_NuclearAttackValue.ResolveDBReferences();
    m_StealTechnologyValue.ResolveDBReferences();
    m_InciteRevolutionValue.ResolveDBReferences();
    m_AssasinateRulerValue.ResolveDBReferences();
    m_InvestigateReadinessValue.ResolveDBReferences();
    m_CreateFranchiseValue.ResolveDBReferences();
    m_CauseUnhappinessValue.ResolveDBReferences();
    m_ConductHitsValue.ResolveDBReferences();
    m_BioTerrorValue.ResolveDBReferences();
    m_NanoTerrorValue.ResolveDBReferences();
    m_PlagueValue.ResolveDBReferences();
    m_SlaveRaidsValue.ResolveDBReferences();
    m_SettlerSlaveRaidsValue.ResolveDBReferences();
    m_SlaveUprisingValue.ResolveDBReferences();
    m_UndergroundRailwayValue.ResolveDBReferences();
    m_IndulgenceSalesValue.ResolveDBReferences();
    m_ConvertCitiesValue.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    m_PlantNukeValue.ResolveDBReferences();
    m_CanSoothsayValue.ResolveDBReferences();
    m_CreateParksValue.ResolveDBReferences();
    m_CanInjoinValue.ResolveDBReferences();
    m_CanReformValue.ResolveDBReferences();
    m_CargoDataValue.ResolveDBReferences();
    if(m_DefaultSprite & 0x80000000) {
        sint32 id = m_DefaultSprite & 0x7fffffff;
        if(!g_theSpriteDB->GetNamedItem(id, m_DefaultSprite)) {
            c3errors_ErrorDialog("DB", "%s not found in Sprite database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultSprite == 0x7fffffff) {
        m_DefaultSprite = -1;
    }
    m_InvestigateCityValue.ResolveDBReferences();
    m_RevolutionValue.ResolveDBReferences();
    if(m_SoundSelect1 & 0x80000000) {
        sint32 id = m_SoundSelect1 & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundSelect1)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundSelect1 == 0x7fffffff) {
        m_SoundSelect1 = -1;
    }
    if(m_SoundSelect2 & 0x80000000) {
        sint32 id = m_SoundSelect2 & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundSelect2)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundSelect2 == 0x7fffffff) {
        m_SoundSelect2 = -1;
    }
    if(m_SoundMove & 0x80000000) {
        sint32 id = m_SoundMove & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundMove)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundMove == 0x7fffffff) {
        m_SoundMove = -1;
    }
    if(m_SoundAcknowledge & 0x80000000) {
        sint32 id = m_SoundAcknowledge & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundAcknowledge)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundAcknowledge == 0x7fffffff) {
        m_SoundAcknowledge = -1;
    }
    if(m_SoundCantMove & 0x80000000) {
        sint32 id = m_SoundCantMove & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundCantMove)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundCantMove == 0x7fffffff) {
        m_SoundCantMove = -1;
    }
    if(m_SoundAttack & 0x80000000) {
        sint32 id = m_SoundAttack & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundAttack)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundAttack == 0x7fffffff) {
        m_SoundAttack = -1;
    }
    if(m_SoundWork & 0x80000000) {
        sint32 id = m_SoundWork & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundWork)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundWork == 0x7fffffff) {
        m_SoundWork = -1;
    }
    if(m_SoundVictory & 0x80000000) {
        sint32 id = m_SoundVictory & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundVictory)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundVictory == 0x7fffffff) {
        m_SoundVictory = -1;
    }
    if(m_SoundDeath & 0x80000000) {
        sint32 id = m_SoundDeath & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundDeath)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundDeath == 0x7fffffff) {
        m_SoundDeath = -1;
    }
    if(m_SoundLoad & 0x80000000) {
        sint32 id = m_SoundLoad & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundLoad)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundLoad == 0x7fffffff) {
        m_SoundLoad = -1;
    }
    if(m_SoundUnload & 0x80000000) {
        sint32 id = m_SoundUnload & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundUnload)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundUnload == 0x7fffffff) {
        m_SoundUnload = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numSpecialAttacks; i++) {
            if(m_SpecialAttacks[i] & 0x80000000) {
                sint32 id = m_SpecialAttacks[i] & 0x7fffffff;
                if(!g_theSpecialAttackInfoDB->GetNamedItem(id, m_SpecialAttacks[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in SpecialAttackInfo database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_SpecialAttacks[i] == 0x7fffffff){
                m_SpecialAttacks[i] = -1;
            }
        }
    }
    if(m_DefaultIcon & 0x80000000) {
        sint32 id = m_DefaultIcon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_DefaultIcon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultIcon == 0x7fffffff) {
        m_DefaultIcon = -1;
    }
}

UnitpromotionRecord::SuccessDeath::SuccessDeath()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitpromotionRecord::SuccessDeath::~SuccessDeath()
{
}

UnitpromotionRecord::SuccessDeath const & UnitpromotionRecord::SuccessDeath::operator = (SuccessDeath const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitpromotionRecord::SuccessDeath::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unitpromotion_SuccessDeath_Tokens[] = {
    "Chance",
    "DeathChance",
};
#define k_Token_Unitpromotion_SuccessDeath_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_SuccessDeath_DeathChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_SuccessDeath_Max ((k_Token_Custom_Base) + 2)
sint32 UnitpromotionRecord::SuccessDeath::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeath::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeath::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SuccessDeath"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_SuccessDeath_Tokens, k_Token_Unitpromotion_SuccessDeath_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_SuccessDeath_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SuccessDeath_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::SuccessDeath::ParseInArray(DBLexer *lex, SuccessDeath **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeath *oldArray = *array;
        *array = new SuccessDeath[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeath[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeath::ParseInArray(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeath::ParseInArraySequential(DBLexer *lex, SuccessDeath **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeath *oldArray = *array;
        *array = new SuccessDeath[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeath[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeath::ParseInArraySequential(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::SuccessDeath::ResolveDBReferences()
{
}

UnitpromotionRecord::SuccessDeathEffect::SuccessDeathEffect()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::SuccessDeathEffect::~SuccessDeathEffect()
{
}

UnitpromotionRecord::SuccessDeathEffect const & UnitpromotionRecord::SuccessDeathEffect::operator = (SuccessDeathEffect const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_DeathChance = rval.m_DeathChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::SuccessDeathEffect::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_DeathChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_DeathChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_SuccessDeathEffect_Tokens[] = {
    "Chance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_SuccessDeathEffect_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_SuccessDeathEffect_DeathChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_SuccessDeathEffect_Sound ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_SuccessDeathEffect_Effect ((k_Token_Custom_Base) + 3)
#define k_Token_Unitpromotion_SuccessDeathEffect_Max ((k_Token_Custom_Base) + 4)
sint32 UnitpromotionRecord::SuccessDeathEffect::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeathEffect::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeathEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SuccessDeathEffect"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_SuccessDeathEffect_Tokens, k_Token_Unitpromotion_SuccessDeathEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_SuccessDeathEffect_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SuccessDeathEffect_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SuccessDeathEffect_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SuccessDeathEffect_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::SuccessDeathEffect::ParseInArray(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeathEffect *oldArray = *array;
        *array = new SuccessDeathEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeathEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeathEffect::ParseInArray(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeathEffect::ParseInArraySequential(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeathEffect *oldArray = *array;
        *array = new SuccessDeathEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeathEffect[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SuccessDeathEffect::ParseInArraySequential(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::SuccessDeathEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::StealTechnologyData::StealTechnologyData()
{
    m_RandomChance = 0.000000;
    m_SpecificChance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::StealTechnologyData::~StealTechnologyData()
{
}

UnitpromotionRecord::StealTechnologyData const & UnitpromotionRecord::StealTechnologyData::operator = (StealTechnologyData const & rval)
{
    if (this != &rval)
    {

        m_RandomChance = rval.m_RandomChance;

        m_SpecificChance = rval.m_SpecificChance;

        m_DeathChance = rval.m_DeathChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::StealTechnologyData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_RandomChance;
        archive << m_SpecificChance;
        archive << m_DeathChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_RandomChance;
        archive >> m_SpecificChance;
        archive >> m_DeathChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_StealTechnologyData_Tokens[] = {
    "RandomChance",
    "SpecificChance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_StealTechnologyData_RandomChance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_StealTechnologyData_SpecificChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_StealTechnologyData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_StealTechnologyData_Sound ((k_Token_Custom_Base) + 3)
#define k_Token_Unitpromotion_StealTechnologyData_Effect ((k_Token_Custom_Base) + 4)
#define k_Token_Unitpromotion_StealTechnologyData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitpromotionRecord::StealTechnologyData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_RandomChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_SpecificChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::StealTechnologyData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_RandomChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_SpecificChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::StealTechnologyData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for StealTechnologyData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_StealTechnologyData_Tokens, k_Token_Unitpromotion_StealTechnologyData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_StealTechnologyData_RandomChance:
                if(!lex->GetFloatAssignment(m_RandomChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_StealTechnologyData_SpecificChance:
                if(!lex->GetFloatAssignment(m_SpecificChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_StealTechnologyData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_StealTechnologyData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_StealTechnologyData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_RandomChance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::StealTechnologyData::ParseInArray(DBLexer *lex, StealTechnologyData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        StealTechnologyData *oldArray = *array;
        *array = new StealTechnologyData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new StealTechnologyData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::StealTechnologyData::ParseInArray(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::StealTechnologyData::ParseInArraySequential(DBLexer *lex, StealTechnologyData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        StealTechnologyData *oldArray = *array;
        *array = new StealTechnologyData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new StealTechnologyData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::StealTechnologyData::ParseInArraySequential(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::StealTechnologyData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::InciteRevolutionData::InciteRevolutionData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::InciteRevolutionData::~InciteRevolutionData()
{
}

UnitpromotionRecord::InciteRevolutionData const & UnitpromotionRecord::InciteRevolutionData::operator = (InciteRevolutionData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::InciteRevolutionData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_InciteRevolutionData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_InciteRevolutionData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_InciteRevolutionData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_InciteRevolutionData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_InciteRevolutionData_Sound ((k_Token_Custom_Base) + 3)
#define k_Token_Unitpromotion_InciteRevolutionData_Effect ((k_Token_Custom_Base) + 4)
#define k_Token_Unitpromotion_InciteRevolutionData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitpromotionRecord::InciteRevolutionData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::InciteRevolutionData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::InciteRevolutionData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for InciteRevolutionData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_InciteRevolutionData_Tokens, k_Token_Unitpromotion_InciteRevolutionData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_InciteRevolutionData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InciteRevolutionData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InciteRevolutionData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InciteRevolutionData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InciteRevolutionData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::InciteRevolutionData::ParseInArray(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InciteRevolutionData *oldArray = *array;
        *array = new InciteRevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InciteRevolutionData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InciteRevolutionData::ParseInArray(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InciteRevolutionData::ParseInArraySequential(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InciteRevolutionData *oldArray = *array;
        *array = new InciteRevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InciteRevolutionData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InciteRevolutionData::ParseInArraySequential(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::InciteRevolutionData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::AssasinateRulerData::AssasinateRulerData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitpromotionRecord::AssasinateRulerData::~AssasinateRulerData()
{
}

UnitpromotionRecord::AssasinateRulerData const & UnitpromotionRecord::AssasinateRulerData::operator = (AssasinateRulerData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitpromotionRecord::AssasinateRulerData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unitpromotion_AssasinateRulerData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unitpromotion_AssasinateRulerData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_AssasinateRulerData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_AssasinateRulerData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_AssasinateRulerData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitpromotionRecord::AssasinateRulerData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::AssasinateRulerData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::AssasinateRulerData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for AssasinateRulerData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_AssasinateRulerData_Tokens, k_Token_Unitpromotion_AssasinateRulerData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_AssasinateRulerData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AssasinateRulerData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_AssasinateRulerData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::AssasinateRulerData::ParseInArray(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AssasinateRulerData *oldArray = *array;
        *array = new AssasinateRulerData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AssasinateRulerData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::AssasinateRulerData::ParseInArray(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::AssasinateRulerData::ParseInArraySequential(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AssasinateRulerData *oldArray = *array;
        *array = new AssasinateRulerData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AssasinateRulerData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::AssasinateRulerData::ParseInArraySequential(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::AssasinateRulerData::ResolveDBReferences()
{
}

UnitpromotionRecord::InvestigateReadinessData::InvestigateReadinessData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitpromotionRecord::InvestigateReadinessData::~InvestigateReadinessData()
{
}

UnitpromotionRecord::InvestigateReadinessData const & UnitpromotionRecord::InvestigateReadinessData::operator = (InvestigateReadinessData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitpromotionRecord::InvestigateReadinessData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unitpromotion_InvestigateReadinessData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unitpromotion_InvestigateReadinessData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_InvestigateReadinessData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_InvestigateReadinessData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_InvestigateReadinessData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitpromotionRecord::InvestigateReadinessData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::InvestigateReadinessData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::InvestigateReadinessData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for InvestigateReadinessData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_InvestigateReadinessData_Tokens, k_Token_Unitpromotion_InvestigateReadinessData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_InvestigateReadinessData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InvestigateReadinessData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InvestigateReadinessData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::InvestigateReadinessData::ParseInArray(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateReadinessData *oldArray = *array;
        *array = new InvestigateReadinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateReadinessData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InvestigateReadinessData::ParseInArray(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InvestigateReadinessData::ParseInArraySequential(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateReadinessData *oldArray = *array;
        *array = new InvestigateReadinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateReadinessData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InvestigateReadinessData::ParseInArraySequential(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::InvestigateReadinessData::ResolveDBReferences()
{
}

UnitpromotionRecord::ChanceEffect::ChanceEffect()
{
    m_Chance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::ChanceEffect::~ChanceEffect()
{
}

UnitpromotionRecord::ChanceEffect const & UnitpromotionRecord::ChanceEffect::operator = (ChanceEffect const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::ChanceEffect::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_ChanceEffect_Tokens[] = {
    "Chance",
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_ChanceEffect_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_ChanceEffect_Sound ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_ChanceEffect_Effect ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_ChanceEffect_Max ((k_Token_Custom_Base) + 3)
sint32 UnitpromotionRecord::ChanceEffect::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::ChanceEffect::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::ChanceEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for ChanceEffect"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_ChanceEffect_Tokens, k_Token_Unitpromotion_ChanceEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_ChanceEffect_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ChanceEffect_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_ChanceEffect_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::ChanceEffect::ParseInArray(DBLexer *lex, ChanceEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ChanceEffect *oldArray = *array;
        *array = new ChanceEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ChanceEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::ChanceEffect::ParseInArray(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::ChanceEffect::ParseInArraySequential(DBLexer *lex, ChanceEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ChanceEffect *oldArray = *array;
        *array = new ChanceEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ChanceEffect[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::ChanceEffect::ParseInArraySequential(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::ChanceEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::CauseUnhappinessData::CauseUnhappinessData()
{
    m_Chance = 0.000000;
    m_Timer = 0;
    m_Amount = 0;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::CauseUnhappinessData::~CauseUnhappinessData()
{
}

UnitpromotionRecord::CauseUnhappinessData const & UnitpromotionRecord::CauseUnhappinessData::operator = (CauseUnhappinessData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_Timer = rval.m_Timer;

        m_Amount = rval.m_Amount;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::CauseUnhappinessData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_Timer;
        archive << m_Amount;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_Timer;
        archive >> m_Amount;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_CauseUnhappinessData_Tokens[] = {
    "Chance",
    "Timer",
    "Amount",
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_CauseUnhappinessData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_CauseUnhappinessData_Timer ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_CauseUnhappinessData_Amount ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_CauseUnhappinessData_Sound ((k_Token_Custom_Base) + 3)
#define k_Token_Unitpromotion_CauseUnhappinessData_Effect ((k_Token_Custom_Base) + 4)
#define k_Token_Unitpromotion_CauseUnhappinessData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitpromotionRecord::CauseUnhappinessData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::CauseUnhappinessData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::CauseUnhappinessData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for CauseUnhappinessData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_CauseUnhappinessData_Tokens, k_Token_Unitpromotion_CauseUnhappinessData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_CauseUnhappinessData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CauseUnhappinessData_Timer:
                if(!lex->GetIntAssignment(m_Timer)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CauseUnhappinessData_Amount:
                if(!lex->GetIntAssignment(m_Amount)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CauseUnhappinessData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CauseUnhappinessData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::CauseUnhappinessData::ParseInArray(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CauseUnhappinessData *oldArray = *array;
        *array = new CauseUnhappinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CauseUnhappinessData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::CauseUnhappinessData::ParseInArray(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::CauseUnhappinessData::ParseInArraySequential(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CauseUnhappinessData *oldArray = *array;
        *array = new CauseUnhappinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CauseUnhappinessData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::CauseUnhappinessData::ParseInArraySequential(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::CauseUnhappinessData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::SlaveRaidsData::SlaveRaidsData()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
    m_Timer = 0;
    m_Amount = 0;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::SlaveRaidsData::~SlaveRaidsData()
{
}

UnitpromotionRecord::SlaveRaidsData const & UnitpromotionRecord::SlaveRaidsData::operator = (SlaveRaidsData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_DeathChance = rval.m_DeathChance;

        m_Timer = rval.m_Timer;

        m_Amount = rval.m_Amount;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::SlaveRaidsData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_DeathChance;
        archive << m_Timer;
        archive << m_Amount;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_DeathChance;
        archive >> m_Timer;
        archive >> m_Amount;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_SlaveRaidsData_Tokens[] = {
    "Chance",
    "DeathChance",
    "Timer",
    "Amount",
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_SlaveRaidsData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_SlaveRaidsData_DeathChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_SlaveRaidsData_Timer ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_SlaveRaidsData_Amount ((k_Token_Custom_Base) + 3)
#define k_Token_Unitpromotion_SlaveRaidsData_Sound ((k_Token_Custom_Base) + 4)
#define k_Token_Unitpromotion_SlaveRaidsData_Effect ((k_Token_Custom_Base) + 5)
#define k_Token_Unitpromotion_SlaveRaidsData_Max ((k_Token_Custom_Base) + 6)
sint32 UnitpromotionRecord::SlaveRaidsData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SlaveRaidsData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SlaveRaidsData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SlaveRaidsData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_SlaveRaidsData_Tokens, k_Token_Unitpromotion_SlaveRaidsData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_SlaveRaidsData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SlaveRaidsData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SlaveRaidsData_Timer:
                if(!lex->GetIntAssignment(m_Timer)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SlaveRaidsData_Amount:
                if(!lex->GetIntAssignment(m_Amount)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SlaveRaidsData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SlaveRaidsData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::SlaveRaidsData::ParseInArray(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SlaveRaidsData *oldArray = *array;
        *array = new SlaveRaidsData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SlaveRaidsData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SlaveRaidsData::ParseInArray(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SlaveRaidsData::ParseInArraySequential(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SlaveRaidsData *oldArray = *array;
        *array = new SlaveRaidsData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SlaveRaidsData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SlaveRaidsData::ParseInArraySequential(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::SlaveRaidsData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::SoundAndEffect::SoundAndEffect()
{
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::SoundAndEffect::~SoundAndEffect()
{
}

UnitpromotionRecord::SoundAndEffect const & UnitpromotionRecord::SoundAndEffect::operator = (SoundAndEffect const & rval)
{
    if (this != &rval)
    {

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::SoundAndEffect::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_SoundAndEffect_Tokens[] = {
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_SoundAndEffect_Sound ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_SoundAndEffect_Effect ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_SoundAndEffect_Max ((k_Token_Custom_Base) + 2)
sint32 UnitpromotionRecord::SoundAndEffect::ParseSequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SoundAndEffect::ParseFullySequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::SoundAndEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SoundAndEffect"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_SoundAndEffect_Tokens, k_Token_Unitpromotion_SoundAndEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_SoundAndEffect_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_SoundAndEffect_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::SoundAndEffect::ParseInArray(DBLexer *lex, SoundAndEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SoundAndEffect *oldArray = *array;
        *array = new SoundAndEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SoundAndEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SoundAndEffect::ParseInArray(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SoundAndEffect::ParseInArraySequential(DBLexer *lex, SoundAndEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SoundAndEffect *oldArray = *array;
        *array = new SoundAndEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SoundAndEffect[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::SoundAndEffect::ParseInArraySequential(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::SoundAndEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::PlantNukeData::PlantNukeData()
{
    m_Chance = 0.000000;
    m_EscapeChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::PlantNukeData::~PlantNukeData()
{
}

UnitpromotionRecord::PlantNukeData const & UnitpromotionRecord::PlantNukeData::operator = (PlantNukeData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EscapeChance = rval.m_EscapeChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::PlantNukeData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EscapeChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_EscapeChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_PlantNukeData_Tokens[] = {
    "Chance",
    "EscapeChance",
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_PlantNukeData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_PlantNukeData_EscapeChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_PlantNukeData_Sound ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_PlantNukeData_Effect ((k_Token_Custom_Base) + 3)
#define k_Token_Unitpromotion_PlantNukeData_Max ((k_Token_Custom_Base) + 4)
sint32 UnitpromotionRecord::PlantNukeData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EscapeChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::PlantNukeData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EscapeChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::PlantNukeData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for PlantNukeData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_PlantNukeData_Tokens, k_Token_Unitpromotion_PlantNukeData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_PlantNukeData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_PlantNukeData_EscapeChance:
                if(!lex->GetFloatAssignment(m_EscapeChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_PlantNukeData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_PlantNukeData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::PlantNukeData::ParseInArray(DBLexer *lex, PlantNukeData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        PlantNukeData *oldArray = *array;
        *array = new PlantNukeData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new PlantNukeData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::PlantNukeData::ParseInArray(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::PlantNukeData::ParseInArraySequential(DBLexer *lex, PlantNukeData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        PlantNukeData *oldArray = *array;
        *array = new PlantNukeData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new PlantNukeData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::PlantNukeData::ParseInArraySequential(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::PlantNukeData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitpromotionRecord::CargoData::CargoData()
{
    m_MaxCargo = 0;
    m_Load = 0x7fffffff;
    m_Unload = 0x7fffffff;
}

UnitpromotionRecord::CargoData::~CargoData()
{
}

UnitpromotionRecord::CargoData const & UnitpromotionRecord::CargoData::operator = (CargoData const & rval)
{
    if (this != &rval)
    {

        m_MaxCargo = rval.m_MaxCargo;

        m_Load = rval.m_Load;

        m_Unload = rval.m_Unload;

    }

    return *this;
}

void UnitpromotionRecord::CargoData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_MaxCargo;
        archive << m_Load;
        archive << m_Unload;
    } else {
        archive >> m_MaxCargo;
        archive >> m_Load;
        archive >> m_Unload;
    }
}

static const char *s_Unitpromotion_CargoData_Tokens[] = {
    "MaxCargo",
    "Load",
    "Unload",
};
#define k_Token_Unitpromotion_CargoData_MaxCargo ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_CargoData_Load     ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_CargoData_Unload   ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_CargoData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitpromotionRecord::CargoData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetIntAssignment(m_MaxCargo)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Load)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Unload)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::CargoData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetInt(m_MaxCargo)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Load)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Unload)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::CargoData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for CargoData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_CargoData_Tokens, k_Token_Unitpromotion_CargoData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_CargoData_MaxCargo:
                if(!lex->GetIntAssignment(m_MaxCargo)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CargoData_Load:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Load)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_CargoData_Unload:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Unload)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_MaxCargo)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::CargoData::ParseInArray(DBLexer *lex, CargoData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CargoData *oldArray = *array;
        *array = new CargoData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CargoData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::CargoData::ParseInArray(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::CargoData::ParseInArraySequential(DBLexer *lex, CargoData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CargoData *oldArray = *array;
        *array = new CargoData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CargoData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::CargoData::ParseInArraySequential(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::CargoData::ResolveDBReferences()
{
    if(m_Load & 0x80000000) {
        sint32 id = m_Load & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Load)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Load == 0x7fffffff) {
        m_Load = -1;
    }
    if(m_Unload & 0x80000000) {
        sint32 id = m_Unload & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Unload)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Unload == 0x7fffffff) {
        m_Unload = -1;
    }
}

UnitpromotionRecord::InvestigateCityData::InvestigateCityData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitpromotionRecord::InvestigateCityData::~InvestigateCityData()
{
}

UnitpromotionRecord::InvestigateCityData const & UnitpromotionRecord::InvestigateCityData::operator = (InvestigateCityData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitpromotionRecord::InvestigateCityData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unitpromotion_InvestigateCityData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unitpromotion_InvestigateCityData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_InvestigateCityData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_InvestigateCityData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unitpromotion_InvestigateCityData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitpromotionRecord::InvestigateCityData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::InvestigateCityData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::InvestigateCityData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for InvestigateCityData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_InvestigateCityData_Tokens, k_Token_Unitpromotion_InvestigateCityData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_InvestigateCityData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InvestigateCityData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_InvestigateCityData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::InvestigateCityData::ParseInArray(DBLexer *lex, InvestigateCityData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateCityData *oldArray = *array;
        *array = new InvestigateCityData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateCityData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InvestigateCityData::ParseInArray(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InvestigateCityData::ParseInArraySequential(DBLexer *lex, InvestigateCityData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateCityData *oldArray = *array;
        *array = new InvestigateCityData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateCityData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::InvestigateCityData::ParseInArraySequential(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::InvestigateCityData::ResolveDBReferences()
{
}

UnitpromotionRecord::RevolutionData::RevolutionData()
{
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitpromotionRecord::RevolutionData::~RevolutionData()
{
}

UnitpromotionRecord::RevolutionData const & UnitpromotionRecord::RevolutionData::operator = (RevolutionData const & rval)
{
    if (this != &rval)
    {

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitpromotionRecord::RevolutionData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unitpromotion_RevolutionData_Tokens[] = {
    "Sound",
    "Effect",
};
#define k_Token_Unitpromotion_RevolutionData_Sound ((k_Token_Custom_Base) + 0)
#define k_Token_Unitpromotion_RevolutionData_Effect ((k_Token_Custom_Base) + 1)
#define k_Token_Unitpromotion_RevolutionData_Max ((k_Token_Custom_Base) + 2)
sint32 UnitpromotionRecord::RevolutionData::ParseSequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::RevolutionData::ParseFullySequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitpromotionRecord::RevolutionData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for RevolutionData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unitpromotion_RevolutionData_Tokens, k_Token_Unitpromotion_RevolutionData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unitpromotion_RevolutionData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unitpromotion_RevolutionData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitpromotionRecord::RevolutionData::ParseInArray(DBLexer *lex, RevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RevolutionData *oldArray = *array;
        *array = new RevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RevolutionData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::RevolutionData::ParseInArray(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::RevolutionData::ParseInArraySequential(DBLexer *lex, RevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RevolutionData *oldArray = *array;
        *array = new RevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RevolutionData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitpromotionRecord::RevolutionData::ParseInArraySequential(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitpromotionRecord::RevolutionData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

static const char *s_Unitpromotion_MovementType_BitNames[] = {
    "Land",
    "Sea",
    "Air",
    "Mountain",
    "Trade",
    "ShallowWater",
    "Space",
};
#define k_Unitpromotion_MovementType_Num_BitNames 7

sint32 UnitpromotionRecord::ParseMovementTypeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_MovementType_BitNames, k_Unitpromotion_MovementType_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of MovementType", lex->GetTokenText()));
        return 0;
    }
    m_MovementType |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_CanCarry_BitNames[] = {
    "SmallLand",
    "MedLand",
    "LargeLand",
    "SmallAir",
    "MedAir",
    "LargeAir",
    "SmallWater",
    "MedWater",
    "LargeWater",
    "SmallSpace",
    "MedSpace",
    "LargeSpace",
};
#define k_Unitpromotion_CanCarry_Num_BitNames 12

sint32 UnitpromotionRecord::ParseCanCarryBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_CanCarry_BitNames, k_Unitpromotion_CanCarry_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanCarry", lex->GetTokenText()));
        return 0;
    }
    m_CanCarry |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_Size_BitNames[] = {
    "Small",
    "Medium",
    "Large",
};
#define k_Unitpromotion_Size_Num_BitNames 3

sint32 UnitpromotionRecord::ParseSizeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_Size_BitNames, k_Unitpromotion_Size_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Size", lex->GetTokenText()));
        return 0;
    }
    m_Size |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_CanBombard_BitNames[] = {
    "Land",
    "Air",
    "Water",
    "Space",
    "Mountain",
};
#define k_Unitpromotion_CanBombard_Num_BitNames 5

sint32 UnitpromotionRecord::ParseCanBombardBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_CanBombard_BitNames, k_Unitpromotion_CanBombard_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanBombard", lex->GetTokenText()));
        return 0;
    }
    m_CanBombard |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_Settle_BitNames[] = {
    "Land",
    "Water",
    "Mountain",
    "Space",
};
#define k_Unitpromotion_Settle_Num_BitNames 4

sint32 UnitpromotionRecord::ParseSettleBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_Settle_BitNames, k_Unitpromotion_Settle_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Settle", lex->GetTokenText()));
        return 0;
    }
    m_Settle |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_Defend_BitNames[] = {
    "Land",
    "Air",
    "Water",
    "Space",
    "Mountain",
};
#define k_Unitpromotion_Defend_Num_BitNames 5

sint32 UnitpromotionRecord::ParseDefendBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_Defend_BitNames, k_Unitpromotion_Defend_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Defend", lex->GetTokenText()));
        return 0;
    }
    m_Defend |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_VisionClass_BitNames[] = {
    "Standard",
    "Underwater",
    "Stealth",
    "UnusedBit3",
    "UnusedBit4",
    "UnusedBit5",
    "UnusedBit6",
    "UnusedBit7",
    "UnusedBit8",
    "UnusedBit9",
    "UnusedBit10",
    "UnusedBit11",
    "UnusedBit12",
    "UnusedBit13",
    "UnusedBit14",
    "UnusedBit15",
};
#define k_Unitpromotion_VisionClass_Num_BitNames 16

sint32 UnitpromotionRecord::ParseVisionClassBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_VisionClass_BitNames, k_Unitpromotion_VisionClass_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of VisionClass", lex->GetTokenText()));
        return 0;
    }
    m_VisionClass |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_CanSee_BitNames[] = {
    "Standard",
    "Underwater",
    "Stealth",
    "UnusedBit3",
    "UnusedBit4",
    "UnusedBit5",
    "UnusedBit6",
    "UnusedBit7",
    "UnusedBit8",
    "UnusedBit9",
    "UnusedBit10",
    "UnusedBit11",
    "UnusedBit12",
    "UnusedBit13",
    "UnusedBit14",
    "UnusedBit15",
};
#define k_Unitpromotion_CanSee_Num_BitNames 16

sint32 UnitpromotionRecord::ParseCanSeeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_CanSee_BitNames, k_Unitpromotion_CanSee_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanSee", lex->GetTokenText()));
        return 0;
    }
    m_CanSee |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_CanAttack_BitNames[] = {
    "Land",
    "Sea",
    "Air",
    "Mountain",
    "Trade",
    "ShallowWater",
    "Space",
    "Underwater",
};
#define k_Unitpromotion_CanAttack_Num_BitNames 8

sint32 UnitpromotionRecord::ParseCanAttackBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_CanAttack_BitNames, k_Unitpromotion_CanAttack_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanAttack", lex->GetTokenText()));
        return 0;
    }
    m_CanAttack |= (1 << bitindex);
    return 1;
}

static const char *s_Unitpromotion_UserFlags_BitNames[] = {
    "UF1",
    "UF2",
    "UF3",
    "UF4",
    "UF5",
    "UF6",
    "UF7",
    "UF8",
    "UF9",
    "UF10",
    "UF11",
    "UF12",
    "UF13",
    "UF14",
    "UF15",
    "UF16",
    "UF17",
    "UF18",
    "UF19",
    "UF20",
    "UF21",
    "UF22",
    "UF23",
    "UF24",
    "UF25",
    "UF26",
    "UF27",
    "UF28",
    "UF29",
    "UF30",
    "UF31",
};
#define k_Unitpromotion_UserFlags_Num_BitNames 31

sint32 UnitpromotionRecord::ParseUserFlagsBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unitpromotion_UserFlags_BitNames, k_Unitpromotion_UserFlags_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of UserFlags", lex->GetTokenText()));
        return 0;
    }
    m_UserFlags |= (1 << bitindex);
    return 1;
}

void UnitpromotionRecord::Merge(const UnitpromotionRecord & rval){
    // only replace values that have been set
    if (rval.m_MovementType)
    {
        m_MovementType = rval.m_MovementType;
    }

    // only replace values that have been set
    if (rval.m_CanCarry)
    {
        m_CanCarry = rval.m_CanCarry;
    }

    if (rval.m_numObsoleteAdvance > 0)
        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

    // resize m_PrerequisiteBuilding if necessary
    if (rval.m_numPrerequisiteBuilding > m_numPrerequisiteBuilding)
    {
        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;
    }
    if (rval.m_numPrerequisiteBuilding > 0)
        std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);

    // resize m_ExcludedByBuilding if necessary
    if (rval.m_numExcludedByBuilding > m_numExcludedByBuilding)
    {
        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;
    }
    if (rval.m_numExcludedByBuilding > 0)
        std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);

    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

    // resize m_UpgradeToPromotion if necessary
    if (rval.m_numUpgradeToPromotion > m_numUpgradeToPromotion)
    {
        delete [] m_UpgradeToPromotion;
        m_UpgradeToPromotion = NULL;
        if (rval.m_numUpgradeToPromotion > 0)
            m_UpgradeToPromotion = new sint32 [rval.m_numUpgradeToPromotion];
        m_numUpgradeToPromotion = rval.m_numUpgradeToPromotion;
    }
    if (rval.m_numUpgradeToPromotion > 0)
        std::copy(rval.m_UpgradeToPromotion, rval.m_UpgradeToPromotion + rval.m_numUpgradeToPromotion, m_UpgradeToPromotion);

    // resize m_ObsoletePromotion if necessary
    if (rval.m_numObsoletePromotion > m_numObsoletePromotion)
    {
        delete [] m_ObsoletePromotion;
        m_ObsoletePromotion = NULL;
        if (rval.m_numObsoletePromotion > 0)
            m_ObsoletePromotion = new sint32 [rval.m_numObsoletePromotion];
        m_numObsoletePromotion = rval.m_numObsoletePromotion;
    }
    if (rval.m_numObsoletePromotion > 0)
        std::copy(rval.m_ObsoletePromotion, rval.m_ObsoletePromotion + rval.m_numObsoletePromotion, m_ObsoletePromotion);

    // resize m_CultureOnly if necessary
    if (rval.m_numCultureOnly > m_numCultureOnly)
    {
        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
        m_numCultureOnly = rval.m_numCultureOnly;
    }
    if (rval.m_numCultureOnly > 0)
        std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);

    // resize m_CityStyleOnly if necessary
    if (rval.m_numCityStyleOnly > m_numCityStyleOnly)
    {
        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
        m_numCityStyleOnly = rval.m_numCityStyleOnly;
    }
    if (rval.m_numCityStyleOnly > 0)
        std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);

    // resize m_CivilisationOnly if necessary
    if (rval.m_numCivilisationOnly > m_numCivilisationOnly)
    {
        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
        m_numCivilisationOnly = rval.m_numCivilisationOnly;
    }
    if (rval.m_numCivilisationOnly > 0)
        std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);

    // resize m_GovernmentOnly if necessary
    if (rval.m_numGovernmentOnly > m_numGovernmentOnly)
    {
        delete [] m_GovernmentOnly;
        m_GovernmentOnly = NULL;
        if (rval.m_numGovernmentOnly > 0)
            m_GovernmentOnly = new sint32 [rval.m_numGovernmentOnly];
        m_numGovernmentOnly = rval.m_numGovernmentOnly;
    }
    if (rval.m_numGovernmentOnly > 0)
        std::copy(rval.m_GovernmentOnly, rval.m_GovernmentOnly + rval.m_numGovernmentOnly, m_GovernmentOnly);

    // resize m_NeedsCityGood if necessary
    if (rval.m_numNeedsCityGood > m_numNeedsCityGood)
    {
        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
        m_numNeedsCityGood = rval.m_numNeedsCityGood;
    }
    if (rval.m_numNeedsCityGood > 0)
        std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);

    // resize m_NeedsCityGoodAll if necessary
    if (rval.m_numNeedsCityGoodAll > m_numNeedsCityGoodAll)
    {
        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;
    }
    if (rval.m_numNeedsCityGoodAll > 0)
        std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);

    // resize m_NeedsCityGoodAnyCity if necessary
    if (rval.m_numNeedsCityGoodAnyCity > m_numNeedsCityGoodAnyCity)
    {
        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;
    }
    if (rval.m_numNeedsCityGoodAnyCity > 0)
        std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);

    // resize m_NeedsFeatToBuild if necessary
    if (rval.m_numNeedsFeatToBuild > m_numNeedsFeatToBuild)
    {
        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;
    }
    if (rval.m_numNeedsFeatToBuild > 0)
        std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);

    // resize m_NeedsAnyPlayerFeatToBuild if necessary
    if (rval.m_numNeedsAnyPlayerFeatToBuild > m_numNeedsAnyPlayerFeatToBuild)
    {
        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;
    }
    if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);

    // resize m_PrerequisiteWonder if necessary
    if (rval.m_numPrerequisiteWonder > m_numPrerequisiteWonder)
    {
        delete [] m_PrerequisiteWonder;
        m_PrerequisiteWonder = NULL;
        if (rval.m_numPrerequisiteWonder > 0)
            m_PrerequisiteWonder = new sint32 [rval.m_numPrerequisiteWonder];
        m_numPrerequisiteWonder = rval.m_numPrerequisiteWonder;
    }
    if (rval.m_numPrerequisiteWonder > 0)
        std::copy(rval.m_PrerequisiteWonder, rval.m_PrerequisiteWonder + rval.m_numPrerequisiteWonder, m_PrerequisiteWonder);

    // resize m_ExcludedByWonder if necessary
    if (rval.m_numExcludedByWonder > m_numExcludedByWonder)
    {
        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
        m_numExcludedByWonder = rval.m_numExcludedByWonder;
    }
    if (rval.m_numExcludedByWonder > 0)
        std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);

    // only replace values that have been set
    if (rval.m_flags0 & k_Unitpromotion_MoveBonus_Bit)
    {
        m_MoveBonusValue = rval.m_MoveBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Unitpromotion_PWMoveCost_Bit)
    {
        m_PWMoveCostValue = rval.m_PWMoveCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Unitpromotion_MerchantGold_Bit)
    {
        m_MerchantGoldValue = rval.m_MerchantGoldValue;
    }

    // resize m_AllTerrainAsImprovement if necessary
    if (rval.m_numAllTerrainAsImprovement > m_numAllTerrainAsImprovement)
    {
        delete [] m_AllTerrainAsImprovement;
        m_AllTerrainAsImprovement = NULL;
        if (rval.m_numAllTerrainAsImprovement > 0)
            m_AllTerrainAsImprovement = new sint32 [rval.m_numAllTerrainAsImprovement];
        m_numAllTerrainAsImprovement = rval.m_numAllTerrainAsImprovement;
    }
    if (rval.m_numAllTerrainAsImprovement > 0)
        std::copy(rval.m_AllTerrainAsImprovement, rval.m_AllTerrainAsImprovement + rval.m_numAllTerrainAsImprovement, m_AllTerrainAsImprovement);

    // resize m_ObsoleteByUnit if necessary
    if (rval.m_numObsoleteByUnit > m_numObsoleteByUnit)
    {
        delete [] m_ObsoleteByUnit;
        m_ObsoleteByUnit = NULL;
        if (rval.m_numObsoleteByUnit > 0)
            m_ObsoleteByUnit = new sint32 [rval.m_numObsoleteByUnit];
        m_numObsoleteByUnit = rval.m_numObsoleteByUnit;
    }
    if (rval.m_numObsoleteByUnit > 0)
        std::copy(rval.m_ObsoleteByUnit, rval.m_ObsoleteByUnit + rval.m_numObsoleteByUnit, m_ObsoleteByUnit);

    // only replace values that have been set
    if (rval.m_Size)
    {
        m_Size = rval.m_Size;
    }

    // only replace values that have been set
    if (rval.m_CanBombard)
    {
        m_CanBombard = rval.m_CanBombard;
    }

    // only replace values that have been set
    if (rval.m_Settle)
    {
        m_Settle = rval.m_Settle;
    }

    // resize m_SettleBuilding if necessary
    if (rval.m_numSettleBuilding > m_numSettleBuilding)
    {
        delete [] m_SettleBuilding;
        m_SettleBuilding = NULL;
        if (rval.m_numSettleBuilding > 0)
            m_SettleBuilding = new sint32 [rval.m_numSettleBuilding];
        m_numSettleBuilding = rval.m_numSettleBuilding;
    }
    if (rval.m_numSettleBuilding > 0)
        std::copy(rval.m_SettleBuilding, rval.m_SettleBuilding + rval.m_numSettleBuilding, m_SettleBuilding);

    // only replace values that have been set
    if (rval.m_flags0 & k_Unitpromotion_SpaceLaunch_Bit)
    {
        m_SpaceLaunchValue = rval.m_SpaceLaunchValue;
    }

    // only replace values that have been set
    if (rval.m_Defend)
    {
        m_Defend = rval.m_Defend;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Unitpromotion_DefendAgainstSpies_Bit)
    {
        m_DefendAgainstSpiesValue = rval.m_DefendAgainstSpiesValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unitpromotion_ReplaceWithCargoModule_Bit)
    {
        m_ReplaceWithCargoModuleValue = rval.m_ReplaceWithCargoModuleValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unitpromotion_NuclearAttack_Bit)
    {
        m_NuclearAttackValue = rval.m_NuclearAttackValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unitpromotion_StealTechnology_Bit)
    {
        m_StealTechnologyValue = rval.m_StealTechnologyValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unitpromotion_InciteRevolution_Bit)
    {
        m_InciteRevolutionValue = rval.m_InciteRevolutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unitpromotion_AssasinateRuler_Bit)
    {
        m_AssasinateRulerValue = rval.m_AssasinateRulerValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unitpromotion_InvestigateReadiness_Bit)
    {
        m_InvestigateReadinessValue = rval.m_InvestigateReadinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_CreateFranchise_Bit)
    {
        m_CreateFranchiseValue = rval.m_CreateFranchiseValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_CauseUnhappiness_Bit)
    {
        m_CauseUnhappinessValue = rval.m_CauseUnhappinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_ConductHits_Bit)
    {
        m_ConductHitsValue = rval.m_ConductHitsValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_BioTerror_Bit)
    {
        m_BioTerrorValue = rval.m_BioTerrorValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_NanoTerror_Bit)
    {
        m_NanoTerrorValue = rval.m_NanoTerrorValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_Plague_Bit)
    {
        m_PlagueValue = rval.m_PlagueValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_SlaveRaids_Bit)
    {
        m_SlaveRaidsValue = rval.m_SlaveRaidsValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_SettlerSlaveRaids_Bit)
    {
        m_SettlerSlaveRaidsValue = rval.m_SettlerSlaveRaidsValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_SlaveUprising_Bit)
    {
        m_SlaveUprisingValue = rval.m_SlaveUprisingValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_UndergroundRailway_Bit)
    {
        m_UndergroundRailwayValue = rval.m_UndergroundRailwayValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_VictoryEnslavementChance_Bit)
    {
        m_VictoryEnslavementChanceValue = rval.m_VictoryEnslavementChanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_IndulgenceSales_Bit)
    {
        m_IndulgenceSalesValue = rval.m_IndulgenceSalesValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_ConvertCities_Bit)
    {
        m_ConvertCitiesValue = rval.m_ConvertCitiesValue;
    }

    // resize m_GovernmentType if necessary
    if (rval.m_numGovernmentType > m_numGovernmentType)
    {
        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
        m_numGovernmentType = rval.m_numGovernmentType;
    }
    if (rval.m_numGovernmentType > 0)
        std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);

    // only replace values that have been set
    if (rval.m_flags3 & k_Unitpromotion_PlantNuke_Bit)
    {
        m_PlantNukeValue = rval.m_PlantNukeValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_CanSoothsay_Bit)
    {
        m_CanSoothsayValue = rval.m_CanSoothsayValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_CreateParks_Bit)
    {
        m_CreateParksValue = rval.m_CreateParksValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_CanInjoin_Bit)
    {
        m_CanInjoinValue = rval.m_CanInjoinValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_PopCostsToBuild_Bit)
    {
        m_PopCostsToBuildValue = rval.m_PopCostsToBuildValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_CanReform_Bit)
    {
        m_CanReformValue = rval.m_CanReformValue;
    }

    // only replace values that have been set
    if (rval.m_VisionClass)
    {
        m_VisionClass = rval.m_VisionClass;
    }

    // only replace values that have been set
    if (rval.m_CanSee)
    {
        m_CanSee = rval.m_CanSee;
    }

    // only replace values that have been set
    if (rval.m_CanAttack)
    {
        m_CanAttack = rval.m_CanAttack;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_CargoData_Bit)
    {
        m_CargoDataValue = rval.m_CargoDataValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_BRange_Bit)
    {
        m_BRangeValue = rval.m_BRangeValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unitpromotion_BRadius_Bit)
    {
        m_BRadiusValue = rval.m_BRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_ElectronicCombatFactor_Bit)
    {
        m_ElectronicCombatFactorValue = rval.m_ElectronicCombatFactorValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_TransType_Bit)
    {
        m_TransTypeValue = rval.m_TransTypeValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_ProbOfBombHit_Bit)
    {
        m_ProbOfBombHitValue = rval.m_ProbOfBombHitValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_BombRounds_Bit)
    {
        m_BombRoundsValue = rval.m_BombRoundsValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_LaunchPollution_Bit)
    {
        m_LaunchPollutionValue = rval.m_LaunchPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_DeathPollution_Bit)
    {
        m_DeathPollutionValue = rval.m_DeathPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_MountedBonus_Bit)
    {
        m_MountedBonusValue = rval.m_MountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_AirBonus_Bit)
    {
        m_AirBonusValue = rval.m_AirBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_WoodenShipBonus_Bit)
    {
        m_WoodenShipBonusValue = rval.m_WoodenShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_AttackCityBonus_Bit)
    {
        m_AttackCityBonusValue = rval.m_AttackCityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_AttackBonusSubmarine_Bit)
    {
        m_AttackBonusSubmarineValue = rval.m_AttackBonusSubmarineValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_FootBonus_Bit)
    {
        m_FootBonusValue = rval.m_FootBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_SiegeBonus_Bit)
    {
        m_SiegeBonusValue = rval.m_SiegeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_WheeledBonus_Bit)
    {
        m_WheeledBonusValue = rval.m_WheeledBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_MechanizedBonus_Bit)
    {
        m_MechanizedBonusValue = rval.m_MechanizedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_HelicopterBonus_Bit)
    {
        m_HelicopterBonusValue = rval.m_HelicopterBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_SpecialForcesBonus_Bit)
    {
        m_SpecialForcesBonusValue = rval.m_SpecialForcesBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_CivilianBonus_Bit)
    {
        m_CivilianBonusValue = rval.m_CivilianBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_GuerrillaBonus_Bit)
    {
        m_GuerrillaBonusValue = rval.m_GuerrillaBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_AgainstMountedBonus_Bit)
    {
        m_AgainstMountedBonusValue = rval.m_AgainstMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_AirDefenseBonus_Bit)
    {
        m_AirDefenseBonusValue = rval.m_AirDefenseBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_CargoModule_Bit)
    {
        m_CargoModuleValue = rval.m_CargoModuleValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_SpyVsSpy_Bit)
    {
        m_SpyVsSpyValue = rval.m_SpyVsSpyValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_InvestigateCity_Bit)
    {
        m_InvestigateCityValue = rval.m_InvestigateCityValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_BonusFood_Bit)
    {
        m_BonusFoodValue = rval.m_BonusFoodValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_BombardRange_Bit)
    {
        m_BombardRangeValue = rval.m_BombardRangeValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_Revolution_Bit)
    {
        m_RevolutionValue = rval.m_RevolutionValue;
    }

    if (rval.m_numSpecialAttacks > 0)
        std::copy(rval.m_SpecialAttacks, rval.m_SpecialAttacks + rval.m_numSpecialAttacks, m_SpecialAttacks);

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_CityGrowthCoefficient_Bit)
    {
        m_CityGrowthCoefficientValue = rval.m_CityGrowthCoefficientValue;
    }

    // only replace values that have been set
    if (rval.m_UserFlags)
    {
        m_UserFlags = rval.m_UserFlags;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_CheatIndex_Bit)
    {
        m_CheatIndexValue = rval.m_CheatIndexValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unitpromotion_Advice_Bit)
    {
        m_AdviceValue = rval.m_AdviceValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyMountedBonus_Bit)
    {
        m_ArmyMountedBonusValue = rval.m_ArmyMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyAirBonus_Bit)
    {
        m_ArmyAirBonusValue = rval.m_ArmyAirBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyWoodenShipBonus_Bit)
    {
        m_ArmyWoodenShipBonusValue = rval.m_ArmyWoodenShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyAttackCityBonus_Bit)
    {
        m_ArmyAttackCityBonusValue = rval.m_ArmyAttackCityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyAttackBonusSubmarine_Bit)
    {
        m_ArmyAttackBonusSubmarineValue = rval.m_ArmyAttackBonusSubmarineValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyFootBonus_Bit)
    {
        m_ArmyFootBonusValue = rval.m_ArmyFootBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmySiegeBonus_Bit)
    {
        m_ArmySiegeBonusValue = rval.m_ArmySiegeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyWheeledBonus_Bit)
    {
        m_ArmyWheeledBonusValue = rval.m_ArmyWheeledBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyMechanizedBonus_Bit)
    {
        m_ArmyMechanizedBonusValue = rval.m_ArmyMechanizedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyHelicopterBonus_Bit)
    {
        m_ArmyHelicopterBonusValue = rval.m_ArmyHelicopterBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmySpecialForcesBonus_Bit)
    {
        m_ArmySpecialForcesBonusValue = rval.m_ArmySpecialForcesBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyCivilianBonus_Bit)
    {
        m_ArmyCivilianBonusValue = rval.m_ArmyCivilianBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyGuerrillaBonus_Bit)
    {
        m_ArmyGuerrillaBonusValue = rval.m_ArmyGuerrillaBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyAgainstMountedBonus_Bit)
    {
        m_ArmyAgainstMountedBonusValue = rval.m_ArmyAgainstMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unitpromotion_ArmyAirDefenseBonus_Bit)
    {
        m_ArmyAirDefenseBonusValue = rval.m_ArmyAirDefenseBonusValue;
    }

}

UnitRecord const * UnitpromotionRecord::GetAvailableUnit() const
{
    return g_theUnitDB->Get(m_AvailableUnit);
}

AdvanceRecord const * UnitpromotionRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 UnitpromotionRecord::GetObsoleteAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return m_ObsoleteAdvance[index];
}

AdvanceRecord const * UnitpromotionRecord::GetObsoleteAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ObsoleteAdvance[index]);
}

sint32 UnitpromotionRecord::GetPrerequisiteBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return m_PrerequisiteBuilding[index];
}

BuildingRecord const * UnitpromotionRecord::GetPrerequisiteBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_PrerequisiteBuilding[index]);
}

sint32 UnitpromotionRecord::GetExcludedByBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return m_ExcludedByBuilding[index];
}

BuildingRecord const * UnitpromotionRecord::GetExcludedByBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_ExcludedByBuilding[index]);
}

sint32 UnitpromotionRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * UnitpromotionRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

sint32 UnitpromotionRecord::GetUpgradeToPromotionIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numUpgradeToPromotion);
    if((index < 0) || (index >= m_numUpgradeToPromotion)) {
        return 0;
    }
    return m_UpgradeToPromotion[index];
}

UnitRecord const * UnitpromotionRecord::GetUpgradeToPromotion(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numUpgradeToPromotion);
    if((index < 0) || (index >= m_numUpgradeToPromotion)) {
        return 0;
    }
    return g_theUnitDB->Get(m_UpgradeToPromotion[index]);
}

sint32 UnitpromotionRecord::GetObsoletePromotionIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoletePromotion);
    if((index < 0) || (index >= m_numObsoletePromotion)) {
        return 0;
    }
    return m_ObsoletePromotion[index];
}

UnitRecord const * UnitpromotionRecord::GetObsoletePromotion(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoletePromotion);
    if((index < 0) || (index >= m_numObsoletePromotion)) {
        return 0;
    }
    return g_theUnitDB->Get(m_ObsoletePromotion[index]);
}

sint32 UnitpromotionRecord::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

CityStyleRecord const * UnitpromotionRecord::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

sint32 UnitpromotionRecord::GetCityStyleOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return m_CityStyleOnly[index];
}

CityStyleRecord const * UnitpromotionRecord::GetCityStyleOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CityStyleOnly[index]);
}

sint32 UnitpromotionRecord::GetCivilisationOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return m_CivilisationOnly[index];
}

CivilisationRecord const * UnitpromotionRecord::GetCivilisationOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return g_theCivilisationDB->Get(m_CivilisationOnly[index]);
}

sint32 UnitpromotionRecord::GetGovernmentOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentOnly);
    if((index < 0) || (index >= m_numGovernmentOnly)) {
        return 0;
    }
    return m_GovernmentOnly[index];
}

GovernmentRecord const * UnitpromotionRecord::GetGovernmentOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentOnly);
    if((index < 0) || (index >= m_numGovernmentOnly)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentOnly[index]);
}

sint32 UnitpromotionRecord::GetNeedsCityGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return m_NeedsCityGood[index];
}

ResourceRecord const * UnitpromotionRecord::GetNeedsCityGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGood[index]);
}

sint32 UnitpromotionRecord::GetNeedsCityGoodAllIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return m_NeedsCityGoodAll[index];
}

ResourceRecord const * UnitpromotionRecord::GetNeedsCityGoodAll(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAll[index]);
}

sint32 UnitpromotionRecord::GetNeedsCityGoodAnyCityIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return m_NeedsCityGoodAnyCity[index];
}

ResourceRecord const * UnitpromotionRecord::GetNeedsCityGoodAnyCity(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAnyCity[index]);
}

sint32 UnitpromotionRecord::GetNeedsFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return m_NeedsFeatToBuild[index];
}

FeatRecord const * UnitpromotionRecord::GetNeedsFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsFeatToBuild[index]);
}

sint32 UnitpromotionRecord::GetNeedsAnyPlayerFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return m_NeedsAnyPlayerFeatToBuild[index];
}

FeatRecord const * UnitpromotionRecord::GetNeedsAnyPlayerFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsAnyPlayerFeatToBuild[index]);
}

sint32 UnitpromotionRecord::GetPrerequisiteWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteWonder);
    if((index < 0) || (index >= m_numPrerequisiteWonder)) {
        return 0;
    }
    return m_PrerequisiteWonder[index];
}

WonderRecord const * UnitpromotionRecord::GetPrerequisiteWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteWonder);
    if((index < 0) || (index >= m_numPrerequisiteWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_PrerequisiteWonder[index]);
}

sint32 UnitpromotionRecord::GetExcludedByWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return m_ExcludedByWonder[index];
}

WonderRecord const * UnitpromotionRecord::GetExcludedByWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_ExcludedByWonder[index]);
}

sint32 UnitpromotionRecord::GetAllTerrainAsImprovementIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAllTerrainAsImprovement);
    if((index < 0) || (index >= m_numAllTerrainAsImprovement)) {
        return 0;
    }
    return m_AllTerrainAsImprovement[index];
}

TerrainImprovementRecord const * UnitpromotionRecord::GetAllTerrainAsImprovement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAllTerrainAsImprovement);
    if((index < 0) || (index >= m_numAllTerrainAsImprovement)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_AllTerrainAsImprovement[index]);
}

sint32 UnitpromotionRecord::GetObsoleteByUnitIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteByUnit);
    if((index < 0) || (index >= m_numObsoleteByUnit)) {
        return 0;
    }
    return m_ObsoleteByUnit[index];
}

UnitRecord const * UnitpromotionRecord::GetObsoleteByUnit(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteByUnit);
    if((index < 0) || (index >= m_numObsoleteByUnit)) {
        return 0;
    }
    return g_theUnitDB->Get(m_ObsoleteByUnit[index]);
}

UnitRecord const * UnitpromotionRecord::GetSettleCityType() const
{
    return g_theUnitDB->Get(m_SettleCityType);
}

sint32 UnitpromotionRecord::GetSettleBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleBuilding);
    if((index < 0) || (index >= m_numSettleBuilding)) {
        return 0;
    }
    return m_SettleBuilding[index];
}

BuildingRecord const * UnitpromotionRecord::GetSettleBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleBuilding);
    if((index < 0) || (index >= m_numSettleBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_SettleBuilding[index]);
}

sint32 UnitpromotionRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

GovernmentRecord const * UnitpromotionRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

SpriteRecord const * UnitpromotionRecord::GetDefaultSprite() const
{
    return g_theSpriteDB->Get(m_DefaultSprite);
}

SoundRecord const * UnitpromotionRecord::GetSoundSelect1() const
{
    return g_theSoundDB->Get(m_SoundSelect1);
}

SoundRecord const * UnitpromotionRecord::GetSoundSelect2() const
{
    return g_theSoundDB->Get(m_SoundSelect2);
}

SoundRecord const * UnitpromotionRecord::GetSoundMove() const
{
    return g_theSoundDB->Get(m_SoundMove);
}

SoundRecord const * UnitpromotionRecord::GetSoundAcknowledge() const
{
    return g_theSoundDB->Get(m_SoundAcknowledge);
}

SoundRecord const * UnitpromotionRecord::GetSoundCantMove() const
{
    return g_theSoundDB->Get(m_SoundCantMove);
}

SoundRecord const * UnitpromotionRecord::GetSoundAttack() const
{
    return g_theSoundDB->Get(m_SoundAttack);
}

SoundRecord const * UnitpromotionRecord::GetSoundWork() const
{
    return g_theSoundDB->Get(m_SoundWork);
}

SoundRecord const * UnitpromotionRecord::GetSoundVictory() const
{
    return g_theSoundDB->Get(m_SoundVictory);
}

SoundRecord const * UnitpromotionRecord::GetSoundDeath() const
{
    return g_theSoundDB->Get(m_SoundDeath);
}

SoundRecord const * UnitpromotionRecord::GetSoundLoad() const
{
    return g_theSoundDB->Get(m_SoundLoad);
}

SoundRecord const * UnitpromotionRecord::GetSoundUnload() const
{
    return g_theSoundDB->Get(m_SoundUnload);
}

sint32 UnitpromotionRecord::GetSpecialAttacksIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSpecialAttacks);
    if((index < 0) || (index >= m_numSpecialAttacks)) {
        return 0;
    }
    return m_SpecialAttacks[index];
}

SpecialAttackInfoRecord const * UnitpromotionRecord::GetSpecialAttacks(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSpecialAttacks);
    if((index < 0) || (index >= m_numSpecialAttacks)) {
        return 0;
    }
    return g_theSpecialAttackInfoDB->Get(m_SpecialAttacks[index]);
}

IconRecord const * UnitpromotionRecord::GetDefaultIcon() const
{
    return g_theIconDB->Get(m_DefaultIcon);
}

const SoundRecord *UnitpromotionRecord::SuccessDeathEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::SuccessDeathEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::StealTechnologyData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::StealTechnologyData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::InciteRevolutionData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::InciteRevolutionData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::ChanceEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::ChanceEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::CauseUnhappinessData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::CauseUnhappinessData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::SlaveRaidsData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::SlaveRaidsData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::SoundAndEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::SoundAndEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::PlantNukeData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::PlantNukeData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitpromotionRecord::CargoData::GetLoad() const
{
    return g_theSoundDB->Get(m_Load);
}

const SoundRecord *UnitpromotionRecord::CargoData::GetUnload() const
{
    return g_theSoundDB->Get(m_Unload);
}

const SoundRecord *UnitpromotionRecord::RevolutionData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitpromotionRecord::RevolutionData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

