
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "DifficultyRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "TerrainImprovementRecord.h"
#include "AdvanceRecord.h"

CTPDatabase<DifficultyRecord> *g_theDifficultyDB = NULL;

void DifficultyRecord::Init()
{
    m_flags0 = 0;
    m_BaseContentment = 0;
    m_GranaryCoeff = 0;
    m_BigCityScale = 0.000000;
    m_BigCityOffset = 0.000000;
    m_ScienceHandicap = 0;
    m_PollutionMultiplier = 0.000000;
    m_RiotChance = 0.000000;
    m_StarvationEffect = 0.000000;
    m_StartingGold = 0;
    m_VisionBonus = 0;
    m_BaseScore = 0;
    memset((uint8*)&m_TimeScale, 0, sizeof(m_TimeScale));
    m_FeatsFactor = 0.000000;
    m_AdvancesFactor = 0.000000;
    m_WondersFactor = 0.000000;
    m_Cities0To3Factor = 0.000000;
    m_Cities3To10Factor = 0.000000;
    m_Cities10To50Factor = 0.000000;
    m_Cities50PlusFactor = 0.000000;
    m_CitiesRecapturedFactor = 0.000000;
    m_PopulationFactor = 0.000000;
    m_RankFactor = 0.000000;
    m_OpponentsConqueredFactor = 0.000000;
    m_AlliesFactor = 0.000000;
    m_WonderVictoryBonus = 0.000000;
    m_SoloVictoryBonus = 0.000000;
    m_AlliedVictoryBonus = 0.000000;
    m_AIStartUnits = 0;
    m_AIStartGold = 0;
    m_AIStartAdvances = 0;
    m_AIStartPublicWorks = 0;
    m_HumanStartLocation = 0;
    m_AIIntelligenceFactor = 0;
    m_AIGangUpFactor = 0;
    m_DistanceFromCapitolAdjustment = 0;
    m_AIDistanceFromCapitolAdjustment = 0;
    m_PollutionAdjust = 0;
    m_AIMinBehind = 0.000000;
    m_AIMaxBehind = 0.000000;
    m_AIMinAhead = 0.000000;
    m_AIMaxAhead = 0.000000;
    m_AIMinBehindTechnologyCost = NULL;
    m_numAIMinBehindTechnologyCost = 0;
    m_AIMaxBehindTechnologyCost = NULL;
    m_numAIMaxBehindTechnologyCost = 0;
    m_AIMinBehindProductionCostAdjustment = NULL;
    m_numAIMinBehindProductionCostAdjustment = 0;
    m_AIMaxBehindProductionCostAdjustment = NULL;
    m_numAIMaxBehindProductionCostAdjustment = 0;
    m_AIMinBehindGoldCostAdjustment = NULL;
    m_numAIMinBehindGoldCostAdjustment = 0;
    m_AIMaxBehindGoldCostAdjustment = NULL;
    m_numAIMaxBehindGoldCostAdjustment = 0;
    m_AIMinAheadTechnologyCost = NULL;
    m_numAIMinAheadTechnologyCost = 0;
    m_AIMaxAheadTechnologyCost = NULL;
    m_numAIMaxAheadTechnologyCost = 0;
    m_AIMinAheadProductionCostAdjustment = NULL;
    m_numAIMinAheadProductionCostAdjustment = 0;
    m_AIMaxAheadProductionCostAdjustment = NULL;
    m_numAIMaxAheadProductionCostAdjustment = 0;
    m_AIMinAheadGoldCostAdjustment = NULL;
    m_numAIMinAheadGoldCostAdjustment = 0;
    m_AIMaxAheadGoldCostAdjustment = NULL;
    m_numAIMaxAheadGoldCostAdjustment = 0;
    m_MaxHumanAdvances = 0;
    m_MaxAIAdvances = 0;
    m_HumanScienceBonus = 0.000000;
    m_HumanFoodBonus = 0.000000;
    m_ExtraSettlerChance = 0;
    memset((uint8*)&m_AdvanceChances, 0, sizeof(m_AdvanceChances));
    m_PollutionStartProductionLevel = 0;
    m_PollutionStartPopulationLevel = 0;
    m_PollutionProductionRatio = 0.000000;
    m_PollutionPopulationRatio = 0.000000;
    m_BarbarianCamps = NULL;
    m_numBarbarianCamps = 0;
    m_GoldPerUnitSupportValue = 0;
    m_GoldPerCityValue = 0;
    m_TechCostKnownDeductionValue = 0.000000;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void DifficultyRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_BaseContentment;
        archive << m_GranaryCoeff;
        archive << m_BigCityScale;
        archive << m_BigCityOffset;
        archive << m_ScienceHandicap;
        archive << m_PollutionMultiplier;
        archive << m_RiotChance;
        archive << m_StarvationEffect;
        archive << m_StartingGold;
        archive << m_VisionBonus;
        archive << m_BaseScore;
        m_TimeScale.Serialize(archive);
        archive << m_FeatsFactor;
        archive << m_AdvancesFactor;
        archive << m_WondersFactor;
        archive << m_Cities0To3Factor;
        archive << m_Cities3To10Factor;
        archive << m_Cities10To50Factor;
        archive << m_Cities50PlusFactor;
        archive << m_CitiesRecapturedFactor;
        archive << m_PopulationFactor;
        archive << m_RankFactor;
        archive << m_OpponentsConqueredFactor;
        archive << m_AlliesFactor;
        archive << m_WonderVictoryBonus;
        archive << m_SoloVictoryBonus;
        archive << m_AlliedVictoryBonus;
        archive << m_AIStartUnits;
        archive << m_AIStartGold;
        archive << m_AIStartAdvances;
        archive << m_AIStartPublicWorks;
        archive << m_HumanStartLocation;
        archive << m_AIIntelligenceFactor;
        archive << m_AIGangUpFactor;
        archive << m_DistanceFromCapitolAdjustment;
        archive << m_AIDistanceFromCapitolAdjustment;
        archive << m_PollutionAdjust;
        archive << m_AIMinBehind;
        archive << m_AIMaxBehind;
        archive << m_AIMinAhead;
        archive << m_AIMaxAhead;
        archive << m_numAIMinBehindTechnologyCost;
        archive.Store((uint8*)m_AIMinBehindTechnologyCost, m_numAIMinBehindTechnologyCost * sizeof(double));

        archive << m_numAIMaxBehindTechnologyCost;
        archive.Store((uint8*)m_AIMaxBehindTechnologyCost, m_numAIMaxBehindTechnologyCost * sizeof(double));

        archive << m_numAIMinBehindProductionCostAdjustment;
        archive.Store((uint8*)m_AIMinBehindProductionCostAdjustment, m_numAIMinBehindProductionCostAdjustment * sizeof(double));

        archive << m_numAIMaxBehindProductionCostAdjustment;
        archive.Store((uint8*)m_AIMaxBehindProductionCostAdjustment, m_numAIMaxBehindProductionCostAdjustment * sizeof(double));

        archive << m_numAIMinBehindGoldCostAdjustment;
        archive.Store((uint8*)m_AIMinBehindGoldCostAdjustment, m_numAIMinBehindGoldCostAdjustment * sizeof(double));

        archive << m_numAIMaxBehindGoldCostAdjustment;
        archive.Store((uint8*)m_AIMaxBehindGoldCostAdjustment, m_numAIMaxBehindGoldCostAdjustment * sizeof(double));

        archive << m_numAIMinAheadTechnologyCost;
        archive.Store((uint8*)m_AIMinAheadTechnologyCost, m_numAIMinAheadTechnologyCost * sizeof(double));

        archive << m_numAIMaxAheadTechnologyCost;
        archive.Store((uint8*)m_AIMaxAheadTechnologyCost, m_numAIMaxAheadTechnologyCost * sizeof(double));

        archive << m_numAIMinAheadProductionCostAdjustment;
        archive.Store((uint8*)m_AIMinAheadProductionCostAdjustment, m_numAIMinAheadProductionCostAdjustment * sizeof(double));

        archive << m_numAIMaxAheadProductionCostAdjustment;
        archive.Store((uint8*)m_AIMaxAheadProductionCostAdjustment, m_numAIMaxAheadProductionCostAdjustment * sizeof(double));

        archive << m_numAIMinAheadGoldCostAdjustment;
        archive.Store((uint8*)m_AIMinAheadGoldCostAdjustment, m_numAIMinAheadGoldCostAdjustment * sizeof(double));

        archive << m_numAIMaxAheadGoldCostAdjustment;
        archive.Store((uint8*)m_AIMaxAheadGoldCostAdjustment, m_numAIMaxAheadGoldCostAdjustment * sizeof(double));

        archive << m_MaxHumanAdvances;
        archive << m_MaxAIAdvances;
        archive << m_HumanScienceBonus;
        archive << m_HumanFoodBonus;
        archive << m_ExtraSettlerChance;
        m_AdvanceChances.Serialize(archive);
        archive << m_PollutionStartProductionLevel;
        archive << m_PollutionStartPopulationLevel;
        archive << m_PollutionProductionRatio;
        archive << m_PollutionPopulationRatio;
        archive << m_numBarbarianCamps;
        archive.Store((uint8*)m_BarbarianCamps, m_numBarbarianCamps * sizeof(sint32));

        archive << m_GoldPerUnitSupportValue;
        archive << m_GoldPerCityValue;
        archive << m_TechCostKnownDeductionValue;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_BaseContentment;
        archive >> m_GranaryCoeff;
        archive >> m_BigCityScale;
        archive >> m_BigCityOffset;
        archive >> m_ScienceHandicap;
        archive >> m_PollutionMultiplier;
        archive >> m_RiotChance;
        archive >> m_StarvationEffect;
        archive >> m_StartingGold;
        archive >> m_VisionBonus;
        archive >> m_BaseScore;
        memset((uint8*)&m_TimeScale, 0, sizeof(m_TimeScale));
        m_TimeScale.Serialize(archive);
        archive >> m_FeatsFactor;
        archive >> m_AdvancesFactor;
        archive >> m_WondersFactor;
        archive >> m_Cities0To3Factor;
        archive >> m_Cities3To10Factor;
        archive >> m_Cities10To50Factor;
        archive >> m_Cities50PlusFactor;
        archive >> m_CitiesRecapturedFactor;
        archive >> m_PopulationFactor;
        archive >> m_RankFactor;
        archive >> m_OpponentsConqueredFactor;
        archive >> m_AlliesFactor;
        archive >> m_WonderVictoryBonus;
        archive >> m_SoloVictoryBonus;
        archive >> m_AlliedVictoryBonus;
        archive >> m_AIStartUnits;
        archive >> m_AIStartGold;
        archive >> m_AIStartAdvances;
        archive >> m_AIStartPublicWorks;
        archive >> m_HumanStartLocation;
        archive >> m_AIIntelligenceFactor;
        archive >> m_AIGangUpFactor;
        archive >> m_DistanceFromCapitolAdjustment;
        archive >> m_AIDistanceFromCapitolAdjustment;
        archive >> m_PollutionAdjust;
        archive >> m_AIMinBehind;
        archive >> m_AIMaxBehind;
        archive >> m_AIMinAhead;
        archive >> m_AIMaxAhead;
        archive >> m_numAIMinBehindTechnologyCost;
        archive.Load((uint8*)m_AIMinBehindTechnologyCost, m_numAIMinBehindTechnologyCost * sizeof(double));

        archive >> m_numAIMaxBehindTechnologyCost;
        archive.Load((uint8*)m_AIMaxBehindTechnologyCost, m_numAIMaxBehindTechnologyCost * sizeof(double));

        archive >> m_numAIMinBehindProductionCostAdjustment;
        archive.Load((uint8*)m_AIMinBehindProductionCostAdjustment, m_numAIMinBehindProductionCostAdjustment * sizeof(double));

        archive >> m_numAIMaxBehindProductionCostAdjustment;
        archive.Load((uint8*)m_AIMaxBehindProductionCostAdjustment, m_numAIMaxBehindProductionCostAdjustment * sizeof(double));

        archive >> m_numAIMinBehindGoldCostAdjustment;
        archive.Load((uint8*)m_AIMinBehindGoldCostAdjustment, m_numAIMinBehindGoldCostAdjustment * sizeof(double));

        archive >> m_numAIMaxBehindGoldCostAdjustment;
        archive.Load((uint8*)m_AIMaxBehindGoldCostAdjustment, m_numAIMaxBehindGoldCostAdjustment * sizeof(double));

        archive >> m_numAIMinAheadTechnologyCost;
        archive.Load((uint8*)m_AIMinAheadTechnologyCost, m_numAIMinAheadTechnologyCost * sizeof(double));

        archive >> m_numAIMaxAheadTechnologyCost;
        archive.Load((uint8*)m_AIMaxAheadTechnologyCost, m_numAIMaxAheadTechnologyCost * sizeof(double));

        archive >> m_numAIMinAheadProductionCostAdjustment;
        archive.Load((uint8*)m_AIMinAheadProductionCostAdjustment, m_numAIMinAheadProductionCostAdjustment * sizeof(double));

        archive >> m_numAIMaxAheadProductionCostAdjustment;
        archive.Load((uint8*)m_AIMaxAheadProductionCostAdjustment, m_numAIMaxAheadProductionCostAdjustment * sizeof(double));

        archive >> m_numAIMinAheadGoldCostAdjustment;
        archive.Load((uint8*)m_AIMinAheadGoldCostAdjustment, m_numAIMinAheadGoldCostAdjustment * sizeof(double));

        archive >> m_numAIMaxAheadGoldCostAdjustment;
        archive.Load((uint8*)m_AIMaxAheadGoldCostAdjustment, m_numAIMaxAheadGoldCostAdjustment * sizeof(double));

        archive >> m_MaxHumanAdvances;
        archive >> m_MaxAIAdvances;
        archive >> m_HumanScienceBonus;
        archive >> m_HumanFoodBonus;
        archive >> m_ExtraSettlerChance;
        memset((uint8*)&m_AdvanceChances, 0, sizeof(m_AdvanceChances));
        m_AdvanceChances.Serialize(archive);
        archive >> m_PollutionStartProductionLevel;
        archive >> m_PollutionStartPopulationLevel;
        archive >> m_PollutionProductionRatio;
        archive >> m_PollutionPopulationRatio;
        archive >> m_numBarbarianCamps;
        archive.Load((uint8*)m_BarbarianCamps, m_numBarbarianCamps * sizeof(sint32));

        archive >> m_GoldPerUnitSupportValue;
        archive >> m_GoldPerCityValue;
        archive >> m_TechCostKnownDeductionValue;
    }
}

DifficultyRecord::~DifficultyRecord()
{
    delete [] m_AIMinBehindTechnologyCost;
    delete [] m_AIMaxBehindTechnologyCost;
    delete [] m_AIMinBehindProductionCostAdjustment;
    delete [] m_AIMaxBehindProductionCostAdjustment;
    delete [] m_AIMinBehindGoldCostAdjustment;
    delete [] m_AIMaxBehindGoldCostAdjustment;
    delete [] m_AIMinAheadTechnologyCost;
    delete [] m_AIMaxAheadTechnologyCost;
    delete [] m_AIMinAheadProductionCostAdjustment;
    delete [] m_AIMaxAheadProductionCostAdjustment;
    delete [] m_AIMinAheadGoldCostAdjustment;
    delete [] m_AIMaxAheadGoldCostAdjustment;
    delete [] m_BarbarianCamps;
}

DifficultyRecord const & DifficultyRecord::operator = (DifficultyRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_BaseContentment = rval.m_BaseContentment;

        m_GranaryCoeff = rval.m_GranaryCoeff;

        m_BigCityScale = rval.m_BigCityScale;

        m_BigCityOffset = rval.m_BigCityOffset;

        m_ScienceHandicap = rval.m_ScienceHandicap;

        m_PollutionMultiplier = rval.m_PollutionMultiplier;

        m_RiotChance = rval.m_RiotChance;

        m_StarvationEffect = rval.m_StarvationEffect;

        m_StartingGold = rval.m_StartingGold;

        m_VisionBonus = rval.m_VisionBonus;

        m_BaseScore = rval.m_BaseScore;

        m_TimeScale = rval.m_TimeScale;

        m_FeatsFactor = rval.m_FeatsFactor;

        m_AdvancesFactor = rval.m_AdvancesFactor;

        m_WondersFactor = rval.m_WondersFactor;

        m_Cities0To3Factor = rval.m_Cities0To3Factor;

        m_Cities3To10Factor = rval.m_Cities3To10Factor;

        m_Cities10To50Factor = rval.m_Cities10To50Factor;

        m_Cities50PlusFactor = rval.m_Cities50PlusFactor;

        m_CitiesRecapturedFactor = rval.m_CitiesRecapturedFactor;

        m_PopulationFactor = rval.m_PopulationFactor;

        m_RankFactor = rval.m_RankFactor;

        m_OpponentsConqueredFactor = rval.m_OpponentsConqueredFactor;

        m_AlliesFactor = rval.m_AlliesFactor;

        m_WonderVictoryBonus = rval.m_WonderVictoryBonus;

        m_SoloVictoryBonus = rval.m_SoloVictoryBonus;

        m_AlliedVictoryBonus = rval.m_AlliedVictoryBonus;

        m_AIStartUnits = rval.m_AIStartUnits;

        m_AIStartGold = rval.m_AIStartGold;

        m_AIStartAdvances = rval.m_AIStartAdvances;

        m_AIStartPublicWorks = rval.m_AIStartPublicWorks;

        m_HumanStartLocation = rval.m_HumanStartLocation;

        m_AIIntelligenceFactor = rval.m_AIIntelligenceFactor;

        m_AIGangUpFactor = rval.m_AIGangUpFactor;

        m_DistanceFromCapitolAdjustment = rval.m_DistanceFromCapitolAdjustment;

        m_AIDistanceFromCapitolAdjustment = rval.m_AIDistanceFromCapitolAdjustment;

        m_PollutionAdjust = rval.m_PollutionAdjust;

        m_AIMinBehind = rval.m_AIMinBehind;

        m_AIMaxBehind = rval.m_AIMaxBehind;

        m_AIMinAhead = rval.m_AIMinAhead;

        m_AIMaxAhead = rval.m_AIMaxAhead;

        delete [] m_AIMinBehindTechnologyCost;
        m_AIMinBehindTechnologyCost = NULL;
        if (rval.m_numAIMinBehindTechnologyCost > 0)
        {
            m_AIMinBehindTechnologyCost = new double [rval.m_numAIMinBehindTechnologyCost];
            std::copy(rval.m_AIMinBehindTechnologyCost, rval.m_AIMinBehindTechnologyCost + rval.m_numAIMinBehindTechnologyCost, m_AIMinBehindTechnologyCost);
        }
        m_numAIMinBehindTechnologyCost = rval.m_numAIMinBehindTechnologyCost;

        delete [] m_AIMaxBehindTechnologyCost;
        m_AIMaxBehindTechnologyCost = NULL;
        if (rval.m_numAIMaxBehindTechnologyCost > 0)
        {
            m_AIMaxBehindTechnologyCost = new double [rval.m_numAIMaxBehindTechnologyCost];
            std::copy(rval.m_AIMaxBehindTechnologyCost, rval.m_AIMaxBehindTechnologyCost + rval.m_numAIMaxBehindTechnologyCost, m_AIMaxBehindTechnologyCost);
        }
        m_numAIMaxBehindTechnologyCost = rval.m_numAIMaxBehindTechnologyCost;

        delete [] m_AIMinBehindProductionCostAdjustment;
        m_AIMinBehindProductionCostAdjustment = NULL;
        if (rval.m_numAIMinBehindProductionCostAdjustment > 0)
        {
            m_AIMinBehindProductionCostAdjustment = new double [rval.m_numAIMinBehindProductionCostAdjustment];
            std::copy(rval.m_AIMinBehindProductionCostAdjustment, rval.m_AIMinBehindProductionCostAdjustment + rval.m_numAIMinBehindProductionCostAdjustment, m_AIMinBehindProductionCostAdjustment);
        }
        m_numAIMinBehindProductionCostAdjustment = rval.m_numAIMinBehindProductionCostAdjustment;

        delete [] m_AIMaxBehindProductionCostAdjustment;
        m_AIMaxBehindProductionCostAdjustment = NULL;
        if (rval.m_numAIMaxBehindProductionCostAdjustment > 0)
        {
            m_AIMaxBehindProductionCostAdjustment = new double [rval.m_numAIMaxBehindProductionCostAdjustment];
            std::copy(rval.m_AIMaxBehindProductionCostAdjustment, rval.m_AIMaxBehindProductionCostAdjustment + rval.m_numAIMaxBehindProductionCostAdjustment, m_AIMaxBehindProductionCostAdjustment);
        }
        m_numAIMaxBehindProductionCostAdjustment = rval.m_numAIMaxBehindProductionCostAdjustment;

        delete [] m_AIMinBehindGoldCostAdjustment;
        m_AIMinBehindGoldCostAdjustment = NULL;
        if (rval.m_numAIMinBehindGoldCostAdjustment > 0)
        {
            m_AIMinBehindGoldCostAdjustment = new double [rval.m_numAIMinBehindGoldCostAdjustment];
            std::copy(rval.m_AIMinBehindGoldCostAdjustment, rval.m_AIMinBehindGoldCostAdjustment + rval.m_numAIMinBehindGoldCostAdjustment, m_AIMinBehindGoldCostAdjustment);
        }
        m_numAIMinBehindGoldCostAdjustment = rval.m_numAIMinBehindGoldCostAdjustment;

        delete [] m_AIMaxBehindGoldCostAdjustment;
        m_AIMaxBehindGoldCostAdjustment = NULL;
        if (rval.m_numAIMaxBehindGoldCostAdjustment > 0)
        {
            m_AIMaxBehindGoldCostAdjustment = new double [rval.m_numAIMaxBehindGoldCostAdjustment];
            std::copy(rval.m_AIMaxBehindGoldCostAdjustment, rval.m_AIMaxBehindGoldCostAdjustment + rval.m_numAIMaxBehindGoldCostAdjustment, m_AIMaxBehindGoldCostAdjustment);
        }
        m_numAIMaxBehindGoldCostAdjustment = rval.m_numAIMaxBehindGoldCostAdjustment;

        delete [] m_AIMinAheadTechnologyCost;
        m_AIMinAheadTechnologyCost = NULL;
        if (rval.m_numAIMinAheadTechnologyCost > 0)
        {
            m_AIMinAheadTechnologyCost = new double [rval.m_numAIMinAheadTechnologyCost];
            std::copy(rval.m_AIMinAheadTechnologyCost, rval.m_AIMinAheadTechnologyCost + rval.m_numAIMinAheadTechnologyCost, m_AIMinAheadTechnologyCost);
        }
        m_numAIMinAheadTechnologyCost = rval.m_numAIMinAheadTechnologyCost;

        delete [] m_AIMaxAheadTechnologyCost;
        m_AIMaxAheadTechnologyCost = NULL;
        if (rval.m_numAIMaxAheadTechnologyCost > 0)
        {
            m_AIMaxAheadTechnologyCost = new double [rval.m_numAIMaxAheadTechnologyCost];
            std::copy(rval.m_AIMaxAheadTechnologyCost, rval.m_AIMaxAheadTechnologyCost + rval.m_numAIMaxAheadTechnologyCost, m_AIMaxAheadTechnologyCost);
        }
        m_numAIMaxAheadTechnologyCost = rval.m_numAIMaxAheadTechnologyCost;

        delete [] m_AIMinAheadProductionCostAdjustment;
        m_AIMinAheadProductionCostAdjustment = NULL;
        if (rval.m_numAIMinAheadProductionCostAdjustment > 0)
        {
            m_AIMinAheadProductionCostAdjustment = new double [rval.m_numAIMinAheadProductionCostAdjustment];
            std::copy(rval.m_AIMinAheadProductionCostAdjustment, rval.m_AIMinAheadProductionCostAdjustment + rval.m_numAIMinAheadProductionCostAdjustment, m_AIMinAheadProductionCostAdjustment);
        }
        m_numAIMinAheadProductionCostAdjustment = rval.m_numAIMinAheadProductionCostAdjustment;

        delete [] m_AIMaxAheadProductionCostAdjustment;
        m_AIMaxAheadProductionCostAdjustment = NULL;
        if (rval.m_numAIMaxAheadProductionCostAdjustment > 0)
        {
            m_AIMaxAheadProductionCostAdjustment = new double [rval.m_numAIMaxAheadProductionCostAdjustment];
            std::copy(rval.m_AIMaxAheadProductionCostAdjustment, rval.m_AIMaxAheadProductionCostAdjustment + rval.m_numAIMaxAheadProductionCostAdjustment, m_AIMaxAheadProductionCostAdjustment);
        }
        m_numAIMaxAheadProductionCostAdjustment = rval.m_numAIMaxAheadProductionCostAdjustment;

        delete [] m_AIMinAheadGoldCostAdjustment;
        m_AIMinAheadGoldCostAdjustment = NULL;
        if (rval.m_numAIMinAheadGoldCostAdjustment > 0)
        {
            m_AIMinAheadGoldCostAdjustment = new double [rval.m_numAIMinAheadGoldCostAdjustment];
            std::copy(rval.m_AIMinAheadGoldCostAdjustment, rval.m_AIMinAheadGoldCostAdjustment + rval.m_numAIMinAheadGoldCostAdjustment, m_AIMinAheadGoldCostAdjustment);
        }
        m_numAIMinAheadGoldCostAdjustment = rval.m_numAIMinAheadGoldCostAdjustment;

        delete [] m_AIMaxAheadGoldCostAdjustment;
        m_AIMaxAheadGoldCostAdjustment = NULL;
        if (rval.m_numAIMaxAheadGoldCostAdjustment > 0)
        {
            m_AIMaxAheadGoldCostAdjustment = new double [rval.m_numAIMaxAheadGoldCostAdjustment];
            std::copy(rval.m_AIMaxAheadGoldCostAdjustment, rval.m_AIMaxAheadGoldCostAdjustment + rval.m_numAIMaxAheadGoldCostAdjustment, m_AIMaxAheadGoldCostAdjustment);
        }
        m_numAIMaxAheadGoldCostAdjustment = rval.m_numAIMaxAheadGoldCostAdjustment;

        m_MaxHumanAdvances = rval.m_MaxHumanAdvances;

        m_MaxAIAdvances = rval.m_MaxAIAdvances;

        m_HumanScienceBonus = rval.m_HumanScienceBonus;

        m_HumanFoodBonus = rval.m_HumanFoodBonus;

        m_ExtraSettlerChance = rval.m_ExtraSettlerChance;

        m_AdvanceChances = rval.m_AdvanceChances;

        m_PollutionStartProductionLevel = rval.m_PollutionStartProductionLevel;

        m_PollutionStartPopulationLevel = rval.m_PollutionStartPopulationLevel;

        m_PollutionProductionRatio = rval.m_PollutionProductionRatio;

        m_PollutionPopulationRatio = rval.m_PollutionPopulationRatio;

        delete [] m_BarbarianCamps;
        m_BarbarianCamps = NULL;
        if (rval.m_numBarbarianCamps > 0)
        {
            m_BarbarianCamps = new sint32 [rval.m_numBarbarianCamps];
            std::copy(rval.m_BarbarianCamps, rval.m_BarbarianCamps + rval.m_numBarbarianCamps, m_BarbarianCamps);
        }
        m_numBarbarianCamps = rval.m_numBarbarianCamps;

        m_GoldPerUnitSupportValue = rval.m_GoldPerUnitSupportValue;

        m_GoldPerCityValue = rval.m_GoldPerCityValue;

        m_TechCostKnownDeductionValue = rval.m_TechCostKnownDeductionValue;

    }

    return *this;
}

const char *g_Difficulty_Tokens[] =
{
    "BaseContentment",
    "GranaryCoeff",
    "BigCityScale",
    "BigCityOffset",
    "ScienceHandicap",
    "PollutionMultiplier",
    "RiotChance",
    "StarvationEffect",
    "StartingGold",
    "VisionBonus",
    "BaseScore",
    "TimeScale",
    "FeatsFactor",
    "AdvancesFactor",
    "WondersFactor",
    "Cities0To3Factor",
    "Cities3To10Factor",
    "Cities10To50Factor",
    "Cities50PlusFactor",
    "CitiesRecapturedFactor",
    "PopulationFactor",
    "RankFactor",
    "OpponentsConqueredFactor",
    "AlliesFactor",
    "WonderVictoryBonus",
    "SoloVictoryBonus",
    "AlliedVictoryBonus",
    "AIStartUnits",
    "AIStartGold",
    "AIStartAdvances",
    "AIStartPublicWorks",
    "HumanStartLocation",
    "AIIntelligenceFactor",
    "AIGangUpFactor",
    "DistanceFromCapitolAdjustment",
    "AIDistanceFromCapitolAdjustment",
    "PollutionAdjust",
    "AIMinBehind",
    "AIMaxBehind",
    "AIMinAhead",
    "AIMaxAhead",
    "AIMinBehindTechnologyCost",
    "AIMaxBehindTechnologyCost",
    "AIMinBehindProductionCostAdjustment",
    "AIMaxBehindProductionCostAdjustment",
    "AIMinBehindGoldCostAdjustment",
    "AIMaxBehindGoldCostAdjustment",
    "AIMinAheadTechnologyCost",
    "AIMaxAheadTechnologyCost",
    "AIMinAheadProductionCostAdjustment",
    "AIMaxAheadProductionCostAdjustment",
    "AIMinAheadGoldCostAdjustment",
    "AIMaxAheadGoldCostAdjustment",
    "MaxHumanAdvances",
    "MaxAIAdvances",
    "HumanScienceBonus",
    "HumanFoodBonus",
    "ExtraSettlerChance",
    "AdvanceChances",
    "PollutionStartProductionLevel",
    "PollutionStartPopulationLevel",
    "PollutionProductionRatio",
    "PollutionPopulationRatio",
    "NoAIProductionDeficit",
    "NoAIGoldDeficit",
    "AICityDefenderBonus",
    "BarbarianCities",
    "SectarianHappiness",
    "RevoltCasualties",
    "RevoltInsurgents",
    "BarbarianCamps",
    "BarbarianSpawnsBarbarian",
    "AINoSinking",
    "AINoCityLimit",
    "GoldPerUnitSupport",
    "GoldPerUnitSupportValue",
    "GoldPerCity",
    "GoldPerCityValue",
    "AINoShieldHunger",
    "AINoGoldHunger",
    "AIFreeUpgrade",
    "AIMilitiaUnit",
    "TechCostKnownDeduction",
    "TechCostKnownDeductionValue",
    "BASE_CONTENTMENT",
    "GRANARY_COEF",
    "BIG_CITY_SCALE",
    "BIG_CITY_OFFSET",
    "SCIENCE_HANDICAP",
    "POLLUTION_MULTIPLIER",
    "RIOT_CHANCE",
    "STARVATION_EFFECT",
    "STARTING_GOLD",
    "SUPER_STEALTH_FUN_FACTOR",
    "BASE_SCORE",
    "TIME_SCALE",
    "FEATS_FACTOR",
    "ADVANCES_FACTOR",
    "WONDERS_FACTOR",
    "CITIES0TO30_FACTOR",
    "CITIES30TO100_FACTOR",
    "CITIES100TO500_FACTOR",
    "CITIES500PLUS_FACTOR",
    "CITIES_RECAPTURED_FACTOR",
    "POPULATION_FACTOR",
    "RANK_FACTOR",
    "OPPONENTS_CONQUERED_FACTOR",
    "ALLIES_FACTOR",
    "WONDER_VICTORY_BONUS",
    "SOLO_VICTORY_BONUS",
    "ALLIED_VICTORY_BONUS",
    "AI_START_UNITS",
    "AI_START_GOLD",
    "AI_START_ADVANCES",
    "AI_START_PUBLIC_WORKS",
    "HUMAN_START_LOCATION",
    "AI_INTELLIGENCE_FACTOR",
    "AI_GANG_UP_FACTOR",
    "DISTANCE_FROM_CAPITOL_ADJUSTMENT",
    "AI_DISTANCE_FROM_CAPITOL_ADJUSTMENT",
    "POLLUTION_ADJUST",
    "AI_MIN_BEHIND_PERCENT",
    "AI_MAX_BEHIND_PERCENT",
    "AI_MIN_AHEAD_PERCENT",
    "AI_MAX_AHEAD_PERCENT",
    "AI_MIN_BEHIND_TECHNOLOGY_COST",
    "AI_MAX_BEHIND_TECHNOLOGY_COST",
    "AI_MIN_BEHIND_PRODUCTION_COST_ADJUSTMENT",
    "AI_MAX_BEHIND_PRODUCTION_COST_ADJUSTMENT",
    "AI_MIN_BEHIND_GOLD_ADJUSTMENT",
    "AI_MAX_BEHIND_GOLD_ADJUSTMENT",
    "AI_MIN_AHEAD_TECHNOLOGY_COST",
    "AI_MAX_AHEAD_TECHNOLOGY_COST",
    "AI_MIN_AHEAD_PRODUCTION_COST_ADJUSTMENT",
    "AI_MAX_AHEAD_PRODUCTION_COST_ADJUSTMENT",
    "AI_MIN_AHEAD_GOLD_ADJUSTMENT",
    "AI_MAX_AHEAD_GOLD_ADJUSTMENT",
    "MAX_HUMAN_ADVANCES",
    "MAX_AI_ADVANCES",
    "HUMAN_SCIENCE_BONUS",
    "HUMAN_FOOD_BONUS",
    "EXTRA_SETTLER_CHANCE",
    "ADVANCE_CHANCES",
    "POLLUTION_START_PRODUCTION_LEVEL",
    "POLLUTION_START_POPULATION_LEVEL",
    "POLLUTION_PRODUCTION_RATIO",
    "POLLUTION_POPULATION_RATIO",
};

DifficultyRecordAccessorInfo g_DifficultyRecord_Accessors[] =
{
    { &DifficultyRecord::GetBaseContentment, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetGranaryCoeff, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetBigCityScale, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetBigCityOffset, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetScienceHandicap, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetPollutionMultiplier, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetRiotChance, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetStarvationEffect, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetStartingGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetVisionBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetBaseScore, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TimeScale */
    { NULL, NULL, &DifficultyRecord::GetFeatsFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetAdvancesFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetWondersFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetCities0To3Factor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetCities3To10Factor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetCities10To50Factor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetCities50PlusFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetCitiesRecapturedFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetPopulationFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetRankFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetOpponentsConqueredFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetAlliesFactor, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetWonderVictoryBonus, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetSoloVictoryBonus, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetAlliedVictoryBonus, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetAIStartUnits, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetAIStartGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetAIStartAdvances, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetAIStartPublicWorks, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetHumanStartLocation, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetAIIntelligenceFactor, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetAIGangUpFactor, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetDistanceFromCapitolAdjustment, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetAIDistanceFromCapitolAdjustment, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetPollutionAdjust, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetAIMinBehind, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetAIMaxBehind, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetAIMinAhead, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetAIMaxAhead, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetNumAIMinBehindTechnologyCost, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMinBehindTechnologyCost}, /* AIMinBehindTechnologyCost (array) */
    { &DifficultyRecord::GetNumAIMaxBehindTechnologyCost, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMaxBehindTechnologyCost}, /* AIMaxBehindTechnologyCost (array) */
    { &DifficultyRecord::GetNumAIMinBehindProductionCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMinBehindProductionCostAdjustment}, /* AIMinBehindProductionCostAdjustment (array) */
    { &DifficultyRecord::GetNumAIMaxBehindProductionCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMaxBehindProductionCostAdjustment}, /* AIMaxBehindProductionCostAdjustment (array) */
    { &DifficultyRecord::GetNumAIMinBehindGoldCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMinBehindGoldCostAdjustment}, /* AIMinBehindGoldCostAdjustment (array) */
    { &DifficultyRecord::GetNumAIMaxBehindGoldCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMaxBehindGoldCostAdjustment}, /* AIMaxBehindGoldCostAdjustment (array) */
    { &DifficultyRecord::GetNumAIMinAheadTechnologyCost, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMinAheadTechnologyCost}, /* AIMinAheadTechnologyCost (array) */
    { &DifficultyRecord::GetNumAIMaxAheadTechnologyCost, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMaxAheadTechnologyCost}, /* AIMaxAheadTechnologyCost (array) */
    { &DifficultyRecord::GetNumAIMinAheadProductionCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMinAheadProductionCostAdjustment}, /* AIMinAheadProductionCostAdjustment (array) */
    { &DifficultyRecord::GetNumAIMaxAheadProductionCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMaxAheadProductionCostAdjustment}, /* AIMaxAheadProductionCostAdjustment (array) */
    { &DifficultyRecord::GetNumAIMinAheadGoldCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMinAheadGoldCostAdjustment}, /* AIMinAheadGoldCostAdjustment (array) */
    { &DifficultyRecord::GetNumAIMaxAheadGoldCostAdjustment, NULL, NULL, NULL, NULL, NULL, &DifficultyRecord::GetAIMaxAheadGoldCostAdjustment}, /* AIMaxAheadGoldCostAdjustment (array) */
    { &DifficultyRecord::GetMaxHumanAdvances, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetMaxAIAdvances, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetHumanScienceBonus, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetHumanFoodBonus, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetExtraSettlerChance, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AdvanceChances */
    { &DifficultyRecord::GetPollutionStartProductionLevel, NULL, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetPollutionStartPopulationLevel, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetPollutionProductionRatio, NULL, NULL, NULL, NULL },
    { NULL, NULL, &DifficultyRecord::GetPollutionPopulationRatio, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetNoAIProductionDeficit, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetNoAIGoldDeficit, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetAICityDefenderBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetBarbarianCities, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetSectarianHappiness, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetRevoltCasualties, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetRevoltInsurgents, NULL, NULL, NULL, NULL, NULL },
    { &DifficultyRecord::GetNumBarbarianCamps, NULL, NULL, NULL, NULL, &DifficultyRecord::GetBarbarianCampsIndex, NULL}, /* BarbarianCamps (array) */
    { NULL, &DifficultyRecord::GetBarbarianSpawnsBarbarian, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetAINoSinking, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetAINoCityLimit, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &DifficultyRecord::GetGoldPerUnitSupport, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerUnitSupport */
    { NULL, NULL, NULL, &DifficultyRecord::GetGoldPerCity, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* GoldPerCity */
    { NULL, &DifficultyRecord::GetAINoShieldHunger, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetAINoGoldHunger, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetAIFreeUpgrade, NULL, NULL, NULL, NULL, NULL },
    { NULL, &DifficultyRecord::GetAIMilitiaUnit, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &DifficultyRecord::GetTechCostKnownDeduction, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TechCostKnownDeduction */
};

#define k_Token_Difficulty_BaseContentment       ((k_Token_Custom_Base) + 0)
#define k_Token_Difficulty_GranaryCoeff          ((k_Token_Custom_Base) + 1)
#define k_Token_Difficulty_BigCityScale          ((k_Token_Custom_Base) + 2)
#define k_Token_Difficulty_BigCityOffset         ((k_Token_Custom_Base) + 3)
#define k_Token_Difficulty_ScienceHandicap       ((k_Token_Custom_Base) + 4)
#define k_Token_Difficulty_PollutionMultiplier   ((k_Token_Custom_Base) + 5)
#define k_Token_Difficulty_RiotChance            ((k_Token_Custom_Base) + 6)
#define k_Token_Difficulty_StarvationEffect      ((k_Token_Custom_Base) + 7)
#define k_Token_Difficulty_StartingGold          ((k_Token_Custom_Base) + 8)
#define k_Token_Difficulty_VisionBonus           ((k_Token_Custom_Base) + 9)
#define k_Token_Difficulty_BaseScore             ((k_Token_Custom_Base) + 10)
#define k_Token_Difficulty_TimeScale             ((k_Token_Custom_Base) + 11)
#define k_Token_Difficulty_FeatsFactor           ((k_Token_Custom_Base) + 12)
#define k_Token_Difficulty_AdvancesFactor        ((k_Token_Custom_Base) + 13)
#define k_Token_Difficulty_WondersFactor         ((k_Token_Custom_Base) + 14)
#define k_Token_Difficulty_Cities0To3Factor      ((k_Token_Custom_Base) + 15)
#define k_Token_Difficulty_Cities3To10Factor     ((k_Token_Custom_Base) + 16)
#define k_Token_Difficulty_Cities10To50Factor    ((k_Token_Custom_Base) + 17)
#define k_Token_Difficulty_Cities50PlusFactor    ((k_Token_Custom_Base) + 18)
#define k_Token_Difficulty_CitiesRecapturedFactor ((k_Token_Custom_Base) + 19)
#define k_Token_Difficulty_PopulationFactor      ((k_Token_Custom_Base) + 20)
#define k_Token_Difficulty_RankFactor            ((k_Token_Custom_Base) + 21)
#define k_Token_Difficulty_OpponentsConqueredFactor ((k_Token_Custom_Base) + 22)
#define k_Token_Difficulty_AlliesFactor          ((k_Token_Custom_Base) + 23)
#define k_Token_Difficulty_WonderVictoryBonus    ((k_Token_Custom_Base) + 24)
#define k_Token_Difficulty_SoloVictoryBonus      ((k_Token_Custom_Base) + 25)
#define k_Token_Difficulty_AlliedVictoryBonus    ((k_Token_Custom_Base) + 26)
#define k_Token_Difficulty_AIStartUnits          ((k_Token_Custom_Base) + 27)
#define k_Token_Difficulty_AIStartGold           ((k_Token_Custom_Base) + 28)
#define k_Token_Difficulty_AIStartAdvances       ((k_Token_Custom_Base) + 29)
#define k_Token_Difficulty_AIStartPublicWorks    ((k_Token_Custom_Base) + 30)
#define k_Token_Difficulty_HumanStartLocation    ((k_Token_Custom_Base) + 31)
#define k_Token_Difficulty_AIIntelligenceFactor  ((k_Token_Custom_Base) + 32)
#define k_Token_Difficulty_AIGangUpFactor        ((k_Token_Custom_Base) + 33)
#define k_Token_Difficulty_DistanceFromCapitolAdjustment ((k_Token_Custom_Base) + 34)
#define k_Token_Difficulty_AIDistanceFromCapitolAdjustment ((k_Token_Custom_Base) + 35)
#define k_Token_Difficulty_PollutionAdjust       ((k_Token_Custom_Base) + 36)
#define k_Token_Difficulty_AIMinBehind           ((k_Token_Custom_Base) + 37)
#define k_Token_Difficulty_AIMaxBehind           ((k_Token_Custom_Base) + 38)
#define k_Token_Difficulty_AIMinAhead            ((k_Token_Custom_Base) + 39)
#define k_Token_Difficulty_AIMaxAhead            ((k_Token_Custom_Base) + 40)
#define k_Token_Difficulty_AIMinBehindTechnologyCost ((k_Token_Custom_Base) + 41)
#define k_Token_Difficulty_AIMaxBehindTechnologyCost ((k_Token_Custom_Base) + 42)
#define k_Token_Difficulty_AIMinBehindProductionCostAdjustment ((k_Token_Custom_Base) + 43)
#define k_Token_Difficulty_AIMaxBehindProductionCostAdjustment ((k_Token_Custom_Base) + 44)
#define k_Token_Difficulty_AIMinBehindGoldCostAdjustment ((k_Token_Custom_Base) + 45)
#define k_Token_Difficulty_AIMaxBehindGoldCostAdjustment ((k_Token_Custom_Base) + 46)
#define k_Token_Difficulty_AIMinAheadTechnologyCost ((k_Token_Custom_Base) + 47)
#define k_Token_Difficulty_AIMaxAheadTechnologyCost ((k_Token_Custom_Base) + 48)
#define k_Token_Difficulty_AIMinAheadProductionCostAdjustment ((k_Token_Custom_Base) + 49)
#define k_Token_Difficulty_AIMaxAheadProductionCostAdjustment ((k_Token_Custom_Base) + 50)
#define k_Token_Difficulty_AIMinAheadGoldCostAdjustment ((k_Token_Custom_Base) + 51)
#define k_Token_Difficulty_AIMaxAheadGoldCostAdjustment ((k_Token_Custom_Base) + 52)
#define k_Token_Difficulty_MaxHumanAdvances      ((k_Token_Custom_Base) + 53)
#define k_Token_Difficulty_MaxAIAdvances         ((k_Token_Custom_Base) + 54)
#define k_Token_Difficulty_HumanScienceBonus     ((k_Token_Custom_Base) + 55)
#define k_Token_Difficulty_HumanFoodBonus        ((k_Token_Custom_Base) + 56)
#define k_Token_Difficulty_ExtraSettlerChance    ((k_Token_Custom_Base) + 57)
#define k_Token_Difficulty_AdvanceChances        ((k_Token_Custom_Base) + 58)
#define k_Token_Difficulty_PollutionStartProductionLevel ((k_Token_Custom_Base) + 59)
#define k_Token_Difficulty_PollutionStartPopulationLevel ((k_Token_Custom_Base) + 60)
#define k_Token_Difficulty_PollutionProductionRatio ((k_Token_Custom_Base) + 61)
#define k_Token_Difficulty_PollutionPopulationRatio ((k_Token_Custom_Base) + 62)
#define k_Token_Difficulty_NoAIProductionDeficit ((k_Token_Custom_Base) + 63)
#define k_Token_Difficulty_NoAIGoldDeficit       ((k_Token_Custom_Base) + 64)
#define k_Token_Difficulty_AICityDefenderBonus   ((k_Token_Custom_Base) + 65)
#define k_Token_Difficulty_BarbarianCities       ((k_Token_Custom_Base) + 66)
#define k_Token_Difficulty_SectarianHappiness    ((k_Token_Custom_Base) + 67)
#define k_Token_Difficulty_RevoltCasualties      ((k_Token_Custom_Base) + 68)
#define k_Token_Difficulty_RevoltInsurgents      ((k_Token_Custom_Base) + 69)
#define k_Token_Difficulty_BarbarianCamps        ((k_Token_Custom_Base) + 70)
#define k_Token_Difficulty_BarbarianSpawnsBarbarian ((k_Token_Custom_Base) + 71)
#define k_Token_Difficulty_AINoSinking           ((k_Token_Custom_Base) + 72)
#define k_Token_Difficulty_AINoCityLimit         ((k_Token_Custom_Base) + 73)
#define k_Token_Difficulty_GoldPerUnitSupport    ((k_Token_Custom_Base) + 74)
#define k_Token_Difficulty_GoldPerUnitSupport_Value ((k_Token_Custom_Base) + 75)
#define k_Token_Difficulty_GoldPerCity           ((k_Token_Custom_Base) + 76)
#define k_Token_Difficulty_GoldPerCity_Value     ((k_Token_Custom_Base) + 77)
#define k_Token_Difficulty_AINoShieldHunger      ((k_Token_Custom_Base) + 78)
#define k_Token_Difficulty_AINoGoldHunger        ((k_Token_Custom_Base) + 79)
#define k_Token_Difficulty_AIFreeUpgrade         ((k_Token_Custom_Base) + 80)
#define k_Token_Difficulty_AIMilitiaUnit         ((k_Token_Custom_Base) + 81)
#define k_Token_Difficulty_TechCostKnownDeduction ((k_Token_Custom_Base) + 82)
#define k_Token_Difficulty_TechCostKnownDeduction_Value ((k_Token_Custom_Base) + 83)
#define k_Token_Difficulty_BASE_CONTENTMENT      ((k_Token_Custom_Base) + 84)
#define k_Token_Difficulty_GRANARY_COEF          ((k_Token_Custom_Base) + 85)
#define k_Token_Difficulty_BIG_CITY_SCALE        ((k_Token_Custom_Base) + 86)
#define k_Token_Difficulty_BIG_CITY_OFFSET       ((k_Token_Custom_Base) + 87)
#define k_Token_Difficulty_SCIENCE_HANDICAP      ((k_Token_Custom_Base) + 88)
#define k_Token_Difficulty_POLLUTION_MULTIPLIER  ((k_Token_Custom_Base) + 89)
#define k_Token_Difficulty_RIOT_CHANCE           ((k_Token_Custom_Base) + 90)
#define k_Token_Difficulty_STARVATION_EFFECT     ((k_Token_Custom_Base) + 91)
#define k_Token_Difficulty_STARTING_GOLD         ((k_Token_Custom_Base) + 92)
#define k_Token_Difficulty_SUPER_STEALTH_FUN_FACTOR ((k_Token_Custom_Base) + 93)
#define k_Token_Difficulty_BASE_SCORE            ((k_Token_Custom_Base) + 94)
#define k_Token_Difficulty_TIME_SCALE            ((k_Token_Custom_Base) + 95)
#define k_Token_Difficulty_FEATS_FACTOR          ((k_Token_Custom_Base) + 96)
#define k_Token_Difficulty_ADVANCES_FACTOR       ((k_Token_Custom_Base) + 97)
#define k_Token_Difficulty_WONDERS_FACTOR        ((k_Token_Custom_Base) + 98)
#define k_Token_Difficulty_CITIES0TO30_FACTOR    ((k_Token_Custom_Base) + 99)
#define k_Token_Difficulty_CITIES30TO100_FACTOR  ((k_Token_Custom_Base) + 100)
#define k_Token_Difficulty_CITIES100TO500_FACTOR ((k_Token_Custom_Base) + 101)
#define k_Token_Difficulty_CITIES500PLUS_FACTOR  ((k_Token_Custom_Base) + 102)
#define k_Token_Difficulty_CITIES_RECAPTURED_FACTOR ((k_Token_Custom_Base) + 103)
#define k_Token_Difficulty_POPULATION_FACTOR     ((k_Token_Custom_Base) + 104)
#define k_Token_Difficulty_RANK_FACTOR           ((k_Token_Custom_Base) + 105)
#define k_Token_Difficulty_OPPONENTS_CONQUERED_FACTOR ((k_Token_Custom_Base) + 106)
#define k_Token_Difficulty_ALLIES_FACTOR         ((k_Token_Custom_Base) + 107)
#define k_Token_Difficulty_WONDER_VICTORY_BONUS  ((k_Token_Custom_Base) + 108)
#define k_Token_Difficulty_SOLO_VICTORY_BONUS    ((k_Token_Custom_Base) + 109)
#define k_Token_Difficulty_ALLIED_VICTORY_BONUS  ((k_Token_Custom_Base) + 110)
#define k_Token_Difficulty_AI_START_UNITS        ((k_Token_Custom_Base) + 111)
#define k_Token_Difficulty_AI_START_GOLD         ((k_Token_Custom_Base) + 112)
#define k_Token_Difficulty_AI_START_ADVANCES     ((k_Token_Custom_Base) + 113)
#define k_Token_Difficulty_AI_START_PUBLIC_WORKS ((k_Token_Custom_Base) + 114)
#define k_Token_Difficulty_HUMAN_START_LOCATION  ((k_Token_Custom_Base) + 115)
#define k_Token_Difficulty_AI_INTELLIGENCE_FACTOR ((k_Token_Custom_Base) + 116)
#define k_Token_Difficulty_AI_GANG_UP_FACTOR     ((k_Token_Custom_Base) + 117)
#define k_Token_Difficulty_DISTANCE_FROM_CAPITOL_ADJUSTMENT ((k_Token_Custom_Base) + 118)
#define k_Token_Difficulty_AI_DISTANCE_FROM_CAPITOL_ADJUSTMENT ((k_Token_Custom_Base) + 119)
#define k_Token_Difficulty_POLLUTION_ADJUST      ((k_Token_Custom_Base) + 120)
#define k_Token_Difficulty_AI_MIN_BEHIND_PERCENT ((k_Token_Custom_Base) + 121)
#define k_Token_Difficulty_AI_MAX_BEHIND_PERCENT ((k_Token_Custom_Base) + 122)
#define k_Token_Difficulty_AI_MIN_AHEAD_PERCENT  ((k_Token_Custom_Base) + 123)
#define k_Token_Difficulty_AI_MAX_AHEAD_PERCENT  ((k_Token_Custom_Base) + 124)
#define k_Token_Difficulty_AI_MIN_BEHIND_TECHNOLOGY_COST ((k_Token_Custom_Base) + 125)
#define k_Token_Difficulty_AI_MAX_BEHIND_TECHNOLOGY_COST ((k_Token_Custom_Base) + 126)
#define k_Token_Difficulty_AI_MIN_BEHIND_PRODUCTION_COST_ADJUSTMENT ((k_Token_Custom_Base) + 127)
#define k_Token_Difficulty_AI_MAX_BEHIND_PRODUCTION_COST_ADJUSTMENT ((k_Token_Custom_Base) + 128)
#define k_Token_Difficulty_AI_MIN_BEHIND_GOLD_ADJUSTMENT ((k_Token_Custom_Base) + 129)
#define k_Token_Difficulty_AI_MAX_BEHIND_GOLD_ADJUSTMENT ((k_Token_Custom_Base) + 130)
#define k_Token_Difficulty_AI_MIN_AHEAD_TECHNOLOGY_COST ((k_Token_Custom_Base) + 131)
#define k_Token_Difficulty_AI_MAX_AHEAD_TECHNOLOGY_COST ((k_Token_Custom_Base) + 132)
#define k_Token_Difficulty_AI_MIN_AHEAD_PRODUCTION_COST_ADJUSTMENT ((k_Token_Custom_Base) + 133)
#define k_Token_Difficulty_AI_MAX_AHEAD_PRODUCTION_COST_ADJUSTMENT ((k_Token_Custom_Base) + 134)
#define k_Token_Difficulty_AI_MIN_AHEAD_GOLD_ADJUSTMENT ((k_Token_Custom_Base) + 135)
#define k_Token_Difficulty_AI_MAX_AHEAD_GOLD_ADJUSTMENT ((k_Token_Custom_Base) + 136)
#define k_Token_Difficulty_MAX_HUMAN_ADVANCES    ((k_Token_Custom_Base) + 137)
#define k_Token_Difficulty_MAX_AI_ADVANCES       ((k_Token_Custom_Base) + 138)
#define k_Token_Difficulty_HUMAN_SCIENCE_BONUS   ((k_Token_Custom_Base) + 139)
#define k_Token_Difficulty_HUMAN_FOOD_BONUS      ((k_Token_Custom_Base) + 140)
#define k_Token_Difficulty_EXTRA_SETTLER_CHANCE  ((k_Token_Custom_Base) + 141)
#define k_Token_Difficulty_ADVANCE_CHANCES       ((k_Token_Custom_Base) + 142)
#define k_Token_Difficulty_POLLUTION_START_PRODUCTION_LEVEL ((k_Token_Custom_Base) + 143)
#define k_Token_Difficulty_POLLUTION_START_POPULATION_LEVEL ((k_Token_Custom_Base) + 144)
#define k_Token_Difficulty_POLLUTION_PRODUCTION_RATIO ((k_Token_Custom_Base) + 145)
#define k_Token_Difficulty_POLLUTION_POPULATION_RATIO ((k_Token_Custom_Base) + 146)
#define k_Token_Difficulty_Max                   ((k_Token_Custom_Base) + 147)


static BitArray s_ParsedTokens(147);
void DifficultyRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_BaseContentment - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_BASE_CONTENTMENT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BaseContentment missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_GranaryCoeff - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_GRANARY_COEF - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field GranaryCoeff missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_BigCityScale - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_BIG_CITY_SCALE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BigCityScale missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_BigCityOffset - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_BIG_CITY_OFFSET - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BigCityOffset missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_ScienceHandicap - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_SCIENCE_HANDICAP - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field ScienceHandicap missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_PollutionMultiplier - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_POLLUTION_MULTIPLIER - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field PollutionMultiplier missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_RiotChance - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_RIOT_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field RiotChance missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_StarvationEffect - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_STARVATION_EFFECT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field StarvationEffect missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_StartingGold - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_STARTING_GOLD - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field StartingGold missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_VisionBonus - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_SUPER_STEALTH_FUN_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field VisionBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_BaseScore - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_BASE_SCORE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BaseScore missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_TimeScale - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_TIME_SCALE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field TimeScale missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_FeatsFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_FEATS_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field FeatsFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AdvancesFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_ADVANCES_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AdvancesFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_WondersFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_WONDERS_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field WondersFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_Cities0To3Factor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_CITIES0TO30_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field Cities0To3Factor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_Cities3To10Factor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_CITIES30TO100_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field Cities3To10Factor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_Cities10To50Factor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_CITIES100TO500_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field Cities10To50Factor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_Cities50PlusFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_CITIES500PLUS_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field Cities50PlusFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_CitiesRecapturedFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_CITIES_RECAPTURED_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field CitiesRecapturedFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_PopulationFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_POPULATION_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field PopulationFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_RankFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_RANK_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field RankFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_OpponentsConqueredFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_OPPONENTS_CONQUERED_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field OpponentsConqueredFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AlliesFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_ALLIES_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AlliesFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_WonderVictoryBonus - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_WONDER_VICTORY_BONUS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field WonderVictoryBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_SoloVictoryBonus - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_SOLO_VICTORY_BONUS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field SoloVictoryBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AlliedVictoryBonus - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_ALLIED_VICTORY_BONUS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AlliedVictoryBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIStartUnits - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_START_UNITS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIStartUnits missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIStartGold - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_START_GOLD - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIStartGold missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIStartAdvances - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_START_ADVANCES - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIStartAdvances missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIStartPublicWorks - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_START_PUBLIC_WORKS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIStartPublicWorks missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_HumanStartLocation - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_HUMAN_START_LOCATION - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HumanStartLocation missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIIntelligenceFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_INTELLIGENCE_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIIntelligenceFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIGangUpFactor - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_GANG_UP_FACTOR - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIGangUpFactor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_DistanceFromCapitolAdjustment - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_DISTANCE_FROM_CAPITOL_ADJUSTMENT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field DistanceFromCapitolAdjustment missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIDistanceFromCapitolAdjustment - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_DISTANCE_FROM_CAPITOL_ADJUSTMENT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIDistanceFromCapitolAdjustment missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_PollutionAdjust - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_POLLUTION_ADJUST - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field PollutionAdjust missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIMinBehind - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_MIN_BEHIND_PERCENT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIMinBehind missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIMaxBehind - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_MAX_BEHIND_PERCENT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIMaxBehind missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIMinAhead - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_MIN_AHEAD_PERCENT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIMinAhead missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AIMaxAhead - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_AI_MAX_AHEAD_PERCENT - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AIMaxAhead missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_MaxHumanAdvances - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_MAX_HUMAN_ADVANCES - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field MaxHumanAdvances missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_MaxAIAdvances - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_MAX_AI_ADVANCES - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field MaxAIAdvances missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_HumanScienceBonus - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_HUMAN_SCIENCE_BONUS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HumanScienceBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_HumanFoodBonus - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_HUMAN_FOOD_BONUS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HumanFoodBonus missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_ExtraSettlerChance - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_EXTRA_SETTLER_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field ExtraSettlerChance missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_AdvanceChances - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_ADVANCE_CHANCES - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field AdvanceChances missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_PollutionStartProductionLevel - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_POLLUTION_START_PRODUCTION_LEVEL - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field PollutionStartProductionLevel missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_PollutionStartPopulationLevel - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_POLLUTION_START_POPULATION_LEVEL - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field PollutionStartPopulationLevel missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_PollutionProductionRatio - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_POLLUTION_PRODUCTION_RATIO - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field PollutionProductionRatio missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Difficulty_PollutionPopulationRatio - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Difficulty_POLLUTION_POPULATION_RATIO - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field PollutionPopulationRatio missing"));
    }
}

sint32 DifficultyRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Difficulty_Tokens, k_Token_Difficulty_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "DIFFICULTY_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Difficulty_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Difficulty_BaseContentment:
            case k_Token_Difficulty_BASE_CONTENTMENT:
                if(!lex->GetIntAssignment(m_BaseContentment)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_GranaryCoeff:
            case k_Token_Difficulty_GRANARY_COEF:
                if(!lex->GetIntAssignment(m_GranaryCoeff)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_BigCityScale:
            case k_Token_Difficulty_BIG_CITY_SCALE:
                if(!lex->GetFloatAssignment(m_BigCityScale)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_BigCityOffset:
            case k_Token_Difficulty_BIG_CITY_OFFSET:
                if(!lex->GetFloatAssignment(m_BigCityOffset)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_ScienceHandicap:
            case k_Token_Difficulty_SCIENCE_HANDICAP:
                if(!lex->GetIntAssignment(m_ScienceHandicap)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_PollutionMultiplier:
            case k_Token_Difficulty_POLLUTION_MULTIPLIER:
                if(!lex->GetFloatAssignment(m_PollutionMultiplier)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_RiotChance:
            case k_Token_Difficulty_RIOT_CHANCE:
                if(!lex->GetFloatAssignment(m_RiotChance)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_StarvationEffect:
            case k_Token_Difficulty_STARVATION_EFFECT:
                if(!lex->GetFloatAssignment(m_StarvationEffect)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_StartingGold:
            case k_Token_Difficulty_STARTING_GOLD:
                if(!lex->GetIntAssignment(m_StartingGold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_VisionBonus:
            case k_Token_Difficulty_SUPER_STEALTH_FUN_FACTOR:
                if(!lex->GetIntAssignment(m_VisionBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_BaseScore:
            case k_Token_Difficulty_BASE_SCORE:
                if(!lex->GetIntAssignment(m_BaseScore)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_TimeScale:
            case k_Token_Difficulty_TIME_SCALE:
                if(!m_TimeScale.Parse(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_FeatsFactor:
            case k_Token_Difficulty_FEATS_FACTOR:
                if(!lex->GetFloatAssignment(m_FeatsFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AdvancesFactor:
            case k_Token_Difficulty_ADVANCES_FACTOR:
                if(!lex->GetFloatAssignment(m_AdvancesFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_WondersFactor:
            case k_Token_Difficulty_WONDERS_FACTOR:
                if(!lex->GetFloatAssignment(m_WondersFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_Cities0To3Factor:
            case k_Token_Difficulty_CITIES0TO30_FACTOR:
                if(!lex->GetFloatAssignment(m_Cities0To3Factor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_Cities3To10Factor:
            case k_Token_Difficulty_CITIES30TO100_FACTOR:
                if(!lex->GetFloatAssignment(m_Cities3To10Factor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_Cities10To50Factor:
            case k_Token_Difficulty_CITIES100TO500_FACTOR:
                if(!lex->GetFloatAssignment(m_Cities10To50Factor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_Cities50PlusFactor:
            case k_Token_Difficulty_CITIES500PLUS_FACTOR:
                if(!lex->GetFloatAssignment(m_Cities50PlusFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_CitiesRecapturedFactor:
            case k_Token_Difficulty_CITIES_RECAPTURED_FACTOR:
                if(!lex->GetFloatAssignment(m_CitiesRecapturedFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_PopulationFactor:
            case k_Token_Difficulty_POPULATION_FACTOR:
                if(!lex->GetFloatAssignment(m_PopulationFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_RankFactor:
            case k_Token_Difficulty_RANK_FACTOR:
                if(!lex->GetFloatAssignment(m_RankFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_OpponentsConqueredFactor:
            case k_Token_Difficulty_OPPONENTS_CONQUERED_FACTOR:
                if(!lex->GetFloatAssignment(m_OpponentsConqueredFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AlliesFactor:
            case k_Token_Difficulty_ALLIES_FACTOR:
                if(!lex->GetFloatAssignment(m_AlliesFactor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_WonderVictoryBonus:
            case k_Token_Difficulty_WONDER_VICTORY_BONUS:
                if(!lex->GetFloatAssignment(m_WonderVictoryBonus)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_SoloVictoryBonus:
            case k_Token_Difficulty_SOLO_VICTORY_BONUS:
                if(!lex->GetFloatAssignment(m_SoloVictoryBonus)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AlliedVictoryBonus:
            case k_Token_Difficulty_ALLIED_VICTORY_BONUS:
                if(!lex->GetFloatAssignment(m_AlliedVictoryBonus)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIStartUnits:
            case k_Token_Difficulty_AI_START_UNITS:
                if(!lex->GetIntAssignment(m_AIStartUnits)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIStartGold:
            case k_Token_Difficulty_AI_START_GOLD:
                if(!lex->GetIntAssignment(m_AIStartGold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIStartAdvances:
            case k_Token_Difficulty_AI_START_ADVANCES:
                if(!lex->GetIntAssignment(m_AIStartAdvances)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIStartPublicWorks:
            case k_Token_Difficulty_AI_START_PUBLIC_WORKS:
                if(!lex->GetIntAssignment(m_AIStartPublicWorks)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_HumanStartLocation:
            case k_Token_Difficulty_HUMAN_START_LOCATION:
                if(!lex->GetIntAssignment(m_HumanStartLocation)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIIntelligenceFactor:
            case k_Token_Difficulty_AI_INTELLIGENCE_FACTOR:
                if(!lex->GetIntAssignment(m_AIIntelligenceFactor)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIGangUpFactor:
            case k_Token_Difficulty_AI_GANG_UP_FACTOR:
                if(!lex->GetIntAssignment(m_AIGangUpFactor)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_DistanceFromCapitolAdjustment:
            case k_Token_Difficulty_DISTANCE_FROM_CAPITOL_ADJUSTMENT:
                if(!lex->GetIntAssignment(m_DistanceFromCapitolAdjustment)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIDistanceFromCapitolAdjustment:
            case k_Token_Difficulty_AI_DISTANCE_FROM_CAPITOL_ADJUSTMENT:
                if(!lex->GetIntAssignment(m_AIDistanceFromCapitolAdjustment)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_PollutionAdjust:
            case k_Token_Difficulty_POLLUTION_ADJUST:
                if(!lex->GetIntAssignment(m_PollutionAdjust)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinBehind:
            case k_Token_Difficulty_AI_MIN_BEHIND_PERCENT:
                if(!lex->GetFloatAssignment(m_AIMinBehind)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxBehind:
            case k_Token_Difficulty_AI_MAX_BEHIND_PERCENT:
                if(!lex->GetFloatAssignment(m_AIMaxBehind)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinAhead:
            case k_Token_Difficulty_AI_MIN_AHEAD_PERCENT:
                if(!lex->GetFloatAssignment(m_AIMinAhead)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxAhead:
            case k_Token_Difficulty_AI_MAX_AHEAD_PERCENT:
                if(!lex->GetFloatAssignment(m_AIMaxAhead)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinBehindTechnologyCost:
            case k_Token_Difficulty_AI_MIN_BEHIND_TECHNOLOGY_COST:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMinBehindTechnologyCost, &m_numAIMinBehindTechnologyCost))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxBehindTechnologyCost:
            case k_Token_Difficulty_AI_MAX_BEHIND_TECHNOLOGY_COST:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMaxBehindTechnologyCost, &m_numAIMaxBehindTechnologyCost))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinBehindProductionCostAdjustment:
            case k_Token_Difficulty_AI_MIN_BEHIND_PRODUCTION_COST_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMinBehindProductionCostAdjustment, &m_numAIMinBehindProductionCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxBehindProductionCostAdjustment:
            case k_Token_Difficulty_AI_MAX_BEHIND_PRODUCTION_COST_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMaxBehindProductionCostAdjustment, &m_numAIMaxBehindProductionCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinBehindGoldCostAdjustment:
            case k_Token_Difficulty_AI_MIN_BEHIND_GOLD_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMinBehindGoldCostAdjustment, &m_numAIMinBehindGoldCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxBehindGoldCostAdjustment:
            case k_Token_Difficulty_AI_MAX_BEHIND_GOLD_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMaxBehindGoldCostAdjustment, &m_numAIMaxBehindGoldCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinAheadTechnologyCost:
            case k_Token_Difficulty_AI_MIN_AHEAD_TECHNOLOGY_COST:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMinAheadTechnologyCost, &m_numAIMinAheadTechnologyCost))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxAheadTechnologyCost:
            case k_Token_Difficulty_AI_MAX_AHEAD_TECHNOLOGY_COST:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMaxAheadTechnologyCost, &m_numAIMaxAheadTechnologyCost))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinAheadProductionCostAdjustment:
            case k_Token_Difficulty_AI_MIN_AHEAD_PRODUCTION_COST_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMinAheadProductionCostAdjustment, &m_numAIMinAheadProductionCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxAheadProductionCostAdjustment:
            case k_Token_Difficulty_AI_MAX_AHEAD_PRODUCTION_COST_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMaxAheadProductionCostAdjustment, &m_numAIMaxAheadProductionCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMinAheadGoldCostAdjustment:
            case k_Token_Difficulty_AI_MIN_AHEAD_GOLD_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMinAheadGoldCostAdjustment, &m_numAIMinAheadGoldCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AIMaxAheadGoldCostAdjustment:
            case k_Token_Difficulty_AI_MAX_AHEAD_GOLD_ADJUSTMENT:
                if(!CTPRecord::ParseFloatInArray(lex, &m_AIMaxAheadGoldCostAdjustment, &m_numAIMaxAheadGoldCostAdjustment))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_MaxHumanAdvances:
            case k_Token_Difficulty_MAX_HUMAN_ADVANCES:
                if(!lex->GetIntAssignment(m_MaxHumanAdvances)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_MaxAIAdvances:
            case k_Token_Difficulty_MAX_AI_ADVANCES:
                if(!lex->GetIntAssignment(m_MaxAIAdvances)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_HumanScienceBonus:
            case k_Token_Difficulty_HUMAN_SCIENCE_BONUS:
                if(!lex->GetFloatAssignment(m_HumanScienceBonus)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_HumanFoodBonus:
            case k_Token_Difficulty_HUMAN_FOOD_BONUS:
                if(!lex->GetFloatAssignment(m_HumanFoodBonus)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_ExtraSettlerChance:
            case k_Token_Difficulty_EXTRA_SETTLER_CHANCE:
                if(!lex->GetIntAssignment(m_ExtraSettlerChance)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AdvanceChances:
            case k_Token_Difficulty_ADVANCE_CHANCES:
                if(!m_AdvanceChances.Parse(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_PollutionStartProductionLevel:
            case k_Token_Difficulty_POLLUTION_START_PRODUCTION_LEVEL:
                if(!lex->GetIntAssignment(m_PollutionStartProductionLevel)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_PollutionStartPopulationLevel:
            case k_Token_Difficulty_POLLUTION_START_POPULATION_LEVEL:
                if(!lex->GetIntAssignment(m_PollutionStartPopulationLevel)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_PollutionProductionRatio:
            case k_Token_Difficulty_POLLUTION_PRODUCTION_RATIO:
                if(!lex->GetFloatAssignment(m_PollutionProductionRatio)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_PollutionPopulationRatio:
            case k_Token_Difficulty_POLLUTION_POPULATION_RATIO:
                if(!lex->GetFloatAssignment(m_PollutionPopulationRatio)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_NoAIProductionDeficit:
                m_flags0 |= k_Difficulty_NoAIProductionDeficit_Bit;
                break;
            case k_Token_Difficulty_NoAIGoldDeficit:
                m_flags0 |= k_Difficulty_NoAIGoldDeficit_Bit;
                break;
            case k_Token_Difficulty_AICityDefenderBonus:
                m_flags0 |= k_Difficulty_AICityDefenderBonus_Bit;
                break;
            case k_Token_Difficulty_BarbarianCities:
                m_flags0 |= k_Difficulty_BarbarianCities_Bit;
                break;
            case k_Token_Difficulty_SectarianHappiness:
                m_flags0 |= k_Difficulty_SectarianHappiness_Bit;
                break;
            case k_Token_Difficulty_RevoltCasualties:
                m_flags0 |= k_Difficulty_RevoltCasualties_Bit;
                break;
            case k_Token_Difficulty_RevoltInsurgents:
                m_flags0 |= k_Difficulty_RevoltInsurgents_Bit;
                break;
            case k_Token_Difficulty_BarbarianCamps:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_BarbarianCamps, &m_numBarbarianCamps))
                {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_BarbarianSpawnsBarbarian:
                m_flags0 |= k_Difficulty_BarbarianSpawnsBarbarian_Bit;
                break;
            case k_Token_Difficulty_AINoSinking:
                m_flags0 |= k_Difficulty_AINoSinking_Bit;
                break;
            case k_Token_Difficulty_AINoCityLimit:
                m_flags0 |= k_Difficulty_AINoCityLimit_Bit;
                break;
            case k_Token_Difficulty_GoldPerUnitSupport:
                m_flags0 |= k_Difficulty_GoldPerUnitSupport_Bit;
                if(!lex->GetIntAssignment(m_GoldPerUnitSupportValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_GoldPerCity:
                m_flags0 |= k_Difficulty_GoldPerCity_Bit;
                if(!lex->GetIntAssignment(m_GoldPerCityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AINoShieldHunger:
                m_flags0 |= k_Difficulty_AINoShieldHunger_Bit;
                break;
            case k_Token_Difficulty_AINoGoldHunger:
                m_flags0 |= k_Difficulty_AINoGoldHunger_Bit;
                break;
            case k_Token_Difficulty_AIFreeUpgrade:
                m_flags0 |= k_Difficulty_AIFreeUpgrade_Bit;
                break;
            case k_Token_Difficulty_AIMilitiaUnit:
                m_flags0 |= k_Difficulty_AIMilitiaUnit_Bit;
                break;
            case k_Token_Difficulty_TechCostKnownDeduction:
                m_flags0 |= k_Difficulty_TechCostKnownDeduction_Bit;
                if(!lex->GetFloatAssignment(m_TechCostKnownDeductionValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_BaseContentment)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void DifficultyRecord::ResolveDBReferences()
{
    m_TimeScale.ResolveDBReferences();
    m_AdvanceChances.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numBarbarianCamps; i++) {
            if(m_BarbarianCamps[i] & 0x80000000) {
                sint32 id = m_BarbarianCamps[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_BarbarianCamps[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_BarbarianCamps[i] == 0x7fffffff){
                m_BarbarianCamps[i] = -1;
            }
        }
    }
}

DifficultyRecord::Period::Period()
{
    m_StartTurn = 0;
    m_YearsPerTurn = 0;
}

DifficultyRecord::Period::~Period()
{
}

DifficultyRecord::Period const & DifficultyRecord::Period::operator = (Period const & rval)
{
    if (this != &rval)
    {

        m_StartTurn = rval.m_StartTurn;

        m_YearsPerTurn = rval.m_YearsPerTurn;

    }

    return *this;
}

void DifficultyRecord::Period::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_StartTurn;
        archive << m_YearsPerTurn;
    } else {
        archive >> m_StartTurn;
        archive >> m_YearsPerTurn;
    }
}

static const char *s_Difficulty_Period_Tokens[] = {
    "StartTurn",
    "YearsPerTurn",
    "START_TURN",
    "YEARS_PER_TURN",
};
#define k_Token_Difficulty_Period_StartTurn      ((k_Token_Custom_Base) + 0)
#define k_Token_Difficulty_Period_YearsPerTurn   ((k_Token_Custom_Base) + 1)
#define k_Token_Difficulty_Period_START_TURN     ((k_Token_Custom_Base) + 2)
#define k_Token_Difficulty_Period_YEARS_PER_TURN ((k_Token_Custom_Base) + 3)
#define k_Token_Difficulty_Period_Max ((k_Token_Custom_Base) + 4)
sint32 DifficultyRecord::Period::ParseSequential(DBLexer *lex)
{
    if(!lex->GetIntAssignment(m_StartTurn)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_YearsPerTurn)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 DifficultyRecord::Period::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetInt(m_StartTurn)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_YearsPerTurn)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 DifficultyRecord::Period::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for Period"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Difficulty_Period_Tokens, k_Token_Difficulty_Period_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Difficulty_Period_StartTurn:
            case k_Token_Difficulty_Period_START_TURN:
                if(!lex->GetIntAssignment(m_StartTurn)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_Period_YearsPerTurn:
            case k_Token_Difficulty_Period_YEARS_PER_TURN:
                if(!lex->GetIntAssignment(m_YearsPerTurn)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_StartTurn)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DifficultyRecord::Period::ParseInArray(DBLexer *lex, Period **array, sint32 *numElements)
{
    if(*numElements > 0) {
        Period *oldArray = *array;
        *array = new Period[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new Period[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::Period::ParseInArray(DBLexer *lex, Period *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::Period::ParseInArraySequential(DBLexer *lex, Period **array, sint32 *numElements)
{
    if(*numElements > 0) {
        Period *oldArray = *array;
        *array = new Period[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new Period[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::Period::ParseInArraySequential(DBLexer *lex, Period *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void DifficultyRecord::Period::ResolveDBReferences()
{
}

DifficultyRecord::TimeScale::TimeScale()
{
    m_StartYear = 0;
    m_NumPeriods = 0;
    m_Period = NULL;
    m_numPeriod = 0;
    m_NegativeYearFormat = 0;
    m_PositiveYearFormat = 0;
}

DifficultyRecord::TimeScale::~TimeScale()
{
    delete [] m_Period;
}

DifficultyRecord::TimeScale const & DifficultyRecord::TimeScale::operator = (TimeScale const & rval)
{
    if (this != &rval)
    {

        m_StartYear = rval.m_StartYear;

        m_NumPeriods = rval.m_NumPeriods;

        delete [] m_Period;
        m_Period = NULL;
        if (rval.m_numPeriod > 0)
        {
            m_Period = new Period [rval.m_numPeriod];
            std::copy(rval.m_Period, rval.m_Period + rval.m_numPeriod, m_Period);
        }
        m_numPeriod = rval.m_numPeriod;

        m_NegativeYearFormat = rval.m_NegativeYearFormat;

        m_PositiveYearFormat = rval.m_PositiveYearFormat;

    }

    return *this;
}

void DifficultyRecord::TimeScale::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_StartYear;
        archive << m_NumPeriods;

        {
            archive << m_numPeriod;
            for(sint32 i = 0; i < m_numPeriod; ++i){
                m_Period[i].Serialize(archive);
            }
        }

        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_NegativeYearFormat);
            archive << tmpString;
        }

        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_PositiveYearFormat);
            archive << tmpString;
        }

    } else {
        archive >> m_StartYear;
        archive >> m_NumPeriods;

        {
            archive >> m_numPeriod;
            m_Period = new Period[m_numPeriod];
            for(sint32 i = 0; i < m_numPeriod; ++i){
                m_Period[i].Serialize(archive);
            }
        }

        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_NegativeYearFormat);
            delete[] tmpString;
        }

        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_PositiveYearFormat);
            delete[] tmpString;
        }

    }
}

static const char *s_Difficulty_TimeScale_Tokens[] = {
    "StartYear",
    "NumPeriods",
    "Period",
    "NegativeYearFormat",
    "PositiveYearFormat",
    "START_YEAR",
    "NUM_PERIODS",
    "PERIOD",
    "NEGATIVE_YEAR_FORMAT",
    "POSITIVE_YEAR_FORMAT",
};
#define k_Token_Difficulty_TimeScale_StartYear   ((k_Token_Custom_Base) + 0)
#define k_Token_Difficulty_TimeScale_NumPeriods  ((k_Token_Custom_Base) + 1)
#define k_Token_Difficulty_TimeScale_Period      ((k_Token_Custom_Base) + 2)
#define k_Token_Difficulty_TimeScale_NegativeYearFormat ((k_Token_Custom_Base) + 3)
#define k_Token_Difficulty_TimeScale_PositiveYearFormat ((k_Token_Custom_Base) + 4)
#define k_Token_Difficulty_TimeScale_START_YEAR  ((k_Token_Custom_Base) + 5)
#define k_Token_Difficulty_TimeScale_NUM_PERIODS ((k_Token_Custom_Base) + 6)
#define k_Token_Difficulty_TimeScale_PERIOD      ((k_Token_Custom_Base) + 7)
#define k_Token_Difficulty_TimeScale_NEGATIVE_YEAR_FORMAT ((k_Token_Custom_Base) + 8)
#define k_Token_Difficulty_TimeScale_POSITIVE_YEAR_FORMAT ((k_Token_Custom_Base) + 9)
#define k_Token_Difficulty_TimeScale_Max ((k_Token_Custom_Base) + 10)
sint32 DifficultyRecord::TimeScale::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for TimeScale"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Difficulty_TimeScale_Tokens, k_Token_Difficulty_TimeScale_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Difficulty_TimeScale_StartYear:
            case k_Token_Difficulty_TimeScale_START_YEAR:
                if(!lex->GetIntAssignment(m_StartYear)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_TimeScale_NumPeriods:
            case k_Token_Difficulty_TimeScale_NUM_PERIODS:
                if(!lex->GetIntAssignment(m_NumPeriods)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_TimeScale_Period:
            case k_Token_Difficulty_TimeScale_PERIOD:
                if(!DifficultyRecord::Period::ParseInArray(lex, &m_Period, &m_numPeriod)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_TimeScale_NegativeYearFormat:
            case k_Token_Difficulty_TimeScale_NEGATIVE_YEAR_FORMAT:
                if(!lex->GetStringIdAssignment(m_NegativeYearFormat)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_TimeScale_PositiveYearFormat:
            case k_Token_Difficulty_TimeScale_POSITIVE_YEAR_FORMAT:
                if(!lex->GetStringIdAssignment(m_PositiveYearFormat)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_StartYear)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DifficultyRecord::TimeScale::ParseInArray(DBLexer *lex, TimeScale **array, sint32 *numElements)
{
    if(*numElements > 0) {
        TimeScale *oldArray = *array;
        *array = new TimeScale[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new TimeScale[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::TimeScale::ParseInArray(DBLexer *lex, TimeScale *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void DifficultyRecord::TimeScale::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numPeriod; i++) {
            m_Period[i].ResolveDBReferences();
        }
    }
}

DifficultyRecord::AdvanceChance::AdvanceChance()
{
    m_StartAdvance = 0x7fffffff;
    m_HumanChance = 0;
    m_AIChance = 0;
}

DifficultyRecord::AdvanceChance::~AdvanceChance()
{
}

DifficultyRecord::AdvanceChance const & DifficultyRecord::AdvanceChance::operator = (AdvanceChance const & rval)
{
    if (this != &rval)
    {

        m_StartAdvance = rval.m_StartAdvance;

        m_HumanChance = rval.m_HumanChance;

        m_AIChance = rval.m_AIChance;

    }

    return *this;
}

void DifficultyRecord::AdvanceChance::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_StartAdvance;
        archive << m_HumanChance;
        archive << m_AIChance;
    } else {
        archive >> m_StartAdvance;
        archive >> m_HumanChance;
        archive >> m_AIChance;
    }
}

static const char *s_Difficulty_AdvanceChance_Tokens[] = {
    "StartAdvance",
    "HumanChance",
    "AIChance",
};
#define k_Token_Difficulty_AdvanceChance_StartAdvance ((k_Token_Custom_Base) + 0)
#define k_Token_Difficulty_AdvanceChance_HumanChance ((k_Token_Custom_Base) + 1)
#define k_Token_Difficulty_AdvanceChance_AIChance ((k_Token_Custom_Base) + 2)
#define k_Token_Difficulty_AdvanceChance_Max ((k_Token_Custom_Base) + 3)
sint32 DifficultyRecord::AdvanceChance::ParseSequential(DBLexer *lex)
{
    if(!g_theAdvanceDB->GetRecordFromLexer(lex, m_StartAdvance)) {
        DBERROR(("Expected record from Advance DB"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_HumanChance)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_AIChance)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 DifficultyRecord::AdvanceChance::ParseFullySequential(DBLexer *lex)
{
    if(!g_theAdvanceDB->GetCurrentRecordFromLexer(lex, m_StartAdvance)) {
        DBERROR(("Expected record from Advance DB"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_HumanChance)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_AIChance)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 DifficultyRecord::AdvanceChance::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for AdvanceChance"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Difficulty_AdvanceChance_Tokens, k_Token_Difficulty_AdvanceChance_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Difficulty_AdvanceChance_StartAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_StartAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AdvanceChance_HumanChance:
                if(!lex->GetIntAssignment(m_HumanChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Difficulty_AdvanceChance_AIChance:
                if(!lex->GetIntAssignment(m_AIChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theAdvanceDB->GetCurrentRecordFromLexer(lex, m_StartAdvance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DifficultyRecord::AdvanceChance::ParseInArray(DBLexer *lex, AdvanceChance **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AdvanceChance *oldArray = *array;
        *array = new AdvanceChance[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AdvanceChance[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::AdvanceChance::ParseInArray(DBLexer *lex, AdvanceChance *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::AdvanceChance::ParseInArraySequential(DBLexer *lex, AdvanceChance **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AdvanceChance *oldArray = *array;
        *array = new AdvanceChance[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AdvanceChance[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::AdvanceChance::ParseInArraySequential(DBLexer *lex, AdvanceChance *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void DifficultyRecord::AdvanceChance::ResolveDBReferences()
{
    if(m_StartAdvance & 0x80000000) {
        sint32 id = m_StartAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_StartAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_StartAdvance == 0x7fffffff) {
        m_StartAdvance = -1;
    }
}

DifficultyRecord::AdvanceChances::AdvanceChances()
{
    m_AdvanceChance = NULL;
    m_numAdvanceChance = 0;
}

DifficultyRecord::AdvanceChances::~AdvanceChances()
{
    delete [] m_AdvanceChance;
}

DifficultyRecord::AdvanceChances const & DifficultyRecord::AdvanceChances::operator = (AdvanceChances const & rval)
{
    if (this != &rval)
    {

        delete [] m_AdvanceChance;
        m_AdvanceChance = NULL;
        if (rval.m_numAdvanceChance > 0)
        {
            m_AdvanceChance = new AdvanceChance [rval.m_numAdvanceChance];
            std::copy(rval.m_AdvanceChance, rval.m_AdvanceChance + rval.m_numAdvanceChance, m_AdvanceChance);
        }
        m_numAdvanceChance = rval.m_numAdvanceChance;

    }

    return *this;
}

void DifficultyRecord::AdvanceChances::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {

        {
            archive << m_numAdvanceChance;
            for(sint32 i = 0; i < m_numAdvanceChance; ++i){
                m_AdvanceChance[i].Serialize(archive);
            }
        }

    } else {

        {
            archive >> m_numAdvanceChance;
            m_AdvanceChance = new AdvanceChance[m_numAdvanceChance];
            for(sint32 i = 0; i < m_numAdvanceChance; ++i){
                m_AdvanceChance[i].Serialize(archive);
            }
        }

    }
}

static const char *s_Difficulty_AdvanceChances_Tokens[] = {
    "AdvanceChance",
};
#define k_Token_Difficulty_AdvanceChances_AdvanceChance ((k_Token_Custom_Base) + 0)
#define k_Token_Difficulty_AdvanceChances_Max ((k_Token_Custom_Base) + 1)
sint32 DifficultyRecord::AdvanceChances::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for AdvanceChances"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Difficulty_AdvanceChances_Tokens, k_Token_Difficulty_AdvanceChances_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Difficulty_AdvanceChances_AdvanceChance:
                if(!DifficultyRecord::AdvanceChance::ParseInArray(lex, &m_AdvanceChance, &m_numAdvanceChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!DifficultyRecord::AdvanceChance::ParseInArraySequential(lex, &m_AdvanceChance, &m_numAdvanceChance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DifficultyRecord::AdvanceChances::ParseInArray(DBLexer *lex, AdvanceChances **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AdvanceChances *oldArray = *array;
        *array = new AdvanceChances[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AdvanceChances[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 DifficultyRecord::AdvanceChances::ParseInArray(DBLexer *lex, AdvanceChances *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void DifficultyRecord::AdvanceChances::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numAdvanceChance; i++) {
            m_AdvanceChance[i].ResolveDBReferences();
        }
    }
}

void DifficultyRecord::Merge(const DifficultyRecord & rval){
    // replace array m_AIMinBehindTechnologyCost
    if (m_numAIMinBehindTechnologyCost != rval.m_numAIMinBehindTechnologyCost)
    {
        delete [] m_AIMinBehindTechnologyCost;
        m_AIMinBehindTechnologyCost = new double [rval.m_numAIMinBehindTechnologyCost];
    }
    m_numAIMinBehindTechnologyCost = rval.m_numAIMinBehindTechnologyCost;
    std::copy(rval.m_AIMinBehindTechnologyCost, rval.m_AIMinBehindTechnologyCost + rval.m_numAIMinBehindTechnologyCost, m_AIMinBehindTechnologyCost);

    // replace array m_AIMaxBehindTechnologyCost
    if (m_numAIMaxBehindTechnologyCost != rval.m_numAIMaxBehindTechnologyCost)
    {
        delete [] m_AIMaxBehindTechnologyCost;
        m_AIMaxBehindTechnologyCost = new double [rval.m_numAIMaxBehindTechnologyCost];
    }
    m_numAIMaxBehindTechnologyCost = rval.m_numAIMaxBehindTechnologyCost;
    std::copy(rval.m_AIMaxBehindTechnologyCost, rval.m_AIMaxBehindTechnologyCost + rval.m_numAIMaxBehindTechnologyCost, m_AIMaxBehindTechnologyCost);

    // replace array m_AIMinBehindProductionCostAdjustment
    if (m_numAIMinBehindProductionCostAdjustment != rval.m_numAIMinBehindProductionCostAdjustment)
    {
        delete [] m_AIMinBehindProductionCostAdjustment;
        m_AIMinBehindProductionCostAdjustment = new double [rval.m_numAIMinBehindProductionCostAdjustment];
    }
    m_numAIMinBehindProductionCostAdjustment = rval.m_numAIMinBehindProductionCostAdjustment;
    std::copy(rval.m_AIMinBehindProductionCostAdjustment, rval.m_AIMinBehindProductionCostAdjustment + rval.m_numAIMinBehindProductionCostAdjustment, m_AIMinBehindProductionCostAdjustment);

    // replace array m_AIMaxBehindProductionCostAdjustment
    if (m_numAIMaxBehindProductionCostAdjustment != rval.m_numAIMaxBehindProductionCostAdjustment)
    {
        delete [] m_AIMaxBehindProductionCostAdjustment;
        m_AIMaxBehindProductionCostAdjustment = new double [rval.m_numAIMaxBehindProductionCostAdjustment];
    }
    m_numAIMaxBehindProductionCostAdjustment = rval.m_numAIMaxBehindProductionCostAdjustment;
    std::copy(rval.m_AIMaxBehindProductionCostAdjustment, rval.m_AIMaxBehindProductionCostAdjustment + rval.m_numAIMaxBehindProductionCostAdjustment, m_AIMaxBehindProductionCostAdjustment);

    // replace array m_AIMinBehindGoldCostAdjustment
    if (m_numAIMinBehindGoldCostAdjustment != rval.m_numAIMinBehindGoldCostAdjustment)
    {
        delete [] m_AIMinBehindGoldCostAdjustment;
        m_AIMinBehindGoldCostAdjustment = new double [rval.m_numAIMinBehindGoldCostAdjustment];
    }
    m_numAIMinBehindGoldCostAdjustment = rval.m_numAIMinBehindGoldCostAdjustment;
    std::copy(rval.m_AIMinBehindGoldCostAdjustment, rval.m_AIMinBehindGoldCostAdjustment + rval.m_numAIMinBehindGoldCostAdjustment, m_AIMinBehindGoldCostAdjustment);

    // replace array m_AIMaxBehindGoldCostAdjustment
    if (m_numAIMaxBehindGoldCostAdjustment != rval.m_numAIMaxBehindGoldCostAdjustment)
    {
        delete [] m_AIMaxBehindGoldCostAdjustment;
        m_AIMaxBehindGoldCostAdjustment = new double [rval.m_numAIMaxBehindGoldCostAdjustment];
    }
    m_numAIMaxBehindGoldCostAdjustment = rval.m_numAIMaxBehindGoldCostAdjustment;
    std::copy(rval.m_AIMaxBehindGoldCostAdjustment, rval.m_AIMaxBehindGoldCostAdjustment + rval.m_numAIMaxBehindGoldCostAdjustment, m_AIMaxBehindGoldCostAdjustment);

    // replace array m_AIMinAheadTechnologyCost
    if (m_numAIMinAheadTechnologyCost != rval.m_numAIMinAheadTechnologyCost)
    {
        delete [] m_AIMinAheadTechnologyCost;
        m_AIMinAheadTechnologyCost = new double [rval.m_numAIMinAheadTechnologyCost];
    }
    m_numAIMinAheadTechnologyCost = rval.m_numAIMinAheadTechnologyCost;
    std::copy(rval.m_AIMinAheadTechnologyCost, rval.m_AIMinAheadTechnologyCost + rval.m_numAIMinAheadTechnologyCost, m_AIMinAheadTechnologyCost);

    // replace array m_AIMaxAheadTechnologyCost
    if (m_numAIMaxAheadTechnologyCost != rval.m_numAIMaxAheadTechnologyCost)
    {
        delete [] m_AIMaxAheadTechnologyCost;
        m_AIMaxAheadTechnologyCost = new double [rval.m_numAIMaxAheadTechnologyCost];
    }
    m_numAIMaxAheadTechnologyCost = rval.m_numAIMaxAheadTechnologyCost;
    std::copy(rval.m_AIMaxAheadTechnologyCost, rval.m_AIMaxAheadTechnologyCost + rval.m_numAIMaxAheadTechnologyCost, m_AIMaxAheadTechnologyCost);

    // replace array m_AIMinAheadProductionCostAdjustment
    if (m_numAIMinAheadProductionCostAdjustment != rval.m_numAIMinAheadProductionCostAdjustment)
    {
        delete [] m_AIMinAheadProductionCostAdjustment;
        m_AIMinAheadProductionCostAdjustment = new double [rval.m_numAIMinAheadProductionCostAdjustment];
    }
    m_numAIMinAheadProductionCostAdjustment = rval.m_numAIMinAheadProductionCostAdjustment;
    std::copy(rval.m_AIMinAheadProductionCostAdjustment, rval.m_AIMinAheadProductionCostAdjustment + rval.m_numAIMinAheadProductionCostAdjustment, m_AIMinAheadProductionCostAdjustment);

    // replace array m_AIMaxAheadProductionCostAdjustment
    if (m_numAIMaxAheadProductionCostAdjustment != rval.m_numAIMaxAheadProductionCostAdjustment)
    {
        delete [] m_AIMaxAheadProductionCostAdjustment;
        m_AIMaxAheadProductionCostAdjustment = new double [rval.m_numAIMaxAheadProductionCostAdjustment];
    }
    m_numAIMaxAheadProductionCostAdjustment = rval.m_numAIMaxAheadProductionCostAdjustment;
    std::copy(rval.m_AIMaxAheadProductionCostAdjustment, rval.m_AIMaxAheadProductionCostAdjustment + rval.m_numAIMaxAheadProductionCostAdjustment, m_AIMaxAheadProductionCostAdjustment);

    // replace array m_AIMinAheadGoldCostAdjustment
    if (m_numAIMinAheadGoldCostAdjustment != rval.m_numAIMinAheadGoldCostAdjustment)
    {
        delete [] m_AIMinAheadGoldCostAdjustment;
        m_AIMinAheadGoldCostAdjustment = new double [rval.m_numAIMinAheadGoldCostAdjustment];
    }
    m_numAIMinAheadGoldCostAdjustment = rval.m_numAIMinAheadGoldCostAdjustment;
    std::copy(rval.m_AIMinAheadGoldCostAdjustment, rval.m_AIMinAheadGoldCostAdjustment + rval.m_numAIMinAheadGoldCostAdjustment, m_AIMinAheadGoldCostAdjustment);

    // replace array m_AIMaxAheadGoldCostAdjustment
    if (m_numAIMaxAheadGoldCostAdjustment != rval.m_numAIMaxAheadGoldCostAdjustment)
    {
        delete [] m_AIMaxAheadGoldCostAdjustment;
        m_AIMaxAheadGoldCostAdjustment = new double [rval.m_numAIMaxAheadGoldCostAdjustment];
    }
    m_numAIMaxAheadGoldCostAdjustment = rval.m_numAIMaxAheadGoldCostAdjustment;
    std::copy(rval.m_AIMaxAheadGoldCostAdjustment, rval.m_AIMaxAheadGoldCostAdjustment + rval.m_numAIMaxAheadGoldCostAdjustment, m_AIMaxAheadGoldCostAdjustment);

    // resize m_BarbarianCamps if necessary
    if (rval.m_numBarbarianCamps > m_numBarbarianCamps)
    {
        delete [] m_BarbarianCamps;
        m_BarbarianCamps = NULL;
        if (rval.m_numBarbarianCamps > 0)
            m_BarbarianCamps = new sint32 [rval.m_numBarbarianCamps];
        m_numBarbarianCamps = rval.m_numBarbarianCamps;
    }
    if (rval.m_numBarbarianCamps > 0)
        std::copy(rval.m_BarbarianCamps, rval.m_BarbarianCamps + rval.m_numBarbarianCamps, m_BarbarianCamps);

    // only replace values that have been set
    if (rval.m_flags0 & k_Difficulty_GoldPerUnitSupport_Bit)
    {
        m_GoldPerUnitSupportValue = rval.m_GoldPerUnitSupportValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Difficulty_GoldPerCity_Bit)
    {
        m_GoldPerCityValue = rval.m_GoldPerCityValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Difficulty_TechCostKnownDeduction_Bit)
    {
        m_TechCostKnownDeductionValue = rval.m_TechCostKnownDeductionValue;
    }

}

double DifficultyRecord::GetAIMinBehindTechnologyCost(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMinBehindTechnologyCost);
    if((index < 0) || (index >= m_numAIMinBehindTechnologyCost)) {
        return 0;
    }
    return m_AIMinBehindTechnologyCost[index];
}

double DifficultyRecord::GetAIMaxBehindTechnologyCost(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMaxBehindTechnologyCost);
    if((index < 0) || (index >= m_numAIMaxBehindTechnologyCost)) {
        return 0;
    }
    return m_AIMaxBehindTechnologyCost[index];
}

double DifficultyRecord::GetAIMinBehindProductionCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMinBehindProductionCostAdjustment);
    if((index < 0) || (index >= m_numAIMinBehindProductionCostAdjustment)) {
        return 0;
    }
    return m_AIMinBehindProductionCostAdjustment[index];
}

double DifficultyRecord::GetAIMaxBehindProductionCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMaxBehindProductionCostAdjustment);
    if((index < 0) || (index >= m_numAIMaxBehindProductionCostAdjustment)) {
        return 0;
    }
    return m_AIMaxBehindProductionCostAdjustment[index];
}

double DifficultyRecord::GetAIMinBehindGoldCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMinBehindGoldCostAdjustment);
    if((index < 0) || (index >= m_numAIMinBehindGoldCostAdjustment)) {
        return 0;
    }
    return m_AIMinBehindGoldCostAdjustment[index];
}

double DifficultyRecord::GetAIMaxBehindGoldCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMaxBehindGoldCostAdjustment);
    if((index < 0) || (index >= m_numAIMaxBehindGoldCostAdjustment)) {
        return 0;
    }
    return m_AIMaxBehindGoldCostAdjustment[index];
}

double DifficultyRecord::GetAIMinAheadTechnologyCost(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMinAheadTechnologyCost);
    if((index < 0) || (index >= m_numAIMinAheadTechnologyCost)) {
        return 0;
    }
    return m_AIMinAheadTechnologyCost[index];
}

double DifficultyRecord::GetAIMaxAheadTechnologyCost(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMaxAheadTechnologyCost);
    if((index < 0) || (index >= m_numAIMaxAheadTechnologyCost)) {
        return 0;
    }
    return m_AIMaxAheadTechnologyCost[index];
}

double DifficultyRecord::GetAIMinAheadProductionCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMinAheadProductionCostAdjustment);
    if((index < 0) || (index >= m_numAIMinAheadProductionCostAdjustment)) {
        return 0;
    }
    return m_AIMinAheadProductionCostAdjustment[index];
}

double DifficultyRecord::GetAIMaxAheadProductionCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMaxAheadProductionCostAdjustment);
    if((index < 0) || (index >= m_numAIMaxAheadProductionCostAdjustment)) {
        return 0;
    }
    return m_AIMaxAheadProductionCostAdjustment[index];
}

double DifficultyRecord::GetAIMinAheadGoldCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMinAheadGoldCostAdjustment);
    if((index < 0) || (index >= m_numAIMinAheadGoldCostAdjustment)) {
        return 0;
    }
    return m_AIMinAheadGoldCostAdjustment[index];
}

double DifficultyRecord::GetAIMaxAheadGoldCostAdjustment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAIMaxAheadGoldCostAdjustment);
    if((index < 0) || (index >= m_numAIMaxAheadGoldCostAdjustment)) {
        return 0;
    }
    return m_AIMaxAheadGoldCostAdjustment[index];
}

sint32 DifficultyRecord::GetBarbarianCampsIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBarbarianCamps);
    if((index < 0) || (index >= m_numBarbarianCamps)) {
        return 0;
    }
    return m_BarbarianCamps[index];
}

TerrainImprovementRecord const * DifficultyRecord::GetBarbarianCamps(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBarbarianCamps);
    if((index < 0) || (index >= m_numBarbarianCamps)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_BarbarianCamps[index]);
}

const DifficultyRecord::Period * DifficultyRecord::TimeScale::GetPeriod(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPeriod);
    if((index < 0) || (index >= m_numPeriod)) {
        return 0;
    }
    return &m_Period[index];
}

const AdvanceRecord *DifficultyRecord::AdvanceChance::GetStartAdvance() const
{
    return g_theAdvanceDB->Get(m_StartAdvance);
}

const DifficultyRecord::AdvanceChance * DifficultyRecord::AdvanceChances::GetAdvanceChance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAdvanceChance);
    if((index < 0) || (index >= m_numAdvanceChance)) {
        return 0;
    }
    return &m_AdvanceChance[index];
}

