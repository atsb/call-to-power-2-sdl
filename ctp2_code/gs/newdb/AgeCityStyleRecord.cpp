
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "AgeCityStyleRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"


CTPDatabase<AgeCityStyleRecord> *g_theAgeCityStyleDB = NULL;

void AgeCityStyleRecord::Init()
{
    m_Sprites = NULL;
    m_numSprites = 0;
    m_HappyInc = 0;
    m_ProductionPercent = 0.000000;
    m_FoodPercent = 0.000000;
    m_CommercePercent = 0.000000;
    m_SciencePercent = 0.000000;
    m_BonusGold = 0;
    m_BonusFood = 0;
    m_BonusProduction = 0;
    m_BonusScience = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void AgeCityStyleRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }

        {
            archive << m_numSprites;
            for(sint32 i = 0; i < m_numSprites; ++i){
                m_Sprites[i].Serialize(archive);
            }
        }

        archive << m_HappyInc;
        archive << m_ProductionPercent;
        archive << m_FoodPercent;
        archive << m_CommercePercent;
        archive << m_SciencePercent;
        archive << m_BonusGold;
        archive << m_BonusFood;
        archive << m_BonusProduction;
        archive << m_BonusScience;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }

        {
            archive >> m_numSprites;
            m_Sprites = new SizeSprite[m_numSprites];
            for(sint32 i = 0; i < m_numSprites; ++i){
                m_Sprites[i].Serialize(archive);
            }
        }

        archive >> m_HappyInc;
        archive >> m_ProductionPercent;
        archive >> m_FoodPercent;
        archive >> m_CommercePercent;
        archive >> m_SciencePercent;
        archive >> m_BonusGold;
        archive >> m_BonusFood;
        archive >> m_BonusProduction;
        archive >> m_BonusScience;
    }
}

AgeCityStyleRecord::~AgeCityStyleRecord()
{
    delete [] m_Sprites;
}

AgeCityStyleRecord const & AgeCityStyleRecord::operator = (AgeCityStyleRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        delete [] m_Sprites;
        m_Sprites = NULL;
        if (rval.m_numSprites > 0)
        {
            m_Sprites = new SizeSprite [rval.m_numSprites];
            std::copy(rval.m_Sprites, rval.m_Sprites + rval.m_numSprites, m_Sprites);
        }
        m_numSprites = rval.m_numSprites;

        m_HappyInc = rval.m_HappyInc;

        m_ProductionPercent = rval.m_ProductionPercent;

        m_FoodPercent = rval.m_FoodPercent;

        m_CommercePercent = rval.m_CommercePercent;

        m_SciencePercent = rval.m_SciencePercent;

        m_BonusGold = rval.m_BonusGold;

        m_BonusFood = rval.m_BonusFood;

        m_BonusProduction = rval.m_BonusProduction;

        m_BonusScience = rval.m_BonusScience;

    }

    return *this;
}

const char *g_AgeCityStyle_Tokens[] =
{
    "Sprites",
    "HappyInc",
    "ProductionPercent",
    "FoodPercent",
    "CommercePercent",
    "SciencePercent",
    "BonusGold",
    "BonusFood",
    "BonusProduction",
    "BonusScience",
};

AgeCityStyleRecordAccessorInfo g_AgeCityStyleRecord_Accessors[] =
{
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Sprites */
    { &AgeCityStyleRecord::GetHappyInc, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &AgeCityStyleRecord::GetProductionPercent, NULL, NULL, NULL, NULL },
    { NULL, NULL, &AgeCityStyleRecord::GetFoodPercent, NULL, NULL, NULL, NULL },
    { NULL, NULL, &AgeCityStyleRecord::GetCommercePercent, NULL, NULL, NULL, NULL },
    { NULL, NULL, &AgeCityStyleRecord::GetSciencePercent, NULL, NULL, NULL, NULL },
    { &AgeCityStyleRecord::GetBonusGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AgeCityStyleRecord::GetBonusFood, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AgeCityStyleRecord::GetBonusProduction, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AgeCityStyleRecord::GetBonusScience, NULL, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_AgeCityStyle_Sprites             ((k_Token_Custom_Base) + 0)
#define k_Token_AgeCityStyle_HappyInc            ((k_Token_Custom_Base) + 1)
#define k_Token_AgeCityStyle_ProductionPercent   ((k_Token_Custom_Base) + 2)
#define k_Token_AgeCityStyle_FoodPercent         ((k_Token_Custom_Base) + 3)
#define k_Token_AgeCityStyle_CommercePercent     ((k_Token_Custom_Base) + 4)
#define k_Token_AgeCityStyle_SciencePercent      ((k_Token_Custom_Base) + 5)
#define k_Token_AgeCityStyle_BonusGold           ((k_Token_Custom_Base) + 6)
#define k_Token_AgeCityStyle_BonusFood           ((k_Token_Custom_Base) + 7)
#define k_Token_AgeCityStyle_BonusProduction     ((k_Token_Custom_Base) + 8)
#define k_Token_AgeCityStyle_BonusScience        ((k_Token_Custom_Base) + 9)
#define k_Token_AgeCityStyle_Max                 ((k_Token_Custom_Base) + 10)


static BitArray s_ParsedTokens(10);
void AgeCityStyleRecord::CheckRequiredFields(DBLexer *lex)
{
}

sint32 AgeCityStyleRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_AgeCityStyle_Tokens, k_Token_AgeCityStyle_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "AGECITYSTYLE_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_AgeCityStyle_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_AgeCityStyle_Sprites:
                if(!AgeCityStyleRecord::SizeSprite::ParseInArray(lex, &m_Sprites, &m_numSprites))
                {
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_HappyInc:
                if(!lex->GetIntAssignment(m_HappyInc)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_ProductionPercent:
                if(!lex->GetFloatAssignment(m_ProductionPercent)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_FoodPercent:
                if(!lex->GetFloatAssignment(m_FoodPercent)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_CommercePercent:
                if(!lex->GetFloatAssignment(m_CommercePercent)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_SciencePercent:
                if(!lex->GetFloatAssignment(m_SciencePercent)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_BonusGold:
                if(!lex->GetIntAssignment(m_BonusGold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_BonusFood:
                if(!lex->GetIntAssignment(m_BonusFood)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_BonusProduction:
                if(!lex->GetIntAssignment(m_BonusProduction)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_BonusScience:
                if(!lex->GetIntAssignment(m_BonusScience)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!AgeCityStyleRecord::SizeSprite::ParseInArray(lex, &m_Sprites, &m_numSprites)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void AgeCityStyleRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numSprites; i++) {
            m_Sprites[i].ResolveDBReferences();
        }
    }
}

AgeCityStyleRecord::SizeSprite::SizeSprite()
{
    m_Type = 0;
    m_MinSize = 0;
    m_MaxSize = 0;
    m_Sprite = 0;
    m_Walls = 38;
    m_ForceField = 154;
}

AgeCityStyleRecord::SizeSprite::~SizeSprite()
{
}

AgeCityStyleRecord::SizeSprite const & AgeCityStyleRecord::SizeSprite::operator = (SizeSprite const & rval)
{
    if (this != &rval)
    {

        m_Type = rval.m_Type;

        m_MinSize = rval.m_MinSize;

        m_MaxSize = rval.m_MaxSize;

        m_Sprite = rval.m_Sprite;

        m_Walls = rval.m_Walls;

        m_ForceField = rval.m_ForceField;

    }

    return *this;
}

void AgeCityStyleRecord::SizeSprite::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Type;
        archive << m_MinSize;
        archive << m_MaxSize;
        archive << m_Sprite;
        archive << m_Walls;
        archive << m_ForceField;
    } else {
        archive >> m_Type;
        archive >> m_MinSize;
        archive >> m_MaxSize;
        archive >> m_Sprite;
        archive >> m_Walls;
        archive >> m_ForceField;
    }
}

static const char *s_AgeCityStyle_SizeSprite_Tokens[] = {
    "Type",
    "MinSize",
    "MaxSize",
    "Sprite",
    "Walls",
    "ForceField",
};
#define k_Token_AgeCityStyle_SizeSprite_Type     ((k_Token_Custom_Base) + 0)
#define k_Token_AgeCityStyle_SizeSprite_MinSize  ((k_Token_Custom_Base) + 1)
#define k_Token_AgeCityStyle_SizeSprite_MaxSize  ((k_Token_Custom_Base) + 2)
#define k_Token_AgeCityStyle_SizeSprite_Sprite   ((k_Token_Custom_Base) + 3)
#define k_Token_AgeCityStyle_SizeSprite_Walls    ((k_Token_Custom_Base) + 4)
#define k_Token_AgeCityStyle_SizeSprite_ForceField ((k_Token_Custom_Base) + 5)
#define k_Token_AgeCityStyle_SizeSprite_Max ((k_Token_Custom_Base) + 6)
sint32 AgeCityStyleRecord::SizeSprite::ParseSequential(DBLexer *lex)
{
    if(!lex->GetIntAssignment(m_Type)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_MinSize)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_MaxSize)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Sprite)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Walls)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_ForceField)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 AgeCityStyleRecord::SizeSprite::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetInt(m_Type)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_MinSize)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_MaxSize)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Sprite)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Walls)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_ForceField)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 AgeCityStyleRecord::SizeSprite::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SizeSprite"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_AgeCityStyle_SizeSprite_Tokens, k_Token_AgeCityStyle_SizeSprite_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_AgeCityStyle_SizeSprite_Type:
                if(!lex->GetIntAssignment(m_Type)) {
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_SizeSprite_MinSize:
                if(!lex->GetIntAssignment(m_MinSize)) {
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_SizeSprite_MaxSize:
                if(!lex->GetIntAssignment(m_MaxSize)) {
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_SizeSprite_Sprite:
                if(!lex->GetIntAssignment(m_Sprite)) {
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_SizeSprite_Walls:
                if(!lex->GetIntAssignment(m_Walls)) {
                    done = true; break;
                }
                break;
            case k_Token_AgeCityStyle_SizeSprite_ForceField:
                if(!lex->GetIntAssignment(m_ForceField)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Type)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 AgeCityStyleRecord::SizeSprite::ParseInArray(DBLexer *lex, SizeSprite **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SizeSprite *oldArray = *array;
        *array = new SizeSprite[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SizeSprite[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 AgeCityStyleRecord::SizeSprite::ParseInArray(DBLexer *lex, SizeSprite *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 AgeCityStyleRecord::SizeSprite::ParseInArraySequential(DBLexer *lex, SizeSprite **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SizeSprite *oldArray = *array;
        *array = new SizeSprite[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SizeSprite[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 AgeCityStyleRecord::SizeSprite::ParseInArraySequential(DBLexer *lex, SizeSprite *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void AgeCityStyleRecord::SizeSprite::ResolveDBReferences()
{
}

void AgeCityStyleRecord::Merge(const AgeCityStyleRecord & rval){
    // replace struct elements of m_Sprites
    for (sint32 index_Sprites = 0; index_Sprites < m_numSprites; ++index_Sprites)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numSprites; ++obj_index)
            if (m_Sprites[index_Sprites] == rval.m_Sprites[obj_index]){
                m_Sprites[index_Sprites] = rval.m_Sprites[obj_index];
            }
    }
}

AgeCityStyleRecord::SizeSprite const * AgeCityStyleRecord::GetSprites(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSprites);
    if((index < 0) || (index >= m_numSprites)) {
        return 0;
    }
    return &m_Sprites[index];
}

