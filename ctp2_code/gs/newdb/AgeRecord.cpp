
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "AgeRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"


CTPDatabase<AgeRecord> *g_theAgeDB = NULL;

void AgeRecord::Init()
{
    m_Age = 0;
    m_StartingRound = 0;
    m_NeedAdvances = 0;
    m_SlicObject = NULL;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void AgeRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_Age;
        archive << m_StartingRound;
        archive << m_NeedAdvances;
        archive << m_SlicObject;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_Age;
        archive >> m_StartingRound;
        archive >> m_NeedAdvances;
        m_SlicObject = NULL;
        archive >> m_SlicObject;

    }
}

AgeRecord::~AgeRecord()
{
    delete m_SlicObject;
}

AgeRecord const & AgeRecord::operator = (AgeRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_Age = rval.m_Age;

        m_StartingRound = rval.m_StartingRound;

        m_NeedAdvances = rval.m_NeedAdvances;

        delete [] m_SlicObject;
        m_SlicObject = NULL;

        if (rval.m_SlicObject)
        {
            m_SlicObject = new char [strlen(rval.m_SlicObject)+1];
            strcpy(m_SlicObject, rval.m_SlicObject);
        }

    }

    return *this;
}

const char *g_Age_Tokens[] =
{
    "Age",
    "StartingRound",
    "NeedAdvances",
    "SlicObject",
};

AgeRecordAccessorInfo g_AgeRecord_Accessors[] =
{
    { &AgeRecord::GetAge, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AgeRecord::GetStartingRound, NULL, NULL, NULL, NULL, NULL, NULL },
    { &AgeRecord::GetNeedAdvances, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlicObject */
};

#define k_Token_Age_Age                          ((k_Token_Custom_Base) + 0)
#define k_Token_Age_StartingRound                ((k_Token_Custom_Base) + 1)
#define k_Token_Age_NeedAdvances                 ((k_Token_Custom_Base) + 2)
#define k_Token_Age_SlicObject                   ((k_Token_Custom_Base) + 3)
#define k_Token_Age_Max                          ((k_Token_Custom_Base) + 4)


static BitArray s_ParsedTokens(4);
void AgeRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Age_Age - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Age missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Age_StartingRound - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field StartingRound missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Age_NeedAdvances - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field NeedAdvances missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Age_SlicObject - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field SlicObject missing"));
    }
}

sint32 AgeRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Age_Tokens, k_Token_Age_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "AGE_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Age_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Age_Age:
                if(!lex->GetIntAssignment(m_Age)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Age_StartingRound:
                if(!lex->GetIntAssignment(m_StartingRound)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Age_NeedAdvances:
                if(!lex->GetIntAssignment(m_NeedAdvances)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Age_SlicObject:
                if(!lex->GetFileAssignment(m_SlicObject)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_Age)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void AgeRecord::ResolveDBReferences()
{
}

void AgeRecord::Merge(const AgeRecord & rval){
}

