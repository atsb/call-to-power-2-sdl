
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "UnitRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "GovernmentRecord.h"
#include "TerrainRecord.h"
#include "CityStyleRecord.h"
#include "CityStyleRecord.h"
#include "CivilisationRecord.h"
#include "GovernmentRecord.h"
#include "TerrainImprovementRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "FeatRecord.h"
#include "FeatRecord.h"
#include "WonderRecord.h"
#include "WonderRecord.h"
#include "TerrainImprovementRecord.h"
#include "BuildingRecord.h"
#include "BuildingRecord.h"
#include "GovernmentRecord.h"
#include "SpriteRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SpecialAttackInfoRecord.h"
#include "IconRecord.h"
#include "MapIconRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"

CTPDatabase<UnitRecord> *g_theUnitDB = NULL;

void UnitRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    m_flags3 = 0;
    m_flags4 = 0;
    m_flags5 = 0;
    m_flags6 = 0;
    m_flags7 = 0;
    m_MovementType = 0;
    m_CanCarry = 0;
    m_EnableAdvance = 0x7fffffff;
    memset(m_ObsoleteAdvance, 0, sizeof(m_ObsoleteAdvance));
    m_numObsoleteAdvance = 0;
    m_PrerequisiteBuilding = NULL;
    m_numPrerequisiteBuilding = 0;
    m_ExcludedByBuilding = NULL;
    m_numExcludedByBuilding = 0;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_CanSettleOn = NULL;
    m_numCanSettleOn = 0;
    m_UpgradeTo = NULL;
    m_numUpgradeTo = 0;
    m_ObsoleteUnit = NULL;
    m_numObsoleteUnit = 0;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_CityStyleOnly = NULL;
    m_numCityStyleOnly = 0;
    m_CivilisationOnly = NULL;
    m_numCivilisationOnly = 0;
    m_GovernmentOnly = NULL;
    m_numGovernmentOnly = 0;
    m_SettleImprovement = NULL;
    m_numSettleImprovement = 0;
    m_NeedsCityGood = NULL;
    m_numNeedsCityGood = 0;
    m_NeedsCityGoodAll = NULL;
    m_numNeedsCityGoodAll = 0;
    m_NeedsCityGoodCapitol = NULL;
    m_numNeedsCityGoodCapitol = 0;
    m_NeedsCityGoodAnyCity = NULL;
    m_numNeedsCityGoodAnyCity = 0;
    m_NeedsFeatToBuild = NULL;
    m_numNeedsFeatToBuild = 0;
    m_NeedsAnyPlayerFeatToBuild = NULL;
    m_numNeedsAnyPlayerFeatToBuild = 0;
    m_PrerequisiteWonder = NULL;
    m_numPrerequisiteWonder = 0;
    m_ExcludedByWonder = NULL;
    m_numExcludedByWonder = 0;
    m_MoveBonusValue = 0;
    m_PWMoveCostValue = 0;
    m_MerchantGoldValue = 0;
    m_AllTerrainAsImprovement = NULL;
    m_numAllTerrainAsImprovement = 0;
    m_ObsoleteByUnit = NULL;
    m_numObsoleteByUnit = 0;
    m_Size = 0;
    m_CanBombard = 0;
    m_Settle = 0;
    m_SettleCityType = 0x7fffffff;
    m_SettleSize = 1;
    m_SettleBuilding = NULL;
    m_numSettleBuilding = 0;
    m_EstablishBuilding = NULL;
    m_numEstablishBuilding = 0;
    m_SpaceLaunchValue = 0;
    m_Defend = 0;
    m_DefendAgainstSpiesValue = 0.000000;
    m_DefendAirBonusValue = 0.000000;
    m_DefendCityBonusValue = 0.000000;
    m_DefendSubmarineBonusValue = 0.000000;
    m_DefendFootBonusValue = 0.000000;
    m_DefendMeleeBonusValue = 0.000000;
    m_DefendSiegeBonusValue = 0.000000;
    m_DefendWheeledBonusValue = 0.000000;
    m_DefendMechanizedBonusValue = 0.000000;
    m_DefendHelicopterBonusValue = 0.000000;
    m_DefendSpecialForcesBonusValue = 0.000000;
    m_DefendCivilianBonusValue = 0.000000;
    m_DefendGuerrillaBonusValue = 0.000000;
    m_DefendMountedBonusValue = 0.000000;
    m_DefendWoodenShipBonusValue = 0.000000;
    m_DefendSurfaceShipBonusValue = 0.000000;
    m_AttackAirBonusValue = 0.000000;
    m_AttackCityBonusValue = 0.000000;
    m_AttackSubmarineBonusValue = 0.000000;
    m_AttackFootBonusValue = 0.000000;
    m_AttackMeleeBonusValue = 0.000000;
    m_AttackSiegeBonusValue = 0.000000;
    m_AttackWheeledBonusValue = 0.000000;
    m_AttackMechanizedBonusValue = 0.000000;
    m_AttackHelicopterBonusValue = 0.000000;
    m_AttackSpecialForcesBonusValue = 0.000000;
    m_AttackCivilianBonusValue = 0.000000;
    m_AttackGuerrillaBonusValue = 0.000000;
    m_AttackMountedBonusValue = 0.000000;
    m_AttackWoodenShipBonusNewValue = 0.000000;
    m_AttackSurfaceShipBonusValue = 0.000000;
    m_RangedAirBonusValue = 0.000000;
    m_RangedAttackCityBonusValue = 0.000000;
    m_RangedDefendCityBonusValue = 0.000000;
    m_RangedSubmarineBonusValue = 0.000000;
    m_RangedFootBonusValue = 0.000000;
    m_RangedMeleeBonusValue = 0.000000;
    m_RangedSiegeBonusValue = 0.000000;
    m_RangedWheeledBonusValue = 0.000000;
    m_RangedMechanizedBonusValue = 0.000000;
    m_RangedHelicopterBonusValue = 0.000000;
    m_RangedSpecialForcesBonusValue = 0.000000;
    m_RangedCivilianBonusValue = 0.000000;
    m_RangedGuerrillaBonusValue = 0.000000;
    m_RangedMountedBonusValue = 0.000000;
    m_RangedWoodenShipBonusValue = 0.000000;
    m_RangedSurfaceShipBonusValue = 0.000000;
    m_WoodenShipBonusValue = 0.000000;
    m_MountedBonusValue = 0.000000;
    m_AirBonusValue = 0.000000;
    m_ReplaceWithCargoModuleValue = 0;
    memset(&m_NuclearAttackValue, 0, sizeof(m_NuclearAttackValue));
    memset(&m_StealTechnologyValue, 0, sizeof(m_StealTechnologyValue));
    memset(&m_InciteRevolutionValue, 0, sizeof(m_InciteRevolutionValue));
    memset(&m_AssasinateRulerValue, 0, sizeof(m_AssasinateRulerValue));
    memset(&m_InvestigateReadinessValue, 0, sizeof(m_InvestigateReadinessValue));
    memset(&m_CreateFranchiseValue, 0, sizeof(m_CreateFranchiseValue));
    memset(&m_CauseUnhappinessValue, 0, sizeof(m_CauseUnhappinessValue));
    memset(&m_ConductHitsValue, 0, sizeof(m_ConductHitsValue));
    memset(&m_BioTerrorValue, 0, sizeof(m_BioTerrorValue));
    memset(&m_NanoTerrorValue, 0, sizeof(m_NanoTerrorValue));
    memset(&m_PlagueValue, 0, sizeof(m_PlagueValue));
    memset(&m_SlaveRaidsValue, 0, sizeof(m_SlaveRaidsValue));
    memset(&m_SettlerSlaveRaidsValue, 0, sizeof(m_SettlerSlaveRaidsValue));
    memset(&m_SlaveUprisingValue, 0, sizeof(m_SlaveUprisingValue));
    memset(&m_UndergroundRailwayValue, 0, sizeof(m_UndergroundRailwayValue));
    m_VictoryEnslavementChanceValue = 0.000000;
    memset(&m_IndulgenceSalesValue, 0, sizeof(m_IndulgenceSalesValue));
    memset(&m_ConvertCitiesValue, 0, sizeof(m_ConvertCitiesValue));
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    memset(&m_PlantNukeValue, 0, sizeof(m_PlantNukeValue));
    memset(&m_CanSoothsayValue, 0, sizeof(m_CanSoothsayValue));
    memset(&m_CreateParksValue, 0, sizeof(m_CreateParksValue));
    memset(&m_CanInjoinValue, 0, sizeof(m_CanInjoinValue));
    m_PopCostsToBuildValue = 0;
    memset(&m_CanReformValue, 0, sizeof(m_CanReformValue));
    m_ReducesDefensesBonus = 0;
    m_VisionClass = 0;
    m_CanSee = 0;
    m_CanAttack = 0;
    memset(&m_CargoDataValue, 0, sizeof(m_CargoDataValue));
    m_ShieldCost = 0;
    m_PowerPoints = 0;
    m_MaxHP = 0;
    m_MaxHPr = 1.000000;
    m_Attack = 0.000000;
    m_Defense = 0.000000;
    m_Firepower = 0;
    m_ZBRangeAttack = 0;
    m_Armor = 0.000000;
    m_BRangeValue = 0;
    m_BRadiusValue = 0;
    m_VisionRange = 0;
    m_ActiveDefenseRange = 0;
    m_ElectronicCombatFactorValue = 0;
    m_MaxMovePoints = 0.000000;
    m_MaxFuel = 0;
    m_TransTypeValue = 0;
    m_ProbOfBombHitValue = 0;
    m_BombRoundsValue = 0;
    m_ShieldHunger = 0;
    m_FoodHunger = 0;
    m_GoldHunger = 0;
    m_DefaultSprite = 0x7fffffff;
    m_LaunchPollutionValue = 0;
    m_DeathPollutionValue = 0;
    m_CargoModuleValue = 0;
    m_SpyVsSpyValue = 0.000000;
    memset(&m_InvestigateCityValue, 0, sizeof(m_InvestigateCityValue));
    m_BonusFoodValue = 0;
    m_BombardRangeValue = 0;
    memset(&m_RevolutionValue, 0, sizeof(m_RevolutionValue));
    m_SoundSelect1 = 0x7fffffff;
    m_SoundSelect2 = 0x7fffffff;
    m_SoundMove = 0x7fffffff;
    m_SoundAcknowledge = 0x7fffffff;
    m_SoundCantMove = 0x7fffffff;
    m_SoundAttack = 0x7fffffff;
    m_SoundWork = 0x7fffffff;
    m_SoundVictory = 0x7fffffff;
    m_SoundDeath = 0x7fffffff;
    m_SoundLoad = 0x7fffffff;
    m_SoundUnload = 0x7fffffff;
    memset(m_SpecialAttacks, 0, sizeof(m_SpecialAttacks));
    m_numSpecialAttacks = 0;
    m_CityGrowthCoefficientValue = 0.000000;
    m_UserFlags = 0;
    m_DefaultIcon = 0x7fffffff;
    m_CheatIndexValue = 0;
    m_Description = 0;
    m_AdviceValue = 0;
    m_Category = 0;
    m_ArmyMountedBonusValue = 0.000000;
    m_ArmyAirBonusValue = 0.000000;
    m_ArmyWoodenShipBonusValue = 0.000000;
    m_ArmyAttackCityBonusValue = 0.000000;
    m_ArmyAttackBonusSubmarineValue = 0.000000;
    m_ArmyFootBonusValue = 0.000000;
    m_ArmyMeleeBonusValue = 0.000000;
    m_ArmySiegeBonusValue = 0.000000;
    m_ArmyWheeledBonusValue = 0.000000;
    m_ArmyMechanizedBonusValue = 0.000000;
    m_ArmyHelicopterBonusValue = 0.000000;
    m_ArmySpecialForcesBonusValue = 0.000000;
    m_ArmyCivilianBonusValue = 0.000000;
    m_ArmyGuerrillaBonusValue = 0.000000;
    m_ArmyAgainstMountedBonusValue = 0.000000;
    m_ArmyAirDefenseBonusValue = 0.000000;
    m_EnergyHunger = 0;
    m_ProducesEnergy = 0;
    m_HasReligionIconValue = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void UnitRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_flags1;
        archive << m_flags2;
        archive << m_flags3;
        archive << m_flags4;
        archive << m_flags5;
        archive << m_flags6;
        archive << m_flags7;
        archive << m_MovementType;
        archive << m_CanCarry;
        archive << m_EnableAdvance;
        archive << m_numObsoleteAdvance;
        archive.Store((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive << m_numPrerequisiteBuilding;
        archive.Store((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive << m_numExcludedByBuilding;
        archive.Store((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_numCanSettleOn;
        archive.Store((uint8*)m_CanSettleOn, m_numCanSettleOn * sizeof(sint32));

        archive << m_numUpgradeTo;
        archive.Store((uint8*)m_UpgradeTo, m_numUpgradeTo * sizeof(sint32));

        archive << m_numObsoleteUnit;
        archive.Store((uint8*)m_ObsoleteUnit, m_numObsoleteUnit * sizeof(sint32));

        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_numCityStyleOnly;
        archive.Store((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive << m_numCivilisationOnly;
        archive.Store((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive << m_numGovernmentOnly;
        archive.Store((uint8*)m_GovernmentOnly, m_numGovernmentOnly * sizeof(sint32));

        archive << m_numSettleImprovement;
        archive.Store((uint8*)m_SettleImprovement, m_numSettleImprovement * sizeof(sint32));

        archive << m_numNeedsCityGood;
        archive.Store((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive << m_numNeedsCityGoodAll;
        archive.Store((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive << m_numNeedsCityGoodCapitol;
        archive.Store((uint8*)m_NeedsCityGoodCapitol, m_numNeedsCityGoodCapitol * sizeof(sint32));

        archive << m_numNeedsCityGoodAnyCity;
        archive.Store((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive << m_numNeedsFeatToBuild;
        archive.Store((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive << m_numNeedsAnyPlayerFeatToBuild;
        archive.Store((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive << m_numPrerequisiteWonder;
        archive.Store((uint8*)m_PrerequisiteWonder, m_numPrerequisiteWonder * sizeof(sint32));

        archive << m_numExcludedByWonder;
        archive.Store((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive << m_MoveBonusValue;
        archive << m_PWMoveCostValue;
        archive << m_MerchantGoldValue;
        archive << m_numAllTerrainAsImprovement;
        archive.Store((uint8*)m_AllTerrainAsImprovement, m_numAllTerrainAsImprovement * sizeof(sint32));

        archive << m_numObsoleteByUnit;
        archive.Store((uint8*)m_ObsoleteByUnit, m_numObsoleteByUnit * sizeof(sint32));

        archive << m_Size;
        archive << m_CanBombard;
        archive << m_Settle;
        archive << m_SettleCityType;
        archive << m_SettleSize;
        archive << m_numSettleBuilding;
        archive.Store((uint8*)m_SettleBuilding, m_numSettleBuilding * sizeof(sint32));

        archive << m_numEstablishBuilding;
        archive.Store((uint8*)m_EstablishBuilding, m_numEstablishBuilding * sizeof(sint32));

        archive << m_SpaceLaunchValue;
        archive << m_Defend;
        archive << m_DefendAgainstSpiesValue;
        archive << m_DefendAirBonusValue;
        archive << m_DefendCityBonusValue;
        archive << m_DefendSubmarineBonusValue;
        archive << m_DefendFootBonusValue;
        archive << m_DefendMeleeBonusValue;
        archive << m_DefendSiegeBonusValue;
        archive << m_DefendWheeledBonusValue;
        archive << m_DefendMechanizedBonusValue;
        archive << m_DefendHelicopterBonusValue;
        archive << m_DefendSpecialForcesBonusValue;
        archive << m_DefendCivilianBonusValue;
        archive << m_DefendGuerrillaBonusValue;
        archive << m_DefendMountedBonusValue;
        archive << m_DefendWoodenShipBonusValue;
        archive << m_DefendSurfaceShipBonusValue;
        archive << m_AttackAirBonusValue;
        archive << m_AttackCityBonusValue;
        archive << m_AttackSubmarineBonusValue;
        archive << m_AttackFootBonusValue;
        archive << m_AttackMeleeBonusValue;
        archive << m_AttackSiegeBonusValue;
        archive << m_AttackWheeledBonusValue;
        archive << m_AttackMechanizedBonusValue;
        archive << m_AttackHelicopterBonusValue;
        archive << m_AttackSpecialForcesBonusValue;
        archive << m_AttackCivilianBonusValue;
        archive << m_AttackGuerrillaBonusValue;
        archive << m_AttackMountedBonusValue;
        archive << m_AttackWoodenShipBonusNewValue;
        archive << m_AttackSurfaceShipBonusValue;
        archive << m_RangedAirBonusValue;
        archive << m_RangedAttackCityBonusValue;
        archive << m_RangedDefendCityBonusValue;
        archive << m_RangedSubmarineBonusValue;
        archive << m_RangedFootBonusValue;
        archive << m_RangedMeleeBonusValue;
        archive << m_RangedSiegeBonusValue;
        archive << m_RangedWheeledBonusValue;
        archive << m_RangedMechanizedBonusValue;
        archive << m_RangedHelicopterBonusValue;
        archive << m_RangedSpecialForcesBonusValue;
        archive << m_RangedCivilianBonusValue;
        archive << m_RangedGuerrillaBonusValue;
        archive << m_RangedMountedBonusValue;
        archive << m_RangedWoodenShipBonusValue;
        archive << m_RangedSurfaceShipBonusValue;
        archive << m_WoodenShipBonusValue;
        archive << m_MountedBonusValue;
        archive << m_AirBonusValue;
        archive << m_ReplaceWithCargoModuleValue;
        m_NuclearAttackValue.Serialize(archive);
        m_StealTechnologyValue.Serialize(archive);
        m_InciteRevolutionValue.Serialize(archive);
        m_AssasinateRulerValue.Serialize(archive);
        m_InvestigateReadinessValue.Serialize(archive);
        m_CreateFranchiseValue.Serialize(archive);
        m_CauseUnhappinessValue.Serialize(archive);
        m_ConductHitsValue.Serialize(archive);
        m_BioTerrorValue.Serialize(archive);
        m_NanoTerrorValue.Serialize(archive);
        m_PlagueValue.Serialize(archive);
        m_SlaveRaidsValue.Serialize(archive);
        m_SettlerSlaveRaidsValue.Serialize(archive);
        m_SlaveUprisingValue.Serialize(archive);
        m_UndergroundRailwayValue.Serialize(archive);
        archive << m_VictoryEnslavementChanceValue;
        m_IndulgenceSalesValue.Serialize(archive);
        m_ConvertCitiesValue.Serialize(archive);
        archive << m_numGovernmentType;
        archive.Store((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        m_PlantNukeValue.Serialize(archive);
        m_CanSoothsayValue.Serialize(archive);
        m_CreateParksValue.Serialize(archive);
        m_CanInjoinValue.Serialize(archive);
        archive << m_PopCostsToBuildValue;
        m_CanReformValue.Serialize(archive);
        archive << m_ReducesDefensesBonus;
        archive << m_VisionClass;
        archive << m_CanSee;
        archive << m_CanAttack;
        m_CargoDataValue.Serialize(archive);
        archive << m_ShieldCost;
        archive << m_PowerPoints;
        archive << m_MaxHP;
        archive << m_MaxHPr;
        archive << m_Attack;
        archive << m_Defense;
        archive << m_Firepower;
        archive << m_ZBRangeAttack;
        archive << m_Armor;
        archive << m_BRangeValue;
        archive << m_BRadiusValue;
        archive << m_VisionRange;
        archive << m_ActiveDefenseRange;
        archive << m_ElectronicCombatFactorValue;
        archive << m_MaxMovePoints;
        archive << m_MaxFuel;
        archive << m_TransTypeValue;
        archive << m_ProbOfBombHitValue;
        archive << m_BombRoundsValue;
        archive << m_ShieldHunger;
        archive << m_FoodHunger;
        archive << m_GoldHunger;
        archive << m_DefaultSprite;
        archive << m_LaunchPollutionValue;
        archive << m_DeathPollutionValue;
        archive << m_CargoModuleValue;
        archive << m_SpyVsSpyValue;
        m_InvestigateCityValue.Serialize(archive);
        archive << m_BonusFoodValue;
        archive << m_BombardRangeValue;
        m_RevolutionValue.Serialize(archive);
        archive << m_SoundSelect1;
        archive << m_SoundSelect2;
        archive << m_SoundMove;
        archive << m_SoundAcknowledge;
        archive << m_SoundCantMove;
        archive << m_SoundAttack;
        archive << m_SoundWork;
        archive << m_SoundVictory;
        archive << m_SoundDeath;
        archive << m_SoundLoad;
        archive << m_SoundUnload;
        archive << m_numSpecialAttacks;
        archive.Store((uint8*)&m_SpecialAttacks, sizeof(m_SpecialAttacks));
        archive << m_CityGrowthCoefficientValue;
        archive << m_UserFlags;
        archive << m_DefaultIcon;
        archive << m_CheatIndexValue;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Description);
            archive << tmpString;
        }

        if (HasAdvice()){
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_AdviceValue);
            archive << tmpString;
        }

        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Category);
            archive << tmpString;
        }

        archive << m_ArmyMountedBonusValue;
        archive << m_ArmyAirBonusValue;
        archive << m_ArmyWoodenShipBonusValue;
        archive << m_ArmyAttackCityBonusValue;
        archive << m_ArmyAttackBonusSubmarineValue;
        archive << m_ArmyFootBonusValue;
        archive << m_ArmyMeleeBonusValue;
        archive << m_ArmySiegeBonusValue;
        archive << m_ArmyWheeledBonusValue;
        archive << m_ArmyMechanizedBonusValue;
        archive << m_ArmyHelicopterBonusValue;
        archive << m_ArmySpecialForcesBonusValue;
        archive << m_ArmyCivilianBonusValue;
        archive << m_ArmyGuerrillaBonusValue;
        archive << m_ArmyAgainstMountedBonusValue;
        archive << m_ArmyAirDefenseBonusValue;
        archive << m_EnergyHunger;
        archive << m_ProducesEnergy;
        archive << m_HasReligionIconValue;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_flags2;
        archive >> m_flags3;
        archive >> m_flags4;
        archive >> m_flags5;
        archive >> m_flags6;
        archive >> m_flags7;
        archive >> m_MovementType;
        archive >> m_CanCarry;
        archive >> m_EnableAdvance;
        archive >> m_numObsoleteAdvance;
        archive.Load((uint8*)&m_ObsoleteAdvance, sizeof(m_ObsoleteAdvance));
        archive >> m_numPrerequisiteBuilding;
        archive.Load((uint8*)m_PrerequisiteBuilding, m_numPrerequisiteBuilding * sizeof(sint32));

        archive >> m_numExcludedByBuilding;
        archive.Load((uint8*)m_ExcludedByBuilding, m_numExcludedByBuilding * sizeof(sint32));

        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive >> m_numCanSettleOn;
        archive.Load((uint8*)m_CanSettleOn, m_numCanSettleOn * sizeof(sint32));

        archive >> m_numUpgradeTo;
        archive.Load((uint8*)m_UpgradeTo, m_numUpgradeTo * sizeof(sint32));

        archive >> m_numObsoleteUnit;
        archive.Load((uint8*)m_ObsoleteUnit, m_numObsoleteUnit * sizeof(sint32));

        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_numCityStyleOnly;
        archive.Load((uint8*)m_CityStyleOnly, m_numCityStyleOnly * sizeof(sint32));

        archive >> m_numCivilisationOnly;
        archive.Load((uint8*)m_CivilisationOnly, m_numCivilisationOnly * sizeof(sint32));

        archive >> m_numGovernmentOnly;
        archive.Load((uint8*)m_GovernmentOnly, m_numGovernmentOnly * sizeof(sint32));

        archive >> m_numSettleImprovement;
        archive.Load((uint8*)m_SettleImprovement, m_numSettleImprovement * sizeof(sint32));

        archive >> m_numNeedsCityGood;
        archive.Load((uint8*)m_NeedsCityGood, m_numNeedsCityGood * sizeof(sint32));

        archive >> m_numNeedsCityGoodAll;
        archive.Load((uint8*)m_NeedsCityGoodAll, m_numNeedsCityGoodAll * sizeof(sint32));

        archive >> m_numNeedsCityGoodCapitol;
        archive.Load((uint8*)m_NeedsCityGoodCapitol, m_numNeedsCityGoodCapitol * sizeof(sint32));

        archive >> m_numNeedsCityGoodAnyCity;
        archive.Load((uint8*)m_NeedsCityGoodAnyCity, m_numNeedsCityGoodAnyCity * sizeof(sint32));

        archive >> m_numNeedsFeatToBuild;
        archive.Load((uint8*)m_NeedsFeatToBuild, m_numNeedsFeatToBuild * sizeof(sint32));

        archive >> m_numNeedsAnyPlayerFeatToBuild;
        archive.Load((uint8*)m_NeedsAnyPlayerFeatToBuild, m_numNeedsAnyPlayerFeatToBuild * sizeof(sint32));

        archive >> m_numPrerequisiteWonder;
        archive.Load((uint8*)m_PrerequisiteWonder, m_numPrerequisiteWonder * sizeof(sint32));

        archive >> m_numExcludedByWonder;
        archive.Load((uint8*)m_ExcludedByWonder, m_numExcludedByWonder * sizeof(sint32));

        archive >> m_MoveBonusValue;
        archive >> m_PWMoveCostValue;
        archive >> m_MerchantGoldValue;
        archive >> m_numAllTerrainAsImprovement;
        archive.Load((uint8*)m_AllTerrainAsImprovement, m_numAllTerrainAsImprovement * sizeof(sint32));

        archive >> m_numObsoleteByUnit;
        archive.Load((uint8*)m_ObsoleteByUnit, m_numObsoleteByUnit * sizeof(sint32));

        archive >> m_Size;
        archive >> m_CanBombard;
        archive >> m_Settle;
        archive >> m_SettleCityType;
        archive >> m_SettleSize;
        archive >> m_numSettleBuilding;
        archive.Load((uint8*)m_SettleBuilding, m_numSettleBuilding * sizeof(sint32));

        archive >> m_numEstablishBuilding;
        archive.Load((uint8*)m_EstablishBuilding, m_numEstablishBuilding * sizeof(sint32));

        archive >> m_SpaceLaunchValue;
        archive >> m_Defend;
        archive >> m_DefendAgainstSpiesValue;
        archive >> m_DefendAirBonusValue;
        archive >> m_DefendCityBonusValue;
        archive >> m_DefendSubmarineBonusValue;
        archive >> m_DefendFootBonusValue;
        archive >> m_DefendMeleeBonusValue;
        archive >> m_DefendSiegeBonusValue;
        archive >> m_DefendWheeledBonusValue;
        archive >> m_DefendMechanizedBonusValue;
        archive >> m_DefendHelicopterBonusValue;
        archive >> m_DefendSpecialForcesBonusValue;
        archive >> m_DefendCivilianBonusValue;
        archive >> m_DefendGuerrillaBonusValue;
        archive >> m_DefendMountedBonusValue;
        archive >> m_DefendWoodenShipBonusValue;
        archive >> m_DefendSurfaceShipBonusValue;
        archive >> m_AttackAirBonusValue;
        archive >> m_AttackCityBonusValue;
        archive >> m_AttackSubmarineBonusValue;
        archive >> m_AttackFootBonusValue;
        archive >> m_AttackMeleeBonusValue;
        archive >> m_AttackSiegeBonusValue;
        archive >> m_AttackWheeledBonusValue;
        archive >> m_AttackMechanizedBonusValue;
        archive >> m_AttackHelicopterBonusValue;
        archive >> m_AttackSpecialForcesBonusValue;
        archive >> m_AttackCivilianBonusValue;
        archive >> m_AttackGuerrillaBonusValue;
        archive >> m_AttackMountedBonusValue;
        archive >> m_AttackWoodenShipBonusNewValue;
        archive >> m_AttackSurfaceShipBonusValue;
        archive >> m_RangedAirBonusValue;
        archive >> m_RangedAttackCityBonusValue;
        archive >> m_RangedDefendCityBonusValue;
        archive >> m_RangedSubmarineBonusValue;
        archive >> m_RangedFootBonusValue;
        archive >> m_RangedMeleeBonusValue;
        archive >> m_RangedSiegeBonusValue;
        archive >> m_RangedWheeledBonusValue;
        archive >> m_RangedMechanizedBonusValue;
        archive >> m_RangedHelicopterBonusValue;
        archive >> m_RangedSpecialForcesBonusValue;
        archive >> m_RangedCivilianBonusValue;
        archive >> m_RangedGuerrillaBonusValue;
        archive >> m_RangedMountedBonusValue;
        archive >> m_RangedWoodenShipBonusValue;
        archive >> m_RangedSurfaceShipBonusValue;
        archive >> m_WoodenShipBonusValue;
        archive >> m_MountedBonusValue;
        archive >> m_AirBonusValue;
        archive >> m_ReplaceWithCargoModuleValue;
        memset((uint8*)&m_NuclearAttackValue, 0, sizeof(m_NuclearAttackValue));
        m_NuclearAttackValue.Serialize(archive);
        memset((uint8*)&m_StealTechnologyValue, 0, sizeof(m_StealTechnologyValue));
        m_StealTechnologyValue.Serialize(archive);
        memset((uint8*)&m_InciteRevolutionValue, 0, sizeof(m_InciteRevolutionValue));
        m_InciteRevolutionValue.Serialize(archive);
        memset((uint8*)&m_AssasinateRulerValue, 0, sizeof(m_AssasinateRulerValue));
        m_AssasinateRulerValue.Serialize(archive);
        memset((uint8*)&m_InvestigateReadinessValue, 0, sizeof(m_InvestigateReadinessValue));
        m_InvestigateReadinessValue.Serialize(archive);
        memset((uint8*)&m_CreateFranchiseValue, 0, sizeof(m_CreateFranchiseValue));
        m_CreateFranchiseValue.Serialize(archive);
        memset((uint8*)&m_CauseUnhappinessValue, 0, sizeof(m_CauseUnhappinessValue));
        m_CauseUnhappinessValue.Serialize(archive);
        memset((uint8*)&m_ConductHitsValue, 0, sizeof(m_ConductHitsValue));
        m_ConductHitsValue.Serialize(archive);
        memset((uint8*)&m_BioTerrorValue, 0, sizeof(m_BioTerrorValue));
        m_BioTerrorValue.Serialize(archive);
        memset((uint8*)&m_NanoTerrorValue, 0, sizeof(m_NanoTerrorValue));
        m_NanoTerrorValue.Serialize(archive);
        memset((uint8*)&m_PlagueValue, 0, sizeof(m_PlagueValue));
        m_PlagueValue.Serialize(archive);
        memset((uint8*)&m_SlaveRaidsValue, 0, sizeof(m_SlaveRaidsValue));
        m_SlaveRaidsValue.Serialize(archive);
        memset((uint8*)&m_SettlerSlaveRaidsValue, 0, sizeof(m_SettlerSlaveRaidsValue));
        m_SettlerSlaveRaidsValue.Serialize(archive);
        memset((uint8*)&m_SlaveUprisingValue, 0, sizeof(m_SlaveUprisingValue));
        m_SlaveUprisingValue.Serialize(archive);
        memset((uint8*)&m_UndergroundRailwayValue, 0, sizeof(m_UndergroundRailwayValue));
        m_UndergroundRailwayValue.Serialize(archive);
        archive >> m_VictoryEnslavementChanceValue;
        memset((uint8*)&m_IndulgenceSalesValue, 0, sizeof(m_IndulgenceSalesValue));
        m_IndulgenceSalesValue.Serialize(archive);
        memset((uint8*)&m_ConvertCitiesValue, 0, sizeof(m_ConvertCitiesValue));
        m_ConvertCitiesValue.Serialize(archive);
        archive >> m_numGovernmentType;
        archive.Load((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        memset((uint8*)&m_PlantNukeValue, 0, sizeof(m_PlantNukeValue));
        m_PlantNukeValue.Serialize(archive);
        memset((uint8*)&m_CanSoothsayValue, 0, sizeof(m_CanSoothsayValue));
        m_CanSoothsayValue.Serialize(archive);
        memset((uint8*)&m_CreateParksValue, 0, sizeof(m_CreateParksValue));
        m_CreateParksValue.Serialize(archive);
        memset((uint8*)&m_CanInjoinValue, 0, sizeof(m_CanInjoinValue));
        m_CanInjoinValue.Serialize(archive);
        archive >> m_PopCostsToBuildValue;
        memset((uint8*)&m_CanReformValue, 0, sizeof(m_CanReformValue));
        m_CanReformValue.Serialize(archive);
        archive >> m_ReducesDefensesBonus;
        archive >> m_VisionClass;
        archive >> m_CanSee;
        archive >> m_CanAttack;
        memset((uint8*)&m_CargoDataValue, 0, sizeof(m_CargoDataValue));
        m_CargoDataValue.Serialize(archive);
        archive >> m_ShieldCost;
        archive >> m_PowerPoints;
        archive >> m_MaxHP;
        archive >> m_MaxHPr;
        archive >> m_Attack;
        archive >> m_Defense;
        archive >> m_Firepower;
        archive >> m_ZBRangeAttack;
        archive >> m_Armor;
        archive >> m_BRangeValue;
        archive >> m_BRadiusValue;
        archive >> m_VisionRange;
        archive >> m_ActiveDefenseRange;
        archive >> m_ElectronicCombatFactorValue;
        archive >> m_MaxMovePoints;
        archive >> m_MaxFuel;
        archive >> m_TransTypeValue;
        archive >> m_ProbOfBombHitValue;
        archive >> m_BombRoundsValue;
        archive >> m_ShieldHunger;
        archive >> m_FoodHunger;
        archive >> m_GoldHunger;
        archive >> m_DefaultSprite;
        archive >> m_LaunchPollutionValue;
        archive >> m_DeathPollutionValue;
        archive >> m_CargoModuleValue;
        archive >> m_SpyVsSpyValue;
        memset((uint8*)&m_InvestigateCityValue, 0, sizeof(m_InvestigateCityValue));
        m_InvestigateCityValue.Serialize(archive);
        archive >> m_BonusFoodValue;
        archive >> m_BombardRangeValue;
        memset((uint8*)&m_RevolutionValue, 0, sizeof(m_RevolutionValue));
        m_RevolutionValue.Serialize(archive);
        archive >> m_SoundSelect1;
        archive >> m_SoundSelect2;
        archive >> m_SoundMove;
        archive >> m_SoundAcknowledge;
        archive >> m_SoundCantMove;
        archive >> m_SoundAttack;
        archive >> m_SoundWork;
        archive >> m_SoundVictory;
        archive >> m_SoundDeath;
        archive >> m_SoundLoad;
        archive >> m_SoundUnload;
        archive >> m_numSpecialAttacks;
        archive.Load((uint8*)&m_SpecialAttacks, sizeof(m_SpecialAttacks));
        archive >> m_CityGrowthCoefficientValue;
        archive >> m_UserFlags;
        archive >> m_DefaultIcon;
        archive >> m_CheatIndexValue;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Description);
            delete[] tmpString;
        }

        {
            if (HasAdvice()){
                MBCHAR* tmpString = NULL;
                archive >> tmpString;
                g_theStringDB->GetStringID(tmpString, m_AdviceValue);
                delete[] tmpString;
            }
        }

        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Category);
            delete[] tmpString;
        }

        archive >> m_ArmyMountedBonusValue;
        archive >> m_ArmyAirBonusValue;
        archive >> m_ArmyWoodenShipBonusValue;
        archive >> m_ArmyAttackCityBonusValue;
        archive >> m_ArmyAttackBonusSubmarineValue;
        archive >> m_ArmyFootBonusValue;
        archive >> m_ArmyMeleeBonusValue;
        archive >> m_ArmySiegeBonusValue;
        archive >> m_ArmyWheeledBonusValue;
        archive >> m_ArmyMechanizedBonusValue;
        archive >> m_ArmyHelicopterBonusValue;
        archive >> m_ArmySpecialForcesBonusValue;
        archive >> m_ArmyCivilianBonusValue;
        archive >> m_ArmyGuerrillaBonusValue;
        archive >> m_ArmyAgainstMountedBonusValue;
        archive >> m_ArmyAirDefenseBonusValue;
        archive >> m_EnergyHunger;
        archive >> m_ProducesEnergy;
        archive >> m_HasReligionIconValue;
    }
}

UnitRecord::~UnitRecord()
{
    delete [] m_PrerequisiteBuilding;
    delete [] m_ExcludedByBuilding;
    delete [] m_GovernmentsModified;
    delete [] m_CanSettleOn;
    delete [] m_UpgradeTo;
    delete [] m_ObsoleteUnit;
    delete [] m_CultureOnly;
    delete [] m_CityStyleOnly;
    delete [] m_CivilisationOnly;
    delete [] m_GovernmentOnly;
    delete [] m_SettleImprovement;
    delete [] m_NeedsCityGood;
    delete [] m_NeedsCityGoodAll;
    delete [] m_NeedsCityGoodCapitol;
    delete [] m_NeedsCityGoodAnyCity;
    delete [] m_NeedsFeatToBuild;
    delete [] m_NeedsAnyPlayerFeatToBuild;
    delete [] m_PrerequisiteWonder;
    delete [] m_ExcludedByWonder;
    delete [] m_AllTerrainAsImprovement;
    delete [] m_ObsoleteByUnit;
    delete [] m_SettleBuilding;
    delete [] m_EstablishBuilding;
    delete [] m_GovernmentType;
}

UnitRecord const & UnitRecord::operator = (UnitRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;
        m_flags2 = rval.m_flags2;
        m_flags3 = rval.m_flags3;
        m_flags4 = rval.m_flags4;
        m_flags5 = rval.m_flags5;
        m_flags6 = rval.m_flags6;
        m_flags7 = rval.m_flags7;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_MovementType = rval.m_MovementType;

        m_CanCarry = rval.m_CanCarry;

        m_EnableAdvance = rval.m_EnableAdvance;

        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
        {
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
            std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);
        }
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;

        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
        {
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
            std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);
        }
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        delete [] m_CanSettleOn;
        m_CanSettleOn = NULL;
        if (rval.m_numCanSettleOn > 0)
        {
            m_CanSettleOn = new sint32 [rval.m_numCanSettleOn];
            std::copy(rval.m_CanSettleOn, rval.m_CanSettleOn + rval.m_numCanSettleOn, m_CanSettleOn);
        }
        m_numCanSettleOn = rval.m_numCanSettleOn;

        delete [] m_UpgradeTo;
        m_UpgradeTo = NULL;
        if (rval.m_numUpgradeTo > 0)
        {
            m_UpgradeTo = new sint32 [rval.m_numUpgradeTo];
            std::copy(rval.m_UpgradeTo, rval.m_UpgradeTo + rval.m_numUpgradeTo, m_UpgradeTo);
        }
        m_numUpgradeTo = rval.m_numUpgradeTo;

        delete [] m_ObsoleteUnit;
        m_ObsoleteUnit = NULL;
        if (rval.m_numObsoleteUnit > 0)
        {
            m_ObsoleteUnit = new sint32 [rval.m_numObsoleteUnit];
            std::copy(rval.m_ObsoleteUnit, rval.m_ObsoleteUnit + rval.m_numObsoleteUnit, m_ObsoleteUnit);
        }
        m_numObsoleteUnit = rval.m_numObsoleteUnit;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
        {
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
            std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);
        }
        m_numCityStyleOnly = rval.m_numCityStyleOnly;

        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
        {
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
            std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);
        }
        m_numCivilisationOnly = rval.m_numCivilisationOnly;

        delete [] m_GovernmentOnly;
        m_GovernmentOnly = NULL;
        if (rval.m_numGovernmentOnly > 0)
        {
            m_GovernmentOnly = new sint32 [rval.m_numGovernmentOnly];
            std::copy(rval.m_GovernmentOnly, rval.m_GovernmentOnly + rval.m_numGovernmentOnly, m_GovernmentOnly);
        }
        m_numGovernmentOnly = rval.m_numGovernmentOnly;

        delete [] m_SettleImprovement;
        m_SettleImprovement = NULL;
        if (rval.m_numSettleImprovement > 0)
        {
            m_SettleImprovement = new sint32 [rval.m_numSettleImprovement];
            std::copy(rval.m_SettleImprovement, rval.m_SettleImprovement + rval.m_numSettleImprovement, m_SettleImprovement);
        }
        m_numSettleImprovement = rval.m_numSettleImprovement;

        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
        {
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
            std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);
        }
        m_numNeedsCityGood = rval.m_numNeedsCityGood;

        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
        {
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
            std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);
        }
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;

        delete [] m_NeedsCityGoodCapitol;
        m_NeedsCityGoodCapitol = NULL;
        if (rval.m_numNeedsCityGoodCapitol > 0)
        {
            m_NeedsCityGoodCapitol = new sint32 [rval.m_numNeedsCityGoodCapitol];
            std::copy(rval.m_NeedsCityGoodCapitol, rval.m_NeedsCityGoodCapitol + rval.m_numNeedsCityGoodCapitol, m_NeedsCityGoodCapitol);
        }
        m_numNeedsCityGoodCapitol = rval.m_numNeedsCityGoodCapitol;

        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
        {
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
            std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);
        }
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;

        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
        {
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
            std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);
        }
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;

        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        {
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
            std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);
        }
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;

        delete [] m_PrerequisiteWonder;
        m_PrerequisiteWonder = NULL;
        if (rval.m_numPrerequisiteWonder > 0)
        {
            m_PrerequisiteWonder = new sint32 [rval.m_numPrerequisiteWonder];
            std::copy(rval.m_PrerequisiteWonder, rval.m_PrerequisiteWonder + rval.m_numPrerequisiteWonder, m_PrerequisiteWonder);
        }
        m_numPrerequisiteWonder = rval.m_numPrerequisiteWonder;

        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
        {
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
            std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);
        }
        m_numExcludedByWonder = rval.m_numExcludedByWonder;

        m_MoveBonusValue = rval.m_MoveBonusValue;

        m_PWMoveCostValue = rval.m_PWMoveCostValue;

        m_MerchantGoldValue = rval.m_MerchantGoldValue;

        delete [] m_AllTerrainAsImprovement;
        m_AllTerrainAsImprovement = NULL;
        if (rval.m_numAllTerrainAsImprovement > 0)
        {
            m_AllTerrainAsImprovement = new sint32 [rval.m_numAllTerrainAsImprovement];
            std::copy(rval.m_AllTerrainAsImprovement, rval.m_AllTerrainAsImprovement + rval.m_numAllTerrainAsImprovement, m_AllTerrainAsImprovement);
        }
        m_numAllTerrainAsImprovement = rval.m_numAllTerrainAsImprovement;

        delete [] m_ObsoleteByUnit;
        m_ObsoleteByUnit = NULL;
        if (rval.m_numObsoleteByUnit > 0)
        {
            m_ObsoleteByUnit = new sint32 [rval.m_numObsoleteByUnit];
            std::copy(rval.m_ObsoleteByUnit, rval.m_ObsoleteByUnit + rval.m_numObsoleteByUnit, m_ObsoleteByUnit);
        }
        m_numObsoleteByUnit = rval.m_numObsoleteByUnit;

        m_Size = rval.m_Size;

        m_CanBombard = rval.m_CanBombard;

        m_Settle = rval.m_Settle;

        m_SettleCityType = rval.m_SettleCityType;

        m_SettleSize = rval.m_SettleSize;

        delete [] m_SettleBuilding;
        m_SettleBuilding = NULL;
        if (rval.m_numSettleBuilding > 0)
        {
            m_SettleBuilding = new sint32 [rval.m_numSettleBuilding];
            std::copy(rval.m_SettleBuilding, rval.m_SettleBuilding + rval.m_numSettleBuilding, m_SettleBuilding);
        }
        m_numSettleBuilding = rval.m_numSettleBuilding;

        delete [] m_EstablishBuilding;
        m_EstablishBuilding = NULL;
        if (rval.m_numEstablishBuilding > 0)
        {
            m_EstablishBuilding = new sint32 [rval.m_numEstablishBuilding];
            std::copy(rval.m_EstablishBuilding, rval.m_EstablishBuilding + rval.m_numEstablishBuilding, m_EstablishBuilding);
        }
        m_numEstablishBuilding = rval.m_numEstablishBuilding;

        m_SpaceLaunchValue = rval.m_SpaceLaunchValue;

        m_Defend = rval.m_Defend;

        m_DefendAgainstSpiesValue = rval.m_DefendAgainstSpiesValue;

        m_DefendAirBonusValue = rval.m_DefendAirBonusValue;

        m_DefendCityBonusValue = rval.m_DefendCityBonusValue;

        m_DefendSubmarineBonusValue = rval.m_DefendSubmarineBonusValue;

        m_DefendFootBonusValue = rval.m_DefendFootBonusValue;

        m_DefendMeleeBonusValue = rval.m_DefendMeleeBonusValue;

        m_DefendSiegeBonusValue = rval.m_DefendSiegeBonusValue;

        m_DefendWheeledBonusValue = rval.m_DefendWheeledBonusValue;

        m_DefendMechanizedBonusValue = rval.m_DefendMechanizedBonusValue;

        m_DefendHelicopterBonusValue = rval.m_DefendHelicopterBonusValue;

        m_DefendSpecialForcesBonusValue = rval.m_DefendSpecialForcesBonusValue;

        m_DefendCivilianBonusValue = rval.m_DefendCivilianBonusValue;

        m_DefendGuerrillaBonusValue = rval.m_DefendGuerrillaBonusValue;

        m_DefendMountedBonusValue = rval.m_DefendMountedBonusValue;

        m_DefendWoodenShipBonusValue = rval.m_DefendWoodenShipBonusValue;

        m_DefendSurfaceShipBonusValue = rval.m_DefendSurfaceShipBonusValue;

        m_AttackAirBonusValue = rval.m_AttackAirBonusValue;

        m_AttackCityBonusValue = rval.m_AttackCityBonusValue;

        m_AttackSubmarineBonusValue = rval.m_AttackSubmarineBonusValue;

        m_AttackFootBonusValue = rval.m_AttackFootBonusValue;

        m_AttackMeleeBonusValue = rval.m_AttackMeleeBonusValue;

        m_AttackSiegeBonusValue = rval.m_AttackSiegeBonusValue;

        m_AttackWheeledBonusValue = rval.m_AttackWheeledBonusValue;

        m_AttackMechanizedBonusValue = rval.m_AttackMechanizedBonusValue;

        m_AttackHelicopterBonusValue = rval.m_AttackHelicopterBonusValue;

        m_AttackSpecialForcesBonusValue = rval.m_AttackSpecialForcesBonusValue;

        m_AttackCivilianBonusValue = rval.m_AttackCivilianBonusValue;

        m_AttackGuerrillaBonusValue = rval.m_AttackGuerrillaBonusValue;

        m_AttackMountedBonusValue = rval.m_AttackMountedBonusValue;

        m_AttackWoodenShipBonusNewValue = rval.m_AttackWoodenShipBonusNewValue;

        m_AttackSurfaceShipBonusValue = rval.m_AttackSurfaceShipBonusValue;

        m_RangedAirBonusValue = rval.m_RangedAirBonusValue;

        m_RangedAttackCityBonusValue = rval.m_RangedAttackCityBonusValue;

        m_RangedDefendCityBonusValue = rval.m_RangedDefendCityBonusValue;

        m_RangedSubmarineBonusValue = rval.m_RangedSubmarineBonusValue;

        m_RangedFootBonusValue = rval.m_RangedFootBonusValue;

        m_RangedMeleeBonusValue = rval.m_RangedMeleeBonusValue;

        m_RangedSiegeBonusValue = rval.m_RangedSiegeBonusValue;

        m_RangedWheeledBonusValue = rval.m_RangedWheeledBonusValue;

        m_RangedMechanizedBonusValue = rval.m_RangedMechanizedBonusValue;

        m_RangedHelicopterBonusValue = rval.m_RangedHelicopterBonusValue;

        m_RangedSpecialForcesBonusValue = rval.m_RangedSpecialForcesBonusValue;

        m_RangedCivilianBonusValue = rval.m_RangedCivilianBonusValue;

        m_RangedGuerrillaBonusValue = rval.m_RangedGuerrillaBonusValue;

        m_RangedMountedBonusValue = rval.m_RangedMountedBonusValue;

        m_RangedWoodenShipBonusValue = rval.m_RangedWoodenShipBonusValue;

        m_RangedSurfaceShipBonusValue = rval.m_RangedSurfaceShipBonusValue;

        m_WoodenShipBonusValue = rval.m_WoodenShipBonusValue;

        m_MountedBonusValue = rval.m_MountedBonusValue;

        m_AirBonusValue = rval.m_AirBonusValue;

        m_ReplaceWithCargoModuleValue = rval.m_ReplaceWithCargoModuleValue;

        m_NuclearAttackValue = rval.m_NuclearAttackValue;

        m_StealTechnologyValue = rval.m_StealTechnologyValue;

        m_InciteRevolutionValue = rval.m_InciteRevolutionValue;

        m_AssasinateRulerValue = rval.m_AssasinateRulerValue;

        m_InvestigateReadinessValue = rval.m_InvestigateReadinessValue;

        m_CreateFranchiseValue = rval.m_CreateFranchiseValue;

        m_CauseUnhappinessValue = rval.m_CauseUnhappinessValue;

        m_ConductHitsValue = rval.m_ConductHitsValue;

        m_BioTerrorValue = rval.m_BioTerrorValue;

        m_NanoTerrorValue = rval.m_NanoTerrorValue;

        m_PlagueValue = rval.m_PlagueValue;

        m_SlaveRaidsValue = rval.m_SlaveRaidsValue;

        m_SettlerSlaveRaidsValue = rval.m_SettlerSlaveRaidsValue;

        m_SlaveUprisingValue = rval.m_SlaveUprisingValue;

        m_UndergroundRailwayValue = rval.m_UndergroundRailwayValue;

        m_VictoryEnslavementChanceValue = rval.m_VictoryEnslavementChanceValue;

        m_IndulgenceSalesValue = rval.m_IndulgenceSalesValue;

        m_ConvertCitiesValue = rval.m_ConvertCitiesValue;

        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
        {
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
            std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);
        }
        m_numGovernmentType = rval.m_numGovernmentType;

        m_PlantNukeValue = rval.m_PlantNukeValue;

        m_CanSoothsayValue = rval.m_CanSoothsayValue;

        m_CreateParksValue = rval.m_CreateParksValue;

        m_CanInjoinValue = rval.m_CanInjoinValue;

        m_PopCostsToBuildValue = rval.m_PopCostsToBuildValue;

        m_CanReformValue = rval.m_CanReformValue;

        m_ReducesDefensesBonus = rval.m_ReducesDefensesBonus;

        m_VisionClass = rval.m_VisionClass;

        m_CanSee = rval.m_CanSee;

        m_CanAttack = rval.m_CanAttack;

        m_CargoDataValue = rval.m_CargoDataValue;

        m_ShieldCost = rval.m_ShieldCost;

        m_PowerPoints = rval.m_PowerPoints;

        m_MaxHP = rval.m_MaxHP;

        m_MaxHPr = rval.m_MaxHPr;

        m_Attack = rval.m_Attack;

        m_Defense = rval.m_Defense;

        m_Firepower = rval.m_Firepower;

        m_ZBRangeAttack = rval.m_ZBRangeAttack;

        m_Armor = rval.m_Armor;

        m_BRangeValue = rval.m_BRangeValue;

        m_BRadiusValue = rval.m_BRadiusValue;

        m_VisionRange = rval.m_VisionRange;

        m_ActiveDefenseRange = rval.m_ActiveDefenseRange;

        m_ElectronicCombatFactorValue = rval.m_ElectronicCombatFactorValue;

        m_MaxMovePoints = rval.m_MaxMovePoints;

        m_MaxFuel = rval.m_MaxFuel;

        m_TransTypeValue = rval.m_TransTypeValue;

        m_ProbOfBombHitValue = rval.m_ProbOfBombHitValue;

        m_BombRoundsValue = rval.m_BombRoundsValue;

        m_ShieldHunger = rval.m_ShieldHunger;

        m_FoodHunger = rval.m_FoodHunger;

        m_GoldHunger = rval.m_GoldHunger;

        m_DefaultSprite = rval.m_DefaultSprite;

        m_LaunchPollutionValue = rval.m_LaunchPollutionValue;

        m_DeathPollutionValue = rval.m_DeathPollutionValue;

        m_CargoModuleValue = rval.m_CargoModuleValue;

        m_SpyVsSpyValue = rval.m_SpyVsSpyValue;

        m_InvestigateCityValue = rval.m_InvestigateCityValue;

        m_BonusFoodValue = rval.m_BonusFoodValue;

        m_BombardRangeValue = rval.m_BombardRangeValue;

        m_RevolutionValue = rval.m_RevolutionValue;

        m_SoundSelect1 = rval.m_SoundSelect1;

        m_SoundSelect2 = rval.m_SoundSelect2;

        m_SoundMove = rval.m_SoundMove;

        m_SoundAcknowledge = rval.m_SoundAcknowledge;

        m_SoundCantMove = rval.m_SoundCantMove;

        m_SoundAttack = rval.m_SoundAttack;

        m_SoundWork = rval.m_SoundWork;

        m_SoundVictory = rval.m_SoundVictory;

        m_SoundDeath = rval.m_SoundDeath;

        m_SoundLoad = rval.m_SoundLoad;

        m_SoundUnload = rval.m_SoundUnload;

        std::copy(rval.m_SpecialAttacks, rval.m_SpecialAttacks + rval.m_numSpecialAttacks, m_SpecialAttacks);

        m_CityGrowthCoefficientValue = rval.m_CityGrowthCoefficientValue;

        m_UserFlags = rval.m_UserFlags;

        m_DefaultIcon = rval.m_DefaultIcon;

        m_CheatIndexValue = rval.m_CheatIndexValue;

        m_Description = rval.m_Description;

        m_AdviceValue = rval.m_AdviceValue;

        m_Category = rval.m_Category;

        m_ArmyMountedBonusValue = rval.m_ArmyMountedBonusValue;

        m_ArmyAirBonusValue = rval.m_ArmyAirBonusValue;

        m_ArmyWoodenShipBonusValue = rval.m_ArmyWoodenShipBonusValue;

        m_ArmyAttackCityBonusValue = rval.m_ArmyAttackCityBonusValue;

        m_ArmyAttackBonusSubmarineValue = rval.m_ArmyAttackBonusSubmarineValue;

        m_ArmyFootBonusValue = rval.m_ArmyFootBonusValue;

        m_ArmyMeleeBonusValue = rval.m_ArmyMeleeBonusValue;

        m_ArmySiegeBonusValue = rval.m_ArmySiegeBonusValue;

        m_ArmyWheeledBonusValue = rval.m_ArmyWheeledBonusValue;

        m_ArmyMechanizedBonusValue = rval.m_ArmyMechanizedBonusValue;

        m_ArmyHelicopterBonusValue = rval.m_ArmyHelicopterBonusValue;

        m_ArmySpecialForcesBonusValue = rval.m_ArmySpecialForcesBonusValue;

        m_ArmyCivilianBonusValue = rval.m_ArmyCivilianBonusValue;

        m_ArmyGuerrillaBonusValue = rval.m_ArmyGuerrillaBonusValue;

        m_ArmyAgainstMountedBonusValue = rval.m_ArmyAgainstMountedBonusValue;

        m_ArmyAirDefenseBonusValue = rval.m_ArmyAirDefenseBonusValue;

        m_EnergyHunger = rval.m_EnergyHunger;

        m_ProducesEnergy = rval.m_ProducesEnergy;

        m_HasReligionIconValue = rval.m_HasReligionIconValue;

    }

    return *this;
}

const char *g_Unit_Tokens[] =
{
    "MovementType",
    "CanCarry",
    "EnableAdvance",
    "ObsoleteAdvance",
    "PrerequisiteBuilding",
    "ExcludedByBuilding",
    "GovernmentsModified",
    "CanSettleOn",
    "UpgradeTo",
    "ObsoleteUnit",
    "CultureOnly",
    "CityStyleOnly",
    "CivilisationOnly",
    "GovernmentOnly",
    "SettleImprovement",
    "NeedsCityGood",
    "NeedsCityGoodAll",
    "NeedsCityGoodCapitol",
    "NeedsCityGoodAnyCity",
    "NeedsFeatToBuild",
    "NeedsAnyPlayerFeatToBuild",
    "PrerequisiteWonder",
    "ExcludedByWonder",
    "MoveBonus",
    "MoveBonusValue",
    "PWMoveCost",
    "PWMoveCostValue",
    "MerchantGold",
    "MerchantGoldValue",
    "IsGreatBuilder",
    "IsGreatArtist",
    "AllTerrainAsImprovement",
    "ObsoleteByUnit",
    "NonLethalBombard",
    "CanBombardTiles",
    "CollateralTileDamage",
    "PrecisionStrike",
    "TargetsCivilians",
    "ImmuneToHostileTerrain",
    "CanRebase",
    "MultipleAttacks",
    "CanBeGifted",
    "UpgradeAnywhere",
    "UpgradeDoesNotHeal",
    "Size",
    "LossMoveToDmgNone",
    "LossMoveToDmgTwo",
    "NoFuelThenCrash",
    "TransformPartial",
    "IgnoreZOC",
    "NoZoc",
    "CanBombard",
    "CanCounterBombard",
    "CanLiftOff",
    "Settle",
    "SettleCityType",
    "SettleSize",
    "SettleBuilding",
    "EstablishBuilding",
    "SpaceLaunch",
    "SpaceLaunchValue",
    "SpaceLand",
    "CantCaptureCity",
    "HasPopAndCanBuild",
    "IsTrader",
    "ExertsMartialLaw",
    "CanEntrench",
    "CanPatrol",
    "NeedsNoSupport",
    "CanExpelPop",
    "IsFlanker",
    "CanBeachAssault",
    "Defend",
    "DefendAgainstSpies",
    "DefendAgainstSpiesValue",
    "CanBeExpelled",
    "CanBeSued",
    "AttackFromSpaceship",
    "CantBeAttacked",
    "CargoPod",
    "IsFoot",
    "IsMelee",
    "IsMounted",
    "IsSiege",
    "IsWheeled",
    "IsMechanized",
    "IsHelicopter",
    "IsSubmarine",
    "IsSurfaceShip",
    "WoodenShip",
    "NoLandAttack",
    "NoSeaAttack",
    "NoAirAttack",
    "NoSpaceAttack",
    "NoUnderwaterAttack",
    "NoMountainAttack",
    "NoShallowWaterAttack",
    "SingleUse",
    "Paratrooper",
    "AssistedDrops",
    "DefendAirBonus",
    "DefendAirBonusValue",
    "DefendCityBonus",
    "DefendCityBonusValue",
    "DefendSubmarineBonus",
    "DefendSubmarineBonusValue",
    "DefendFootBonus",
    "DefendFootBonusValue",
    "DefendMeleeBonus",
    "DefendMeleeBonusValue",
    "DefendSiegeBonus",
    "DefendSiegeBonusValue",
    "DefendWheeledBonus",
    "DefendWheeledBonusValue",
    "DefendMechanizedBonus",
    "DefendMechanizedBonusValue",
    "DefendHelicopterBonus",
    "DefendHelicopterBonusValue",
    "DefendSpecialForcesBonus",
    "DefendSpecialForcesBonusValue",
    "DefendCivilianBonus",
    "DefendCivilianBonusValue",
    "DefendGuerrillaBonus",
    "DefendGuerrillaBonusValue",
    "DefendMountedBonus",
    "DefendMountedBonusValue",
    "DefendWoodenShipBonus",
    "DefendWoodenShipBonusValue",
    "DefendSurfaceShipBonus",
    "DefendSurfaceShipBonusValue",
    "NoDefenseBonuses",
    "AttackAirBonus",
    "AttackAirBonusValue",
    "AttackCityBonus",
    "AttackCityBonusValue",
    "AttackSubmarineBonus",
    "AttackSubmarineBonusValue",
    "AttackFootBonus",
    "AttackFootBonusValue",
    "AttackMeleeBonus",
    "AttackMeleeBonusValue",
    "AttackSiegeBonus",
    "AttackSiegeBonusValue",
    "AttackWheeledBonus",
    "AttackWheeledBonusValue",
    "AttackMechanizedBonus",
    "AttackMechanizedBonusValue",
    "AttackHelicopterBonus",
    "AttackHelicopterBonusValue",
    "AttackSpecialForcesBonus",
    "AttackSpecialForcesBonusValue",
    "AttackCivilianBonus",
    "AttackCivilianBonusValue",
    "AttackGuerrillaBonus",
    "AttackGuerrillaBonusValue",
    "AttackMountedBonus",
    "AttackMountedBonusValue",
    "AttackWoodenShipBonusNew",
    "AttackWoodenShipBonusNewValue",
    "AttackSurfaceShipBonus",
    "AttackSurfaceShipBonusValue",
    "RangedAirBonus",
    "RangedAirBonusValue",
    "RangedAttackCityBonus",
    "RangedAttackCityBonusValue",
    "RangedDefendCityBonus",
    "RangedDefendCityBonusValue",
    "RangedSubmarineBonus",
    "RangedSubmarineBonusValue",
    "RangedFootBonus",
    "RangedFootBonusValue",
    "RangedMeleeBonus",
    "RangedMeleeBonusValue",
    "RangedSiegeBonus",
    "RangedSiegeBonusValue",
    "RangedWheeledBonus",
    "RangedWheeledBonusValue",
    "RangedMechanizedBonus",
    "RangedMechanizedBonusValue",
    "RangedHelicopterBonus",
    "RangedHelicopterBonusValue",
    "RangedSpecialForcesBonus",
    "RangedSpecialForcesBonusValue",
    "RangedCivilianBonus",
    "RangedCivilianBonusValue",
    "RangedGuerrillaBonus",
    "RangedGuerrillaBonusValue",
    "RangedMountedBonus",
    "RangedMountedBonusValue",
    "RangedWoodenShipBonus",
    "RangedWoodenShipBonusValue",
    "RangedSurfaceShipBonus",
    "RangedSurfaceShipBonusValue",
    "IgnoreCityWalls",
    "AlwaysHeal",
    "AttackWoodenShipBonus",
    "WoodenShipBonus",
    "WoodenShipBonusValue",
    "BonusAgainstMounted",
    "MountedBonus",
    "MountedBonusValue",
    "BonusAirDefense",
    "AirBonus",
    "AirBonusValue",
    "ReplaceWithCargoModule",
    "ReplaceWithCargoModuleValue",
    "VisibileAttacking",
    "NuclearAttack",
    "NuclearAttackValue",
    "CanSue",
    "IsStealthy",
    "SeeSurfaceFromSpace",
    "EstablishEmbassy",
    "ThrowParty",
    "HearGossip",
    "StealTechnology",
    "StealTechnologyValue",
    "InciteRevolution",
    "InciteRevolutionValue",
    "AssasinateRuler",
    "AssasinateRulerValue",
    "InvestigateReadiness",
    "InvestigateReadinessValue",
    "NullifyCityWalls",
    "CreateFranchise",
    "CreateFranchiseValue",
    "CauseUnhappiness",
    "CauseUnhappinessValue",
    "ConductHits",
    "ConductHitsValue",
    "BioTerror",
    "BioTerrorValue",
    "NanoTerror",
    "NanoTerrorValue",
    "Plague",
    "PlagueValue",
    "SlaveRaids",
    "SlaveRaidsValue",
    "SettlerSlaveRaids",
    "SettlerSlaveRaidsValue",
    "SlaveUprising",
    "SlaveUprisingValue",
    "UndergroundRailway",
    "UndergroundRailwayValue",
    "VictoryEnslavement",
    "VictoryEnslavementChance",
    "VictoryEnslavementChanceValue",
    "VictoryEnslavementStacks",
    "DefuseLandMines",
    "DefuseSeaMines",
    "DefuseXrayMines",
    "IndulgenceSales",
    "IndulgenceSalesValue",
    "ConvertCities",
    "ConvertCitiesValue",
    "BuildXrayMines",
    "BuildWonder",
    "GovernmentType",
    "NoSlaves",
    "CreateRift",
    "CanCloak",
    "HiddenNationality",
    "SneakAttack",
    "SneakPillage",
    "SneakBombard",
    "ParatrooperTransport",
    "CantBuild",
    "PlantNuke",
    "PlantNukeValue",
    "IsTelevangelist",
    "CanSoothsay",
    "CanSoothsayValue",
    "CanBeRustled",
    "CreateParks",
    "CreateParksValue",
    "CanInjoin",
    "CanInjoinValue",
    "WormholeProbe",
    "HasBonusFood",
    "LandCityCanBuild",
    "SeaCityCanBuild",
    "SpaceCityCanBuild",
    "IsSpecialForces",
    "IsPeaceKeeper",
    "IsGuerrilla",
    "IsWorker",
    "NotAffectedByLandMines",
    "InternalReserved",
    "DeathEffectsHappy",
    "EnableCarrierDefenses",
    "ActiveDefenseOnlyWhenCarryingEnablers",
    "BuildingRemovesAPop",
    "PopCostsToBuild",
    "PopCostsToBuildValue",
    "Explodes",
    "Advertise",
    "CanRustle",
    "OnlyBuildOne",
    "CanExpel",
    "CanReform",
    "CanReformValue",
    "CanPillage",
    "CanPirate",
    "CanCaptureTile",
    "ReducesDefensesBonus",
    "VisionClass",
    "CanSee",
    "CanAttack",
    "CargoData",
    "CargoDataValue",
    "ShieldCost",
    "PowerPoints",
    "MaxHP",
    "MaxHPr",
    "Attack",
    "Defense",
    "Firepower",
    "ZBRangeAttack",
    "Armor",
    "BRange",
    "BRangeValue",
    "BRadius",
    "BRadiusValue",
    "VisionRange",
    "ActiveDefenseRange",
    "ElectronicCombatFactor",
    "ElectronicCombatFactorValue",
    "MaxMovePoints",
    "MaxFuel",
    "TransType",
    "TransTypeValue",
    "ProbOfBombHit",
    "ProbOfBombHitValue",
    "BombRounds",
    "BombRoundsValue",
    "ShieldHunger",
    "FoodHunger",
    "GoldHunger",
    "DefaultSprite",
    "LaunchPollution",
    "LaunchPollutionValue",
    "DeathPollution",
    "DeathPollutionValue",
    "CargoModule",
    "CargoModuleValue",
    "SpyVsSpy",
    "SpyVsSpyValue",
    "InvestigateCity",
    "InvestigateCityValue",
    "BonusFood",
    "BonusFoodValue",
    "BombardRange",
    "BombardRangeValue",
    "Revolution",
    "RevolutionValue",
    "SoundSelect1",
    "SoundSelect2",
    "SoundMove",
    "SoundAcknowledge",
    "SoundCantMove",
    "SoundAttack",
    "SoundWork",
    "SoundVictory",
    "SoundDeath",
    "SoundLoad",
    "SoundUnload",
    "SpecialAttacks",
    "CityGrowthCoefficient",
    "CityGrowthCoefficientValue",
    "UserFlags",
    "DefaultIcon",
    "NoIndex",
    "CheatIndex",
    "CheatIndexValue",
    "Description",
    "Advice",
    "AdviceValue",
    "Category",
    "GLHidden",
    "CantMove",
    "Civilian",
    "InvisibleForGlobeSat",
    "NoBarbarian",
    "GoodyHutExcluded",
    "CanHarvest",
    "CantGroup",
    "SpawnsBarbarians",
    "CanSinkInSea",
    "Leader",
    "ArmyMountedBonus",
    "ArmyMountedBonusValue",
    "ArmyAirBonus",
    "ArmyAirBonusValue",
    "ArmyWoodenShipBonus",
    "ArmyWoodenShipBonusValue",
    "ArmyAttackCityBonus",
    "ArmyAttackCityBonusValue",
    "ArmyAttackBonusSubmarine",
    "ArmyAttackBonusSubmarineValue",
    "ArmyFootBonus",
    "ArmyFootBonusValue",
    "ArmyMeleeBonus",
    "ArmyMeleeBonusValue",
    "ArmySiegeBonus",
    "ArmySiegeBonusValue",
    "ArmyWheeledBonus",
    "ArmyWheeledBonusValue",
    "ArmyMechanizedBonus",
    "ArmyMechanizedBonusValue",
    "ArmyHelicopterBonus",
    "ArmyHelicopterBonusValue",
    "ArmySpecialForcesBonus",
    "ArmySpecialForcesBonusValue",
    "ArmyCivilianBonus",
    "ArmyCivilianBonusValue",
    "ArmyGuerrillaBonus",
    "ArmyGuerrillaBonusValue",
    "ArmyAgainstMountedBonus",
    "ArmyAgainstMountedBonusValue",
    "ArmyAirDefenseBonus",
    "ArmyAirDefenseBonusValue",
    "EnergyHunger",
    "ProducesEnergy",
    "HasReligionIcon",
    "HasReligionIconValue",
};

UnitRecordAccessorInfo g_UnitRecord_Accessors[] =
{
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MovementType */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanCarry */
    { &UnitRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetNumObsoleteAdvance, NULL, NULL, NULL, NULL, &UnitRecord::GetObsoleteAdvanceIndex, NULL}, /* ObsoleteAdvance (array) */
    { &UnitRecord::GetNumPrerequisiteBuilding, NULL, NULL, NULL, NULL, &UnitRecord::GetPrerequisiteBuildingIndex, NULL}, /* PrerequisiteBuilding (array) */
    { &UnitRecord::GetNumExcludedByBuilding, NULL, NULL, NULL, NULL, &UnitRecord::GetExcludedByBuildingIndex, NULL}, /* ExcludedByBuilding (array) */
    { &UnitRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &UnitRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { &UnitRecord::GetNumCanSettleOn, NULL, NULL, NULL, NULL, &UnitRecord::GetCanSettleOnIndex, NULL}, /* CanSettleOn (array) */
    { &UnitRecord::GetNumUpgradeTo, NULL, NULL, NULL, NULL, &UnitRecord::GetUpgradeToIndex, NULL}, /* UpgradeTo (array) */
    { &UnitRecord::GetNumObsoleteUnit, NULL, NULL, NULL, NULL, &UnitRecord::GetObsoleteUnitIndex, NULL}, /* ObsoleteUnit (array) */
    { &UnitRecord::GetNumCultureOnly, NULL, NULL, NULL, NULL, &UnitRecord::GetCultureOnlyIndex, NULL}, /* CultureOnly (array) */
    { &UnitRecord::GetNumCityStyleOnly, NULL, NULL, NULL, NULL, &UnitRecord::GetCityStyleOnlyIndex, NULL}, /* CityStyleOnly (array) */
    { &UnitRecord::GetNumCivilisationOnly, NULL, NULL, NULL, NULL, &UnitRecord::GetCivilisationOnlyIndex, NULL}, /* CivilisationOnly (array) */
    { &UnitRecord::GetNumGovernmentOnly, NULL, NULL, NULL, NULL, &UnitRecord::GetGovernmentOnlyIndex, NULL}, /* GovernmentOnly (array) */
    { &UnitRecord::GetNumSettleImprovement, NULL, NULL, NULL, NULL, &UnitRecord::GetSettleImprovementIndex, NULL}, /* SettleImprovement (array) */
    { &UnitRecord::GetNumNeedsCityGood, NULL, NULL, NULL, NULL, &UnitRecord::GetNeedsCityGoodIndex, NULL}, /* NeedsCityGood (array) */
    { &UnitRecord::GetNumNeedsCityGoodAll, NULL, NULL, NULL, NULL, &UnitRecord::GetNeedsCityGoodAllIndex, NULL}, /* NeedsCityGoodAll (array) */
    { &UnitRecord::GetNumNeedsCityGoodCapitol, NULL, NULL, NULL, NULL, &UnitRecord::GetNeedsCityGoodCapitolIndex, NULL}, /* NeedsCityGoodCapitol (array) */
    { &UnitRecord::GetNumNeedsCityGoodAnyCity, NULL, NULL, NULL, NULL, &UnitRecord::GetNeedsCityGoodAnyCityIndex, NULL}, /* NeedsCityGoodAnyCity (array) */
    { &UnitRecord::GetNumNeedsFeatToBuild, NULL, NULL, NULL, NULL, &UnitRecord::GetNeedsFeatToBuildIndex, NULL}, /* NeedsFeatToBuild (array) */
    { &UnitRecord::GetNumNeedsAnyPlayerFeatToBuild, NULL, NULL, NULL, NULL, &UnitRecord::GetNeedsAnyPlayerFeatToBuildIndex, NULL}, /* NeedsAnyPlayerFeatToBuild (array) */
    { &UnitRecord::GetNumPrerequisiteWonder, NULL, NULL, NULL, NULL, &UnitRecord::GetPrerequisiteWonderIndex, NULL}, /* PrerequisiteWonder (array) */
    { &UnitRecord::GetNumExcludedByWonder, NULL, NULL, NULL, NULL, &UnitRecord::GetExcludedByWonderIndex, NULL}, /* ExcludedByWonder (array) */
    { NULL, NULL, NULL, &UnitRecord::GetMoveBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MoveBonus */
    { NULL, NULL, NULL, &UnitRecord::GetPWMoveCost, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PWMoveCost */
    { NULL, NULL, NULL, &UnitRecord::GetMerchantGold, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MerchantGold */
    { NULL, &UnitRecord::GetIsGreatBuilder, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsGreatArtist, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetNumAllTerrainAsImprovement, NULL, NULL, NULL, NULL, &UnitRecord::GetAllTerrainAsImprovementIndex, NULL}, /* AllTerrainAsImprovement (array) */
    { &UnitRecord::GetNumObsoleteByUnit, NULL, NULL, NULL, NULL, &UnitRecord::GetObsoleteByUnitIndex, NULL}, /* ObsoleteByUnit (array) */
    { NULL, &UnitRecord::GetNonLethalBombard, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanBombardTiles, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCollateralTileDamage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetPrecisionStrike, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetTargetsCivilians, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetImmuneToHostileTerrain, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanRebase, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetMultipleAttacks, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanBeGifted, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetUpgradeAnywhere, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetUpgradeDoesNotHeal, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Size */
    { NULL, &UnitRecord::GetLossMoveToDmgNone, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetLossMoveToDmgTwo, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoFuelThenCrash, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetTransformPartial, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIgnoreZOC, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoZoc, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanBombard */
    { NULL, &UnitRecord::GetCanCounterBombard, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanLiftOff, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Settle */
    { &UnitRecord::GetSettleCityTypeIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSettleSize, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetNumSettleBuilding, NULL, NULL, NULL, NULL, &UnitRecord::GetSettleBuildingIndex, NULL}, /* SettleBuilding (array) */
    { &UnitRecord::GetNumEstablishBuilding, NULL, NULL, NULL, NULL, &UnitRecord::GetEstablishBuildingIndex, NULL}, /* EstablishBuilding (array) */
    { NULL, NULL, NULL, &UnitRecord::GetSpaceLaunch, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpaceLaunch */
    { NULL, &UnitRecord::GetSpaceLand, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCantCaptureCity, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetHasPopAndCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsTrader, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetExertsMartialLaw, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanEntrench, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanPatrol, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNeedsNoSupport, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanExpelPop, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsFlanker, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanBeachAssault, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Defend */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendAgainstSpies, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendAgainstSpies */
    { NULL, &UnitRecord::GetCanBeExpelled, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanBeSued, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetAttackFromSpaceship, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCantBeAttacked, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCargoPod, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsFoot, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsMelee, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsMounted, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsSiege, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsWheeled, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsMechanized, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsHelicopter, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsSubmarine, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsSurfaceShip, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetWoodenShip, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoLandAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoSeaAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoAirAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoSpaceAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoUnderwaterAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoMountainAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoShallowWaterAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSingleUse, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetParatrooper, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetAssistedDrops, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendAirBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendAirBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendCityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendCityBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendSubmarineBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendSubmarineBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendFootBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendFootBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendMeleeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendMeleeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendSiegeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendSiegeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendWheeledBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendWheeledBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendMechanizedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendMechanizedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendHelicopterBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendHelicopterBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendSpecialForcesBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendSpecialForcesBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendCivilianBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendCivilianBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendGuerrillaBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendGuerrillaBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendWoodenShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendWoodenShipBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetDefendSurfaceShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefendSurfaceShipBonus */
    { NULL, &UnitRecord::GetNoDefenseBonuses, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackAirBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackAirBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackCityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackCityBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackSubmarineBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackSubmarineBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackFootBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackFootBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackMeleeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackMeleeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackSiegeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackSiegeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackWheeledBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackWheeledBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackMechanizedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackMechanizedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackHelicopterBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackHelicopterBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackSpecialForcesBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackSpecialForcesBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackCivilianBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackCivilianBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackGuerrillaBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackGuerrillaBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackWoodenShipBonusNew, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackWoodenShipBonusNew */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAttackSurfaceShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AttackSurfaceShipBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedAirBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedAirBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedAttackCityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedAttackCityBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedDefendCityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedDefendCityBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedSubmarineBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedSubmarineBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedFootBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedFootBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedMeleeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedMeleeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedSiegeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedSiegeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedWheeledBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedWheeledBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedMechanizedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedMechanizedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedHelicopterBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedHelicopterBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedSpecialForcesBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedSpecialForcesBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedCivilianBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedCivilianBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedGuerrillaBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedGuerrillaBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedWoodenShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedWoodenShipBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetRangedSurfaceShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* RangedSurfaceShipBonus */
    { NULL, &UnitRecord::GetIgnoreCityWalls, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetAlwaysHeal, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetAttackWoodenShipBonus, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitRecord::GetWoodenShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* WoodenShipBonus */
    { NULL, &UnitRecord::GetBonusAgainstMounted, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitRecord::GetMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MountedBonus */
    { NULL, &UnitRecord::GetBonusAirDefense, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitRecord::GetAirBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AirBonus */
    { NULL, NULL, NULL, &UnitRecord::GetReplaceWithCargoModule, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ReplaceWithCargoModule */
    { NULL, &UnitRecord::GetVisibileAttacking, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearAttack */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearAttack */
    { NULL, &UnitRecord::GetCanSue, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsStealthy, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSeeSurfaceFromSpace, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetEstablishEmbassy, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetThrowParty, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetHearGossip, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StealTechnology */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StealTechnology */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InciteRevolution */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InciteRevolution */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AssasinateRuler */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AssasinateRuler */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateReadiness */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateReadiness */
    { NULL, &UnitRecord::GetNullifyCityWalls, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateFranchise */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateFranchise */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CauseUnhappiness */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CauseUnhappiness */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConductHits */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConductHits */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BioTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BioTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NanoTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NanoTerror */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Plague */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Plague */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SettlerSlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SettlerSlaveRaids */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveUprising */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SlaveUprising */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UndergroundRailway */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UndergroundRailway */
    { NULL, &UnitRecord::GetVictoryEnslavement, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitRecord::GetVictoryEnslavementChance, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* VictoryEnslavementChance */
    { NULL, &UnitRecord::GetVictoryEnslavementStacks, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetDefuseLandMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetDefuseSeaMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetDefuseXrayMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IndulgenceSales */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IndulgenceSales */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConvertCities */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ConvertCities */
    { NULL, &UnitRecord::GetBuildXrayMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetBuildWonder, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetNumGovernmentType, NULL, NULL, NULL, NULL, &UnitRecord::GetGovernmentTypeIndex, NULL}, /* GovernmentType (array) */
    { NULL, &UnitRecord::GetNoSlaves, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCreateRift, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanCloak, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetHiddenNationality, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSneakAttack, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSneakPillage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSneakBombard, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetParatrooperTransport, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCantBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PlantNuke */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PlantNuke */
    { NULL, &UnitRecord::GetIsTelevangelist, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanSoothsay */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanSoothsay */
    { NULL, &UnitRecord::GetCanBeRustled, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateParks */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CreateParks */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanInjoin */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanInjoin */
    { NULL, &UnitRecord::GetWormholeProbe, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetHasBonusFood, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetLandCityCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSeaCityCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSpaceCityCanBuild, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsSpecialForces, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsPeaceKeeper, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsGuerrilla, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetIsWorker, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNotAffectedByLandMines, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetInternalReserved, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetDeathEffectsHappy, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetEnableCarrierDefenses, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetActiveDefenseOnlyWhenCarryingEnablers, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetBuildingRemovesAPop, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitRecord::GetPopCostsToBuild, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* PopCostsToBuild */
    { NULL, &UnitRecord::GetExplodes, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetAdvertise, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanRustle, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetOnlyBuildOne, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanExpel, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanReform */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanReform */
    { NULL, &UnitRecord::GetCanPillage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanPirate, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanCaptureTile, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetReducesDefensesBonus, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* VisionClass */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanSee */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanAttack */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CargoData */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CargoData */
    { &UnitRecord::GetShieldCost, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetPowerPoints, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetMaxHP, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitRecord::GetMaxHPr, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitRecord::GetAttack, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitRecord::GetDefense, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetFirepower, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetZBRangeAttack, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &UnitRecord::GetArmor, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitRecord::GetBRange, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BRange */
    { NULL, NULL, NULL, &UnitRecord::GetBRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BRadius */
    { &UnitRecord::GetVisionRange, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetActiveDefenseRange, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitRecord::GetElectronicCombatFactor, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ElectronicCombatFactor */
    { NULL, NULL, &UnitRecord::GetMaxMovePoints, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetMaxFuel, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitRecord::GetTransType, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TransType */
    { NULL, NULL, NULL, &UnitRecord::GetProbOfBombHit, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ProbOfBombHit */
    { NULL, NULL, NULL, &UnitRecord::GetBombRounds, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BombRounds */
    { &UnitRecord::GetShieldHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetFoodHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetGoldHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetDefaultSpriteIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitRecord::GetLaunchPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LaunchPollution */
    { NULL, NULL, NULL, &UnitRecord::GetDeathPollution, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DeathPollution */
    { NULL, NULL, NULL, &UnitRecord::GetCargoModule, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CargoModule */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetSpyVsSpy, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SpyVsSpy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateCity */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* InvestigateCity */
    { NULL, NULL, NULL, &UnitRecord::GetBonusFood, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BonusFood */
    { NULL, NULL, NULL, &UnitRecord::GetBombardRange, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BombardRange */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Revolution */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Revolution */
    { &UnitRecord::GetSoundSelect1Index, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundSelect2Index, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundMoveIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundAcknowledgeIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundCantMoveIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundAttackIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundWorkIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundVictoryIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundDeathIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundLoadIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetSoundUnloadIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetNumSpecialAttacks, NULL, NULL, NULL, NULL, &UnitRecord::GetSpecialAttacksIndex, NULL}, /* SpecialAttacks (array) */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetCityGrowthCoefficient, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CityGrowthCoefficient */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* UserFlags */
    { &UnitRecord::GetDefaultIconIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoIndex, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, &UnitRecord::GetCheatIndex, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CheatIndex */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Description */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Advice */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Advice */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Category */
    { NULL, &UnitRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCantMove, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCivilian, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetInvisibleForGlobeSat, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetNoBarbarian, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetGoodyHutExcluded, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanHarvest, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCantGroup, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetSpawnsBarbarians, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetCanSinkInSea, NULL, NULL, NULL, NULL, NULL },
    { NULL, &UnitRecord::GetLeader, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyAirBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAirBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyWoodenShipBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyWoodenShipBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyAttackCityBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAttackCityBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyAttackBonusSubmarine, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAttackBonusSubmarine */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyFootBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyFootBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyMeleeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyMeleeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmySiegeBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmySiegeBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyWheeledBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyWheeledBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyMechanizedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyMechanizedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyHelicopterBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyHelicopterBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmySpecialForcesBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmySpecialForcesBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyCivilianBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyCivilianBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyGuerrillaBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyGuerrillaBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyAgainstMountedBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAgainstMountedBonus */
    { NULL, NULL, NULL, NULL, &UnitRecord::GetArmyAirDefenseBonus, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ArmyAirDefenseBonus */
    { &UnitRecord::GetEnergyHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &UnitRecord::GetProducesEnergy, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* HasReligionIcon */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* HasReligionIcon */
};

#define k_Token_Unit_MovementType                ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_CanCarry                    ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_EnableAdvance               ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_ObsoleteAdvance             ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_PrerequisiteBuilding        ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_ExcludedByBuilding          ((k_Token_Custom_Base) + 5)
#define k_Token_Unit_GovernmentsModified         ((k_Token_Custom_Base) + 6)
#define k_Token_Unit_CanSettleOn                 ((k_Token_Custom_Base) + 7)
#define k_Token_Unit_UpgradeTo                   ((k_Token_Custom_Base) + 8)
#define k_Token_Unit_ObsoleteUnit                ((k_Token_Custom_Base) + 9)
#define k_Token_Unit_CultureOnly                 ((k_Token_Custom_Base) + 10)
#define k_Token_Unit_CityStyleOnly               ((k_Token_Custom_Base) + 11)
#define k_Token_Unit_CivilisationOnly            ((k_Token_Custom_Base) + 12)
#define k_Token_Unit_GovernmentOnly              ((k_Token_Custom_Base) + 13)
#define k_Token_Unit_SettleImprovement           ((k_Token_Custom_Base) + 14)
#define k_Token_Unit_NeedsCityGood               ((k_Token_Custom_Base) + 15)
#define k_Token_Unit_NeedsCityGoodAll            ((k_Token_Custom_Base) + 16)
#define k_Token_Unit_NeedsCityGoodCapitol        ((k_Token_Custom_Base) + 17)
#define k_Token_Unit_NeedsCityGoodAnyCity        ((k_Token_Custom_Base) + 18)
#define k_Token_Unit_NeedsFeatToBuild            ((k_Token_Custom_Base) + 19)
#define k_Token_Unit_NeedsAnyPlayerFeatToBuild   ((k_Token_Custom_Base) + 20)
#define k_Token_Unit_PrerequisiteWonder          ((k_Token_Custom_Base) + 21)
#define k_Token_Unit_ExcludedByWonder            ((k_Token_Custom_Base) + 22)
#define k_Token_Unit_MoveBonus                   ((k_Token_Custom_Base) + 23)
#define k_Token_Unit_MoveBonus_Value             ((k_Token_Custom_Base) + 24)
#define k_Token_Unit_PWMoveCost                  ((k_Token_Custom_Base) + 25)
#define k_Token_Unit_PWMoveCost_Value            ((k_Token_Custom_Base) + 26)
#define k_Token_Unit_MerchantGold                ((k_Token_Custom_Base) + 27)
#define k_Token_Unit_MerchantGold_Value          ((k_Token_Custom_Base) + 28)
#define k_Token_Unit_IsGreatBuilder              ((k_Token_Custom_Base) + 29)
#define k_Token_Unit_IsGreatArtist               ((k_Token_Custom_Base) + 30)
#define k_Token_Unit_AllTerrainAsImprovement     ((k_Token_Custom_Base) + 31)
#define k_Token_Unit_ObsoleteByUnit              ((k_Token_Custom_Base) + 32)
#define k_Token_Unit_NonLethalBombard            ((k_Token_Custom_Base) + 33)
#define k_Token_Unit_CanBombardTiles             ((k_Token_Custom_Base) + 34)
#define k_Token_Unit_CollateralTileDamage        ((k_Token_Custom_Base) + 35)
#define k_Token_Unit_PrecisionStrike             ((k_Token_Custom_Base) + 36)
#define k_Token_Unit_TargetsCivilians            ((k_Token_Custom_Base) + 37)
#define k_Token_Unit_ImmuneToHostileTerrain      ((k_Token_Custom_Base) + 38)
#define k_Token_Unit_CanRebase                   ((k_Token_Custom_Base) + 39)
#define k_Token_Unit_MultipleAttacks             ((k_Token_Custom_Base) + 40)
#define k_Token_Unit_CanBeGifted                 ((k_Token_Custom_Base) + 41)
#define k_Token_Unit_UpgradeAnywhere             ((k_Token_Custom_Base) + 42)
#define k_Token_Unit_UpgradeDoesNotHeal          ((k_Token_Custom_Base) + 43)
#define k_Token_Unit_Size                        ((k_Token_Custom_Base) + 44)
#define k_Token_Unit_LossMoveToDmgNone           ((k_Token_Custom_Base) + 45)
#define k_Token_Unit_LossMoveToDmgTwo            ((k_Token_Custom_Base) + 46)
#define k_Token_Unit_NoFuelThenCrash             ((k_Token_Custom_Base) + 47)
#define k_Token_Unit_TransformPartial            ((k_Token_Custom_Base) + 48)
#define k_Token_Unit_IgnoreZOC                   ((k_Token_Custom_Base) + 49)
#define k_Token_Unit_NoZoc                       ((k_Token_Custom_Base) + 50)
#define k_Token_Unit_CanBombard                  ((k_Token_Custom_Base) + 51)
#define k_Token_Unit_CanCounterBombard           ((k_Token_Custom_Base) + 52)
#define k_Token_Unit_CanLiftOff                  ((k_Token_Custom_Base) + 53)
#define k_Token_Unit_Settle                      ((k_Token_Custom_Base) + 54)
#define k_Token_Unit_SettleCityType              ((k_Token_Custom_Base) + 55)
#define k_Token_Unit_SettleSize                  ((k_Token_Custom_Base) + 56)
#define k_Token_Unit_SettleBuilding              ((k_Token_Custom_Base) + 57)
#define k_Token_Unit_EstablishBuilding           ((k_Token_Custom_Base) + 58)
#define k_Token_Unit_SpaceLaunch                 ((k_Token_Custom_Base) + 59)
#define k_Token_Unit_SpaceLaunch_Value           ((k_Token_Custom_Base) + 60)
#define k_Token_Unit_SpaceLand                   ((k_Token_Custom_Base) + 61)
#define k_Token_Unit_CantCaptureCity             ((k_Token_Custom_Base) + 62)
#define k_Token_Unit_HasPopAndCanBuild           ((k_Token_Custom_Base) + 63)
#define k_Token_Unit_IsTrader                    ((k_Token_Custom_Base) + 64)
#define k_Token_Unit_ExertsMartialLaw            ((k_Token_Custom_Base) + 65)
#define k_Token_Unit_CanEntrench                 ((k_Token_Custom_Base) + 66)
#define k_Token_Unit_CanPatrol                   ((k_Token_Custom_Base) + 67)
#define k_Token_Unit_NeedsNoSupport              ((k_Token_Custom_Base) + 68)
#define k_Token_Unit_CanExpelPop                 ((k_Token_Custom_Base) + 69)
#define k_Token_Unit_IsFlanker                   ((k_Token_Custom_Base) + 70)
#define k_Token_Unit_CanBeachAssault             ((k_Token_Custom_Base) + 71)
#define k_Token_Unit_Defend                      ((k_Token_Custom_Base) + 72)
#define k_Token_Unit_DefendAgainstSpies          ((k_Token_Custom_Base) + 73)
#define k_Token_Unit_DefendAgainstSpies_Value    ((k_Token_Custom_Base) + 74)
#define k_Token_Unit_CanBeExpelled               ((k_Token_Custom_Base) + 75)
#define k_Token_Unit_CanBeSued                   ((k_Token_Custom_Base) + 76)
#define k_Token_Unit_AttackFromSpaceship         ((k_Token_Custom_Base) + 77)
#define k_Token_Unit_CantBeAttacked              ((k_Token_Custom_Base) + 78)
#define k_Token_Unit_CargoPod                    ((k_Token_Custom_Base) + 79)
#define k_Token_Unit_IsFoot                      ((k_Token_Custom_Base) + 80)
#define k_Token_Unit_IsMelee                     ((k_Token_Custom_Base) + 81)
#define k_Token_Unit_IsMounted                   ((k_Token_Custom_Base) + 82)
#define k_Token_Unit_IsSiege                     ((k_Token_Custom_Base) + 83)
#define k_Token_Unit_IsWheeled                   ((k_Token_Custom_Base) + 84)
#define k_Token_Unit_IsMechanized                ((k_Token_Custom_Base) + 85)
#define k_Token_Unit_IsHelicopter                ((k_Token_Custom_Base) + 86)
#define k_Token_Unit_IsSubmarine                 ((k_Token_Custom_Base) + 87)
#define k_Token_Unit_IsSurfaceShip               ((k_Token_Custom_Base) + 88)
#define k_Token_Unit_WoodenShip                  ((k_Token_Custom_Base) + 89)
#define k_Token_Unit_NoLandAttack                ((k_Token_Custom_Base) + 90)
#define k_Token_Unit_NoSeaAttack                 ((k_Token_Custom_Base) + 91)
#define k_Token_Unit_NoAirAttack                 ((k_Token_Custom_Base) + 92)
#define k_Token_Unit_NoSpaceAttack               ((k_Token_Custom_Base) + 93)
#define k_Token_Unit_NoUnderwaterAttack          ((k_Token_Custom_Base) + 94)
#define k_Token_Unit_NoMountainAttack            ((k_Token_Custom_Base) + 95)
#define k_Token_Unit_NoShallowWaterAttack        ((k_Token_Custom_Base) + 96)
#define k_Token_Unit_SingleUse                   ((k_Token_Custom_Base) + 97)
#define k_Token_Unit_Paratrooper                 ((k_Token_Custom_Base) + 98)
#define k_Token_Unit_AssistedDrops               ((k_Token_Custom_Base) + 99)
#define k_Token_Unit_DefendAirBonus              ((k_Token_Custom_Base) + 100)
#define k_Token_Unit_DefendAirBonus_Value        ((k_Token_Custom_Base) + 101)
#define k_Token_Unit_DefendCityBonus             ((k_Token_Custom_Base) + 102)
#define k_Token_Unit_DefendCityBonus_Value       ((k_Token_Custom_Base) + 103)
#define k_Token_Unit_DefendSubmarineBonus        ((k_Token_Custom_Base) + 104)
#define k_Token_Unit_DefendSubmarineBonus_Value  ((k_Token_Custom_Base) + 105)
#define k_Token_Unit_DefendFootBonus             ((k_Token_Custom_Base) + 106)
#define k_Token_Unit_DefendFootBonus_Value       ((k_Token_Custom_Base) + 107)
#define k_Token_Unit_DefendMeleeBonus            ((k_Token_Custom_Base) + 108)
#define k_Token_Unit_DefendMeleeBonus_Value      ((k_Token_Custom_Base) + 109)
#define k_Token_Unit_DefendSiegeBonus            ((k_Token_Custom_Base) + 110)
#define k_Token_Unit_DefendSiegeBonus_Value      ((k_Token_Custom_Base) + 111)
#define k_Token_Unit_DefendWheeledBonus          ((k_Token_Custom_Base) + 112)
#define k_Token_Unit_DefendWheeledBonus_Value    ((k_Token_Custom_Base) + 113)
#define k_Token_Unit_DefendMechanizedBonus       ((k_Token_Custom_Base) + 114)
#define k_Token_Unit_DefendMechanizedBonus_Value ((k_Token_Custom_Base) + 115)
#define k_Token_Unit_DefendHelicopterBonus       ((k_Token_Custom_Base) + 116)
#define k_Token_Unit_DefendHelicopterBonus_Value ((k_Token_Custom_Base) + 117)
#define k_Token_Unit_DefendSpecialForcesBonus    ((k_Token_Custom_Base) + 118)
#define k_Token_Unit_DefendSpecialForcesBonus_Value ((k_Token_Custom_Base) + 119)
#define k_Token_Unit_DefendCivilianBonus         ((k_Token_Custom_Base) + 120)
#define k_Token_Unit_DefendCivilianBonus_Value   ((k_Token_Custom_Base) + 121)
#define k_Token_Unit_DefendGuerrillaBonus        ((k_Token_Custom_Base) + 122)
#define k_Token_Unit_DefendGuerrillaBonus_Value  ((k_Token_Custom_Base) + 123)
#define k_Token_Unit_DefendMountedBonus          ((k_Token_Custom_Base) + 124)
#define k_Token_Unit_DefendMountedBonus_Value    ((k_Token_Custom_Base) + 125)
#define k_Token_Unit_DefendWoodenShipBonus       ((k_Token_Custom_Base) + 126)
#define k_Token_Unit_DefendWoodenShipBonus_Value ((k_Token_Custom_Base) + 127)
#define k_Token_Unit_DefendSurfaceShipBonus      ((k_Token_Custom_Base) + 128)
#define k_Token_Unit_DefendSurfaceShipBonus_Value ((k_Token_Custom_Base) + 129)
#define k_Token_Unit_NoDefenseBonuses            ((k_Token_Custom_Base) + 130)
#define k_Token_Unit_AttackAirBonus              ((k_Token_Custom_Base) + 131)
#define k_Token_Unit_AttackAirBonus_Value        ((k_Token_Custom_Base) + 132)
#define k_Token_Unit_AttackCityBonus             ((k_Token_Custom_Base) + 133)
#define k_Token_Unit_AttackCityBonus_Value       ((k_Token_Custom_Base) + 134)
#define k_Token_Unit_AttackSubmarineBonus        ((k_Token_Custom_Base) + 135)
#define k_Token_Unit_AttackSubmarineBonus_Value  ((k_Token_Custom_Base) + 136)
#define k_Token_Unit_AttackFootBonus             ((k_Token_Custom_Base) + 137)
#define k_Token_Unit_AttackFootBonus_Value       ((k_Token_Custom_Base) + 138)
#define k_Token_Unit_AttackMeleeBonus            ((k_Token_Custom_Base) + 139)
#define k_Token_Unit_AttackMeleeBonus_Value      ((k_Token_Custom_Base) + 140)
#define k_Token_Unit_AttackSiegeBonus            ((k_Token_Custom_Base) + 141)
#define k_Token_Unit_AttackSiegeBonus_Value      ((k_Token_Custom_Base) + 142)
#define k_Token_Unit_AttackWheeledBonus          ((k_Token_Custom_Base) + 143)
#define k_Token_Unit_AttackWheeledBonus_Value    ((k_Token_Custom_Base) + 144)
#define k_Token_Unit_AttackMechanizedBonus       ((k_Token_Custom_Base) + 145)
#define k_Token_Unit_AttackMechanizedBonus_Value ((k_Token_Custom_Base) + 146)
#define k_Token_Unit_AttackHelicopterBonus       ((k_Token_Custom_Base) + 147)
#define k_Token_Unit_AttackHelicopterBonus_Value ((k_Token_Custom_Base) + 148)
#define k_Token_Unit_AttackSpecialForcesBonus    ((k_Token_Custom_Base) + 149)
#define k_Token_Unit_AttackSpecialForcesBonus_Value ((k_Token_Custom_Base) + 150)
#define k_Token_Unit_AttackCivilianBonus         ((k_Token_Custom_Base) + 151)
#define k_Token_Unit_AttackCivilianBonus_Value   ((k_Token_Custom_Base) + 152)
#define k_Token_Unit_AttackGuerrillaBonus        ((k_Token_Custom_Base) + 153)
#define k_Token_Unit_AttackGuerrillaBonus_Value  ((k_Token_Custom_Base) + 154)
#define k_Token_Unit_AttackMountedBonus          ((k_Token_Custom_Base) + 155)
#define k_Token_Unit_AttackMountedBonus_Value    ((k_Token_Custom_Base) + 156)
#define k_Token_Unit_AttackWoodenShipBonusNew    ((k_Token_Custom_Base) + 157)
#define k_Token_Unit_AttackWoodenShipBonusNew_Value ((k_Token_Custom_Base) + 158)
#define k_Token_Unit_AttackSurfaceShipBonus      ((k_Token_Custom_Base) + 159)
#define k_Token_Unit_AttackSurfaceShipBonus_Value ((k_Token_Custom_Base) + 160)
#define k_Token_Unit_RangedAirBonus              ((k_Token_Custom_Base) + 161)
#define k_Token_Unit_RangedAirBonus_Value        ((k_Token_Custom_Base) + 162)
#define k_Token_Unit_RangedAttackCityBonus       ((k_Token_Custom_Base) + 163)
#define k_Token_Unit_RangedAttackCityBonus_Value ((k_Token_Custom_Base) + 164)
#define k_Token_Unit_RangedDefendCityBonus       ((k_Token_Custom_Base) + 165)
#define k_Token_Unit_RangedDefendCityBonus_Value ((k_Token_Custom_Base) + 166)
#define k_Token_Unit_RangedSubmarineBonus        ((k_Token_Custom_Base) + 167)
#define k_Token_Unit_RangedSubmarineBonus_Value  ((k_Token_Custom_Base) + 168)
#define k_Token_Unit_RangedFootBonus             ((k_Token_Custom_Base) + 169)
#define k_Token_Unit_RangedFootBonus_Value       ((k_Token_Custom_Base) + 170)
#define k_Token_Unit_RangedMeleeBonus            ((k_Token_Custom_Base) + 171)
#define k_Token_Unit_RangedMeleeBonus_Value      ((k_Token_Custom_Base) + 172)
#define k_Token_Unit_RangedSiegeBonus            ((k_Token_Custom_Base) + 173)
#define k_Token_Unit_RangedSiegeBonus_Value      ((k_Token_Custom_Base) + 174)
#define k_Token_Unit_RangedWheeledBonus          ((k_Token_Custom_Base) + 175)
#define k_Token_Unit_RangedWheeledBonus_Value    ((k_Token_Custom_Base) + 176)
#define k_Token_Unit_RangedMechanizedBonus       ((k_Token_Custom_Base) + 177)
#define k_Token_Unit_RangedMechanizedBonus_Value ((k_Token_Custom_Base) + 178)
#define k_Token_Unit_RangedHelicopterBonus       ((k_Token_Custom_Base) + 179)
#define k_Token_Unit_RangedHelicopterBonus_Value ((k_Token_Custom_Base) + 180)
#define k_Token_Unit_RangedSpecialForcesBonus    ((k_Token_Custom_Base) + 181)
#define k_Token_Unit_RangedSpecialForcesBonus_Value ((k_Token_Custom_Base) + 182)
#define k_Token_Unit_RangedCivilianBonus         ((k_Token_Custom_Base) + 183)
#define k_Token_Unit_RangedCivilianBonus_Value   ((k_Token_Custom_Base) + 184)
#define k_Token_Unit_RangedGuerrillaBonus        ((k_Token_Custom_Base) + 185)
#define k_Token_Unit_RangedGuerrillaBonus_Value  ((k_Token_Custom_Base) + 186)
#define k_Token_Unit_RangedMountedBonus          ((k_Token_Custom_Base) + 187)
#define k_Token_Unit_RangedMountedBonus_Value    ((k_Token_Custom_Base) + 188)
#define k_Token_Unit_RangedWoodenShipBonus       ((k_Token_Custom_Base) + 189)
#define k_Token_Unit_RangedWoodenShipBonus_Value ((k_Token_Custom_Base) + 190)
#define k_Token_Unit_RangedSurfaceShipBonus      ((k_Token_Custom_Base) + 191)
#define k_Token_Unit_RangedSurfaceShipBonus_Value ((k_Token_Custom_Base) + 192)
#define k_Token_Unit_IgnoreCityWalls             ((k_Token_Custom_Base) + 193)
#define k_Token_Unit_AlwaysHeal                  ((k_Token_Custom_Base) + 194)
#define k_Token_Unit_AttackWoodenShipBonus       ((k_Token_Custom_Base) + 195)
#define k_Token_Unit_WoodenShipBonus             ((k_Token_Custom_Base) + 196)
#define k_Token_Unit_WoodenShipBonus_Value       ((k_Token_Custom_Base) + 197)
#define k_Token_Unit_BonusAgainstMounted         ((k_Token_Custom_Base) + 198)
#define k_Token_Unit_MountedBonus                ((k_Token_Custom_Base) + 199)
#define k_Token_Unit_MountedBonus_Value          ((k_Token_Custom_Base) + 200)
#define k_Token_Unit_BonusAirDefense             ((k_Token_Custom_Base) + 201)
#define k_Token_Unit_AirBonus                    ((k_Token_Custom_Base) + 202)
#define k_Token_Unit_AirBonus_Value              ((k_Token_Custom_Base) + 203)
#define k_Token_Unit_ReplaceWithCargoModule      ((k_Token_Custom_Base) + 204)
#define k_Token_Unit_ReplaceWithCargoModule_Value ((k_Token_Custom_Base) + 205)
#define k_Token_Unit_VisibileAttacking           ((k_Token_Custom_Base) + 206)
#define k_Token_Unit_NuclearAttack               ((k_Token_Custom_Base) + 207)
#define k_Token_Unit_NuclearAttack_Value         ((k_Token_Custom_Base) + 208)
#define k_Token_Unit_CanSue                      ((k_Token_Custom_Base) + 209)
#define k_Token_Unit_IsStealthy                  ((k_Token_Custom_Base) + 210)
#define k_Token_Unit_SeeSurfaceFromSpace         ((k_Token_Custom_Base) + 211)
#define k_Token_Unit_EstablishEmbassy            ((k_Token_Custom_Base) + 212)
#define k_Token_Unit_ThrowParty                  ((k_Token_Custom_Base) + 213)
#define k_Token_Unit_HearGossip                  ((k_Token_Custom_Base) + 214)
#define k_Token_Unit_StealTechnology             ((k_Token_Custom_Base) + 215)
#define k_Token_Unit_StealTechnology_Value       ((k_Token_Custom_Base) + 216)
#define k_Token_Unit_InciteRevolution            ((k_Token_Custom_Base) + 217)
#define k_Token_Unit_InciteRevolution_Value      ((k_Token_Custom_Base) + 218)
#define k_Token_Unit_AssasinateRuler             ((k_Token_Custom_Base) + 219)
#define k_Token_Unit_AssasinateRuler_Value       ((k_Token_Custom_Base) + 220)
#define k_Token_Unit_InvestigateReadiness        ((k_Token_Custom_Base) + 221)
#define k_Token_Unit_InvestigateReadiness_Value  ((k_Token_Custom_Base) + 222)
#define k_Token_Unit_NullifyCityWalls            ((k_Token_Custom_Base) + 223)
#define k_Token_Unit_CreateFranchise             ((k_Token_Custom_Base) + 224)
#define k_Token_Unit_CreateFranchise_Value       ((k_Token_Custom_Base) + 225)
#define k_Token_Unit_CauseUnhappiness            ((k_Token_Custom_Base) + 226)
#define k_Token_Unit_CauseUnhappiness_Value      ((k_Token_Custom_Base) + 227)
#define k_Token_Unit_ConductHits                 ((k_Token_Custom_Base) + 228)
#define k_Token_Unit_ConductHits_Value           ((k_Token_Custom_Base) + 229)
#define k_Token_Unit_BioTerror                   ((k_Token_Custom_Base) + 230)
#define k_Token_Unit_BioTerror_Value             ((k_Token_Custom_Base) + 231)
#define k_Token_Unit_NanoTerror                  ((k_Token_Custom_Base) + 232)
#define k_Token_Unit_NanoTerror_Value            ((k_Token_Custom_Base) + 233)
#define k_Token_Unit_Plague                      ((k_Token_Custom_Base) + 234)
#define k_Token_Unit_Plague_Value                ((k_Token_Custom_Base) + 235)
#define k_Token_Unit_SlaveRaids                  ((k_Token_Custom_Base) + 236)
#define k_Token_Unit_SlaveRaids_Value            ((k_Token_Custom_Base) + 237)
#define k_Token_Unit_SettlerSlaveRaids           ((k_Token_Custom_Base) + 238)
#define k_Token_Unit_SettlerSlaveRaids_Value     ((k_Token_Custom_Base) + 239)
#define k_Token_Unit_SlaveUprising               ((k_Token_Custom_Base) + 240)
#define k_Token_Unit_SlaveUprising_Value         ((k_Token_Custom_Base) + 241)
#define k_Token_Unit_UndergroundRailway          ((k_Token_Custom_Base) + 242)
#define k_Token_Unit_UndergroundRailway_Value    ((k_Token_Custom_Base) + 243)
#define k_Token_Unit_VictoryEnslavement          ((k_Token_Custom_Base) + 244)
#define k_Token_Unit_VictoryEnslavementChance    ((k_Token_Custom_Base) + 245)
#define k_Token_Unit_VictoryEnslavementChance_Value ((k_Token_Custom_Base) + 246)
#define k_Token_Unit_VictoryEnslavementStacks    ((k_Token_Custom_Base) + 247)
#define k_Token_Unit_DefuseLandMines             ((k_Token_Custom_Base) + 248)
#define k_Token_Unit_DefuseSeaMines              ((k_Token_Custom_Base) + 249)
#define k_Token_Unit_DefuseXrayMines             ((k_Token_Custom_Base) + 250)
#define k_Token_Unit_IndulgenceSales             ((k_Token_Custom_Base) + 251)
#define k_Token_Unit_IndulgenceSales_Value       ((k_Token_Custom_Base) + 252)
#define k_Token_Unit_ConvertCities               ((k_Token_Custom_Base) + 253)
#define k_Token_Unit_ConvertCities_Value         ((k_Token_Custom_Base) + 254)
#define k_Token_Unit_BuildXrayMines              ((k_Token_Custom_Base) + 255)
#define k_Token_Unit_BuildWonder                 ((k_Token_Custom_Base) + 256)
#define k_Token_Unit_GovernmentType              ((k_Token_Custom_Base) + 257)
#define k_Token_Unit_NoSlaves                    ((k_Token_Custom_Base) + 258)
#define k_Token_Unit_CreateRift                  ((k_Token_Custom_Base) + 259)
#define k_Token_Unit_CanCloak                    ((k_Token_Custom_Base) + 260)
#define k_Token_Unit_HiddenNationality           ((k_Token_Custom_Base) + 261)
#define k_Token_Unit_SneakAttack                 ((k_Token_Custom_Base) + 262)
#define k_Token_Unit_SneakPillage                ((k_Token_Custom_Base) + 263)
#define k_Token_Unit_SneakBombard                ((k_Token_Custom_Base) + 264)
#define k_Token_Unit_ParatrooperTransport        ((k_Token_Custom_Base) + 265)
#define k_Token_Unit_CantBuild                   ((k_Token_Custom_Base) + 266)
#define k_Token_Unit_PlantNuke                   ((k_Token_Custom_Base) + 267)
#define k_Token_Unit_PlantNuke_Value             ((k_Token_Custom_Base) + 268)
#define k_Token_Unit_IsTelevangelist             ((k_Token_Custom_Base) + 269)
#define k_Token_Unit_CanSoothsay                 ((k_Token_Custom_Base) + 270)
#define k_Token_Unit_CanSoothsay_Value           ((k_Token_Custom_Base) + 271)
#define k_Token_Unit_CanBeRustled                ((k_Token_Custom_Base) + 272)
#define k_Token_Unit_CreateParks                 ((k_Token_Custom_Base) + 273)
#define k_Token_Unit_CreateParks_Value           ((k_Token_Custom_Base) + 274)
#define k_Token_Unit_CanInjoin                   ((k_Token_Custom_Base) + 275)
#define k_Token_Unit_CanInjoin_Value             ((k_Token_Custom_Base) + 276)
#define k_Token_Unit_WormholeProbe               ((k_Token_Custom_Base) + 277)
#define k_Token_Unit_HasBonusFood                ((k_Token_Custom_Base) + 278)
#define k_Token_Unit_LandCityCanBuild            ((k_Token_Custom_Base) + 279)
#define k_Token_Unit_SeaCityCanBuild             ((k_Token_Custom_Base) + 280)
#define k_Token_Unit_SpaceCityCanBuild           ((k_Token_Custom_Base) + 281)
#define k_Token_Unit_IsSpecialForces             ((k_Token_Custom_Base) + 282)
#define k_Token_Unit_IsPeaceKeeper               ((k_Token_Custom_Base) + 283)
#define k_Token_Unit_IsGuerrilla                 ((k_Token_Custom_Base) + 284)
#define k_Token_Unit_IsWorker                    ((k_Token_Custom_Base) + 285)
#define k_Token_Unit_NotAffectedByLandMines      ((k_Token_Custom_Base) + 286)
#define k_Token_Unit_InternalReserved            ((k_Token_Custom_Base) + 287)
#define k_Token_Unit_DeathEffectsHappy           ((k_Token_Custom_Base) + 288)
#define k_Token_Unit_EnableCarrierDefenses       ((k_Token_Custom_Base) + 289)
#define k_Token_Unit_ActiveDefenseOnlyWhenCarryingEnablers ((k_Token_Custom_Base) + 290)
#define k_Token_Unit_BuildingRemovesAPop         ((k_Token_Custom_Base) + 291)
#define k_Token_Unit_PopCostsToBuild             ((k_Token_Custom_Base) + 292)
#define k_Token_Unit_PopCostsToBuild_Value       ((k_Token_Custom_Base) + 293)
#define k_Token_Unit_Explodes                    ((k_Token_Custom_Base) + 294)
#define k_Token_Unit_Advertise                   ((k_Token_Custom_Base) + 295)
#define k_Token_Unit_CanRustle                   ((k_Token_Custom_Base) + 296)
#define k_Token_Unit_OnlyBuildOne                ((k_Token_Custom_Base) + 297)
#define k_Token_Unit_CanExpel                    ((k_Token_Custom_Base) + 298)
#define k_Token_Unit_CanReform                   ((k_Token_Custom_Base) + 299)
#define k_Token_Unit_CanReform_Value             ((k_Token_Custom_Base) + 300)
#define k_Token_Unit_CanPillage                  ((k_Token_Custom_Base) + 301)
#define k_Token_Unit_CanPirate                   ((k_Token_Custom_Base) + 302)
#define k_Token_Unit_CanCaptureTile              ((k_Token_Custom_Base) + 303)
#define k_Token_Unit_ReducesDefensesBonus        ((k_Token_Custom_Base) + 304)
#define k_Token_Unit_VisionClass                 ((k_Token_Custom_Base) + 305)
#define k_Token_Unit_CanSee                      ((k_Token_Custom_Base) + 306)
#define k_Token_Unit_CanAttack                   ((k_Token_Custom_Base) + 307)
#define k_Token_Unit_CargoData                   ((k_Token_Custom_Base) + 308)
#define k_Token_Unit_CargoData_Value             ((k_Token_Custom_Base) + 309)
#define k_Token_Unit_ShieldCost                  ((k_Token_Custom_Base) + 310)
#define k_Token_Unit_PowerPoints                 ((k_Token_Custom_Base) + 311)
#define k_Token_Unit_MaxHP                       ((k_Token_Custom_Base) + 312)
#define k_Token_Unit_MaxHPr                      ((k_Token_Custom_Base) + 313)
#define k_Token_Unit_Attack                      ((k_Token_Custom_Base) + 314)
#define k_Token_Unit_Defense                     ((k_Token_Custom_Base) + 315)
#define k_Token_Unit_Firepower                   ((k_Token_Custom_Base) + 316)
#define k_Token_Unit_ZBRangeAttack               ((k_Token_Custom_Base) + 317)
#define k_Token_Unit_Armor                       ((k_Token_Custom_Base) + 318)
#define k_Token_Unit_BRange                      ((k_Token_Custom_Base) + 319)
#define k_Token_Unit_BRange_Value                ((k_Token_Custom_Base) + 320)
#define k_Token_Unit_BRadius                     ((k_Token_Custom_Base) + 321)
#define k_Token_Unit_BRadius_Value               ((k_Token_Custom_Base) + 322)
#define k_Token_Unit_VisionRange                 ((k_Token_Custom_Base) + 323)
#define k_Token_Unit_ActiveDefenseRange          ((k_Token_Custom_Base) + 324)
#define k_Token_Unit_ElectronicCombatFactor      ((k_Token_Custom_Base) + 325)
#define k_Token_Unit_ElectronicCombatFactor_Value ((k_Token_Custom_Base) + 326)
#define k_Token_Unit_MaxMovePoints               ((k_Token_Custom_Base) + 327)
#define k_Token_Unit_MaxFuel                     ((k_Token_Custom_Base) + 328)
#define k_Token_Unit_TransType                   ((k_Token_Custom_Base) + 329)
#define k_Token_Unit_TransType_Value             ((k_Token_Custom_Base) + 330)
#define k_Token_Unit_ProbOfBombHit               ((k_Token_Custom_Base) + 331)
#define k_Token_Unit_ProbOfBombHit_Value         ((k_Token_Custom_Base) + 332)
#define k_Token_Unit_BombRounds                  ((k_Token_Custom_Base) + 333)
#define k_Token_Unit_BombRounds_Value            ((k_Token_Custom_Base) + 334)
#define k_Token_Unit_ShieldHunger                ((k_Token_Custom_Base) + 335)
#define k_Token_Unit_FoodHunger                  ((k_Token_Custom_Base) + 336)
#define k_Token_Unit_GoldHunger                  ((k_Token_Custom_Base) + 337)
#define k_Token_Unit_DefaultSprite               ((k_Token_Custom_Base) + 338)
#define k_Token_Unit_LaunchPollution             ((k_Token_Custom_Base) + 339)
#define k_Token_Unit_LaunchPollution_Value       ((k_Token_Custom_Base) + 340)
#define k_Token_Unit_DeathPollution              ((k_Token_Custom_Base) + 341)
#define k_Token_Unit_DeathPollution_Value        ((k_Token_Custom_Base) + 342)
#define k_Token_Unit_CargoModule                 ((k_Token_Custom_Base) + 343)
#define k_Token_Unit_CargoModule_Value           ((k_Token_Custom_Base) + 344)
#define k_Token_Unit_SpyVsSpy                    ((k_Token_Custom_Base) + 345)
#define k_Token_Unit_SpyVsSpy_Value              ((k_Token_Custom_Base) + 346)
#define k_Token_Unit_InvestigateCity             ((k_Token_Custom_Base) + 347)
#define k_Token_Unit_InvestigateCity_Value       ((k_Token_Custom_Base) + 348)
#define k_Token_Unit_BonusFood                   ((k_Token_Custom_Base) + 349)
#define k_Token_Unit_BonusFood_Value             ((k_Token_Custom_Base) + 350)
#define k_Token_Unit_BombardRange                ((k_Token_Custom_Base) + 351)
#define k_Token_Unit_BombardRange_Value          ((k_Token_Custom_Base) + 352)
#define k_Token_Unit_Revolution                  ((k_Token_Custom_Base) + 353)
#define k_Token_Unit_Revolution_Value            ((k_Token_Custom_Base) + 354)
#define k_Token_Unit_SoundSelect1                ((k_Token_Custom_Base) + 355)
#define k_Token_Unit_SoundSelect2                ((k_Token_Custom_Base) + 356)
#define k_Token_Unit_SoundMove                   ((k_Token_Custom_Base) + 357)
#define k_Token_Unit_SoundAcknowledge            ((k_Token_Custom_Base) + 358)
#define k_Token_Unit_SoundCantMove               ((k_Token_Custom_Base) + 359)
#define k_Token_Unit_SoundAttack                 ((k_Token_Custom_Base) + 360)
#define k_Token_Unit_SoundWork                   ((k_Token_Custom_Base) + 361)
#define k_Token_Unit_SoundVictory                ((k_Token_Custom_Base) + 362)
#define k_Token_Unit_SoundDeath                  ((k_Token_Custom_Base) + 363)
#define k_Token_Unit_SoundLoad                   ((k_Token_Custom_Base) + 364)
#define k_Token_Unit_SoundUnload                 ((k_Token_Custom_Base) + 365)
#define k_Token_Unit_SpecialAttacks              ((k_Token_Custom_Base) + 366)
#define k_Token_Unit_CityGrowthCoefficient       ((k_Token_Custom_Base) + 367)
#define k_Token_Unit_CityGrowthCoefficient_Value ((k_Token_Custom_Base) + 368)
#define k_Token_Unit_UserFlags                   ((k_Token_Custom_Base) + 369)
#define k_Token_Unit_DefaultIcon                 ((k_Token_Custom_Base) + 370)
#define k_Token_Unit_NoIndex                     ((k_Token_Custom_Base) + 371)
#define k_Token_Unit_CheatIndex                  ((k_Token_Custom_Base) + 372)
#define k_Token_Unit_CheatIndex_Value            ((k_Token_Custom_Base) + 373)
#define k_Token_Unit_Description                 ((k_Token_Custom_Base) + 374)
#define k_Token_Unit_Advice                      ((k_Token_Custom_Base) + 375)
#define k_Token_Unit_Advice_Value                ((k_Token_Custom_Base) + 376)
#define k_Token_Unit_Category                    ((k_Token_Custom_Base) + 377)
#define k_Token_Unit_GLHidden                    ((k_Token_Custom_Base) + 378)
#define k_Token_Unit_CantMove                    ((k_Token_Custom_Base) + 379)
#define k_Token_Unit_Civilian                    ((k_Token_Custom_Base) + 380)
#define k_Token_Unit_InvisibleForGlobeSat        ((k_Token_Custom_Base) + 381)
#define k_Token_Unit_NoBarbarian                 ((k_Token_Custom_Base) + 382)
#define k_Token_Unit_GoodyHutExcluded            ((k_Token_Custom_Base) + 383)
#define k_Token_Unit_CanHarvest                  ((k_Token_Custom_Base) + 384)
#define k_Token_Unit_CantGroup                   ((k_Token_Custom_Base) + 385)
#define k_Token_Unit_SpawnsBarbarians            ((k_Token_Custom_Base) + 386)
#define k_Token_Unit_CanSinkInSea                ((k_Token_Custom_Base) + 387)
#define k_Token_Unit_Leader                      ((k_Token_Custom_Base) + 388)
#define k_Token_Unit_ArmyMountedBonus            ((k_Token_Custom_Base) + 389)
#define k_Token_Unit_ArmyMountedBonus_Value      ((k_Token_Custom_Base) + 390)
#define k_Token_Unit_ArmyAirBonus                ((k_Token_Custom_Base) + 391)
#define k_Token_Unit_ArmyAirBonus_Value          ((k_Token_Custom_Base) + 392)
#define k_Token_Unit_ArmyWoodenShipBonus         ((k_Token_Custom_Base) + 393)
#define k_Token_Unit_ArmyWoodenShipBonus_Value   ((k_Token_Custom_Base) + 394)
#define k_Token_Unit_ArmyAttackCityBonus         ((k_Token_Custom_Base) + 395)
#define k_Token_Unit_ArmyAttackCityBonus_Value   ((k_Token_Custom_Base) + 396)
#define k_Token_Unit_ArmyAttackBonusSubmarine    ((k_Token_Custom_Base) + 397)
#define k_Token_Unit_ArmyAttackBonusSubmarine_Value ((k_Token_Custom_Base) + 398)
#define k_Token_Unit_ArmyFootBonus               ((k_Token_Custom_Base) + 399)
#define k_Token_Unit_ArmyFootBonus_Value         ((k_Token_Custom_Base) + 400)
#define k_Token_Unit_ArmyMeleeBonus              ((k_Token_Custom_Base) + 401)
#define k_Token_Unit_ArmyMeleeBonus_Value        ((k_Token_Custom_Base) + 402)
#define k_Token_Unit_ArmySiegeBonus              ((k_Token_Custom_Base) + 403)
#define k_Token_Unit_ArmySiegeBonus_Value        ((k_Token_Custom_Base) + 404)
#define k_Token_Unit_ArmyWheeledBonus            ((k_Token_Custom_Base) + 405)
#define k_Token_Unit_ArmyWheeledBonus_Value      ((k_Token_Custom_Base) + 406)
#define k_Token_Unit_ArmyMechanizedBonus         ((k_Token_Custom_Base) + 407)
#define k_Token_Unit_ArmyMechanizedBonus_Value   ((k_Token_Custom_Base) + 408)
#define k_Token_Unit_ArmyHelicopterBonus         ((k_Token_Custom_Base) + 409)
#define k_Token_Unit_ArmyHelicopterBonus_Value   ((k_Token_Custom_Base) + 410)
#define k_Token_Unit_ArmySpecialForcesBonus      ((k_Token_Custom_Base) + 411)
#define k_Token_Unit_ArmySpecialForcesBonus_Value ((k_Token_Custom_Base) + 412)
#define k_Token_Unit_ArmyCivilianBonus           ((k_Token_Custom_Base) + 413)
#define k_Token_Unit_ArmyCivilianBonus_Value     ((k_Token_Custom_Base) + 414)
#define k_Token_Unit_ArmyGuerrillaBonus          ((k_Token_Custom_Base) + 415)
#define k_Token_Unit_ArmyGuerrillaBonus_Value    ((k_Token_Custom_Base) + 416)
#define k_Token_Unit_ArmyAgainstMountedBonus     ((k_Token_Custom_Base) + 417)
#define k_Token_Unit_ArmyAgainstMountedBonus_Value ((k_Token_Custom_Base) + 418)
#define k_Token_Unit_ArmyAirDefenseBonus         ((k_Token_Custom_Base) + 419)
#define k_Token_Unit_ArmyAirDefenseBonus_Value   ((k_Token_Custom_Base) + 420)
#define k_Token_Unit_EnergyHunger                ((k_Token_Custom_Base) + 421)
#define k_Token_Unit_ProducesEnergy              ((k_Token_Custom_Base) + 422)
#define k_Token_Unit_HasReligionIcon             ((k_Token_Custom_Base) + 423)
#define k_Token_Unit_HasReligionIcon_Value       ((k_Token_Custom_Base) + 424)
#define k_Token_Unit_Max                         ((k_Token_Custom_Base) + 425)


static BitArray s_ParsedTokens(425);
void UnitRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Unit_ShieldCost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ShieldCost missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_PowerPoints - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field PowerPoints missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_MaxHP - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxHP missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Attack - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Attack missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Defense - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Defense missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Firepower - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Firepower missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_ZBRangeAttack - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ZBRangeAttack missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Armor - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Armor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_VisionRange - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field VisionRange missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_ActiveDefenseRange - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ActiveDefenseRange missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_MaxMovePoints - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxMovePoints missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_MaxFuel - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxFuel missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_ShieldHunger - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ShieldHunger missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_FoodHunger - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field FoodHunger missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Category - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Category missing"));
    }
}

sint32 UnitRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Unit_Tokens, k_Token_Unit_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "UNIT_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Unit_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Unit_MovementType:
                if(!ParseMovementTypeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanCarry:
                if(!ParseCanCarryBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_EnableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ObsoleteAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_ObsoleteAdvance, &m_numObsoleteAdvance, k_MAX_ObsoleteAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PrerequisiteBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteBuilding, &m_numPrerequisiteBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ExcludedByBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByBuilding, &m_numExcludedByBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanSettleOn:
                if(!g_theTerrainDB->ParseRecordInArray(lex, (sint32 **)&m_CanSettleOn, &m_numCanSettleOn))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_UpgradeTo:
                if(!g_theUnitDB->ParseRecordInArray(lex, (sint32 **)&m_UpgradeTo, &m_numUpgradeTo))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ObsoleteUnit:
                if(!g_theUnitDB->ParseRecordInArray(lex, (sint32 **)&m_ObsoleteUnit, &m_numObsoleteUnit))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CultureOnly, &m_numCultureOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CityStyleOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CityStyleOnly, &m_numCityStyleOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CivilisationOnly:
                if(!g_theCivilisationDB->ParseRecordInArray(lex, (sint32 **)&m_CivilisationOnly, &m_numCivilisationOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_GovernmentOnly:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentOnly, &m_numGovernmentOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettleImprovement:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_SettleImprovement, &m_numSettleImprovement))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NeedsCityGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGood, &m_numNeedsCityGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NeedsCityGoodAll:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAll, &m_numNeedsCityGoodAll))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NeedsCityGoodCapitol:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodCapitol, &m_numNeedsCityGoodCapitol))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NeedsCityGoodAnyCity:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsCityGoodAnyCity, &m_numNeedsCityGoodAnyCity))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NeedsFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsFeatToBuild, &m_numNeedsFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NeedsAnyPlayerFeatToBuild:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_NeedsAnyPlayerFeatToBuild, &m_numNeedsAnyPlayerFeatToBuild))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PrerequisiteWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteWonder, &m_numPrerequisiteWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ExcludedByWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludedByWonder, &m_numExcludedByWonder))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_MoveBonus:
                m_flags0 |= k_Unit_MoveBonus_Bit;
                if(!lex->GetIntAssignment(m_MoveBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_PWMoveCost:
                m_flags0 |= k_Unit_PWMoveCost_Bit;
                if(!lex->GetIntAssignment(m_PWMoveCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MerchantGold:
                m_flags0 |= k_Unit_MerchantGold_Bit;
                if(!lex->GetIntAssignment(m_MerchantGoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_IsGreatBuilder:
                m_flags0 |= k_Unit_IsGreatBuilder_Bit;
                break;
            case k_Token_Unit_IsGreatArtist:
                m_flags0 |= k_Unit_IsGreatArtist_Bit;
                break;
            case k_Token_Unit_AllTerrainAsImprovement:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_AllTerrainAsImprovement, &m_numAllTerrainAsImprovement))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ObsoleteByUnit:
                if(!g_theUnitDB->ParseRecordInArray(lex, (sint32 **)&m_ObsoleteByUnit, &m_numObsoleteByUnit))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NonLethalBombard:
                m_flags0 |= k_Unit_NonLethalBombard_Bit;
                break;
            case k_Token_Unit_CanBombardTiles:
                m_flags0 |= k_Unit_CanBombardTiles_Bit;
                break;
            case k_Token_Unit_CollateralTileDamage:
                m_flags0 |= k_Unit_CollateralTileDamage_Bit;
                break;
            case k_Token_Unit_PrecisionStrike:
                m_flags0 |= k_Unit_PrecisionStrike_Bit;
                break;
            case k_Token_Unit_TargetsCivilians:
                m_flags0 |= k_Unit_TargetsCivilians_Bit;
                break;
            case k_Token_Unit_ImmuneToHostileTerrain:
                m_flags0 |= k_Unit_ImmuneToHostileTerrain_Bit;
                break;
            case k_Token_Unit_CanRebase:
                m_flags0 |= k_Unit_CanRebase_Bit;
                break;
            case k_Token_Unit_MultipleAttacks:
                m_flags0 |= k_Unit_MultipleAttacks_Bit;
                break;
            case k_Token_Unit_CanBeGifted:
                m_flags0 |= k_Unit_CanBeGifted_Bit;
                break;
            case k_Token_Unit_UpgradeAnywhere:
                m_flags0 |= k_Unit_UpgradeAnywhere_Bit;
                break;
            case k_Token_Unit_UpgradeDoesNotHeal:
                m_flags0 |= k_Unit_UpgradeDoesNotHeal_Bit;
                break;
            case k_Token_Unit_Size:
                if(!ParseSizeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_LossMoveToDmgNone:
                m_flags0 |= k_Unit_LossMoveToDmgNone_Bit;
                break;
            case k_Token_Unit_LossMoveToDmgTwo:
                m_flags0 |= k_Unit_LossMoveToDmgTwo_Bit;
                break;
            case k_Token_Unit_NoFuelThenCrash:
                m_flags0 |= k_Unit_NoFuelThenCrash_Bit;
                break;
            case k_Token_Unit_TransformPartial:
                m_flags0 |= k_Unit_TransformPartial_Bit;
                break;
            case k_Token_Unit_IgnoreZOC:
                m_flags0 |= k_Unit_IgnoreZOC_Bit;
                break;
            case k_Token_Unit_NoZoc:
                m_flags0 |= k_Unit_NoZoc_Bit;
                break;
            case k_Token_Unit_CanBombard:
                if(!ParseCanBombardBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanCounterBombard:
                m_flags0 |= k_Unit_CanCounterBombard_Bit;
                break;
            case k_Token_Unit_CanLiftOff:
                m_flags0 |= k_Unit_CanLiftOff_Bit;
                break;
            case k_Token_Unit_Settle:
                if(!ParseSettleBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettleCityType:
                if (!g_theUnitDB->GetRecordFromLexer(lex, m_SettleCityType)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettleSize:
                if(!lex->GetIntAssignment(m_SettleSize)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettleBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_SettleBuilding, &m_numSettleBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_EstablishBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_EstablishBuilding, &m_numEstablishBuilding))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpaceLaunch:
                m_flags0 |= k_Unit_SpaceLaunch_Bit;
                if(!lex->GetIntAssignment(m_SpaceLaunchValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpaceLand:
                m_flags0 |= k_Unit_SpaceLand_Bit;
                break;
            case k_Token_Unit_CantCaptureCity:
                m_flags0 |= k_Unit_CantCaptureCity_Bit;
                break;
            case k_Token_Unit_HasPopAndCanBuild:
                m_flags0 |= k_Unit_HasPopAndCanBuild_Bit;
                break;
            case k_Token_Unit_IsTrader:
                m_flags0 |= k_Unit_IsTrader_Bit;
                break;
            case k_Token_Unit_ExertsMartialLaw:
                m_flags0 |= k_Unit_ExertsMartialLaw_Bit;
                break;
            case k_Token_Unit_CanEntrench:
                m_flags0 |= k_Unit_CanEntrench_Bit;
                break;
            case k_Token_Unit_CanPatrol:
                m_flags0 |= k_Unit_CanPatrol_Bit;
                break;
            case k_Token_Unit_NeedsNoSupport:
                m_flags1 |= k_Unit_NeedsNoSupport_Bit;
                break;
            case k_Token_Unit_CanExpelPop:
                m_flags1 |= k_Unit_CanExpelPop_Bit;
                break;
            case k_Token_Unit_IsFlanker:
                m_flags1 |= k_Unit_IsFlanker_Bit;
                break;
            case k_Token_Unit_CanBeachAssault:
                m_flags1 |= k_Unit_CanBeachAssault_Bit;
                break;
            case k_Token_Unit_Defend:
                if(!ParseDefendBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendAgainstSpies:
                m_flags1 |= k_Unit_DefendAgainstSpies_Bit;
                if(!lex->GetFloatAssignment(m_DefendAgainstSpiesValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanBeExpelled:
                m_flags1 |= k_Unit_CanBeExpelled_Bit;
                break;
            case k_Token_Unit_CanBeSued:
                m_flags1 |= k_Unit_CanBeSued_Bit;
                break;
            case k_Token_Unit_AttackFromSpaceship:
                m_flags1 |= k_Unit_AttackFromSpaceship_Bit;
                break;
            case k_Token_Unit_CantBeAttacked:
                m_flags1 |= k_Unit_CantBeAttacked_Bit;
                break;
            case k_Token_Unit_CargoPod:
                m_flags1 |= k_Unit_CargoPod_Bit;
                break;
            case k_Token_Unit_IsFoot:
                m_flags1 |= k_Unit_IsFoot_Bit;
                break;
            case k_Token_Unit_IsMelee:
                m_flags1 |= k_Unit_IsMelee_Bit;
                break;
            case k_Token_Unit_IsMounted:
                m_flags1 |= k_Unit_IsMounted_Bit;
                break;
            case k_Token_Unit_IsSiege:
                m_flags1 |= k_Unit_IsSiege_Bit;
                break;
            case k_Token_Unit_IsWheeled:
                m_flags1 |= k_Unit_IsWheeled_Bit;
                break;
            case k_Token_Unit_IsMechanized:
                m_flags1 |= k_Unit_IsMechanized_Bit;
                break;
            case k_Token_Unit_IsHelicopter:
                m_flags1 |= k_Unit_IsHelicopter_Bit;
                break;
            case k_Token_Unit_IsSubmarine:
                m_flags1 |= k_Unit_IsSubmarine_Bit;
                break;
            case k_Token_Unit_IsSurfaceShip:
                m_flags1 |= k_Unit_IsSurfaceShip_Bit;
                break;
            case k_Token_Unit_WoodenShip:
                m_flags1 |= k_Unit_WoodenShip_Bit;
                break;
            case k_Token_Unit_NoLandAttack:
                m_flags1 |= k_Unit_NoLandAttack_Bit;
                break;
            case k_Token_Unit_NoSeaAttack:
                m_flags1 |= k_Unit_NoSeaAttack_Bit;
                break;
            case k_Token_Unit_NoAirAttack:
                m_flags1 |= k_Unit_NoAirAttack_Bit;
                break;
            case k_Token_Unit_NoSpaceAttack:
                m_flags1 |= k_Unit_NoSpaceAttack_Bit;
                break;
            case k_Token_Unit_NoUnderwaterAttack:
                m_flags1 |= k_Unit_NoUnderwaterAttack_Bit;
                break;
            case k_Token_Unit_NoMountainAttack:
                m_flags1 |= k_Unit_NoMountainAttack_Bit;
                break;
            case k_Token_Unit_NoShallowWaterAttack:
                m_flags1 |= k_Unit_NoShallowWaterAttack_Bit;
                break;
            case k_Token_Unit_SingleUse:
                m_flags1 |= k_Unit_SingleUse_Bit;
                break;
            case k_Token_Unit_Paratrooper:
                m_flags1 |= k_Unit_Paratrooper_Bit;
                break;
            case k_Token_Unit_AssistedDrops:
                m_flags1 |= k_Unit_AssistedDrops_Bit;
                break;
            case k_Token_Unit_DefendAirBonus:
                m_flags1 |= k_Unit_DefendAirBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendAirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendCityBonus:
                m_flags1 |= k_Unit_DefendCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendSubmarineBonus:
                m_flags2 |= k_Unit_DefendSubmarineBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendSubmarineBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendFootBonus:
                m_flags2 |= k_Unit_DefendFootBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendFootBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendMeleeBonus:
                m_flags2 |= k_Unit_DefendMeleeBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendMeleeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendSiegeBonus:
                m_flags2 |= k_Unit_DefendSiegeBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendSiegeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendWheeledBonus:
                m_flags2 |= k_Unit_DefendWheeledBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendWheeledBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendMechanizedBonus:
                m_flags2 |= k_Unit_DefendMechanizedBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendMechanizedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendHelicopterBonus:
                m_flags2 |= k_Unit_DefendHelicopterBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendHelicopterBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendSpecialForcesBonus:
                m_flags2 |= k_Unit_DefendSpecialForcesBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendSpecialForcesBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendCivilianBonus:
                m_flags2 |= k_Unit_DefendCivilianBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendCivilianBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendGuerrillaBonus:
                m_flags2 |= k_Unit_DefendGuerrillaBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendGuerrillaBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendMountedBonus:
                m_flags2 |= k_Unit_DefendMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendWoodenShipBonus:
                m_flags2 |= k_Unit_DefendWoodenShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendWoodenShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendSurfaceShipBonus:
                m_flags2 |= k_Unit_DefendSurfaceShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefendSurfaceShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_NoDefenseBonuses:
                m_flags2 |= k_Unit_NoDefenseBonuses_Bit;
                break;
            case k_Token_Unit_AttackAirBonus:
                m_flags2 |= k_Unit_AttackAirBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackAirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackCityBonus:
                m_flags2 |= k_Unit_AttackCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackSubmarineBonus:
                m_flags2 |= k_Unit_AttackSubmarineBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackSubmarineBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackFootBonus:
                m_flags2 |= k_Unit_AttackFootBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackFootBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackMeleeBonus:
                m_flags2 |= k_Unit_AttackMeleeBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackMeleeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackSiegeBonus:
                m_flags2 |= k_Unit_AttackSiegeBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackSiegeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackWheeledBonus:
                m_flags2 |= k_Unit_AttackWheeledBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackWheeledBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackMechanizedBonus:
                m_flags2 |= k_Unit_AttackMechanizedBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackMechanizedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackHelicopterBonus:
                m_flags2 |= k_Unit_AttackHelicopterBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackHelicopterBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackSpecialForcesBonus:
                m_flags2 |= k_Unit_AttackSpecialForcesBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackSpecialForcesBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackCivilianBonus:
                m_flags2 |= k_Unit_AttackCivilianBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackCivilianBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackGuerrillaBonus:
                m_flags2 |= k_Unit_AttackGuerrillaBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackGuerrillaBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackMountedBonus:
                m_flags2 |= k_Unit_AttackMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackWoodenShipBonusNew:
                m_flags2 |= k_Unit_AttackWoodenShipBonusNew_Bit;
                if(!lex->GetFloatAssignment(m_AttackWoodenShipBonusNewValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackSurfaceShipBonus:
                m_flags2 |= k_Unit_AttackSurfaceShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackSurfaceShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedAirBonus:
                m_flags2 |= k_Unit_RangedAirBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedAirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedAttackCityBonus:
                m_flags2 |= k_Unit_RangedAttackCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedAttackCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedDefendCityBonus:
                m_flags2 |= k_Unit_RangedDefendCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedDefendCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedSubmarineBonus:
                m_flags3 |= k_Unit_RangedSubmarineBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedSubmarineBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedFootBonus:
                m_flags3 |= k_Unit_RangedFootBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedFootBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedMeleeBonus:
                m_flags3 |= k_Unit_RangedMeleeBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedMeleeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedSiegeBonus:
                m_flags3 |= k_Unit_RangedSiegeBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedSiegeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedWheeledBonus:
                m_flags3 |= k_Unit_RangedWheeledBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedWheeledBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedMechanizedBonus:
                m_flags3 |= k_Unit_RangedMechanizedBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedMechanizedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedHelicopterBonus:
                m_flags3 |= k_Unit_RangedHelicopterBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedHelicopterBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedSpecialForcesBonus:
                m_flags3 |= k_Unit_RangedSpecialForcesBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedSpecialForcesBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedCivilianBonus:
                m_flags3 |= k_Unit_RangedCivilianBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedCivilianBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedGuerrillaBonus:
                m_flags3 |= k_Unit_RangedGuerrillaBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedGuerrillaBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedMountedBonus:
                m_flags3 |= k_Unit_RangedMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedWoodenShipBonus:
                m_flags3 |= k_Unit_RangedWoodenShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedWoodenShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_RangedSurfaceShipBonus:
                m_flags3 |= k_Unit_RangedSurfaceShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_RangedSurfaceShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_IgnoreCityWalls:
                m_flags3 |= k_Unit_IgnoreCityWalls_Bit;
                break;
            case k_Token_Unit_AlwaysHeal:
                m_flags3 |= k_Unit_AlwaysHeal_Bit;
                break;
            case k_Token_Unit_AttackWoodenShipBonus:
                m_flags3 |= k_Unit_AttackWoodenShipBonus_Bit;
                break;
            case k_Token_Unit_WoodenShipBonus:
                m_flags3 |= k_Unit_WoodenShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_WoodenShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BonusAgainstMounted:
                m_flags3 |= k_Unit_BonusAgainstMounted_Bit;
                break;
            case k_Token_Unit_MountedBonus:
                m_flags3 |= k_Unit_MountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_MountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BonusAirDefense:
                m_flags3 |= k_Unit_BonusAirDefense_Bit;
                break;
            case k_Token_Unit_AirBonus:
                m_flags3 |= k_Unit_AirBonus_Bit;
                if(!lex->GetFloatAssignment(m_AirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ReplaceWithCargoModule:
                m_flags3 |= k_Unit_ReplaceWithCargoModule_Bit;
                if(!lex->GetIntAssignment(m_ReplaceWithCargoModuleValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VisibileAttacking:
                m_flags3 |= k_Unit_VisibileAttacking_Bit;
                break;
            case k_Token_Unit_NuclearAttack:
                m_flags3 |= k_Unit_NuclearAttack_Bit;
                if(!m_NuclearAttackValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanSue:
                m_flags3 |= k_Unit_CanSue_Bit;
                break;
            case k_Token_Unit_IsStealthy:
                m_flags3 |= k_Unit_IsStealthy_Bit;
                break;
            case k_Token_Unit_SeeSurfaceFromSpace:
                m_flags3 |= k_Unit_SeeSurfaceFromSpace_Bit;
                break;
            case k_Token_Unit_EstablishEmbassy:
                m_flags3 |= k_Unit_EstablishEmbassy_Bit;
                break;
            case k_Token_Unit_ThrowParty:
                m_flags3 |= k_Unit_ThrowParty_Bit;
                break;
            case k_Token_Unit_HearGossip:
                m_flags3 |= k_Unit_HearGossip_Bit;
                break;
            case k_Token_Unit_StealTechnology:
                m_flags3 |= k_Unit_StealTechnology_Bit;
                if(!m_StealTechnologyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolution:
                m_flags3 |= k_Unit_InciteRevolution_Bit;
                if(!m_InciteRevolutionValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AssasinateRuler:
                m_flags4 |= k_Unit_AssasinateRuler_Bit;
                if(!m_AssasinateRulerValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateReadiness:
                m_flags4 |= k_Unit_InvestigateReadiness_Bit;
                if(!m_InvestigateReadinessValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_NullifyCityWalls:
                m_flags4 |= k_Unit_NullifyCityWalls_Bit;
                break;
            case k_Token_Unit_CreateFranchise:
                m_flags4 |= k_Unit_CreateFranchise_Bit;
                if(!m_CreateFranchiseValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappiness:
                m_flags4 |= k_Unit_CauseUnhappiness_Bit;
                if(!m_CauseUnhappinessValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ConductHits:
                m_flags4 |= k_Unit_ConductHits_Bit;
                if(!m_ConductHitsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BioTerror:
                m_flags4 |= k_Unit_BioTerror_Bit;
                if(!m_BioTerrorValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_NanoTerror:
                m_flags4 |= k_Unit_NanoTerror_Bit;
                if(!m_NanoTerrorValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Plague:
                m_flags4 |= k_Unit_Plague_Bit;
                if(!m_PlagueValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaids:
                m_flags4 |= k_Unit_SlaveRaids_Bit;
                if(!m_SlaveRaidsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettlerSlaveRaids:
                m_flags4 |= k_Unit_SettlerSlaveRaids_Bit;
                if(!m_SettlerSlaveRaidsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveUprising:
                m_flags4 |= k_Unit_SlaveUprising_Bit;
                if(!m_SlaveUprisingValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_UndergroundRailway:
                m_flags4 |= k_Unit_UndergroundRailway_Bit;
                if(!m_UndergroundRailwayValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VictoryEnslavement:
                m_flags4 |= k_Unit_VictoryEnslavement_Bit;
                break;
            case k_Token_Unit_VictoryEnslavementChance:
                m_flags4 |= k_Unit_VictoryEnslavementChance_Bit;
                if(!lex->GetFloatAssignment(m_VictoryEnslavementChanceValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VictoryEnslavementStacks:
                m_flags4 |= k_Unit_VictoryEnslavementStacks_Bit;
                break;
            case k_Token_Unit_DefuseLandMines:
                m_flags4 |= k_Unit_DefuseLandMines_Bit;
                break;
            case k_Token_Unit_DefuseSeaMines:
                m_flags4 |= k_Unit_DefuseSeaMines_Bit;
                break;
            case k_Token_Unit_DefuseXrayMines:
                m_flags4 |= k_Unit_DefuseXrayMines_Bit;
                break;
            case k_Token_Unit_IndulgenceSales:
                m_flags4 |= k_Unit_IndulgenceSales_Bit;
                if(!m_IndulgenceSalesValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ConvertCities:
                m_flags4 |= k_Unit_ConvertCities_Bit;
                if(!m_ConvertCitiesValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BuildXrayMines:
                m_flags4 |= k_Unit_BuildXrayMines_Bit;
                break;
            case k_Token_Unit_BuildWonder:
                m_flags4 |= k_Unit_BuildWonder_Bit;
                break;
            case k_Token_Unit_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NoSlaves:
                m_flags4 |= k_Unit_NoSlaves_Bit;
                break;
            case k_Token_Unit_CreateRift:
                m_flags4 |= k_Unit_CreateRift_Bit;
                break;
            case k_Token_Unit_CanCloak:
                m_flags4 |= k_Unit_CanCloak_Bit;
                break;
            case k_Token_Unit_HiddenNationality:
                m_flags4 |= k_Unit_HiddenNationality_Bit;
                break;
            case k_Token_Unit_SneakAttack:
                m_flags4 |= k_Unit_SneakAttack_Bit;
                break;
            case k_Token_Unit_SneakPillage:
                m_flags4 |= k_Unit_SneakPillage_Bit;
                break;
            case k_Token_Unit_SneakBombard:
                m_flags4 |= k_Unit_SneakBombard_Bit;
                break;
            case k_Token_Unit_ParatrooperTransport:
                m_flags4 |= k_Unit_ParatrooperTransport_Bit;
                break;
            case k_Token_Unit_CantBuild:
                m_flags4 |= k_Unit_CantBuild_Bit;
                break;
            case k_Token_Unit_PlantNuke:
                m_flags5 |= k_Unit_PlantNuke_Bit;
                if(!m_PlantNukeValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_IsTelevangelist:
                m_flags5 |= k_Unit_IsTelevangelist_Bit;
                break;
            case k_Token_Unit_CanSoothsay:
                m_flags5 |= k_Unit_CanSoothsay_Bit;
                if(!m_CanSoothsayValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanBeRustled:
                m_flags5 |= k_Unit_CanBeRustled_Bit;
                break;
            case k_Token_Unit_CreateParks:
                m_flags5 |= k_Unit_CreateParks_Bit;
                if(!m_CreateParksValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanInjoin:
                m_flags5 |= k_Unit_CanInjoin_Bit;
                if(!m_CanInjoinValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_WormholeProbe:
                m_flags5 |= k_Unit_WormholeProbe_Bit;
                break;
            case k_Token_Unit_HasBonusFood:
                m_flags5 |= k_Unit_HasBonusFood_Bit;
                break;
            case k_Token_Unit_LandCityCanBuild:
                m_flags5 |= k_Unit_LandCityCanBuild_Bit;
                break;
            case k_Token_Unit_SeaCityCanBuild:
                m_flags5 |= k_Unit_SeaCityCanBuild_Bit;
                break;
            case k_Token_Unit_SpaceCityCanBuild:
                m_flags5 |= k_Unit_SpaceCityCanBuild_Bit;
                break;
            case k_Token_Unit_IsSpecialForces:
                m_flags5 |= k_Unit_IsSpecialForces_Bit;
                break;
            case k_Token_Unit_IsPeaceKeeper:
                m_flags5 |= k_Unit_IsPeaceKeeper_Bit;
                break;
            case k_Token_Unit_IsGuerrilla:
                m_flags5 |= k_Unit_IsGuerrilla_Bit;
                break;
            case k_Token_Unit_IsWorker:
                m_flags5 |= k_Unit_IsWorker_Bit;
                break;
            case k_Token_Unit_NotAffectedByLandMines:
                m_flags5 |= k_Unit_NotAffectedByLandMines_Bit;
                break;
            case k_Token_Unit_InternalReserved:
                m_flags5 |= k_Unit_InternalReserved_Bit;
                break;
            case k_Token_Unit_DeathEffectsHappy:
                m_flags5 |= k_Unit_DeathEffectsHappy_Bit;
                break;
            case k_Token_Unit_EnableCarrierDefenses:
                m_flags5 |= k_Unit_EnableCarrierDefenses_Bit;
                break;
            case k_Token_Unit_ActiveDefenseOnlyWhenCarryingEnablers:
                m_flags5 |= k_Unit_ActiveDefenseOnlyWhenCarryingEnablers_Bit;
                break;
            case k_Token_Unit_BuildingRemovesAPop:
                m_flags5 |= k_Unit_BuildingRemovesAPop_Bit;
                break;
            case k_Token_Unit_PopCostsToBuild:
                m_flags5 |= k_Unit_PopCostsToBuild_Bit;
                if(!lex->GetIntAssignment(m_PopCostsToBuildValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Explodes:
                m_flags5 |= k_Unit_Explodes_Bit;
                break;
            case k_Token_Unit_Advertise:
                m_flags5 |= k_Unit_Advertise_Bit;
                break;
            case k_Token_Unit_CanRustle:
                m_flags5 |= k_Unit_CanRustle_Bit;
                break;
            case k_Token_Unit_OnlyBuildOne:
                m_flags5 |= k_Unit_OnlyBuildOne_Bit;
                break;
            case k_Token_Unit_CanExpel:
                m_flags5 |= k_Unit_CanExpel_Bit;
                break;
            case k_Token_Unit_CanReform:
                m_flags5 |= k_Unit_CanReform_Bit;
                if(!m_CanReformValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanPillage:
                m_flags5 |= k_Unit_CanPillage_Bit;
                break;
            case k_Token_Unit_CanPirate:
                m_flags5 |= k_Unit_CanPirate_Bit;
                break;
            case k_Token_Unit_CanCaptureTile:
                m_flags5 |= k_Unit_CanCaptureTile_Bit;
                break;
            case k_Token_Unit_ReducesDefensesBonus:
                if(!lex->GetIntAssignment(m_ReducesDefensesBonus)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VisionClass:
                if(!ParseVisionClassBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanSee:
                if(!ParseCanSeeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanAttack:
                if(!ParseCanAttackBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoData:
                m_flags5 |= k_Unit_CargoData_Bit;
                if(!m_CargoDataValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ShieldCost:
                if(!lex->GetIntAssignment(m_ShieldCost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_PowerPoints:
                if(!lex->GetIntAssignment(m_PowerPoints)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxHP:
                if(!lex->GetIntAssignment(m_MaxHP)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxHPr:
                if(!lex->GetFloatAssignment(m_MaxHPr)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Attack:
                if(!lex->GetFloatAssignment(m_Attack)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Defense:
                if(!lex->GetFloatAssignment(m_Defense)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Firepower:
                if(!lex->GetIntAssignment(m_Firepower)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ZBRangeAttack:
                if(!lex->GetIntAssignment(m_ZBRangeAttack)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Armor:
                if(!lex->GetFloatAssignment(m_Armor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BRange:
                m_flags6 |= k_Unit_BRange_Bit;
                if(!lex->GetIntAssignment(m_BRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BRadius:
                m_flags6 |= k_Unit_BRadius_Bit;
                if(!lex->GetIntAssignment(m_BRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VisionRange:
                if(!lex->GetIntAssignment(m_VisionRange)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ActiveDefenseRange:
                if(!lex->GetIntAssignment(m_ActiveDefenseRange)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ElectronicCombatFactor:
                m_flags6 |= k_Unit_ElectronicCombatFactor_Bit;
                if(!lex->GetIntAssignment(m_ElectronicCombatFactorValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxMovePoints:
                if(!lex->GetFloatAssignment(m_MaxMovePoints)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxFuel:
                if(!lex->GetIntAssignment(m_MaxFuel)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_TransType:
                m_flags6 |= k_Unit_TransType_Bit;
                if(!lex->GetIntAssignment(m_TransTypeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ProbOfBombHit:
                m_flags6 |= k_Unit_ProbOfBombHit_Bit;
                if(!lex->GetIntAssignment(m_ProbOfBombHitValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BombRounds:
                m_flags6 |= k_Unit_BombRounds_Bit;
                if(!lex->GetIntAssignment(m_BombRoundsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ShieldHunger:
                if(!lex->GetIntAssignment(m_ShieldHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_FoodHunger:
                if(!lex->GetIntAssignment(m_FoodHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_GoldHunger:
                if(!lex->GetIntAssignment(m_GoldHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefaultSprite:
                if (!g_theSpriteDB->GetRecordFromLexer(lex, m_DefaultSprite)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_LaunchPollution:
                m_flags6 |= k_Unit_LaunchPollution_Bit;
                if(!lex->GetIntAssignment(m_LaunchPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DeathPollution:
                m_flags6 |= k_Unit_DeathPollution_Bit;
                if(!lex->GetIntAssignment(m_DeathPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoModule:
                m_flags6 |= k_Unit_CargoModule_Bit;
                if(!lex->GetIntAssignment(m_CargoModuleValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpyVsSpy:
                m_flags6 |= k_Unit_SpyVsSpy_Bit;
                if(!lex->GetFloatAssignment(m_SpyVsSpyValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateCity:
                m_flags6 |= k_Unit_InvestigateCity_Bit;
                if(!m_InvestigateCityValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BonusFood:
                m_flags6 |= k_Unit_BonusFood_Bit;
                if(!lex->GetIntAssignment(m_BonusFoodValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BombardRange:
                m_flags6 |= k_Unit_BombardRange_Bit;
                if(!lex->GetIntAssignment(m_BombardRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Revolution:
                m_flags6 |= k_Unit_Revolution_Bit;
                if(!m_RevolutionValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundSelect1:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundSelect1)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundSelect2:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundSelect2)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundMove:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundMove)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundAcknowledge:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundAcknowledge)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundCantMove:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundCantMove)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundAttack:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundAttack)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundWork:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundWork)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundVictory:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundVictory)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundDeath:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundDeath)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundLoad:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundLoad)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundUnload:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_SoundUnload)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpecialAttacks:
                if(!g_theSpecialAttackInfoDB->ParseRecordInArray(lex, (sint32 *)m_SpecialAttacks, &m_numSpecialAttacks, k_MAX_SpecialAttacks)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CityGrowthCoefficient:
                m_flags6 |= k_Unit_CityGrowthCoefficient_Bit;
                if(!lex->GetFloatAssignment(m_CityGrowthCoefficientValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_UserFlags:
                if(!ParseUserFlagsBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefaultIcon:
                if (!g_theIconDB->GetRecordFromLexer(lex, m_DefaultIcon)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NoIndex:
                m_flags6 |= k_Unit_NoIndex_Bit;
                break;
            case k_Token_Unit_CheatIndex:
                m_flags6 |= k_Unit_CheatIndex_Bit;
                if(!lex->GetIntAssignment(m_CheatIndexValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Advice:
                m_flags6 |= k_Unit_Advice_Bit;
                if(!lex->GetStringIdAssignment(m_AdviceValue)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Category:
                if(!lex->GetStringIdAssignment(m_Category)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_GLHidden:
                m_flags6 |= k_Unit_GLHidden_Bit;
                break;
            case k_Token_Unit_CantMove:
                m_flags6 |= k_Unit_CantMove_Bit;
                break;
            case k_Token_Unit_Civilian:
                m_flags6 |= k_Unit_Civilian_Bit;
                break;
            case k_Token_Unit_InvisibleForGlobeSat:
                m_flags6 |= k_Unit_InvisibleForGlobeSat_Bit;
                break;
            case k_Token_Unit_NoBarbarian:
                m_flags6 |= k_Unit_NoBarbarian_Bit;
                break;
            case k_Token_Unit_GoodyHutExcluded:
                m_flags6 |= k_Unit_GoodyHutExcluded_Bit;
                break;
            case k_Token_Unit_CanHarvest:
                m_flags6 |= k_Unit_CanHarvest_Bit;
                break;
            case k_Token_Unit_CantGroup:
                m_flags6 |= k_Unit_CantGroup_Bit;
                break;
            case k_Token_Unit_SpawnsBarbarians:
                m_flags6 |= k_Unit_SpawnsBarbarians_Bit;
                break;
            case k_Token_Unit_CanSinkInSea:
                m_flags6 |= k_Unit_CanSinkInSea_Bit;
                break;
            case k_Token_Unit_Leader:
                m_flags6 |= k_Unit_Leader_Bit;
                break;
            case k_Token_Unit_ArmyMountedBonus:
                m_flags6 |= k_Unit_ArmyMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyAirBonus:
                m_flags6 |= k_Unit_ArmyAirBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyWoodenShipBonus:
                m_flags6 |= k_Unit_ArmyWoodenShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyWoodenShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyAttackCityBonus:
                m_flags7 |= k_Unit_ArmyAttackCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAttackCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyAttackBonusSubmarine:
                m_flags7 |= k_Unit_ArmyAttackBonusSubmarine_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAttackBonusSubmarineValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyFootBonus:
                m_flags7 |= k_Unit_ArmyFootBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyFootBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyMeleeBonus:
                m_flags7 |= k_Unit_ArmyMeleeBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyMeleeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmySiegeBonus:
                m_flags7 |= k_Unit_ArmySiegeBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmySiegeBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyWheeledBonus:
                m_flags7 |= k_Unit_ArmyWheeledBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyWheeledBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyMechanizedBonus:
                m_flags7 |= k_Unit_ArmyMechanizedBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyMechanizedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyHelicopterBonus:
                m_flags7 |= k_Unit_ArmyHelicopterBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyHelicopterBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmySpecialForcesBonus:
                m_flags7 |= k_Unit_ArmySpecialForcesBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmySpecialForcesBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyCivilianBonus:
                m_flags7 |= k_Unit_ArmyCivilianBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyCivilianBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyGuerrillaBonus:
                m_flags7 |= k_Unit_ArmyGuerrillaBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyGuerrillaBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyAgainstMountedBonus:
                m_flags7 |= k_Unit_ArmyAgainstMountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAgainstMountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ArmyAirDefenseBonus:
                m_flags7 |= k_Unit_ArmyAirDefenseBonus_Bit;
                if(!lex->GetFloatAssignment(m_ArmyAirDefenseBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_EnergyHunger:
                if(!lex->GetIntAssignment(m_EnergyHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ProducesEnergy:
                if(!lex->GetIntAssignment(m_ProducesEnergy)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_HasReligionIcon:
                m_flags7 |= k_Unit_HasReligionIcon_Bit;
                if(!g_theMapIconDB->GetRecordFromLexer(lex, m_HasReligionIconValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!ParseMovementTypeBit(lex)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void UnitRecord::ResolveDBReferences()
{
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteAdvance; i++) {
            if(m_ObsoleteAdvance[i] & 0x80000000) {
                sint32 id = m_ObsoleteAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ObsoleteAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteAdvance[i] == 0x7fffffff){
                m_ObsoleteAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteBuilding; i++) {
            if(m_PrerequisiteBuilding[i] & 0x80000000) {
                sint32 id = m_PrerequisiteBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_PrerequisiteBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteBuilding[i] == 0x7fffffff){
                m_PrerequisiteBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByBuilding; i++) {
            if(m_ExcludedByBuilding[i] & 0x80000000) {
                sint32 id = m_ExcludedByBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_ExcludedByBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByBuilding[i] == 0x7fffffff){
                m_ExcludedByBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCanSettleOn; i++) {
            if(m_CanSettleOn[i] & 0x80000000) {
                sint32 id = m_CanSettleOn[i] & 0x7fffffff;
                if(!g_theTerrainDB->GetNamedItem(id, m_CanSettleOn[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Terrain database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CanSettleOn[i] == 0x7fffffff){
                m_CanSettleOn[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numUpgradeTo; i++) {
            if(m_UpgradeTo[i] & 0x80000000) {
                sint32 id = m_UpgradeTo[i] & 0x7fffffff;
                if(!g_theUnitDB->GetNamedItem(id, m_UpgradeTo[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_UpgradeTo[i] == 0x7fffffff){
                m_UpgradeTo[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteUnit; i++) {
            if(m_ObsoleteUnit[i] & 0x80000000) {
                sint32 id = m_ObsoleteUnit[i] & 0x7fffffff;
                if(!g_theUnitDB->GetNamedItem(id, m_ObsoleteUnit[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteUnit[i] == 0x7fffffff){
                m_ObsoleteUnit[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCityStyleOnly; i++) {
            if(m_CityStyleOnly[i] & 0x80000000) {
                sint32 id = m_CityStyleOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CityStyleOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CityStyleOnly[i] == 0x7fffffff){
                m_CityStyleOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCivilisationOnly; i++) {
            if(m_CivilisationOnly[i] & 0x80000000) {
                sint32 id = m_CivilisationOnly[i] & 0x7fffffff;
                if(!g_theCivilisationDB->GetNamedItem(id, m_CivilisationOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Civilisation database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CivilisationOnly[i] == 0x7fffffff){
                m_CivilisationOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentOnly; i++) {
            if(m_GovernmentOnly[i] & 0x80000000) {
                sint32 id = m_GovernmentOnly[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentOnly[i] == 0x7fffffff){
                m_GovernmentOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numSettleImprovement; i++) {
            if(m_SettleImprovement[i] & 0x80000000) {
                sint32 id = m_SettleImprovement[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_SettleImprovement[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_SettleImprovement[i] == 0x7fffffff){
                m_SettleImprovement[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGood; i++) {
            if(m_NeedsCityGood[i] & 0x80000000) {
                sint32 id = m_NeedsCityGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGood[i] == 0x7fffffff){
                m_NeedsCityGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAll; i++) {
            if(m_NeedsCityGoodAll[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAll[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAll[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAll[i] == 0x7fffffff){
                m_NeedsCityGoodAll[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodCapitol; i++) {
            if(m_NeedsCityGoodCapitol[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodCapitol[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodCapitol[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodCapitol[i] == 0x7fffffff){
                m_NeedsCityGoodCapitol[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsCityGoodAnyCity; i++) {
            if(m_NeedsCityGoodAnyCity[i] & 0x80000000) {
                sint32 id = m_NeedsCityGoodAnyCity[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_NeedsCityGoodAnyCity[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsCityGoodAnyCity[i] == 0x7fffffff){
                m_NeedsCityGoodAnyCity[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsFeatToBuild; i++) {
            if(m_NeedsFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsFeatToBuild[i] == 0x7fffffff){
                m_NeedsFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numNeedsAnyPlayerFeatToBuild; i++) {
            if(m_NeedsAnyPlayerFeatToBuild[i] & 0x80000000) {
                sint32 id = m_NeedsAnyPlayerFeatToBuild[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_NeedsAnyPlayerFeatToBuild[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_NeedsAnyPlayerFeatToBuild[i] == 0x7fffffff){
                m_NeedsAnyPlayerFeatToBuild[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteWonder; i++) {
            if(m_PrerequisiteWonder[i] & 0x80000000) {
                sint32 id = m_PrerequisiteWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_PrerequisiteWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteWonder[i] == 0x7fffffff){
                m_PrerequisiteWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludedByWonder; i++) {
            if(m_ExcludedByWonder[i] & 0x80000000) {
                sint32 id = m_ExcludedByWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_ExcludedByWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludedByWonder[i] == 0x7fffffff){
                m_ExcludedByWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numAllTerrainAsImprovement; i++) {
            if(m_AllTerrainAsImprovement[i] & 0x80000000) {
                sint32 id = m_AllTerrainAsImprovement[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_AllTerrainAsImprovement[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_AllTerrainAsImprovement[i] == 0x7fffffff){
                m_AllTerrainAsImprovement[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteByUnit; i++) {
            if(m_ObsoleteByUnit[i] & 0x80000000) {
                sint32 id = m_ObsoleteByUnit[i] & 0x7fffffff;
                if(!g_theUnitDB->GetNamedItem(id, m_ObsoleteByUnit[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteByUnit[i] == 0x7fffffff){
                m_ObsoleteByUnit[i] = -1;
            }
        }
    }
    if(m_SettleCityType & 0x80000000) {
        sint32 id = m_SettleCityType & 0x7fffffff;
        if(!g_theUnitDB->GetNamedItem(id, m_SettleCityType)) {
            c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SettleCityType == 0x7fffffff) {
        m_SettleCityType = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numSettleBuilding; i++) {
            if(m_SettleBuilding[i] & 0x80000000) {
                sint32 id = m_SettleBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_SettleBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_SettleBuilding[i] == 0x7fffffff){
                m_SettleBuilding[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numEstablishBuilding; i++) {
            if(m_EstablishBuilding[i] & 0x80000000) {
                sint32 id = m_EstablishBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_EstablishBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_EstablishBuilding[i] == 0x7fffffff){
                m_EstablishBuilding[i] = -1;
            }
        }
    }
    m_NuclearAttackValue.ResolveDBReferences();
    m_StealTechnologyValue.ResolveDBReferences();
    m_InciteRevolutionValue.ResolveDBReferences();
    m_AssasinateRulerValue.ResolveDBReferences();
    m_InvestigateReadinessValue.ResolveDBReferences();
    m_CreateFranchiseValue.ResolveDBReferences();
    m_CauseUnhappinessValue.ResolveDBReferences();
    m_ConductHitsValue.ResolveDBReferences();
    m_BioTerrorValue.ResolveDBReferences();
    m_NanoTerrorValue.ResolveDBReferences();
    m_PlagueValue.ResolveDBReferences();
    m_SlaveRaidsValue.ResolveDBReferences();
    m_SettlerSlaveRaidsValue.ResolveDBReferences();
    m_SlaveUprisingValue.ResolveDBReferences();
    m_UndergroundRailwayValue.ResolveDBReferences();
    m_IndulgenceSalesValue.ResolveDBReferences();
    m_ConvertCitiesValue.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    m_PlantNukeValue.ResolveDBReferences();
    m_CanSoothsayValue.ResolveDBReferences();
    m_CreateParksValue.ResolveDBReferences();
    m_CanInjoinValue.ResolveDBReferences();
    m_CanReformValue.ResolveDBReferences();
    m_CargoDataValue.ResolveDBReferences();
    if(m_DefaultSprite & 0x80000000) {
        sint32 id = m_DefaultSprite & 0x7fffffff;
        if(!g_theSpriteDB->GetNamedItem(id, m_DefaultSprite)) {
            c3errors_ErrorDialog("DB", "%s not found in Sprite database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultSprite == 0x7fffffff) {
        m_DefaultSprite = -1;
    }
    m_InvestigateCityValue.ResolveDBReferences();
    m_RevolutionValue.ResolveDBReferences();
    if(m_SoundSelect1 & 0x80000000) {
        sint32 id = m_SoundSelect1 & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundSelect1)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundSelect1 == 0x7fffffff) {
        m_SoundSelect1 = -1;
    }
    if(m_SoundSelect2 & 0x80000000) {
        sint32 id = m_SoundSelect2 & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundSelect2)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundSelect2 == 0x7fffffff) {
        m_SoundSelect2 = -1;
    }
    if(m_SoundMove & 0x80000000) {
        sint32 id = m_SoundMove & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundMove)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundMove == 0x7fffffff) {
        m_SoundMove = -1;
    }
    if(m_SoundAcknowledge & 0x80000000) {
        sint32 id = m_SoundAcknowledge & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundAcknowledge)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundAcknowledge == 0x7fffffff) {
        m_SoundAcknowledge = -1;
    }
    if(m_SoundCantMove & 0x80000000) {
        sint32 id = m_SoundCantMove & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundCantMove)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundCantMove == 0x7fffffff) {
        m_SoundCantMove = -1;
    }
    if(m_SoundAttack & 0x80000000) {
        sint32 id = m_SoundAttack & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundAttack)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundAttack == 0x7fffffff) {
        m_SoundAttack = -1;
    }
    if(m_SoundWork & 0x80000000) {
        sint32 id = m_SoundWork & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundWork)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundWork == 0x7fffffff) {
        m_SoundWork = -1;
    }
    if(m_SoundVictory & 0x80000000) {
        sint32 id = m_SoundVictory & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundVictory)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundVictory == 0x7fffffff) {
        m_SoundVictory = -1;
    }
    if(m_SoundDeath & 0x80000000) {
        sint32 id = m_SoundDeath & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundDeath)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundDeath == 0x7fffffff) {
        m_SoundDeath = -1;
    }
    if(m_SoundLoad & 0x80000000) {
        sint32 id = m_SoundLoad & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundLoad)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundLoad == 0x7fffffff) {
        m_SoundLoad = -1;
    }
    if(m_SoundUnload & 0x80000000) {
        sint32 id = m_SoundUnload & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundUnload)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundUnload == 0x7fffffff) {
        m_SoundUnload = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numSpecialAttacks; i++) {
            if(m_SpecialAttacks[i] & 0x80000000) {
                sint32 id = m_SpecialAttacks[i] & 0x7fffffff;
                if(!g_theSpecialAttackInfoDB->GetNamedItem(id, m_SpecialAttacks[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in SpecialAttackInfo database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_SpecialAttacks[i] == 0x7fffffff){
                m_SpecialAttacks[i] = -1;
            }
        }
    }
    if(m_DefaultIcon & 0x80000000) {
        sint32 id = m_DefaultIcon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_DefaultIcon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultIcon == 0x7fffffff) {
        m_DefaultIcon = -1;
    }
    if(m_HasReligionIconValue & 0x80000000) {
        sint32 id = m_HasReligionIconValue & 0x7fffffff;
        if(!g_theMapIconDB->GetNamedItem(id, m_HasReligionIconValue)) {
            c3errors_ErrorDialog("DB", "%s not found in MapIcon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_HasReligionIconValue == 0x7fffffff) {
        m_HasReligionIconValue = -1;
    }
}

UnitRecord::SuccessDeath::SuccessDeath()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitRecord::SuccessDeath::~SuccessDeath()
{
}

UnitRecord::SuccessDeath const & UnitRecord::SuccessDeath::operator = (SuccessDeath const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitRecord::SuccessDeath::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unit_SuccessDeath_Tokens[] = {
    "Chance",
    "DeathChance",
};
#define k_Token_Unit_SuccessDeath_Chance         ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SuccessDeath_DeathChance    ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SuccessDeath_Max ((k_Token_Custom_Base) + 2)
sint32 UnitRecord::SuccessDeath::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SuccessDeath::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SuccessDeath::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SuccessDeath"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_SuccessDeath_Tokens, k_Token_Unit_SuccessDeath_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SuccessDeath_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeath_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SuccessDeath::ParseInArray(DBLexer *lex, SuccessDeath **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeath *oldArray = *array;
        *array = new SuccessDeath[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeath[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SuccessDeath::ParseInArray(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SuccessDeath::ParseInArraySequential(DBLexer *lex, SuccessDeath **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeath *oldArray = *array;
        *array = new SuccessDeath[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeath[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SuccessDeath::ParseInArraySequential(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::SuccessDeath::ResolveDBReferences()
{
}

UnitRecord::SuccessDeathEffect::SuccessDeathEffect()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::SuccessDeathEffect::~SuccessDeathEffect()
{
}

UnitRecord::SuccessDeathEffect const & UnitRecord::SuccessDeathEffect::operator = (SuccessDeathEffect const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_DeathChance = rval.m_DeathChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::SuccessDeathEffect::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_DeathChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_DeathChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_SuccessDeathEffect_Tokens[] = {
    "Chance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_SuccessDeathEffect_Chance   ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SuccessDeathEffect_DeathChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SuccessDeathEffect_Sound    ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_SuccessDeathEffect_Effect   ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_SuccessDeathEffect_Max ((k_Token_Custom_Base) + 4)
sint32 UnitRecord::SuccessDeathEffect::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SuccessDeathEffect::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SuccessDeathEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SuccessDeathEffect"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_SuccessDeathEffect_Tokens, k_Token_Unit_SuccessDeathEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SuccessDeathEffect_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeathEffect_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeathEffect_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeathEffect_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SuccessDeathEffect::ParseInArray(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeathEffect *oldArray = *array;
        *array = new SuccessDeathEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeathEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SuccessDeathEffect::ParseInArray(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SuccessDeathEffect::ParseInArraySequential(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeathEffect *oldArray = *array;
        *array = new SuccessDeathEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeathEffect[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SuccessDeathEffect::ParseInArraySequential(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::SuccessDeathEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::StealTechnologyData::StealTechnologyData()
{
    m_RandomChance = 0.000000;
    m_SpecificChance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::StealTechnologyData::~StealTechnologyData()
{
}

UnitRecord::StealTechnologyData const & UnitRecord::StealTechnologyData::operator = (StealTechnologyData const & rval)
{
    if (this != &rval)
    {

        m_RandomChance = rval.m_RandomChance;

        m_SpecificChance = rval.m_SpecificChance;

        m_DeathChance = rval.m_DeathChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::StealTechnologyData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_RandomChance;
        archive << m_SpecificChance;
        archive << m_DeathChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_RandomChance;
        archive >> m_SpecificChance;
        archive >> m_DeathChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_StealTechnologyData_Tokens[] = {
    "RandomChance",
    "SpecificChance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_StealTechnologyData_RandomChance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_StealTechnologyData_SpecificChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_StealTechnologyData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_StealTechnologyData_Sound   ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_StealTechnologyData_Effect  ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_StealTechnologyData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitRecord::StealTechnologyData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_RandomChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_SpecificChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::StealTechnologyData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_RandomChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_SpecificChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::StealTechnologyData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for StealTechnologyData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_StealTechnologyData_Tokens, k_Token_Unit_StealTechnologyData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_StealTechnologyData_RandomChance:
                if(!lex->GetFloatAssignment(m_RandomChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_SpecificChance:
                if(!lex->GetFloatAssignment(m_SpecificChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_RandomChance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::StealTechnologyData::ParseInArray(DBLexer *lex, StealTechnologyData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        StealTechnologyData *oldArray = *array;
        *array = new StealTechnologyData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new StealTechnologyData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::StealTechnologyData::ParseInArray(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::StealTechnologyData::ParseInArraySequential(DBLexer *lex, StealTechnologyData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        StealTechnologyData *oldArray = *array;
        *array = new StealTechnologyData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new StealTechnologyData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::StealTechnologyData::ParseInArraySequential(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::StealTechnologyData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::InciteRevolutionData::InciteRevolutionData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::InciteRevolutionData::~InciteRevolutionData()
{
}

UnitRecord::InciteRevolutionData const & UnitRecord::InciteRevolutionData::operator = (InciteRevolutionData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::InciteRevolutionData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_InciteRevolutionData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_InciteRevolutionData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_InciteRevolutionData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_InciteRevolutionData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_InciteRevolutionData_Sound  ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_InciteRevolutionData_Effect ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_InciteRevolutionData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitRecord::InciteRevolutionData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::InciteRevolutionData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::InciteRevolutionData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for InciteRevolutionData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_InciteRevolutionData_Tokens, k_Token_Unit_InciteRevolutionData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_InciteRevolutionData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::InciteRevolutionData::ParseInArray(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InciteRevolutionData *oldArray = *array;
        *array = new InciteRevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InciteRevolutionData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InciteRevolutionData::ParseInArray(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InciteRevolutionData::ParseInArraySequential(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InciteRevolutionData *oldArray = *array;
        *array = new InciteRevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InciteRevolutionData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InciteRevolutionData::ParseInArraySequential(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::InciteRevolutionData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::AssasinateRulerData::AssasinateRulerData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitRecord::AssasinateRulerData::~AssasinateRulerData()
{
}

UnitRecord::AssasinateRulerData const & UnitRecord::AssasinateRulerData::operator = (AssasinateRulerData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitRecord::AssasinateRulerData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unit_AssasinateRulerData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unit_AssasinateRulerData_Chance  ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_AssasinateRulerData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_AssasinateRulerData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_AssasinateRulerData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::AssasinateRulerData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::AssasinateRulerData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::AssasinateRulerData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for AssasinateRulerData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_AssasinateRulerData_Tokens, k_Token_Unit_AssasinateRulerData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_AssasinateRulerData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_AssasinateRulerData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_AssasinateRulerData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::AssasinateRulerData::ParseInArray(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AssasinateRulerData *oldArray = *array;
        *array = new AssasinateRulerData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AssasinateRulerData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::AssasinateRulerData::ParseInArray(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::AssasinateRulerData::ParseInArraySequential(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AssasinateRulerData *oldArray = *array;
        *array = new AssasinateRulerData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AssasinateRulerData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::AssasinateRulerData::ParseInArraySequential(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::AssasinateRulerData::ResolveDBReferences()
{
}

UnitRecord::InvestigateReadinessData::InvestigateReadinessData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitRecord::InvestigateReadinessData::~InvestigateReadinessData()
{
}

UnitRecord::InvestigateReadinessData const & UnitRecord::InvestigateReadinessData::operator = (InvestigateReadinessData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitRecord::InvestigateReadinessData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unit_InvestigateReadinessData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unit_InvestigateReadinessData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_InvestigateReadinessData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_InvestigateReadinessData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_InvestigateReadinessData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::InvestigateReadinessData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::InvestigateReadinessData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::InvestigateReadinessData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for InvestigateReadinessData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_InvestigateReadinessData_Tokens, k_Token_Unit_InvestigateReadinessData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_InvestigateReadinessData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateReadinessData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateReadinessData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::InvestigateReadinessData::ParseInArray(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateReadinessData *oldArray = *array;
        *array = new InvestigateReadinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateReadinessData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InvestigateReadinessData::ParseInArray(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InvestigateReadinessData::ParseInArraySequential(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateReadinessData *oldArray = *array;
        *array = new InvestigateReadinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateReadinessData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InvestigateReadinessData::ParseInArraySequential(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::InvestigateReadinessData::ResolveDBReferences()
{
}

UnitRecord::ChanceEffect::ChanceEffect()
{
    m_Chance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::ChanceEffect::~ChanceEffect()
{
}

UnitRecord::ChanceEffect const & UnitRecord::ChanceEffect::operator = (ChanceEffect const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::ChanceEffect::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_ChanceEffect_Tokens[] = {
    "Chance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_ChanceEffect_Chance         ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_ChanceEffect_Sound          ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_ChanceEffect_Effect         ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_ChanceEffect_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::ChanceEffect::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::ChanceEffect::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::ChanceEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for ChanceEffect"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_ChanceEffect_Tokens, k_Token_Unit_ChanceEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_ChanceEffect_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ChanceEffect_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ChanceEffect_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::ChanceEffect::ParseInArray(DBLexer *lex, ChanceEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ChanceEffect *oldArray = *array;
        *array = new ChanceEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ChanceEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::ChanceEffect::ParseInArray(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::ChanceEffect::ParseInArraySequential(DBLexer *lex, ChanceEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ChanceEffect *oldArray = *array;
        *array = new ChanceEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ChanceEffect[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::ChanceEffect::ParseInArraySequential(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::ChanceEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::CauseUnhappinessData::CauseUnhappinessData()
{
    m_Chance = 0.000000;
    m_Timer = 0;
    m_Amount = 0;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::CauseUnhappinessData::~CauseUnhappinessData()
{
}

UnitRecord::CauseUnhappinessData const & UnitRecord::CauseUnhappinessData::operator = (CauseUnhappinessData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_Timer = rval.m_Timer;

        m_Amount = rval.m_Amount;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::CauseUnhappinessData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_Timer;
        archive << m_Amount;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_Timer;
        archive >> m_Amount;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_CauseUnhappinessData_Tokens[] = {
    "Chance",
    "Timer",
    "Amount",
    "Sound",
    "Effect",
};
#define k_Token_Unit_CauseUnhappinessData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_CauseUnhappinessData_Timer  ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_CauseUnhappinessData_Amount ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_CauseUnhappinessData_Sound  ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_CauseUnhappinessData_Effect ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_CauseUnhappinessData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitRecord::CauseUnhappinessData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::CauseUnhappinessData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::CauseUnhappinessData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for CauseUnhappinessData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_CauseUnhappinessData_Tokens, k_Token_Unit_CauseUnhappinessData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_CauseUnhappinessData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Timer:
                if(!lex->GetIntAssignment(m_Timer)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Amount:
                if(!lex->GetIntAssignment(m_Amount)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::CauseUnhappinessData::ParseInArray(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CauseUnhappinessData *oldArray = *array;
        *array = new CauseUnhappinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CauseUnhappinessData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::CauseUnhappinessData::ParseInArray(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::CauseUnhappinessData::ParseInArraySequential(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CauseUnhappinessData *oldArray = *array;
        *array = new CauseUnhappinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CauseUnhappinessData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::CauseUnhappinessData::ParseInArraySequential(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::CauseUnhappinessData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::SlaveRaidsData::SlaveRaidsData()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
    m_Timer = 0;
    m_Amount = 0;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::SlaveRaidsData::~SlaveRaidsData()
{
}

UnitRecord::SlaveRaidsData const & UnitRecord::SlaveRaidsData::operator = (SlaveRaidsData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_DeathChance = rval.m_DeathChance;

        m_Timer = rval.m_Timer;

        m_Amount = rval.m_Amount;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::SlaveRaidsData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_DeathChance;
        archive << m_Timer;
        archive << m_Amount;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_DeathChance;
        archive >> m_Timer;
        archive >> m_Amount;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_SlaveRaidsData_Tokens[] = {
    "Chance",
    "DeathChance",
    "Timer",
    "Amount",
    "Sound",
    "Effect",
};
#define k_Token_Unit_SlaveRaidsData_Chance       ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SlaveRaidsData_DeathChance  ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SlaveRaidsData_Timer        ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_SlaveRaidsData_Amount       ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_SlaveRaidsData_Sound        ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_SlaveRaidsData_Effect       ((k_Token_Custom_Base) + 5)
#define k_Token_Unit_SlaveRaidsData_Max ((k_Token_Custom_Base) + 6)
sint32 UnitRecord::SlaveRaidsData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SlaveRaidsData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SlaveRaidsData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SlaveRaidsData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_SlaveRaidsData_Tokens, k_Token_Unit_SlaveRaidsData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SlaveRaidsData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Timer:
                if(!lex->GetIntAssignment(m_Timer)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Amount:
                if(!lex->GetIntAssignment(m_Amount)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SlaveRaidsData::ParseInArray(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SlaveRaidsData *oldArray = *array;
        *array = new SlaveRaidsData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SlaveRaidsData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SlaveRaidsData::ParseInArray(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SlaveRaidsData::ParseInArraySequential(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SlaveRaidsData *oldArray = *array;
        *array = new SlaveRaidsData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SlaveRaidsData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SlaveRaidsData::ParseInArraySequential(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::SlaveRaidsData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::SoundAndEffect::SoundAndEffect()
{
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::SoundAndEffect::~SoundAndEffect()
{
}

UnitRecord::SoundAndEffect const & UnitRecord::SoundAndEffect::operator = (SoundAndEffect const & rval)
{
    if (this != &rval)
    {

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::SoundAndEffect::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_SoundAndEffect_Tokens[] = {
    "Sound",
    "Effect",
};
#define k_Token_Unit_SoundAndEffect_Sound        ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SoundAndEffect_Effect       ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SoundAndEffect_Max ((k_Token_Custom_Base) + 2)
sint32 UnitRecord::SoundAndEffect::ParseSequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SoundAndEffect::ParseFullySequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::SoundAndEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for SoundAndEffect"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_SoundAndEffect_Tokens, k_Token_Unit_SoundAndEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SoundAndEffect_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundAndEffect_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SoundAndEffect::ParseInArray(DBLexer *lex, SoundAndEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SoundAndEffect *oldArray = *array;
        *array = new SoundAndEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SoundAndEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SoundAndEffect::ParseInArray(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SoundAndEffect::ParseInArraySequential(DBLexer *lex, SoundAndEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SoundAndEffect *oldArray = *array;
        *array = new SoundAndEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SoundAndEffect[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::SoundAndEffect::ParseInArraySequential(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::SoundAndEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::PlantNukeData::PlantNukeData()
{
    m_Chance = 0.000000;
    m_EscapeChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::PlantNukeData::~PlantNukeData()
{
}

UnitRecord::PlantNukeData const & UnitRecord::PlantNukeData::operator = (PlantNukeData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EscapeChance = rval.m_EscapeChance;

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::PlantNukeData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EscapeChance;
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Chance;
        archive >> m_EscapeChance;
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_PlantNukeData_Tokens[] = {
    "Chance",
    "EscapeChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_PlantNukeData_Chance        ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_PlantNukeData_EscapeChance  ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_PlantNukeData_Sound         ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_PlantNukeData_Effect        ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_PlantNukeData_Max ((k_Token_Custom_Base) + 4)
sint32 UnitRecord::PlantNukeData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EscapeChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::PlantNukeData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EscapeChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::PlantNukeData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for PlantNukeData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_PlantNukeData_Tokens, k_Token_Unit_PlantNukeData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_PlantNukeData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PlantNukeData_EscapeChance:
                if(!lex->GetFloatAssignment(m_EscapeChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PlantNukeData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PlantNukeData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::PlantNukeData::ParseInArray(DBLexer *lex, PlantNukeData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        PlantNukeData *oldArray = *array;
        *array = new PlantNukeData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new PlantNukeData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::PlantNukeData::ParseInArray(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::PlantNukeData::ParseInArraySequential(DBLexer *lex, PlantNukeData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        PlantNukeData *oldArray = *array;
        *array = new PlantNukeData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new PlantNukeData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::PlantNukeData::ParseInArraySequential(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::PlantNukeData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

UnitRecord::CargoData::CargoData()
{
    m_MaxCargo = 0;
    m_Load = 0x7fffffff;
    m_Unload = 0x7fffffff;
}

UnitRecord::CargoData::~CargoData()
{
}

UnitRecord::CargoData const & UnitRecord::CargoData::operator = (CargoData const & rval)
{
    if (this != &rval)
    {

        m_MaxCargo = rval.m_MaxCargo;

        m_Load = rval.m_Load;

        m_Unload = rval.m_Unload;

    }

    return *this;
}

void UnitRecord::CargoData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_MaxCargo;
        archive << m_Load;
        archive << m_Unload;
    } else {
        archive >> m_MaxCargo;
        archive >> m_Load;
        archive >> m_Unload;
    }
}

static const char *s_Unit_CargoData_Tokens[] = {
    "MaxCargo",
    "Load",
    "Unload",
};
#define k_Token_Unit_CargoData_MaxCargo          ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_CargoData_Load              ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_CargoData_Unload            ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_CargoData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::CargoData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetIntAssignment(m_MaxCargo)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Load)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Unload)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::CargoData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetInt(m_MaxCargo)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Load)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Unload)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::CargoData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for CargoData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_CargoData_Tokens, k_Token_Unit_CargoData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_CargoData_MaxCargo:
                if(!lex->GetIntAssignment(m_MaxCargo)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoData_Load:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Load)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoData_Unload:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Unload)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_MaxCargo)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::CargoData::ParseInArray(DBLexer *lex, CargoData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CargoData *oldArray = *array;
        *array = new CargoData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CargoData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::CargoData::ParseInArray(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::CargoData::ParseInArraySequential(DBLexer *lex, CargoData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CargoData *oldArray = *array;
        *array = new CargoData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CargoData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::CargoData::ParseInArraySequential(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::CargoData::ResolveDBReferences()
{
    if(m_Load & 0x80000000) {
        sint32 id = m_Load & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Load)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Load == 0x7fffffff) {
        m_Load = -1;
    }
    if(m_Unload & 0x80000000) {
        sint32 id = m_Unload & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Unload)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Unload == 0x7fffffff) {
        m_Unload = -1;
    }
}

UnitRecord::InvestigateCityData::InvestigateCityData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}

UnitRecord::InvestigateCityData::~InvestigateCityData()
{
}

UnitRecord::InvestigateCityData const & UnitRecord::InvestigateCityData::operator = (InvestigateCityData const & rval)
{
    if (this != &rval)
    {

        m_Chance = rval.m_Chance;

        m_EliteChance = rval.m_EliteChance;

        m_DeathChance = rval.m_DeathChance;

    }

    return *this;
}

void UnitRecord::InvestigateCityData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Chance;
        archive << m_EliteChance;
        archive << m_DeathChance;
    } else {
        archive >> m_Chance;
        archive >> m_EliteChance;
        archive >> m_DeathChance;
    }
}

static const char *s_Unit_InvestigateCityData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unit_InvestigateCityData_Chance  ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_InvestigateCityData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_InvestigateCityData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_InvestigateCityData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::InvestigateCityData::ParseSequential(DBLexer *lex)
{
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::InvestigateCityData::ParseFullySequential(DBLexer *lex)
{
    if(!lex->GetFloat(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetFloat(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::InvestigateCityData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for InvestigateCityData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_InvestigateCityData_Tokens, k_Token_Unit_InvestigateCityData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_InvestigateCityData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateCityData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateCityData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_Chance)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::InvestigateCityData::ParseInArray(DBLexer *lex, InvestigateCityData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateCityData *oldArray = *array;
        *array = new InvestigateCityData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateCityData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InvestigateCityData::ParseInArray(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InvestigateCityData::ParseInArraySequential(DBLexer *lex, InvestigateCityData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateCityData *oldArray = *array;
        *array = new InvestigateCityData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateCityData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::InvestigateCityData::ParseInArraySequential(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::InvestigateCityData::ResolveDBReferences()
{
}

UnitRecord::RevolutionData::RevolutionData()
{
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}

UnitRecord::RevolutionData::~RevolutionData()
{
}

UnitRecord::RevolutionData const & UnitRecord::RevolutionData::operator = (RevolutionData const & rval)
{
    if (this != &rval)
    {

        m_Sound = rval.m_Sound;

        m_Effect = rval.m_Effect;

    }

    return *this;
}

void UnitRecord::RevolutionData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Sound;
        archive << m_Effect;
    } else {
        archive >> m_Sound;
        archive >> m_Effect;
    }
}

static const char *s_Unit_RevolutionData_Tokens[] = {
    "Sound",
    "Effect",
};
#define k_Token_Unit_RevolutionData_Sound        ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_RevolutionData_Effect       ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_RevolutionData_Max ((k_Token_Custom_Base) + 2)
sint32 UnitRecord::RevolutionData::ParseSequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::RevolutionData::ParseFullySequential(DBLexer *lex)
{
    if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    lex->GetToken();
    if(!g_theSpecialEffectDB->GetCurrentRecordFromLexer(lex, m_Effect)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}

sint32 UnitRecord::RevolutionData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for RevolutionData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Unit_RevolutionData_Tokens, k_Token_Unit_RevolutionData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_RevolutionData_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_RevolutionData_Effect:
                if (!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theSoundDB->GetCurrentRecordFromLexer(lex, m_Sound)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::RevolutionData::ParseInArray(DBLexer *lex, RevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RevolutionData *oldArray = *array;
        *array = new RevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RevolutionData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::RevolutionData::ParseInArray(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::RevolutionData::ParseInArraySequential(DBLexer *lex, RevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RevolutionData *oldArray = *array;
        *array = new RevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RevolutionData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 UnitRecord::RevolutionData::ParseInArraySequential(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void UnitRecord::RevolutionData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}

static const char *s_Unit_MovementType_BitNames[] = {
    "Land",
    "Sea",
    "Air",
    "Mountain",
    "Trade",
    "ShallowWater",
    "Space",
};
#define k_Unit_MovementType_Num_BitNames 7

sint32 UnitRecord::ParseMovementTypeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_MovementType_BitNames, k_Unit_MovementType_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of MovementType", lex->GetTokenText()));
        return 0;
    }
    m_MovementType |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_CanCarry_BitNames[] = {
    "SmallLand",
    "MedLand",
    "LargeLand",
    "SmallAir",
    "MedAir",
    "LargeAir",
    "SmallWater",
    "MedWater",
    "LargeWater",
    "SmallSpace",
    "MedSpace",
    "LargeSpace",
};
#define k_Unit_CanCarry_Num_BitNames 12

sint32 UnitRecord::ParseCanCarryBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanCarry_BitNames, k_Unit_CanCarry_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanCarry", lex->GetTokenText()));
        return 0;
    }
    m_CanCarry |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_Size_BitNames[] = {
    "Small",
    "Medium",
    "Large",
};
#define k_Unit_Size_Num_BitNames 3

sint32 UnitRecord::ParseSizeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_Size_BitNames, k_Unit_Size_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Size", lex->GetTokenText()));
        return 0;
    }
    m_Size |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_CanBombard_BitNames[] = {
    "Land",
    "Air",
    "Water",
    "Space",
    "Mountain",
};
#define k_Unit_CanBombard_Num_BitNames 5

sint32 UnitRecord::ParseCanBombardBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanBombard_BitNames, k_Unit_CanBombard_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanBombard", lex->GetTokenText()));
        return 0;
    }
    m_CanBombard |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_Settle_BitNames[] = {
    "Land",
    "Water",
    "Mountain",
    "Space",
};
#define k_Unit_Settle_Num_BitNames 4

sint32 UnitRecord::ParseSettleBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_Settle_BitNames, k_Unit_Settle_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Settle", lex->GetTokenText()));
        return 0;
    }
    m_Settle |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_Defend_BitNames[] = {
    "Land",
    "Air",
    "Water",
    "Space",
    "Mountain",
};
#define k_Unit_Defend_Num_BitNames 5

sint32 UnitRecord::ParseDefendBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_Defend_BitNames, k_Unit_Defend_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Defend", lex->GetTokenText()));
        return 0;
    }
    m_Defend |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_VisionClass_BitNames[] = {
    "Standard",
    "Underwater",
    "Stealth",
    "UnusedBit3",
    "UnusedBit4",
    "UnusedBit5",
    "UnusedBit6",
    "UnusedBit7",
    "UnusedBit8",
    "UnusedBit9",
    "UnusedBit10",
    "UnusedBit11",
    "UnusedBit12",
    "UnusedBit13",
    "UnusedBit14",
    "UnusedBit15",
};
#define k_Unit_VisionClass_Num_BitNames 16

sint32 UnitRecord::ParseVisionClassBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_VisionClass_BitNames, k_Unit_VisionClass_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of VisionClass", lex->GetTokenText()));
        return 0;
    }
    m_VisionClass |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_CanSee_BitNames[] = {
    "Standard",
    "Underwater",
    "Stealth",
    "UnusedBit3",
    "UnusedBit4",
    "UnusedBit5",
    "UnusedBit6",
    "UnusedBit7",
    "UnusedBit8",
    "UnusedBit9",
    "UnusedBit10",
    "UnusedBit11",
    "UnusedBit12",
    "UnusedBit13",
    "UnusedBit14",
    "UnusedBit15",
};
#define k_Unit_CanSee_Num_BitNames 16

sint32 UnitRecord::ParseCanSeeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanSee_BitNames, k_Unit_CanSee_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanSee", lex->GetTokenText()));
        return 0;
    }
    m_CanSee |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_CanAttack_BitNames[] = {
    "Land",
    "Sea",
    "Air",
    "Mountain",
    "Trade",
    "ShallowWater",
    "Space",
    "Underwater",
};
#define k_Unit_CanAttack_Num_BitNames 8

sint32 UnitRecord::ParseCanAttackBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanAttack_BitNames, k_Unit_CanAttack_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanAttack", lex->GetTokenText()));
        return 0;
    }
    m_CanAttack |= (1 << bitindex);
    return 1;
}

static const char *s_Unit_UserFlags_BitNames[] = {
    "UF1",
    "UF2",
    "UF3",
    "UF4",
    "UF5",
    "UF6",
    "UF7",
    "UF8",
    "UF9",
    "UF10",
    "UF11",
    "UF12",
    "UF13",
    "UF14",
    "UF15",
    "UF16",
    "UF17",
    "UF18",
    "UF19",
    "UF20",
    "UF21",
    "UF22",
    "UF23",
    "UF24",
    "UF25",
    "UF26",
    "UF27",
    "UF28",
    "UF29",
    "UF30",
    "UF31",
};
#define k_Unit_UserFlags_Num_BitNames 31

sint32 UnitRecord::ParseUserFlagsBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_UserFlags_BitNames, k_Unit_UserFlags_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of UserFlags", lex->GetTokenText()));
        return 0;
    }
    m_UserFlags |= (1 << bitindex);
    return 1;
}

void UnitRecord::Merge(const UnitRecord & rval){
    // only replace values that have been set
    if (rval.m_MovementType)
    {
        m_MovementType = rval.m_MovementType;
    }

    // only replace values that have been set
    if (rval.m_CanCarry)
    {
        m_CanCarry = rval.m_CanCarry;
    }

    if (rval.m_numObsoleteAdvance > 0)
        std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);

    // resize m_PrerequisiteBuilding if necessary
    if (rval.m_numPrerequisiteBuilding > m_numPrerequisiteBuilding)
    {
        delete [] m_PrerequisiteBuilding;
        m_PrerequisiteBuilding = NULL;
        if (rval.m_numPrerequisiteBuilding > 0)
            m_PrerequisiteBuilding = new sint32 [rval.m_numPrerequisiteBuilding];
        m_numPrerequisiteBuilding = rval.m_numPrerequisiteBuilding;
    }
    if (rval.m_numPrerequisiteBuilding > 0)
        std::copy(rval.m_PrerequisiteBuilding, rval.m_PrerequisiteBuilding + rval.m_numPrerequisiteBuilding, m_PrerequisiteBuilding);

    // resize m_ExcludedByBuilding if necessary
    if (rval.m_numExcludedByBuilding > m_numExcludedByBuilding)
    {
        delete [] m_ExcludedByBuilding;
        m_ExcludedByBuilding = NULL;
        if (rval.m_numExcludedByBuilding > 0)
            m_ExcludedByBuilding = new sint32 [rval.m_numExcludedByBuilding];
        m_numExcludedByBuilding = rval.m_numExcludedByBuilding;
    }
    if (rval.m_numExcludedByBuilding > 0)
        std::copy(rval.m_ExcludedByBuilding, rval.m_ExcludedByBuilding + rval.m_numExcludedByBuilding, m_ExcludedByBuilding);

    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

    // resize m_CanSettleOn if necessary
    if (rval.m_numCanSettleOn > m_numCanSettleOn)
    {
        delete [] m_CanSettleOn;
        m_CanSettleOn = NULL;
        if (rval.m_numCanSettleOn > 0)
            m_CanSettleOn = new sint32 [rval.m_numCanSettleOn];
        m_numCanSettleOn = rval.m_numCanSettleOn;
    }
    if (rval.m_numCanSettleOn > 0)
        std::copy(rval.m_CanSettleOn, rval.m_CanSettleOn + rval.m_numCanSettleOn, m_CanSettleOn);

    // resize m_UpgradeTo if necessary
    if (rval.m_numUpgradeTo > m_numUpgradeTo)
    {
        delete [] m_UpgradeTo;
        m_UpgradeTo = NULL;
        if (rval.m_numUpgradeTo > 0)
            m_UpgradeTo = new sint32 [rval.m_numUpgradeTo];
        m_numUpgradeTo = rval.m_numUpgradeTo;
    }
    if (rval.m_numUpgradeTo > 0)
        std::copy(rval.m_UpgradeTo, rval.m_UpgradeTo + rval.m_numUpgradeTo, m_UpgradeTo);

    // resize m_ObsoleteUnit if necessary
    if (rval.m_numObsoleteUnit > m_numObsoleteUnit)
    {
        delete [] m_ObsoleteUnit;
        m_ObsoleteUnit = NULL;
        if (rval.m_numObsoleteUnit > 0)
            m_ObsoleteUnit = new sint32 [rval.m_numObsoleteUnit];
        m_numObsoleteUnit = rval.m_numObsoleteUnit;
    }
    if (rval.m_numObsoleteUnit > 0)
        std::copy(rval.m_ObsoleteUnit, rval.m_ObsoleteUnit + rval.m_numObsoleteUnit, m_ObsoleteUnit);

    // resize m_CultureOnly if necessary
    if (rval.m_numCultureOnly > m_numCultureOnly)
    {
        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
        m_numCultureOnly = rval.m_numCultureOnly;
    }
    if (rval.m_numCultureOnly > 0)
        std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);

    // resize m_CityStyleOnly if necessary
    if (rval.m_numCityStyleOnly > m_numCityStyleOnly)
    {
        delete [] m_CityStyleOnly;
        m_CityStyleOnly = NULL;
        if (rval.m_numCityStyleOnly > 0)
            m_CityStyleOnly = new sint32 [rval.m_numCityStyleOnly];
        m_numCityStyleOnly = rval.m_numCityStyleOnly;
    }
    if (rval.m_numCityStyleOnly > 0)
        std::copy(rval.m_CityStyleOnly, rval.m_CityStyleOnly + rval.m_numCityStyleOnly, m_CityStyleOnly);

    // resize m_CivilisationOnly if necessary
    if (rval.m_numCivilisationOnly > m_numCivilisationOnly)
    {
        delete [] m_CivilisationOnly;
        m_CivilisationOnly = NULL;
        if (rval.m_numCivilisationOnly > 0)
            m_CivilisationOnly = new sint32 [rval.m_numCivilisationOnly];
        m_numCivilisationOnly = rval.m_numCivilisationOnly;
    }
    if (rval.m_numCivilisationOnly > 0)
        std::copy(rval.m_CivilisationOnly, rval.m_CivilisationOnly + rval.m_numCivilisationOnly, m_CivilisationOnly);

    // resize m_GovernmentOnly if necessary
    if (rval.m_numGovernmentOnly > m_numGovernmentOnly)
    {
        delete [] m_GovernmentOnly;
        m_GovernmentOnly = NULL;
        if (rval.m_numGovernmentOnly > 0)
            m_GovernmentOnly = new sint32 [rval.m_numGovernmentOnly];
        m_numGovernmentOnly = rval.m_numGovernmentOnly;
    }
    if (rval.m_numGovernmentOnly > 0)
        std::copy(rval.m_GovernmentOnly, rval.m_GovernmentOnly + rval.m_numGovernmentOnly, m_GovernmentOnly);

    // resize m_SettleImprovement if necessary
    if (rval.m_numSettleImprovement > m_numSettleImprovement)
    {
        delete [] m_SettleImprovement;
        m_SettleImprovement = NULL;
        if (rval.m_numSettleImprovement > 0)
            m_SettleImprovement = new sint32 [rval.m_numSettleImprovement];
        m_numSettleImprovement = rval.m_numSettleImprovement;
    }
    if (rval.m_numSettleImprovement > 0)
        std::copy(rval.m_SettleImprovement, rval.m_SettleImprovement + rval.m_numSettleImprovement, m_SettleImprovement);

    // resize m_NeedsCityGood if necessary
    if (rval.m_numNeedsCityGood > m_numNeedsCityGood)
    {
        delete [] m_NeedsCityGood;
        m_NeedsCityGood = NULL;
        if (rval.m_numNeedsCityGood > 0)
            m_NeedsCityGood = new sint32 [rval.m_numNeedsCityGood];
        m_numNeedsCityGood = rval.m_numNeedsCityGood;
    }
    if (rval.m_numNeedsCityGood > 0)
        std::copy(rval.m_NeedsCityGood, rval.m_NeedsCityGood + rval.m_numNeedsCityGood, m_NeedsCityGood);

    // resize m_NeedsCityGoodAll if necessary
    if (rval.m_numNeedsCityGoodAll > m_numNeedsCityGoodAll)
    {
        delete [] m_NeedsCityGoodAll;
        m_NeedsCityGoodAll = NULL;
        if (rval.m_numNeedsCityGoodAll > 0)
            m_NeedsCityGoodAll = new sint32 [rval.m_numNeedsCityGoodAll];
        m_numNeedsCityGoodAll = rval.m_numNeedsCityGoodAll;
    }
    if (rval.m_numNeedsCityGoodAll > 0)
        std::copy(rval.m_NeedsCityGoodAll, rval.m_NeedsCityGoodAll + rval.m_numNeedsCityGoodAll, m_NeedsCityGoodAll);

    // resize m_NeedsCityGoodCapitol if necessary
    if (rval.m_numNeedsCityGoodCapitol > m_numNeedsCityGoodCapitol)
    {
        delete [] m_NeedsCityGoodCapitol;
        m_NeedsCityGoodCapitol = NULL;
        if (rval.m_numNeedsCityGoodCapitol > 0)
            m_NeedsCityGoodCapitol = new sint32 [rval.m_numNeedsCityGoodCapitol];
        m_numNeedsCityGoodCapitol = rval.m_numNeedsCityGoodCapitol;
    }
    if (rval.m_numNeedsCityGoodCapitol > 0)
        std::copy(rval.m_NeedsCityGoodCapitol, rval.m_NeedsCityGoodCapitol + rval.m_numNeedsCityGoodCapitol, m_NeedsCityGoodCapitol);

    // resize m_NeedsCityGoodAnyCity if necessary
    if (rval.m_numNeedsCityGoodAnyCity > m_numNeedsCityGoodAnyCity)
    {
        delete [] m_NeedsCityGoodAnyCity;
        m_NeedsCityGoodAnyCity = NULL;
        if (rval.m_numNeedsCityGoodAnyCity > 0)
            m_NeedsCityGoodAnyCity = new sint32 [rval.m_numNeedsCityGoodAnyCity];
        m_numNeedsCityGoodAnyCity = rval.m_numNeedsCityGoodAnyCity;
    }
    if (rval.m_numNeedsCityGoodAnyCity > 0)
        std::copy(rval.m_NeedsCityGoodAnyCity, rval.m_NeedsCityGoodAnyCity + rval.m_numNeedsCityGoodAnyCity, m_NeedsCityGoodAnyCity);

    // resize m_NeedsFeatToBuild if necessary
    if (rval.m_numNeedsFeatToBuild > m_numNeedsFeatToBuild)
    {
        delete [] m_NeedsFeatToBuild;
        m_NeedsFeatToBuild = NULL;
        if (rval.m_numNeedsFeatToBuild > 0)
            m_NeedsFeatToBuild = new sint32 [rval.m_numNeedsFeatToBuild];
        m_numNeedsFeatToBuild = rval.m_numNeedsFeatToBuild;
    }
    if (rval.m_numNeedsFeatToBuild > 0)
        std::copy(rval.m_NeedsFeatToBuild, rval.m_NeedsFeatToBuild + rval.m_numNeedsFeatToBuild, m_NeedsFeatToBuild);

    // resize m_NeedsAnyPlayerFeatToBuild if necessary
    if (rval.m_numNeedsAnyPlayerFeatToBuild > m_numNeedsAnyPlayerFeatToBuild)
    {
        delete [] m_NeedsAnyPlayerFeatToBuild;
        m_NeedsAnyPlayerFeatToBuild = NULL;
        if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
            m_NeedsAnyPlayerFeatToBuild = new sint32 [rval.m_numNeedsAnyPlayerFeatToBuild];
        m_numNeedsAnyPlayerFeatToBuild = rval.m_numNeedsAnyPlayerFeatToBuild;
    }
    if (rval.m_numNeedsAnyPlayerFeatToBuild > 0)
        std::copy(rval.m_NeedsAnyPlayerFeatToBuild, rval.m_NeedsAnyPlayerFeatToBuild + rval.m_numNeedsAnyPlayerFeatToBuild, m_NeedsAnyPlayerFeatToBuild);

    // resize m_PrerequisiteWonder if necessary
    if (rval.m_numPrerequisiteWonder > m_numPrerequisiteWonder)
    {
        delete [] m_PrerequisiteWonder;
        m_PrerequisiteWonder = NULL;
        if (rval.m_numPrerequisiteWonder > 0)
            m_PrerequisiteWonder = new sint32 [rval.m_numPrerequisiteWonder];
        m_numPrerequisiteWonder = rval.m_numPrerequisiteWonder;
    }
    if (rval.m_numPrerequisiteWonder > 0)
        std::copy(rval.m_PrerequisiteWonder, rval.m_PrerequisiteWonder + rval.m_numPrerequisiteWonder, m_PrerequisiteWonder);

    // resize m_ExcludedByWonder if necessary
    if (rval.m_numExcludedByWonder > m_numExcludedByWonder)
    {
        delete [] m_ExcludedByWonder;
        m_ExcludedByWonder = NULL;
        if (rval.m_numExcludedByWonder > 0)
            m_ExcludedByWonder = new sint32 [rval.m_numExcludedByWonder];
        m_numExcludedByWonder = rval.m_numExcludedByWonder;
    }
    if (rval.m_numExcludedByWonder > 0)
        std::copy(rval.m_ExcludedByWonder, rval.m_ExcludedByWonder + rval.m_numExcludedByWonder, m_ExcludedByWonder);

    // only replace values that have been set
    if (rval.m_flags0 & k_Unit_MoveBonus_Bit)
    {
        m_MoveBonusValue = rval.m_MoveBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Unit_PWMoveCost_Bit)
    {
        m_PWMoveCostValue = rval.m_PWMoveCostValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Unit_MerchantGold_Bit)
    {
        m_MerchantGoldValue = rval.m_MerchantGoldValue;
    }

    // resize m_AllTerrainAsImprovement if necessary
    if (rval.m_numAllTerrainAsImprovement > m_numAllTerrainAsImprovement)
    {
        delete [] m_AllTerrainAsImprovement;
        m_AllTerrainAsImprovement = NULL;
        if (rval.m_numAllTerrainAsImprovement > 0)
            m_AllTerrainAsImprovement = new sint32 [rval.m_numAllTerrainAsImprovement];
        m_numAllTerrainAsImprovement = rval.m_numAllTerrainAsImprovement;
    }
    if (rval.m_numAllTerrainAsImprovement > 0)
        std::copy(rval.m_AllTerrainAsImprovement, rval.m_AllTerrainAsImprovement + rval.m_numAllTerrainAsImprovement, m_AllTerrainAsImprovement);

    // resize m_ObsoleteByUnit if necessary
    if (rval.m_numObsoleteByUnit > m_numObsoleteByUnit)
    {
        delete [] m_ObsoleteByUnit;
        m_ObsoleteByUnit = NULL;
        if (rval.m_numObsoleteByUnit > 0)
            m_ObsoleteByUnit = new sint32 [rval.m_numObsoleteByUnit];
        m_numObsoleteByUnit = rval.m_numObsoleteByUnit;
    }
    if (rval.m_numObsoleteByUnit > 0)
        std::copy(rval.m_ObsoleteByUnit, rval.m_ObsoleteByUnit + rval.m_numObsoleteByUnit, m_ObsoleteByUnit);

    // only replace values that have been set
    if (rval.m_Size)
    {
        m_Size = rval.m_Size;
    }

    // only replace values that have been set
    if (rval.m_CanBombard)
    {
        m_CanBombard = rval.m_CanBombard;
    }

    // only replace values that have been set
    if (rval.m_Settle)
    {
        m_Settle = rval.m_Settle;
    }

    // resize m_SettleBuilding if necessary
    if (rval.m_numSettleBuilding > m_numSettleBuilding)
    {
        delete [] m_SettleBuilding;
        m_SettleBuilding = NULL;
        if (rval.m_numSettleBuilding > 0)
            m_SettleBuilding = new sint32 [rval.m_numSettleBuilding];
        m_numSettleBuilding = rval.m_numSettleBuilding;
    }
    if (rval.m_numSettleBuilding > 0)
        std::copy(rval.m_SettleBuilding, rval.m_SettleBuilding + rval.m_numSettleBuilding, m_SettleBuilding);

    // resize m_EstablishBuilding if necessary
    if (rval.m_numEstablishBuilding > m_numEstablishBuilding)
    {
        delete [] m_EstablishBuilding;
        m_EstablishBuilding = NULL;
        if (rval.m_numEstablishBuilding > 0)
            m_EstablishBuilding = new sint32 [rval.m_numEstablishBuilding];
        m_numEstablishBuilding = rval.m_numEstablishBuilding;
    }
    if (rval.m_numEstablishBuilding > 0)
        std::copy(rval.m_EstablishBuilding, rval.m_EstablishBuilding + rval.m_numEstablishBuilding, m_EstablishBuilding);

    // only replace values that have been set
    if (rval.m_flags0 & k_Unit_SpaceLaunch_Bit)
    {
        m_SpaceLaunchValue = rval.m_SpaceLaunchValue;
    }

    // only replace values that have been set
    if (rval.m_Defend)
    {
        m_Defend = rval.m_Defend;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Unit_DefendAgainstSpies_Bit)
    {
        m_DefendAgainstSpiesValue = rval.m_DefendAgainstSpiesValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Unit_DefendAirBonus_Bit)
    {
        m_DefendAirBonusValue = rval.m_DefendAirBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags1 & k_Unit_DefendCityBonus_Bit)
    {
        m_DefendCityBonusValue = rval.m_DefendCityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendSubmarineBonus_Bit)
    {
        m_DefendSubmarineBonusValue = rval.m_DefendSubmarineBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendFootBonus_Bit)
    {
        m_DefendFootBonusValue = rval.m_DefendFootBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendMeleeBonus_Bit)
    {
        m_DefendMeleeBonusValue = rval.m_DefendMeleeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendSiegeBonus_Bit)
    {
        m_DefendSiegeBonusValue = rval.m_DefendSiegeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendWheeledBonus_Bit)
    {
        m_DefendWheeledBonusValue = rval.m_DefendWheeledBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendMechanizedBonus_Bit)
    {
        m_DefendMechanizedBonusValue = rval.m_DefendMechanizedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendHelicopterBonus_Bit)
    {
        m_DefendHelicopterBonusValue = rval.m_DefendHelicopterBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendSpecialForcesBonus_Bit)
    {
        m_DefendSpecialForcesBonusValue = rval.m_DefendSpecialForcesBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendCivilianBonus_Bit)
    {
        m_DefendCivilianBonusValue = rval.m_DefendCivilianBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendGuerrillaBonus_Bit)
    {
        m_DefendGuerrillaBonusValue = rval.m_DefendGuerrillaBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendMountedBonus_Bit)
    {
        m_DefendMountedBonusValue = rval.m_DefendMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendWoodenShipBonus_Bit)
    {
        m_DefendWoodenShipBonusValue = rval.m_DefendWoodenShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_DefendSurfaceShipBonus_Bit)
    {
        m_DefendSurfaceShipBonusValue = rval.m_DefendSurfaceShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackAirBonus_Bit)
    {
        m_AttackAirBonusValue = rval.m_AttackAirBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackCityBonus_Bit)
    {
        m_AttackCityBonusValue = rval.m_AttackCityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackSubmarineBonus_Bit)
    {
        m_AttackSubmarineBonusValue = rval.m_AttackSubmarineBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackFootBonus_Bit)
    {
        m_AttackFootBonusValue = rval.m_AttackFootBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackMeleeBonus_Bit)
    {
        m_AttackMeleeBonusValue = rval.m_AttackMeleeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackSiegeBonus_Bit)
    {
        m_AttackSiegeBonusValue = rval.m_AttackSiegeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackWheeledBonus_Bit)
    {
        m_AttackWheeledBonusValue = rval.m_AttackWheeledBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackMechanizedBonus_Bit)
    {
        m_AttackMechanizedBonusValue = rval.m_AttackMechanizedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackHelicopterBonus_Bit)
    {
        m_AttackHelicopterBonusValue = rval.m_AttackHelicopterBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackSpecialForcesBonus_Bit)
    {
        m_AttackSpecialForcesBonusValue = rval.m_AttackSpecialForcesBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackCivilianBonus_Bit)
    {
        m_AttackCivilianBonusValue = rval.m_AttackCivilianBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackGuerrillaBonus_Bit)
    {
        m_AttackGuerrillaBonusValue = rval.m_AttackGuerrillaBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackMountedBonus_Bit)
    {
        m_AttackMountedBonusValue = rval.m_AttackMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackWoodenShipBonusNew_Bit)
    {
        m_AttackWoodenShipBonusNewValue = rval.m_AttackWoodenShipBonusNewValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_AttackSurfaceShipBonus_Bit)
    {
        m_AttackSurfaceShipBonusValue = rval.m_AttackSurfaceShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_RangedAirBonus_Bit)
    {
        m_RangedAirBonusValue = rval.m_RangedAirBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_RangedAttackCityBonus_Bit)
    {
        m_RangedAttackCityBonusValue = rval.m_RangedAttackCityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags2 & k_Unit_RangedDefendCityBonus_Bit)
    {
        m_RangedDefendCityBonusValue = rval.m_RangedDefendCityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedSubmarineBonus_Bit)
    {
        m_RangedSubmarineBonusValue = rval.m_RangedSubmarineBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedFootBonus_Bit)
    {
        m_RangedFootBonusValue = rval.m_RangedFootBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedMeleeBonus_Bit)
    {
        m_RangedMeleeBonusValue = rval.m_RangedMeleeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedSiegeBonus_Bit)
    {
        m_RangedSiegeBonusValue = rval.m_RangedSiegeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedWheeledBonus_Bit)
    {
        m_RangedWheeledBonusValue = rval.m_RangedWheeledBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedMechanizedBonus_Bit)
    {
        m_RangedMechanizedBonusValue = rval.m_RangedMechanizedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedHelicopterBonus_Bit)
    {
        m_RangedHelicopterBonusValue = rval.m_RangedHelicopterBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedSpecialForcesBonus_Bit)
    {
        m_RangedSpecialForcesBonusValue = rval.m_RangedSpecialForcesBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedCivilianBonus_Bit)
    {
        m_RangedCivilianBonusValue = rval.m_RangedCivilianBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedGuerrillaBonus_Bit)
    {
        m_RangedGuerrillaBonusValue = rval.m_RangedGuerrillaBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedMountedBonus_Bit)
    {
        m_RangedMountedBonusValue = rval.m_RangedMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedWoodenShipBonus_Bit)
    {
        m_RangedWoodenShipBonusValue = rval.m_RangedWoodenShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_RangedSurfaceShipBonus_Bit)
    {
        m_RangedSurfaceShipBonusValue = rval.m_RangedSurfaceShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_WoodenShipBonus_Bit)
    {
        m_WoodenShipBonusValue = rval.m_WoodenShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_MountedBonus_Bit)
    {
        m_MountedBonusValue = rval.m_MountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_AirBonus_Bit)
    {
        m_AirBonusValue = rval.m_AirBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_ReplaceWithCargoModule_Bit)
    {
        m_ReplaceWithCargoModuleValue = rval.m_ReplaceWithCargoModuleValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_NuclearAttack_Bit)
    {
        m_NuclearAttackValue = rval.m_NuclearAttackValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_StealTechnology_Bit)
    {
        m_StealTechnologyValue = rval.m_StealTechnologyValue;
    }

    // only replace values that have been set
    if (rval.m_flags3 & k_Unit_InciteRevolution_Bit)
    {
        m_InciteRevolutionValue = rval.m_InciteRevolutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_AssasinateRuler_Bit)
    {
        m_AssasinateRulerValue = rval.m_AssasinateRulerValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_InvestigateReadiness_Bit)
    {
        m_InvestigateReadinessValue = rval.m_InvestigateReadinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_CreateFranchise_Bit)
    {
        m_CreateFranchiseValue = rval.m_CreateFranchiseValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_CauseUnhappiness_Bit)
    {
        m_CauseUnhappinessValue = rval.m_CauseUnhappinessValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_ConductHits_Bit)
    {
        m_ConductHitsValue = rval.m_ConductHitsValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_BioTerror_Bit)
    {
        m_BioTerrorValue = rval.m_BioTerrorValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_NanoTerror_Bit)
    {
        m_NanoTerrorValue = rval.m_NanoTerrorValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_Plague_Bit)
    {
        m_PlagueValue = rval.m_PlagueValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_SlaveRaids_Bit)
    {
        m_SlaveRaidsValue = rval.m_SlaveRaidsValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_SettlerSlaveRaids_Bit)
    {
        m_SettlerSlaveRaidsValue = rval.m_SettlerSlaveRaidsValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_SlaveUprising_Bit)
    {
        m_SlaveUprisingValue = rval.m_SlaveUprisingValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_UndergroundRailway_Bit)
    {
        m_UndergroundRailwayValue = rval.m_UndergroundRailwayValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_VictoryEnslavementChance_Bit)
    {
        m_VictoryEnslavementChanceValue = rval.m_VictoryEnslavementChanceValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_IndulgenceSales_Bit)
    {
        m_IndulgenceSalesValue = rval.m_IndulgenceSalesValue;
    }

    // only replace values that have been set
    if (rval.m_flags4 & k_Unit_ConvertCities_Bit)
    {
        m_ConvertCitiesValue = rval.m_ConvertCitiesValue;
    }

    // resize m_GovernmentType if necessary
    if (rval.m_numGovernmentType > m_numGovernmentType)
    {
        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
        m_numGovernmentType = rval.m_numGovernmentType;
    }
    if (rval.m_numGovernmentType > 0)
        std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);

    // only replace values that have been set
    if (rval.m_flags5 & k_Unit_PlantNuke_Bit)
    {
        m_PlantNukeValue = rval.m_PlantNukeValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unit_CanSoothsay_Bit)
    {
        m_CanSoothsayValue = rval.m_CanSoothsayValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unit_CreateParks_Bit)
    {
        m_CreateParksValue = rval.m_CreateParksValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unit_CanInjoin_Bit)
    {
        m_CanInjoinValue = rval.m_CanInjoinValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unit_PopCostsToBuild_Bit)
    {
        m_PopCostsToBuildValue = rval.m_PopCostsToBuildValue;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unit_CanReform_Bit)
    {
        m_CanReformValue = rval.m_CanReformValue;
    }

    // only replace values that have been set
    if (rval.m_VisionClass)
    {
        m_VisionClass = rval.m_VisionClass;
    }

    // only replace values that have been set
    if (rval.m_CanSee)
    {
        m_CanSee = rval.m_CanSee;
    }

    // only replace values that have been set
    if (rval.m_CanAttack)
    {
        m_CanAttack = rval.m_CanAttack;
    }

    // only replace values that have been set
    if (rval.m_flags5 & k_Unit_CargoData_Bit)
    {
        m_CargoDataValue = rval.m_CargoDataValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_BRange_Bit)
    {
        m_BRangeValue = rval.m_BRangeValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_BRadius_Bit)
    {
        m_BRadiusValue = rval.m_BRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_ElectronicCombatFactor_Bit)
    {
        m_ElectronicCombatFactorValue = rval.m_ElectronicCombatFactorValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_TransType_Bit)
    {
        m_TransTypeValue = rval.m_TransTypeValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_ProbOfBombHit_Bit)
    {
        m_ProbOfBombHitValue = rval.m_ProbOfBombHitValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_BombRounds_Bit)
    {
        m_BombRoundsValue = rval.m_BombRoundsValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_LaunchPollution_Bit)
    {
        m_LaunchPollutionValue = rval.m_LaunchPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_DeathPollution_Bit)
    {
        m_DeathPollutionValue = rval.m_DeathPollutionValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_CargoModule_Bit)
    {
        m_CargoModuleValue = rval.m_CargoModuleValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_SpyVsSpy_Bit)
    {
        m_SpyVsSpyValue = rval.m_SpyVsSpyValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_InvestigateCity_Bit)
    {
        m_InvestigateCityValue = rval.m_InvestigateCityValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_BonusFood_Bit)
    {
        m_BonusFoodValue = rval.m_BonusFoodValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_BombardRange_Bit)
    {
        m_BombardRangeValue = rval.m_BombardRangeValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_Revolution_Bit)
    {
        m_RevolutionValue = rval.m_RevolutionValue;
    }

    if (rval.m_numSpecialAttacks > 0)
        std::copy(rval.m_SpecialAttacks, rval.m_SpecialAttacks + rval.m_numSpecialAttacks, m_SpecialAttacks);

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_CityGrowthCoefficient_Bit)
    {
        m_CityGrowthCoefficientValue = rval.m_CityGrowthCoefficientValue;
    }

    // only replace values that have been set
    if (rval.m_UserFlags)
    {
        m_UserFlags = rval.m_UserFlags;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_CheatIndex_Bit)
    {
        m_CheatIndexValue = rval.m_CheatIndexValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_Advice_Bit)
    {
        m_AdviceValue = rval.m_AdviceValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_ArmyMountedBonus_Bit)
    {
        m_ArmyMountedBonusValue = rval.m_ArmyMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_ArmyAirBonus_Bit)
    {
        m_ArmyAirBonusValue = rval.m_ArmyAirBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags6 & k_Unit_ArmyWoodenShipBonus_Bit)
    {
        m_ArmyWoodenShipBonusValue = rval.m_ArmyWoodenShipBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyAttackCityBonus_Bit)
    {
        m_ArmyAttackCityBonusValue = rval.m_ArmyAttackCityBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyAttackBonusSubmarine_Bit)
    {
        m_ArmyAttackBonusSubmarineValue = rval.m_ArmyAttackBonusSubmarineValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyFootBonus_Bit)
    {
        m_ArmyFootBonusValue = rval.m_ArmyFootBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyMeleeBonus_Bit)
    {
        m_ArmyMeleeBonusValue = rval.m_ArmyMeleeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmySiegeBonus_Bit)
    {
        m_ArmySiegeBonusValue = rval.m_ArmySiegeBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyWheeledBonus_Bit)
    {
        m_ArmyWheeledBonusValue = rval.m_ArmyWheeledBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyMechanizedBonus_Bit)
    {
        m_ArmyMechanizedBonusValue = rval.m_ArmyMechanizedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyHelicopterBonus_Bit)
    {
        m_ArmyHelicopterBonusValue = rval.m_ArmyHelicopterBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmySpecialForcesBonus_Bit)
    {
        m_ArmySpecialForcesBonusValue = rval.m_ArmySpecialForcesBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyCivilianBonus_Bit)
    {
        m_ArmyCivilianBonusValue = rval.m_ArmyCivilianBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyGuerrillaBonus_Bit)
    {
        m_ArmyGuerrillaBonusValue = rval.m_ArmyGuerrillaBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyAgainstMountedBonus_Bit)
    {
        m_ArmyAgainstMountedBonusValue = rval.m_ArmyAgainstMountedBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_ArmyAirDefenseBonus_Bit)
    {
        m_ArmyAirDefenseBonusValue = rval.m_ArmyAirDefenseBonusValue;
    }

    // only replace values that have been set
    if (rval.m_flags7 & k_Unit_HasReligionIcon_Bit)
    {
        m_HasReligionIconValue = rval.m_HasReligionIconValue;
    }

}

AdvanceRecord const * UnitRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 UnitRecord::GetObsoleteAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return m_ObsoleteAdvance[index];
}

AdvanceRecord const * UnitRecord::GetObsoleteAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ObsoleteAdvance[index]);
}

sint32 UnitRecord::GetPrerequisiteBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return m_PrerequisiteBuilding[index];
}

BuildingRecord const * UnitRecord::GetPrerequisiteBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteBuilding);
    if((index < 0) || (index >= m_numPrerequisiteBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_PrerequisiteBuilding[index]);
}

sint32 UnitRecord::GetExcludedByBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return m_ExcludedByBuilding[index];
}

BuildingRecord const * UnitRecord::GetExcludedByBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByBuilding);
    if((index < 0) || (index >= m_numExcludedByBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_ExcludedByBuilding[index]);
}

sint32 UnitRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * UnitRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

sint32 UnitRecord::GetCanSettleOnIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCanSettleOn);
    if((index < 0) || (index >= m_numCanSettleOn)) {
        return 0;
    }
    return m_CanSettleOn[index];
}

TerrainRecord const * UnitRecord::GetCanSettleOn(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCanSettleOn);
    if((index < 0) || (index >= m_numCanSettleOn)) {
        return 0;
    }
    return g_theTerrainDB->Get(m_CanSettleOn[index]);
}

sint32 UnitRecord::GetUpgradeToIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numUpgradeTo);
    if((index < 0) || (index >= m_numUpgradeTo)) {
        return 0;
    }
    return m_UpgradeTo[index];
}

UnitRecord const * UnitRecord::GetUpgradeTo(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numUpgradeTo);
    if((index < 0) || (index >= m_numUpgradeTo)) {
        return 0;
    }
    return g_theUnitDB->Get(m_UpgradeTo[index]);
}

sint32 UnitRecord::GetObsoleteUnitIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteUnit);
    if((index < 0) || (index >= m_numObsoleteUnit)) {
        return 0;
    }
    return m_ObsoleteUnit[index];
}

UnitRecord const * UnitRecord::GetObsoleteUnit(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteUnit);
    if((index < 0) || (index >= m_numObsoleteUnit)) {
        return 0;
    }
    return g_theUnitDB->Get(m_ObsoleteUnit[index]);
}

sint32 UnitRecord::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

CityStyleRecord const * UnitRecord::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

sint32 UnitRecord::GetCityStyleOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return m_CityStyleOnly[index];
}

CityStyleRecord const * UnitRecord::GetCityStyleOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCityStyleOnly);
    if((index < 0) || (index >= m_numCityStyleOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CityStyleOnly[index]);
}

sint32 UnitRecord::GetCivilisationOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return m_CivilisationOnly[index];
}

CivilisationRecord const * UnitRecord::GetCivilisationOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCivilisationOnly);
    if((index < 0) || (index >= m_numCivilisationOnly)) {
        return 0;
    }
    return g_theCivilisationDB->Get(m_CivilisationOnly[index]);
}

sint32 UnitRecord::GetGovernmentOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentOnly);
    if((index < 0) || (index >= m_numGovernmentOnly)) {
        return 0;
    }
    return m_GovernmentOnly[index];
}

GovernmentRecord const * UnitRecord::GetGovernmentOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentOnly);
    if((index < 0) || (index >= m_numGovernmentOnly)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentOnly[index]);
}

sint32 UnitRecord::GetSettleImprovementIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleImprovement);
    if((index < 0) || (index >= m_numSettleImprovement)) {
        return 0;
    }
    return m_SettleImprovement[index];
}

TerrainImprovementRecord const * UnitRecord::GetSettleImprovement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleImprovement);
    if((index < 0) || (index >= m_numSettleImprovement)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_SettleImprovement[index]);
}

sint32 UnitRecord::GetNeedsCityGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return m_NeedsCityGood[index];
}

ResourceRecord const * UnitRecord::GetNeedsCityGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGood);
    if((index < 0) || (index >= m_numNeedsCityGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGood[index]);
}

sint32 UnitRecord::GetNeedsCityGoodAllIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return m_NeedsCityGoodAll[index];
}

ResourceRecord const * UnitRecord::GetNeedsCityGoodAll(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAll);
    if((index < 0) || (index >= m_numNeedsCityGoodAll)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAll[index]);
}

sint32 UnitRecord::GetNeedsCityGoodCapitolIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodCapitol);
    if((index < 0) || (index >= m_numNeedsCityGoodCapitol)) {
        return 0;
    }
    return m_NeedsCityGoodCapitol[index];
}

ResourceRecord const * UnitRecord::GetNeedsCityGoodCapitol(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodCapitol);
    if((index < 0) || (index >= m_numNeedsCityGoodCapitol)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodCapitol[index]);
}

sint32 UnitRecord::GetNeedsCityGoodAnyCityIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return m_NeedsCityGoodAnyCity[index];
}

ResourceRecord const * UnitRecord::GetNeedsCityGoodAnyCity(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsCityGoodAnyCity);
    if((index < 0) || (index >= m_numNeedsCityGoodAnyCity)) {
        return 0;
    }
    return g_theResourceDB->Get(m_NeedsCityGoodAnyCity[index]);
}

sint32 UnitRecord::GetNeedsFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return m_NeedsFeatToBuild[index];
}

FeatRecord const * UnitRecord::GetNeedsFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsFeatToBuild);
    if((index < 0) || (index >= m_numNeedsFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsFeatToBuild[index]);
}

sint32 UnitRecord::GetNeedsAnyPlayerFeatToBuildIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return m_NeedsAnyPlayerFeatToBuild[index];
}

FeatRecord const * UnitRecord::GetNeedsAnyPlayerFeatToBuild(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numNeedsAnyPlayerFeatToBuild);
    if((index < 0) || (index >= m_numNeedsAnyPlayerFeatToBuild)) {
        return 0;
    }
    return g_theFeatDB->Get(m_NeedsAnyPlayerFeatToBuild[index]);
}

sint32 UnitRecord::GetPrerequisiteWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteWonder);
    if((index < 0) || (index >= m_numPrerequisiteWonder)) {
        return 0;
    }
    return m_PrerequisiteWonder[index];
}

WonderRecord const * UnitRecord::GetPrerequisiteWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteWonder);
    if((index < 0) || (index >= m_numPrerequisiteWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_PrerequisiteWonder[index]);
}

sint32 UnitRecord::GetExcludedByWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return m_ExcludedByWonder[index];
}

WonderRecord const * UnitRecord::GetExcludedByWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludedByWonder);
    if((index < 0) || (index >= m_numExcludedByWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_ExcludedByWonder[index]);
}

sint32 UnitRecord::GetAllTerrainAsImprovementIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAllTerrainAsImprovement);
    if((index < 0) || (index >= m_numAllTerrainAsImprovement)) {
        return 0;
    }
    return m_AllTerrainAsImprovement[index];
}

TerrainImprovementRecord const * UnitRecord::GetAllTerrainAsImprovement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numAllTerrainAsImprovement);
    if((index < 0) || (index >= m_numAllTerrainAsImprovement)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_AllTerrainAsImprovement[index]);
}

sint32 UnitRecord::GetObsoleteByUnitIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteByUnit);
    if((index < 0) || (index >= m_numObsoleteByUnit)) {
        return 0;
    }
    return m_ObsoleteByUnit[index];
}

UnitRecord const * UnitRecord::GetObsoleteByUnit(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteByUnit);
    if((index < 0) || (index >= m_numObsoleteByUnit)) {
        return 0;
    }
    return g_theUnitDB->Get(m_ObsoleteByUnit[index]);
}

UnitRecord const * UnitRecord::GetSettleCityType() const
{
    return g_theUnitDB->Get(m_SettleCityType);
}

sint32 UnitRecord::GetSettleBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleBuilding);
    if((index < 0) || (index >= m_numSettleBuilding)) {
        return 0;
    }
    return m_SettleBuilding[index];
}

BuildingRecord const * UnitRecord::GetSettleBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleBuilding);
    if((index < 0) || (index >= m_numSettleBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_SettleBuilding[index]);
}

sint32 UnitRecord::GetEstablishBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEstablishBuilding);
    if((index < 0) || (index >= m_numEstablishBuilding)) {
        return 0;
    }
    return m_EstablishBuilding[index];
}

BuildingRecord const * UnitRecord::GetEstablishBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEstablishBuilding);
    if((index < 0) || (index >= m_numEstablishBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_EstablishBuilding[index]);
}

sint32 UnitRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

GovernmentRecord const * UnitRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

SpriteRecord const * UnitRecord::GetDefaultSprite() const
{
    return g_theSpriteDB->Get(m_DefaultSprite);
}

SoundRecord const * UnitRecord::GetSoundSelect1() const
{
    return g_theSoundDB->Get(m_SoundSelect1);
}

SoundRecord const * UnitRecord::GetSoundSelect2() const
{
    return g_theSoundDB->Get(m_SoundSelect2);
}

SoundRecord const * UnitRecord::GetSoundMove() const
{
    return g_theSoundDB->Get(m_SoundMove);
}

SoundRecord const * UnitRecord::GetSoundAcknowledge() const
{
    return g_theSoundDB->Get(m_SoundAcknowledge);
}

SoundRecord const * UnitRecord::GetSoundCantMove() const
{
    return g_theSoundDB->Get(m_SoundCantMove);
}

SoundRecord const * UnitRecord::GetSoundAttack() const
{
    return g_theSoundDB->Get(m_SoundAttack);
}

SoundRecord const * UnitRecord::GetSoundWork() const
{
    return g_theSoundDB->Get(m_SoundWork);
}

SoundRecord const * UnitRecord::GetSoundVictory() const
{
    return g_theSoundDB->Get(m_SoundVictory);
}

SoundRecord const * UnitRecord::GetSoundDeath() const
{
    return g_theSoundDB->Get(m_SoundDeath);
}

SoundRecord const * UnitRecord::GetSoundLoad() const
{
    return g_theSoundDB->Get(m_SoundLoad);
}

SoundRecord const * UnitRecord::GetSoundUnload() const
{
    return g_theSoundDB->Get(m_SoundUnload);
}

sint32 UnitRecord::GetSpecialAttacksIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSpecialAttacks);
    if((index < 0) || (index >= m_numSpecialAttacks)) {
        return 0;
    }
    return m_SpecialAttacks[index];
}

SpecialAttackInfoRecord const * UnitRecord::GetSpecialAttacks(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSpecialAttacks);
    if((index < 0) || (index >= m_numSpecialAttacks)) {
        return 0;
    }
    return g_theSpecialAttackInfoDB->Get(m_SpecialAttacks[index]);
}

IconRecord const * UnitRecord::GetDefaultIcon() const
{
    return g_theIconDB->Get(m_DefaultIcon);
}

MapIconRecord const * UnitRecord::GetHasReligionIconPtr() const
{
    return g_theMapIconDB->Get(m_HasReligionIconValue);
}

const SoundRecord *UnitRecord::SuccessDeathEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::SuccessDeathEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::StealTechnologyData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::StealTechnologyData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::InciteRevolutionData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::InciteRevolutionData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::ChanceEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::ChanceEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::CauseUnhappinessData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::CauseUnhappinessData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::SlaveRaidsData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::SlaveRaidsData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::SoundAndEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::SoundAndEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::PlantNukeData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::PlantNukeData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::CargoData::GetLoad() const
{
    return g_theSoundDB->Get(m_Load);
}

const SoundRecord *UnitRecord::CargoData::GetUnload() const
{
    return g_theSoundDB->Get(m_Unload);
}

const SoundRecord *UnitRecord::RevolutionData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::RevolutionData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

