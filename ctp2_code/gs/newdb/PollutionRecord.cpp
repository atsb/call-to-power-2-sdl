
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "PollutionRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"


CTPDatabase<PollutionRecord> *g_thePollutionDB = NULL;

void PollutionRecord::Init()
{
    m_Phase = NULL;
    m_numPhase = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void PollutionRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }

        {
            archive << m_numPhase;
            for(sint32 i = 0; i < m_numPhase; ++i){
                m_Phase[i].Serialize(archive);
            }
        }

    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }

        {
            archive >> m_numPhase;
            m_Phase = new Phase[m_numPhase];
            for(sint32 i = 0; i < m_numPhase; ++i){
                m_Phase[i].Serialize(archive);
            }
        }

    }
}

PollutionRecord::~PollutionRecord()
{
    delete [] m_Phase;
}

PollutionRecord const & PollutionRecord::operator = (PollutionRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        delete [] m_Phase;
        m_Phase = NULL;
        if (rval.m_numPhase > 0)
        {
            m_Phase = new Phase [rval.m_numPhase];
            std::copy(rval.m_Phase, rval.m_Phase + rval.m_numPhase, m_Phase);
        }
        m_numPhase = rval.m_numPhase;

    }

    return *this;
}

const char *g_Pollution_Tokens[] =
{
    "Phase",
};

PollutionRecordAccessorInfo g_PollutionRecord_Accessors[] =
{
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Phase */
};

#define k_Token_Pollution_Phase                  ((k_Token_Custom_Base) + 0)
#define k_Token_Pollution_Max                    ((k_Token_Custom_Base) + 1)


static BitArray s_ParsedTokens(1);
void PollutionRecord::CheckRequiredFields(DBLexer *lex)
{
}

sint32 PollutionRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Pollution_Tokens, k_Token_Pollution_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "POLLUTION_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Pollution_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Pollution_Phase:
                if(!PollutionRecord::Phase::ParseInArray(lex, &m_Phase, &m_numPhase))
                {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!PollutionRecord::Phase::ParseInArray(lex, &m_Phase, &m_numPhase)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void PollutionRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numPhase; i++) {
            m_Phase[i].ResolveDBReferences();
        }
    }
}

PollutionRecord::Phase::Phase()
{
    m_flags0 = 0;
    m_PollutionTrigger = 0;
}

PollutionRecord::Phase::~Phase()
{
}

PollutionRecord::Phase const & PollutionRecord::Phase::operator = (Phase const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;

        m_PollutionTrigger = rval.m_PollutionTrigger;

    }

    return *this;
}

void PollutionRecord::Phase::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_PollutionTrigger;
    } else {
        archive >> m_flags0;
        archive >> m_PollutionTrigger;
    }
}

static const char *s_Pollution_Phase_Tokens[] = {
    "PollutionTrigger",
    "OzoneDisaster",
    "FloodDisaster",
    "Warning",
    "POLLUTION_TRIGGER",
    "POLLUTION_OZONE_DISASTER",
    "POLLUTION_FLOOD_DISASTER",
    "POLLUTION_WARNING",
};
#define k_Token_Pollution_Phase_PollutionTrigger ((k_Token_Custom_Base) + 0)
#define k_Token_Pollution_Phase_OzoneDisaster    ((k_Token_Custom_Base) + 1)
#define k_Token_Pollution_Phase_FloodDisaster    ((k_Token_Custom_Base) + 2)
#define k_Token_Pollution_Phase_Warning          ((k_Token_Custom_Base) + 3)
#define k_Token_Pollution_Phase_POLLUTION_TRIGGER ((k_Token_Custom_Base) + 4)
#define k_Token_Pollution_Phase_POLLUTION_OZONE_DISASTER ((k_Token_Custom_Base) + 5)
#define k_Token_Pollution_Phase_POLLUTION_FLOOD_DISASTER ((k_Token_Custom_Base) + 6)
#define k_Token_Pollution_Phase_POLLUTION_WARNING ((k_Token_Custom_Base) + 7)
#define k_Token_Pollution_Phase_Max ((k_Token_Custom_Base) + 8)
sint32 PollutionRecord::Phase::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseNum(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for Phase"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Pollution_Phase_Tokens, k_Token_Pollution_Phase_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Pollution_Phase_PollutionTrigger:
            case k_Token_Pollution_Phase_POLLUTION_TRIGGER:
                if(!lex->GetIntAssignment(m_PollutionTrigger)) {
                    done = true; break;
                }
                break;
            case k_Token_Pollution_Phase_OzoneDisaster:
            case k_Token_Pollution_Phase_POLLUTION_OZONE_DISASTER:
                m_flags0 |= k_Phase_OzoneDisaster_Bit;
                break;
            case k_Token_Pollution_Phase_FloodDisaster:
            case k_Token_Pollution_Phase_POLLUTION_FLOOD_DISASTER:
                m_flags0 |= k_Phase_FloodDisaster_Bit;
                break;
            case k_Token_Pollution_Phase_Warning:
            case k_Token_Pollution_Phase_POLLUTION_WARNING:
                m_flags0 |= k_Phase_Warning_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetInt(m_PollutionTrigger)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 PollutionRecord::Phase::ParseInArray(DBLexer *lex, Phase **array, sint32 *numElements)
{
    if(*numElements > 0) {
        Phase *oldArray = *array;
        *array = new Phase[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new Phase[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 PollutionRecord::Phase::ParseInArray(DBLexer *lex, Phase *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 PollutionRecord::Phase::ParseNum(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    lex->SetTokens(s_Pollution_Phase_Tokens, k_Token_Pollution_Phase_Max);
    for(sint32 i = 0; i < 2; ++i) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Pollution_Phase_PollutionTrigger:
            case k_Token_Pollution_Phase_POLLUTION_TRIGGER:
                if(!lex->GetIntAssignment(m_PollutionTrigger)) {
                    done = true; break;
                }
                break;
            case k_Token_Pollution_Phase_OzoneDisaster:
            case k_Token_Pollution_Phase_POLLUTION_OZONE_DISASTER:
                m_flags0 |= k_Phase_OzoneDisaster_Bit;
                break;
            case k_Token_Pollution_Phase_FloodDisaster:
            case k_Token_Pollution_Phase_POLLUTION_FLOOD_DISASTER:
                m_flags0 |= k_Phase_FloodDisaster_Bit;
                break;
            case k_Token_Pollution_Phase_Warning:
            case k_Token_Pollution_Phase_POLLUTION_WARNING:
                m_flags0 |= k_Phase_Warning_Bit;
                break;
            default:
                if(!lex->GetInt(m_PollutionTrigger)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();

    if(done)
        return 0;

    return 1;
}

void PollutionRecord::Phase::ResolveDBReferences()
{
}

void PollutionRecord::Merge(const PollutionRecord & rval){
    // replace struct elements of m_Phase
    for (sint32 index_Phase = 0; index_Phase < m_numPhase; ++index_Phase)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numPhase; ++obj_index)
            if (m_Phase[index_Phase] == rval.m_Phase[obj_index]){
                m_Phase[index_Phase] = rval.m_Phase[obj_index];
            }
    }
}

PollutionRecord::Phase const * PollutionRecord::GetPhase(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPhase);
    if((index < 0) || (index >= m_numPhase)) {
        return 0;
    }
    return &m_Phase[index];
}

