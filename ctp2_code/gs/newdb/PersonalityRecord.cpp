
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "PersonalityRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "StrategyRecord.h"
#include "StrategyRecord.h"

CTPDatabase<PersonalityRecord> *g_thePersonalityDB = NULL;

void PersonalityRecord::Init()
{
    m_flags0 = 0;
    m_DefaultStrategy = 0x7fffffff;
    m_MaxIslandSize = 100;
    memset(&m_IslandNationStrategyValue, 0, sizeof(m_IslandNationStrategyValue));
    memset(&m_StartStrategyValue, 0, sizeof(m_StartStrategyValue));
    memset(&m_StartLowDefenceStrategyValue, 0, sizeof(m_StartLowDefenceStrategyValue));
    memset(&m_StartHighDefenceStrategyValue, 0, sizeof(m_StartHighDefenceStrategyValue));
    m_LastStartTurn = 75;
    memset(&m_DefenceNoneStrategyValue, 0, sizeof(m_DefenceNoneStrategyValue));
    memset(&m_DefenceVeryLowStrategyValue, 0, sizeof(m_DefenceVeryLowStrategyValue));
    memset(&m_DefenceLowStrategyValue, 0, sizeof(m_DefenceLowStrategyValue));
    memset(&m_DefenceMediumStrategyValue, 0, sizeof(m_DefenceMediumStrategyValue));
    memset(&m_DefenceHighStrategyValue, 0, sizeof(m_DefenceHighStrategyValue));
    memset(&m_DefenceVeryHighStrategyValue, 0, sizeof(m_DefenceVeryHighStrategyValue));
    memset(&m_ExplorationStrategyValue, 0, sizeof(m_ExplorationStrategyValue));
    memset(&m_ExpansionStrategyValue, 0, sizeof(m_ExpansionStrategyValue));
    memset(&m_DiscoveryStrategyValue, 0, sizeof(m_DiscoveryStrategyValue));
    memset(&m_FullAttackStrategyValue, 0, sizeof(m_FullAttackStrategyValue));
    memset(&m_BuildupStrengthStrategyValue, 0, sizeof(m_BuildupStrengthStrategyValue));
    memset(&m_SeigeCitiesStrategyValue, 0, sizeof(m_SeigeCitiesStrategyValue));
    memset(&m_NuclearStrikeStrategyValue, 0, sizeof(m_NuclearStrikeStrategyValue));
    memset(&m_MinimumNukesStrategyValue, 0, sizeof(m_MinimumNukesStrategyValue));
    memset(&m_LowNukesStrategyValue, 0, sizeof(m_LowNukesStrategyValue));
    memset(&m_AverageNukesStrategyValue, 0, sizeof(m_AverageNukesStrategyValue));
    memset(&m_MaximumNukesStrategyValue, 0, sizeof(m_MaximumNukesStrategyValue));
    m_CitiesOverLimit = 0;
    memset(&m_OverCityLimitStrategyValue, 0, sizeof(m_OverCityLimitStrategyValue));
    memset(&m_NoRevolutionStrategyValue, 0, sizeof(m_NoRevolutionStrategyValue));
    m_Exploration = 0;
    m_Conquest = 0;
    m_Expansion = 0;
    m_Discovery = 0;
    m_Trustworthiness = 0;
    m_Alignment = 0;
    m_StrongGreeting = 0;
    m_WeakGreeting = 0;
    m_ThreatFollowThrough = 0.000000;
    m_Description = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void PersonalityRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_DefaultStrategy;
        archive << m_MaxIslandSize;
        m_IslandNationStrategyValue.Serialize(archive);
        m_StartStrategyValue.Serialize(archive);
        m_StartLowDefenceStrategyValue.Serialize(archive);
        m_StartHighDefenceStrategyValue.Serialize(archive);
        archive << m_LastStartTurn;
        m_DefenceNoneStrategyValue.Serialize(archive);
        m_DefenceVeryLowStrategyValue.Serialize(archive);
        m_DefenceLowStrategyValue.Serialize(archive);
        m_DefenceMediumStrategyValue.Serialize(archive);
        m_DefenceHighStrategyValue.Serialize(archive);
        m_DefenceVeryHighStrategyValue.Serialize(archive);
        m_ExplorationStrategyValue.Serialize(archive);
        m_ExpansionStrategyValue.Serialize(archive);
        m_DiscoveryStrategyValue.Serialize(archive);
        m_FullAttackStrategyValue.Serialize(archive);
        m_BuildupStrengthStrategyValue.Serialize(archive);
        m_SeigeCitiesStrategyValue.Serialize(archive);
        m_NuclearStrikeStrategyValue.Serialize(archive);
        m_MinimumNukesStrategyValue.Serialize(archive);
        m_LowNukesStrategyValue.Serialize(archive);
        m_AverageNukesStrategyValue.Serialize(archive);
        m_MaximumNukesStrategyValue.Serialize(archive);
        archive << m_CitiesOverLimit;
        m_OverCityLimitStrategyValue.Serialize(archive);
        m_NoRevolutionStrategyValue.Serialize(archive);
        archive << m_Exploration;
        archive << m_Conquest;
        archive << m_Expansion;
        archive << m_Discovery;
        archive << m_Trustworthiness;
        archive << m_Alignment;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_StrongGreeting);
            archive << tmpString;
        }

        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_WeakGreeting);
            archive << tmpString;
        }

        archive << m_ThreatFollowThrough;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Description);
            archive << tmpString;
        }

    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_DefaultStrategy;
        archive >> m_MaxIslandSize;
        memset((uint8*)&m_IslandNationStrategyValue, 0, sizeof(m_IslandNationStrategyValue));
        m_IslandNationStrategyValue.Serialize(archive);
        memset((uint8*)&m_StartStrategyValue, 0, sizeof(m_StartStrategyValue));
        m_StartStrategyValue.Serialize(archive);
        memset((uint8*)&m_StartLowDefenceStrategyValue, 0, sizeof(m_StartLowDefenceStrategyValue));
        m_StartLowDefenceStrategyValue.Serialize(archive);
        memset((uint8*)&m_StartHighDefenceStrategyValue, 0, sizeof(m_StartHighDefenceStrategyValue));
        m_StartHighDefenceStrategyValue.Serialize(archive);
        archive >> m_LastStartTurn;
        memset((uint8*)&m_DefenceNoneStrategyValue, 0, sizeof(m_DefenceNoneStrategyValue));
        m_DefenceNoneStrategyValue.Serialize(archive);
        memset((uint8*)&m_DefenceVeryLowStrategyValue, 0, sizeof(m_DefenceVeryLowStrategyValue));
        m_DefenceVeryLowStrategyValue.Serialize(archive);
        memset((uint8*)&m_DefenceLowStrategyValue, 0, sizeof(m_DefenceLowStrategyValue));
        m_DefenceLowStrategyValue.Serialize(archive);
        memset((uint8*)&m_DefenceMediumStrategyValue, 0, sizeof(m_DefenceMediumStrategyValue));
        m_DefenceMediumStrategyValue.Serialize(archive);
        memset((uint8*)&m_DefenceHighStrategyValue, 0, sizeof(m_DefenceHighStrategyValue));
        m_DefenceHighStrategyValue.Serialize(archive);
        memset((uint8*)&m_DefenceVeryHighStrategyValue, 0, sizeof(m_DefenceVeryHighStrategyValue));
        m_DefenceVeryHighStrategyValue.Serialize(archive);
        memset((uint8*)&m_ExplorationStrategyValue, 0, sizeof(m_ExplorationStrategyValue));
        m_ExplorationStrategyValue.Serialize(archive);
        memset((uint8*)&m_ExpansionStrategyValue, 0, sizeof(m_ExpansionStrategyValue));
        m_ExpansionStrategyValue.Serialize(archive);
        memset((uint8*)&m_DiscoveryStrategyValue, 0, sizeof(m_DiscoveryStrategyValue));
        m_DiscoveryStrategyValue.Serialize(archive);
        memset((uint8*)&m_FullAttackStrategyValue, 0, sizeof(m_FullAttackStrategyValue));
        m_FullAttackStrategyValue.Serialize(archive);
        memset((uint8*)&m_BuildupStrengthStrategyValue, 0, sizeof(m_BuildupStrengthStrategyValue));
        m_BuildupStrengthStrategyValue.Serialize(archive);
        memset((uint8*)&m_SeigeCitiesStrategyValue, 0, sizeof(m_SeigeCitiesStrategyValue));
        m_SeigeCitiesStrategyValue.Serialize(archive);
        memset((uint8*)&m_NuclearStrikeStrategyValue, 0, sizeof(m_NuclearStrikeStrategyValue));
        m_NuclearStrikeStrategyValue.Serialize(archive);
        memset((uint8*)&m_MinimumNukesStrategyValue, 0, sizeof(m_MinimumNukesStrategyValue));
        m_MinimumNukesStrategyValue.Serialize(archive);
        memset((uint8*)&m_LowNukesStrategyValue, 0, sizeof(m_LowNukesStrategyValue));
        m_LowNukesStrategyValue.Serialize(archive);
        memset((uint8*)&m_AverageNukesStrategyValue, 0, sizeof(m_AverageNukesStrategyValue));
        m_AverageNukesStrategyValue.Serialize(archive);
        memset((uint8*)&m_MaximumNukesStrategyValue, 0, sizeof(m_MaximumNukesStrategyValue));
        m_MaximumNukesStrategyValue.Serialize(archive);
        archive >> m_CitiesOverLimit;
        memset((uint8*)&m_OverCityLimitStrategyValue, 0, sizeof(m_OverCityLimitStrategyValue));
        m_OverCityLimitStrategyValue.Serialize(archive);
        memset((uint8*)&m_NoRevolutionStrategyValue, 0, sizeof(m_NoRevolutionStrategyValue));
        m_NoRevolutionStrategyValue.Serialize(archive);
        archive >> m_Exploration;
        archive >> m_Conquest;
        archive >> m_Expansion;
        archive >> m_Discovery;
        archive >> m_Trustworthiness;
        archive >> m_Alignment;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_StrongGreeting);
            delete[] tmpString;
        }

        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_WeakGreeting);
            delete[] tmpString;
        }

        archive >> m_ThreatFollowThrough;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Description);
            delete[] tmpString;
        }

    }
}

PersonalityRecord::~PersonalityRecord()
{
}

PersonalityRecord const & PersonalityRecord::operator = (PersonalityRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_DefaultStrategy = rval.m_DefaultStrategy;

        m_MaxIslandSize = rval.m_MaxIslandSize;

        m_IslandNationStrategyValue = rval.m_IslandNationStrategyValue;

        m_StartStrategyValue = rval.m_StartStrategyValue;

        m_StartLowDefenceStrategyValue = rval.m_StartLowDefenceStrategyValue;

        m_StartHighDefenceStrategyValue = rval.m_StartHighDefenceStrategyValue;

        m_LastStartTurn = rval.m_LastStartTurn;

        m_DefenceNoneStrategyValue = rval.m_DefenceNoneStrategyValue;

        m_DefenceVeryLowStrategyValue = rval.m_DefenceVeryLowStrategyValue;

        m_DefenceLowStrategyValue = rval.m_DefenceLowStrategyValue;

        m_DefenceMediumStrategyValue = rval.m_DefenceMediumStrategyValue;

        m_DefenceHighStrategyValue = rval.m_DefenceHighStrategyValue;

        m_DefenceVeryHighStrategyValue = rval.m_DefenceVeryHighStrategyValue;

        m_ExplorationStrategyValue = rval.m_ExplorationStrategyValue;

        m_ExpansionStrategyValue = rval.m_ExpansionStrategyValue;

        m_DiscoveryStrategyValue = rval.m_DiscoveryStrategyValue;

        m_FullAttackStrategyValue = rval.m_FullAttackStrategyValue;

        m_BuildupStrengthStrategyValue = rval.m_BuildupStrengthStrategyValue;

        m_SeigeCitiesStrategyValue = rval.m_SeigeCitiesStrategyValue;

        m_NuclearStrikeStrategyValue = rval.m_NuclearStrikeStrategyValue;

        m_MinimumNukesStrategyValue = rval.m_MinimumNukesStrategyValue;

        m_LowNukesStrategyValue = rval.m_LowNukesStrategyValue;

        m_AverageNukesStrategyValue = rval.m_AverageNukesStrategyValue;

        m_MaximumNukesStrategyValue = rval.m_MaximumNukesStrategyValue;

        m_CitiesOverLimit = rval.m_CitiesOverLimit;

        m_OverCityLimitStrategyValue = rval.m_OverCityLimitStrategyValue;

        m_NoRevolutionStrategyValue = rval.m_NoRevolutionStrategyValue;

        m_Exploration = rval.m_Exploration;

        m_Conquest = rval.m_Conquest;

        m_Expansion = rval.m_Expansion;

        m_Discovery = rval.m_Discovery;

        m_Trustworthiness = rval.m_Trustworthiness;

        m_Alignment = rval.m_Alignment;

        m_StrongGreeting = rval.m_StrongGreeting;

        m_WeakGreeting = rval.m_WeakGreeting;

        m_ThreatFollowThrough = rval.m_ThreatFollowThrough;

        m_Description = rval.m_Description;

    }

    return *this;
}

const char *g_Personality_Tokens[] =
{
    "DefaultStrategy",
    "MaxIslandSize",
    "IslandNationStrategy",
    "IslandNationStrategyValue",
    "StartStrategy",
    "StartStrategyValue",
    "StartLowDefenceStrategy",
    "StartLowDefenceStrategyValue",
    "StartHighDefenceStrategy",
    "StartHighDefenceStrategyValue",
    "LastStartTurn",
    "DefenceNoneStrategy",
    "DefenceNoneStrategyValue",
    "DefenceVeryLowStrategy",
    "DefenceVeryLowStrategyValue",
    "DefenceLowStrategy",
    "DefenceLowStrategyValue",
    "DefenceMediumStrategy",
    "DefenceMediumStrategyValue",
    "DefenceHighStrategy",
    "DefenceHighStrategyValue",
    "DefenceVeryHighStrategy",
    "DefenceVeryHighStrategyValue",
    "ExplorationStrategy",
    "ExplorationStrategyValue",
    "ExpansionStrategy",
    "ExpansionStrategyValue",
    "DiscoveryStrategy",
    "DiscoveryStrategyValue",
    "FullAttackStrategy",
    "FullAttackStrategyValue",
    "BuildupStrengthStrategy",
    "BuildupStrengthStrategyValue",
    "SeigeCitiesStrategy",
    "SeigeCitiesStrategyValue",
    "NuclearStrikeStrategy",
    "NuclearStrikeStrategyValue",
    "MinimumNukesStrategy",
    "MinimumNukesStrategyValue",
    "LowNukesStrategy",
    "LowNukesStrategyValue",
    "AverageNukesStrategy",
    "AverageNukesStrategyValue",
    "MaximumNukesStrategy",
    "MaximumNukesStrategyValue",
    "ReduceSettlers",
    "CitiesOverLimit",
    "OverCityLimitStrategy",
    "OverCityLimitStrategyValue",
    "NoRevolutionStrategy",
    "NoRevolutionStrategyValue",
    "Exploration",
    "Conquest",
    "Expansion",
    "Discovery",
    "Trustworthiness",
    "Alignment",
    "StrongGreeting",
    "WeakGreeting",
    "ThreatFollowThrough",
    "Description",
};

PersonalityRecordAccessorInfo g_PersonalityRecord_Accessors[] =
{
    { &PersonalityRecord::GetDefaultStrategyIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &PersonalityRecord::GetMaxIslandSize, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IslandNationStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IslandNationStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StartStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StartStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StartLowDefenceStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StartLowDefenceStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StartHighDefenceStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StartHighDefenceStrategy */
    { &PersonalityRecord::GetLastStartTurn, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceNoneStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceNoneStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceVeryLowStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceVeryLowStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceLowStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceLowStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceMediumStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceMediumStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceHighStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceHighStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceVeryHighStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DefenceVeryHighStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ExplorationStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ExplorationStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ExpansionStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* ExpansionStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DiscoveryStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* DiscoveryStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FullAttackStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* FullAttackStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildupStrengthStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* BuildupStrengthStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeigeCitiesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SeigeCitiesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearStrikeStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NuclearStrikeStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MinimumNukesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MinimumNukesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LowNukesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* LowNukesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AverageNukesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* AverageNukesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaximumNukesStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MaximumNukesStrategy */
    { NULL, &PersonalityRecord::GetReduceSettlers, NULL, NULL, NULL, NULL, NULL },
    { &PersonalityRecord::GetCitiesOverLimit, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OverCityLimitStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* OverCityLimitStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NoRevolutionStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* NoRevolutionStrategy */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Exploration */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Conquest */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Expansion */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Discovery */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Trustworthiness */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Alignment */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* StrongGreeting */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* WeakGreeting */
    { NULL, NULL, &PersonalityRecord::GetThreatFollowThrough, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Description */
};

#define k_Token_Personality_DefaultStrategy      ((k_Token_Custom_Base) + 0)
#define k_Token_Personality_MaxIslandSize        ((k_Token_Custom_Base) + 1)
#define k_Token_Personality_IslandNationStrategy ((k_Token_Custom_Base) + 2)
#define k_Token_Personality_IslandNationStrategy_Value ((k_Token_Custom_Base) + 3)
#define k_Token_Personality_StartStrategy        ((k_Token_Custom_Base) + 4)
#define k_Token_Personality_StartStrategy_Value  ((k_Token_Custom_Base) + 5)
#define k_Token_Personality_StartLowDefenceStrategy ((k_Token_Custom_Base) + 6)
#define k_Token_Personality_StartLowDefenceStrategy_Value ((k_Token_Custom_Base) + 7)
#define k_Token_Personality_StartHighDefenceStrategy ((k_Token_Custom_Base) + 8)
#define k_Token_Personality_StartHighDefenceStrategy_Value ((k_Token_Custom_Base) + 9)
#define k_Token_Personality_LastStartTurn        ((k_Token_Custom_Base) + 10)
#define k_Token_Personality_DefenceNoneStrategy  ((k_Token_Custom_Base) + 11)
#define k_Token_Personality_DefenceNoneStrategy_Value ((k_Token_Custom_Base) + 12)
#define k_Token_Personality_DefenceVeryLowStrategy ((k_Token_Custom_Base) + 13)
#define k_Token_Personality_DefenceVeryLowStrategy_Value ((k_Token_Custom_Base) + 14)
#define k_Token_Personality_DefenceLowStrategy   ((k_Token_Custom_Base) + 15)
#define k_Token_Personality_DefenceLowStrategy_Value ((k_Token_Custom_Base) + 16)
#define k_Token_Personality_DefenceMediumStrategy ((k_Token_Custom_Base) + 17)
#define k_Token_Personality_DefenceMediumStrategy_Value ((k_Token_Custom_Base) + 18)
#define k_Token_Personality_DefenceHighStrategy  ((k_Token_Custom_Base) + 19)
#define k_Token_Personality_DefenceHighStrategy_Value ((k_Token_Custom_Base) + 20)
#define k_Token_Personality_DefenceVeryHighStrategy ((k_Token_Custom_Base) + 21)
#define k_Token_Personality_DefenceVeryHighStrategy_Value ((k_Token_Custom_Base) + 22)
#define k_Token_Personality_ExplorationStrategy  ((k_Token_Custom_Base) + 23)
#define k_Token_Personality_ExplorationStrategy_Value ((k_Token_Custom_Base) + 24)
#define k_Token_Personality_ExpansionStrategy    ((k_Token_Custom_Base) + 25)
#define k_Token_Personality_ExpansionStrategy_Value ((k_Token_Custom_Base) + 26)
#define k_Token_Personality_DiscoveryStrategy    ((k_Token_Custom_Base) + 27)
#define k_Token_Personality_DiscoveryStrategy_Value ((k_Token_Custom_Base) + 28)
#define k_Token_Personality_FullAttackStrategy   ((k_Token_Custom_Base) + 29)
#define k_Token_Personality_FullAttackStrategy_Value ((k_Token_Custom_Base) + 30)
#define k_Token_Personality_BuildupStrengthStrategy ((k_Token_Custom_Base) + 31)
#define k_Token_Personality_BuildupStrengthStrategy_Value ((k_Token_Custom_Base) + 32)
#define k_Token_Personality_SeigeCitiesStrategy  ((k_Token_Custom_Base) + 33)
#define k_Token_Personality_SeigeCitiesStrategy_Value ((k_Token_Custom_Base) + 34)
#define k_Token_Personality_NuclearStrikeStrategy ((k_Token_Custom_Base) + 35)
#define k_Token_Personality_NuclearStrikeStrategy_Value ((k_Token_Custom_Base) + 36)
#define k_Token_Personality_MinimumNukesStrategy ((k_Token_Custom_Base) + 37)
#define k_Token_Personality_MinimumNukesStrategy_Value ((k_Token_Custom_Base) + 38)
#define k_Token_Personality_LowNukesStrategy     ((k_Token_Custom_Base) + 39)
#define k_Token_Personality_LowNukesStrategy_Value ((k_Token_Custom_Base) + 40)
#define k_Token_Personality_AverageNukesStrategy ((k_Token_Custom_Base) + 41)
#define k_Token_Personality_AverageNukesStrategy_Value ((k_Token_Custom_Base) + 42)
#define k_Token_Personality_MaximumNukesStrategy ((k_Token_Custom_Base) + 43)
#define k_Token_Personality_MaximumNukesStrategy_Value ((k_Token_Custom_Base) + 44)
#define k_Token_Personality_ReduceSettlers       ((k_Token_Custom_Base) + 45)
#define k_Token_Personality_CitiesOverLimit      ((k_Token_Custom_Base) + 46)
#define k_Token_Personality_OverCityLimitStrategy ((k_Token_Custom_Base) + 47)
#define k_Token_Personality_OverCityLimitStrategy_Value ((k_Token_Custom_Base) + 48)
#define k_Token_Personality_NoRevolutionStrategy ((k_Token_Custom_Base) + 49)
#define k_Token_Personality_NoRevolutionStrategy_Value ((k_Token_Custom_Base) + 50)
#define k_Token_Personality_Exploration          ((k_Token_Custom_Base) + 51)
#define k_Token_Personality_Conquest             ((k_Token_Custom_Base) + 52)
#define k_Token_Personality_Expansion            ((k_Token_Custom_Base) + 53)
#define k_Token_Personality_Discovery            ((k_Token_Custom_Base) + 54)
#define k_Token_Personality_Trustworthiness      ((k_Token_Custom_Base) + 55)
#define k_Token_Personality_Alignment            ((k_Token_Custom_Base) + 56)
#define k_Token_Personality_StrongGreeting       ((k_Token_Custom_Base) + 57)
#define k_Token_Personality_WeakGreeting         ((k_Token_Custom_Base) + 58)
#define k_Token_Personality_ThreatFollowThrough  ((k_Token_Custom_Base) + 59)
#define k_Token_Personality_Description          ((k_Token_Custom_Base) + 60)
#define k_Token_Personality_Max                  ((k_Token_Custom_Base) + 61)


static BitArray s_ParsedTokens(61);
void PersonalityRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Personality_StrongGreeting - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field StrongGreeting missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Personality_WeakGreeting - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field WeakGreeting missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Personality_ThreatFollowThrough - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ThreatFollowThrough missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Personality_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
}

sint32 PersonalityRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Personality_Tokens, k_Token_Personality_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "PERSONALITY_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Personality_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Personality_DefaultStrategy:
                if (!g_theStrategyDB->GetRecordFromLexer(lex, m_DefaultStrategy)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_MaxIslandSize:
                if(!lex->GetIntAssignment(m_MaxIslandSize)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_IslandNationStrategy:
                m_flags0 |= k_Personality_IslandNationStrategy_Bit;
                if(!m_IslandNationStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_StartStrategy:
                m_flags0 |= k_Personality_StartStrategy_Bit;
                if(!m_StartStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_StartLowDefenceStrategy:
                m_flags0 |= k_Personality_StartLowDefenceStrategy_Bit;
                if(!m_StartLowDefenceStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_StartHighDefenceStrategy:
                m_flags0 |= k_Personality_StartHighDefenceStrategy_Bit;
                if(!m_StartHighDefenceStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_LastStartTurn:
                if(!lex->GetIntAssignment(m_LastStartTurn)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_DefenceNoneStrategy:
                m_flags0 |= k_Personality_DefenceNoneStrategy_Bit;
                if(!m_DefenceNoneStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_DefenceVeryLowStrategy:
                m_flags0 |= k_Personality_DefenceVeryLowStrategy_Bit;
                if(!m_DefenceVeryLowStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_DefenceLowStrategy:
                m_flags0 |= k_Personality_DefenceLowStrategy_Bit;
                if(!m_DefenceLowStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_DefenceMediumStrategy:
                m_flags0 |= k_Personality_DefenceMediumStrategy_Bit;
                if(!m_DefenceMediumStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_DefenceHighStrategy:
                m_flags0 |= k_Personality_DefenceHighStrategy_Bit;
                if(!m_DefenceHighStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_DefenceVeryHighStrategy:
                m_flags0 |= k_Personality_DefenceVeryHighStrategy_Bit;
                if(!m_DefenceVeryHighStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_ExplorationStrategy:
                m_flags0 |= k_Personality_ExplorationStrategy_Bit;
                if(!m_ExplorationStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_ExpansionStrategy:
                m_flags0 |= k_Personality_ExpansionStrategy_Bit;
                if(!m_ExpansionStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_DiscoveryStrategy:
                m_flags0 |= k_Personality_DiscoveryStrategy_Bit;
                if(!m_DiscoveryStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_FullAttackStrategy:
                m_flags0 |= k_Personality_FullAttackStrategy_Bit;
                if(!m_FullAttackStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_BuildupStrengthStrategy:
                m_flags0 |= k_Personality_BuildupStrengthStrategy_Bit;
                if(!m_BuildupStrengthStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_SeigeCitiesStrategy:
                m_flags0 |= k_Personality_SeigeCitiesStrategy_Bit;
                if(!m_SeigeCitiesStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_NuclearStrikeStrategy:
                m_flags0 |= k_Personality_NuclearStrikeStrategy_Bit;
                if(!m_NuclearStrikeStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_MinimumNukesStrategy:
                m_flags0 |= k_Personality_MinimumNukesStrategy_Bit;
                if(!m_MinimumNukesStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_LowNukesStrategy:
                m_flags0 |= k_Personality_LowNukesStrategy_Bit;
                if(!m_LowNukesStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_AverageNukesStrategy:
                m_flags0 |= k_Personality_AverageNukesStrategy_Bit;
                if(!m_AverageNukesStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_MaximumNukesStrategy:
                m_flags0 |= k_Personality_MaximumNukesStrategy_Bit;
                if(!m_MaximumNukesStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_ReduceSettlers:
                m_flags0 |= k_Personality_ReduceSettlers_Bit;
                break;
            case k_Token_Personality_CitiesOverLimit:
                if(!lex->GetIntAssignment(m_CitiesOverLimit)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_OverCityLimitStrategy:
                m_flags0 |= k_Personality_OverCityLimitStrategy_Bit;
                if(!m_OverCityLimitStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_NoRevolutionStrategy:
                m_flags0 |= k_Personality_NoRevolutionStrategy_Bit;
                if(!m_NoRevolutionStrategyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_Exploration:
                if(!ParseExplorationBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Conquest:
                if(!ParseConquestBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Expansion:
                if(!ParseExpansionBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Discovery:
                if(!ParseDiscoveryBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Trustworthiness:
                if(!ParseTrustworthinessBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Alignment:
                if(!ParseAlignmentBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_StrongGreeting:
                if(!lex->GetStringIdAssignment(m_StrongGreeting)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_WeakGreeting:
                if(!lex->GetStringIdAssignment(m_WeakGreeting)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_ThreatFollowThrough:
                if(!lex->GetFloatAssignment(m_ThreatFollowThrough)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theStrategyDB->GetCurrentRecordFromLexer(lex, m_DefaultStrategy)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void PersonalityRecord::ResolveDBReferences()
{
    if(m_DefaultStrategy & 0x80000000) {
        sint32 id = m_DefaultStrategy & 0x7fffffff;
        if(!g_theStrategyDB->GetNamedItem(id, m_DefaultStrategy)) {
            c3errors_ErrorDialog("DB", "%s not found in Strategy database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultStrategy == 0x7fffffff) {
        m_DefaultStrategy = -1;
    }
    m_IslandNationStrategyValue.ResolveDBReferences();
    m_StartStrategyValue.ResolveDBReferences();
    m_StartLowDefenceStrategyValue.ResolveDBReferences();
    m_StartHighDefenceStrategyValue.ResolveDBReferences();
    m_DefenceNoneStrategyValue.ResolveDBReferences();
    m_DefenceVeryLowStrategyValue.ResolveDBReferences();
    m_DefenceLowStrategyValue.ResolveDBReferences();
    m_DefenceMediumStrategyValue.ResolveDBReferences();
    m_DefenceHighStrategyValue.ResolveDBReferences();
    m_DefenceVeryHighStrategyValue.ResolveDBReferences();
    m_ExplorationStrategyValue.ResolveDBReferences();
    m_ExpansionStrategyValue.ResolveDBReferences();
    m_DiscoveryStrategyValue.ResolveDBReferences();
    m_FullAttackStrategyValue.ResolveDBReferences();
    m_BuildupStrengthStrategyValue.ResolveDBReferences();
    m_SeigeCitiesStrategyValue.ResolveDBReferences();
    m_NuclearStrikeStrategyValue.ResolveDBReferences();
    m_MinimumNukesStrategyValue.ResolveDBReferences();
    m_LowNukesStrategyValue.ResolveDBReferences();
    m_AverageNukesStrategyValue.ResolveDBReferences();
    m_MaximumNukesStrategyValue.ResolveDBReferences();
    m_OverCityLimitStrategyValue.ResolveDBReferences();
    m_NoRevolutionStrategyValue.ResolveDBReferences();
}

PersonalityRecord::StrategyData::StrategyData()
{
    m_Strategy = 0x7fffffff;
    m_Priority = 0;
}

PersonalityRecord::StrategyData::~StrategyData()
{
}

PersonalityRecord::StrategyData const & PersonalityRecord::StrategyData::operator = (StrategyData const & rval)
{
    if (this != &rval)
    {

        m_Strategy = rval.m_Strategy;

        m_Priority = rval.m_Priority;

    }

    return *this;
}

void PersonalityRecord::StrategyData::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_Strategy;
        archive << m_Priority;
    } else {
        archive >> m_Strategy;
        archive >> m_Priority;
    }
}

static const char *s_Personality_StrategyData_Tokens[] = {
    "Strategy",
    "Priority",
};
#define k_Token_Personality_StrategyData_Strategy ((k_Token_Custom_Base) + 0)
#define k_Token_Personality_StrategyData_Priority ((k_Token_Custom_Base) + 1)
#define k_Token_Personality_StrategyData_Max ((k_Token_Custom_Base) + 2)
sint32 PersonalityRecord::StrategyData::ParseSequential(DBLexer *lex)
{
    if(!g_theStrategyDB->GetRecordFromLexer(lex, m_Strategy)) {
        DBERROR(("Expected record from Strategy DB"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Priority)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 PersonalityRecord::StrategyData::ParseFullySequential(DBLexer *lex)
{
    if(!g_theStrategyDB->GetCurrentRecordFromLexer(lex, m_Strategy)) {
        DBERROR(("Expected record from Strategy DB"));
        return 0;
    }
    lex->GetToken();
    if(!lex->GetInt(m_Priority)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    return 1;
}

sint32 PersonalityRecord::StrategyData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            if(ParseSequential(lex)) {
                return 1;
            }
            DBERROR(("Expected open brace for StrategyData"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_Personality_StrategyData_Tokens, k_Token_Personality_StrategyData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Personality_StrategyData_Strategy:
                if (!g_theStrategyDB->GetRecordFromLexer(lex, m_Strategy)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_StrategyData_Priority:
                if(!lex->GetIntAssignment(m_Priority)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!g_theStrategyDB->GetCurrentRecordFromLexer(lex, m_Strategy)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 PersonalityRecord::StrategyData::ParseInArray(DBLexer *lex, StrategyData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        StrategyData *oldArray = *array;
        *array = new StrategyData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new StrategyData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 PersonalityRecord::StrategyData::ParseInArray(DBLexer *lex, StrategyData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 PersonalityRecord::StrategyData::ParseInArraySequential(DBLexer *lex, StrategyData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        StrategyData *oldArray = *array;
        *array = new StrategyData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new StrategyData[1];
    }
    (*array)[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

sint32 PersonalityRecord::StrategyData::ParseInArraySequential(DBLexer *lex, StrategyData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].ParseFullySequential(lex);
    *numElements += 1;
    return 1;
}

void PersonalityRecord::StrategyData::ResolveDBReferences()
{
    if(m_Strategy & 0x80000000) {
        sint32 id = m_Strategy & 0x7fffffff;
        if(!g_theStrategyDB->GetNamedItem(id, m_Strategy)) {
            c3errors_ErrorDialog("DB", "%s not found in Strategy database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Strategy == 0x7fffffff) {
        m_Strategy = -1;
    }
}

static const char *s_Personality_Exploration_BitNames[] = {
    "Wide",
    "Medium",
    "Minimal",
};
#define k_Personality_Exploration_Num_BitNames 3

sint32 PersonalityRecord::ParseExplorationBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Exploration_BitNames, k_Personality_Exploration_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Exploration", lex->GetTokenText()));
        return 0;
    }
    m_Exploration |= (1 << bitindex);
    return 1;
}

static const char *s_Personality_Conquest_BitNames[] = {
    "Agressive",
    "Neutral",
    "Passive",
};
#define k_Personality_Conquest_Num_BitNames 3

sint32 PersonalityRecord::ParseConquestBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Conquest_BitNames, k_Personality_Conquest_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Conquest", lex->GetTokenText()));
        return 0;
    }
    m_Conquest |= (1 << bitindex);
    return 1;
}

static const char *s_Personality_Expansion_BitNames[] = {
    "Maximum",
    "Average",
    "Minimum",
};
#define k_Personality_Expansion_Num_BitNames 3

sint32 PersonalityRecord::ParseExpansionBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Expansion_BitNames, k_Personality_Expansion_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Expansion", lex->GetTokenText()));
        return 0;
    }
    m_Expansion |= (1 << bitindex);
    return 1;
}

static const char *s_Personality_Discovery_BitNames[] = {
    "Scientist",
    "Military",
    "Economic",
    "Ecotopian",
    "Diplomatic",
};
#define k_Personality_Discovery_Num_BitNames 5

sint32 PersonalityRecord::ParseDiscoveryBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Discovery_BitNames, k_Personality_Discovery_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Discovery", lex->GetTokenText()));
        return 0;
    }
    m_Discovery |= (1 << bitindex);
    return 1;
}

static const char *s_Personality_Trustworthiness_BitNames[] = {
    "Chaotic",
    "Neutral",
    "Lawful",
};
#define k_Personality_Trustworthiness_Num_BitNames 3

sint32 PersonalityRecord::ParseTrustworthinessBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Trustworthiness_BitNames, k_Personality_Trustworthiness_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Trustworthiness", lex->GetTokenText()));
        return 0;
    }
    m_Trustworthiness |= (1 << bitindex);
    return 1;
}

static const char *s_Personality_Alignment_BitNames[] = {
    "Evil",
    "Neutral",
    "Good",
};
#define k_Personality_Alignment_Num_BitNames 3

sint32 PersonalityRecord::ParseAlignmentBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Alignment_BitNames, k_Personality_Alignment_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Alignment", lex->GetTokenText()));
        return 0;
    }
    m_Alignment |= (1 << bitindex);
    return 1;
}

void PersonalityRecord::Merge(const PersonalityRecord & rval){
    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_IslandNationStrategy_Bit)
    {
        m_IslandNationStrategyValue = rval.m_IslandNationStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_StartStrategy_Bit)
    {
        m_StartStrategyValue = rval.m_StartStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_StartLowDefenceStrategy_Bit)
    {
        m_StartLowDefenceStrategyValue = rval.m_StartLowDefenceStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_StartHighDefenceStrategy_Bit)
    {
        m_StartHighDefenceStrategyValue = rval.m_StartHighDefenceStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_DefenceNoneStrategy_Bit)
    {
        m_DefenceNoneStrategyValue = rval.m_DefenceNoneStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_DefenceVeryLowStrategy_Bit)
    {
        m_DefenceVeryLowStrategyValue = rval.m_DefenceVeryLowStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_DefenceLowStrategy_Bit)
    {
        m_DefenceLowStrategyValue = rval.m_DefenceLowStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_DefenceMediumStrategy_Bit)
    {
        m_DefenceMediumStrategyValue = rval.m_DefenceMediumStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_DefenceHighStrategy_Bit)
    {
        m_DefenceHighStrategyValue = rval.m_DefenceHighStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_DefenceVeryHighStrategy_Bit)
    {
        m_DefenceVeryHighStrategyValue = rval.m_DefenceVeryHighStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_ExplorationStrategy_Bit)
    {
        m_ExplorationStrategyValue = rval.m_ExplorationStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_ExpansionStrategy_Bit)
    {
        m_ExpansionStrategyValue = rval.m_ExpansionStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_DiscoveryStrategy_Bit)
    {
        m_DiscoveryStrategyValue = rval.m_DiscoveryStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_FullAttackStrategy_Bit)
    {
        m_FullAttackStrategyValue = rval.m_FullAttackStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_BuildupStrengthStrategy_Bit)
    {
        m_BuildupStrengthStrategyValue = rval.m_BuildupStrengthStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_SeigeCitiesStrategy_Bit)
    {
        m_SeigeCitiesStrategyValue = rval.m_SeigeCitiesStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_NuclearStrikeStrategy_Bit)
    {
        m_NuclearStrikeStrategyValue = rval.m_NuclearStrikeStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_MinimumNukesStrategy_Bit)
    {
        m_MinimumNukesStrategyValue = rval.m_MinimumNukesStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_LowNukesStrategy_Bit)
    {
        m_LowNukesStrategyValue = rval.m_LowNukesStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_AverageNukesStrategy_Bit)
    {
        m_AverageNukesStrategyValue = rval.m_AverageNukesStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_MaximumNukesStrategy_Bit)
    {
        m_MaximumNukesStrategyValue = rval.m_MaximumNukesStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_OverCityLimitStrategy_Bit)
    {
        m_OverCityLimitStrategyValue = rval.m_OverCityLimitStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_Personality_NoRevolutionStrategy_Bit)
    {
        m_NoRevolutionStrategyValue = rval.m_NoRevolutionStrategyValue;
    }

    // only replace values that have been set
    if (rval.m_Exploration)
    {
        m_Exploration = rval.m_Exploration;
    }

    // only replace values that have been set
    if (rval.m_Conquest)
    {
        m_Conquest = rval.m_Conquest;
    }

    // only replace values that have been set
    if (rval.m_Expansion)
    {
        m_Expansion = rval.m_Expansion;
    }

    // only replace values that have been set
    if (rval.m_Discovery)
    {
        m_Discovery = rval.m_Discovery;
    }

    // only replace values that have been set
    if (rval.m_Trustworthiness)
    {
        m_Trustworthiness = rval.m_Trustworthiness;
    }

    // only replace values that have been set
    if (rval.m_Alignment)
    {
        m_Alignment = rval.m_Alignment;
    }

}

StrategyRecord const * PersonalityRecord::GetDefaultStrategy() const
{
    return g_theStrategyDB->Get(m_DefaultStrategy);
}

const StrategyRecord *PersonalityRecord::StrategyData::GetStrategy() const
{
    return g_theStrategyDB->Get(m_Strategy);
}

