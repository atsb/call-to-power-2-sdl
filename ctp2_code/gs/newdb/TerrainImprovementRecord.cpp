
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "TerrainImprovementRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"

#include "SoundRecord.h"
#include "TerrainRecord.h"
#include "GovernmentRecord.h"
#include "CityStyleRecord.h"
#include "GovernmentRecord.h"
#include "ResourceRecord.h"
#include "ResourceRecord.h"
#include "IconRecord.h"
#include "TerrainRecord.h"
#include "TerrainRecord.h"
#include "TerrainImprovementRecord.h"
#include "CityStyleRecord.h"
#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "ResourceRecord.h"
#include "WonderRecord.h"

CTPDatabase<TerrainImprovementRecord> *g_theTerrainImprovementDB = NULL;

void TerrainImprovementRecord::Init()
{
    m_flags0 = 0;
    m_Class = 0;
    m_Excludes = 0;
    m_CanSee = 0;
    m_Sound = 0x7fffffff;
    m_CantBuildOn = NULL;
    m_numCantBuildOn = 0;
    m_GovernmentsModified = NULL;
    m_numGovernmentsModified = 0;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    m_IsRestrictedToGood = NULL;
    m_numIsRestrictedToGood = 0;
    m_EnablesGood = NULL;
    m_numEnablesGood = 0;
    memset(&m_EffectValue, 0, sizeof(m_EffectValue));
    m_TerrainEffect = NULL;
    m_numTerrainEffect = 0;
    m_PrerequisiteTileImp = NULL;
    m_numPrerequisiteTileImp = 0;
    m_Icon = 0x7fffffff;
    m_Tooltip = 0;
    m_Statusbar = 0;
    m_Level = 0;
    m_ConstructionTiles = NULL;
    m_numConstructionTiles = 0;
    m_TerraformTerrainValue = 0;
    m_ColumnValue = 0;
    m_IntBorderRadiusValue = 0;
    m_SquaredBorderRadiusValue = 0;
    m_MoveBonusValue = 0;
    m_DisplayLevel = 0;
    m_EnergyHunger = 0;
    m_ProducesEnergy = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = true;
}

void TerrainImprovementRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_flags0;
        archive << m_Class;
        archive << m_Excludes;
        archive << m_CanSee;
        archive << m_Sound;
        archive << m_numCantBuildOn;
        archive.Store((uint8*)m_CantBuildOn, m_numCantBuildOn * sizeof(sint32));

        archive << m_numGovernmentsModified;
        archive.Store((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_numGovernmentType;
        archive.Store((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive << m_numIsRestrictedToGood;
        archive.Store((uint8*)m_IsRestrictedToGood, m_numIsRestrictedToGood * sizeof(sint32));

        archive << m_numEnablesGood;
        archive.Store((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        m_EffectValue.Serialize(archive);

        {
            archive << m_numTerrainEffect;
            for(sint32 i = 0; i < m_numTerrainEffect; ++i){
                m_TerrainEffect[i].Serialize(archive);
            }
        }

        archive << m_numPrerequisiteTileImp;
        archive.Store((uint8*)m_PrerequisiteTileImp, m_numPrerequisiteTileImp * sizeof(sint32));

        archive << m_Icon;
        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Tooltip);
            archive << tmpString;
        }

        {
            MBCHAR* tmpString = g_theStringDB->GetIdStr(m_Statusbar);
            archive << tmpString;
        }

        archive << m_Level;
        archive << m_numConstructionTiles;
        archive.Store((uint8*)m_ConstructionTiles, m_numConstructionTiles * sizeof(sint32));

        archive << m_TerraformTerrainValue;
        archive << m_ColumnValue;
        archive << m_IntBorderRadiusValue;
        archive << m_SquaredBorderRadiusValue;
        archive << m_MoveBonusValue;
        archive << m_DisplayLevel;
        archive << m_EnergyHunger;
        archive << m_ProducesEnergy;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = true;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_flags0;
        archive >> m_Class;
        archive >> m_Excludes;
        archive >> m_CanSee;
        archive >> m_Sound;
        archive >> m_numCantBuildOn;
        archive.Load((uint8*)m_CantBuildOn, m_numCantBuildOn * sizeof(sint32));

        archive >> m_numGovernmentsModified;
        archive.Load((uint8*)m_GovernmentsModified, m_numGovernmentsModified * sizeof(sint32));

        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_numGovernmentType;
        archive.Load((uint8*)m_GovernmentType, m_numGovernmentType * sizeof(sint32));

        archive >> m_numIsRestrictedToGood;
        archive.Load((uint8*)m_IsRestrictedToGood, m_numIsRestrictedToGood * sizeof(sint32));

        archive >> m_numEnablesGood;
        archive.Load((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        memset((uint8*)&m_EffectValue, 0, sizeof(m_EffectValue));
        m_EffectValue.Serialize(archive);

        {
            archive >> m_numTerrainEffect;
            m_TerrainEffect = new Effect[m_numTerrainEffect];
            for(sint32 i = 0; i < m_numTerrainEffect; ++i){
                m_TerrainEffect[i].Serialize(archive);
            }
        }

        archive >> m_numPrerequisiteTileImp;
        archive.Load((uint8*)m_PrerequisiteTileImp, m_numPrerequisiteTileImp * sizeof(sint32));

        archive >> m_Icon;
        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Tooltip);
            delete[] tmpString;
        }

        {
            MBCHAR* tmpString = NULL;
            archive >> tmpString;
            g_theStringDB->GetStringID(tmpString, m_Statusbar);
            delete[] tmpString;
        }

        archive >> m_Level;
        archive >> m_numConstructionTiles;
        archive.Load((uint8*)m_ConstructionTiles, m_numConstructionTiles * sizeof(sint32));

        archive >> m_TerraformTerrainValue;
        archive >> m_ColumnValue;
        archive >> m_IntBorderRadiusValue;
        archive >> m_SquaredBorderRadiusValue;
        archive >> m_MoveBonusValue;
        archive >> m_DisplayLevel;
        archive >> m_EnergyHunger;
        archive >> m_ProducesEnergy;
    }
}

TerrainImprovementRecord::~TerrainImprovementRecord()
{
    delete [] m_CantBuildOn;
    delete [] m_GovernmentsModified;
    delete [] m_CultureOnly;
    delete [] m_GovernmentType;
    delete [] m_IsRestrictedToGood;
    delete [] m_EnablesGood;
    delete [] m_TerrainEffect;
    delete [] m_PrerequisiteTileImp;
    delete [] m_ConstructionTiles;
}

TerrainImprovementRecord const & TerrainImprovementRecord::operator = (TerrainImprovementRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_flags0 = rval.m_flags0;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_Class = rval.m_Class;

        m_Excludes = rval.m_Excludes;

        m_CanSee = rval.m_CanSee;

        m_Sound = rval.m_Sound;

        delete [] m_CantBuildOn;
        m_CantBuildOn = NULL;
        if (rval.m_numCantBuildOn > 0)
        {
            m_CantBuildOn = new sint32 [rval.m_numCantBuildOn];
            std::copy(rval.m_CantBuildOn, rval.m_CantBuildOn + rval.m_numCantBuildOn, m_CantBuildOn);
        }
        m_numCantBuildOn = rval.m_numCantBuildOn;

        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
        {
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
            std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);
        }
        m_numGovernmentsModified = rval.m_numGovernmentsModified;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
        {
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
            std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);
        }
        m_numGovernmentType = rval.m_numGovernmentType;

        delete [] m_IsRestrictedToGood;
        m_IsRestrictedToGood = NULL;
        if (rval.m_numIsRestrictedToGood > 0)
        {
            m_IsRestrictedToGood = new sint32 [rval.m_numIsRestrictedToGood];
            std::copy(rval.m_IsRestrictedToGood, rval.m_IsRestrictedToGood + rval.m_numIsRestrictedToGood, m_IsRestrictedToGood);
        }
        m_numIsRestrictedToGood = rval.m_numIsRestrictedToGood;

        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
        {
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
            std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);
        }
        m_numEnablesGood = rval.m_numEnablesGood;

        m_EffectValue = rval.m_EffectValue;

        delete [] m_TerrainEffect;
        m_TerrainEffect = NULL;
        if (rval.m_numTerrainEffect > 0)
        {
            m_TerrainEffect = new Effect [rval.m_numTerrainEffect];
            std::copy(rval.m_TerrainEffect, rval.m_TerrainEffect + rval.m_numTerrainEffect, m_TerrainEffect);
        }
        m_numTerrainEffect = rval.m_numTerrainEffect;

        delete [] m_PrerequisiteTileImp;
        m_PrerequisiteTileImp = NULL;
        if (rval.m_numPrerequisiteTileImp > 0)
        {
            m_PrerequisiteTileImp = new sint32 [rval.m_numPrerequisiteTileImp];
            std::copy(rval.m_PrerequisiteTileImp, rval.m_PrerequisiteTileImp + rval.m_numPrerequisiteTileImp, m_PrerequisiteTileImp);
        }
        m_numPrerequisiteTileImp = rval.m_numPrerequisiteTileImp;

        m_Icon = rval.m_Icon;

        m_Tooltip = rval.m_Tooltip;

        m_Statusbar = rval.m_Statusbar;

        m_Level = rval.m_Level;

        delete [] m_ConstructionTiles;
        m_ConstructionTiles = NULL;
        if (rval.m_numConstructionTiles > 0)
        {
            m_ConstructionTiles = new sint32 [rval.m_numConstructionTiles];
            std::copy(rval.m_ConstructionTiles, rval.m_ConstructionTiles + rval.m_numConstructionTiles, m_ConstructionTiles);
        }
        m_numConstructionTiles = rval.m_numConstructionTiles;

        m_TerraformTerrainValue = rval.m_TerraformTerrainValue;

        m_ColumnValue = rval.m_ColumnValue;

        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;

        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;

        m_MoveBonusValue = rval.m_MoveBonusValue;

        m_DisplayLevel = rval.m_DisplayLevel;

        m_EnergyHunger = rval.m_EnergyHunger;

        m_ProducesEnergy = rval.m_ProducesEnergy;

    }

    return *this;
}

const char *g_TerrainImprovement_Tokens[] =
{
    "Class",
    "Excludes",
    "CanSee",
    "Sound",
    "CantBuildOn",
    "GovernmentsModified",
    "CultureOnly",
    "GovernmentType",
    "IsRestrictedToGood",
    "EnablesGood",
    "Effect",
    "EffectValue",
    "TerrainEffect",
    "DeniedToEnemy",
    "CanExportTileValue",
    "CanExportGood",
    "CanExportTileValueRadius",
    "PrerequisiteTileImp",
    "IsCanal",
    "OnlySpecialBuild",
    "Icon",
    "Tooltip",
    "Statusbar",
    "Level",
    "ConstructionTiles",
    "TerraformTerrain",
    "TerraformTerrainValue",
    "Column",
    "ColumnValue",
    "IntBorderRadius",
    "IntBorderRadiusValue",
    "SquaredBorderRadius",
    "SquaredBorderRadiusValue",
    "MoveBonus",
    "MoveBonusValue",
    "Colony",
    "GLHidden",
    "DisplayLevel",
    "CantPillage",
    "SpawnsBarbarians",
    "CanBuildAlly",
    "CanBuildWasteland",
    "CanUpgrade",
    "IsCityRuin",
    "EnergyHunger",
    "ProducesEnergy",
};

TerrainImprovementRecordAccessorInfo g_TerrainImprovementRecord_Accessors[] =
{
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Class */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Excludes */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* CanSee */
    { &TerrainImprovementRecord::GetSoundIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { &TerrainImprovementRecord::GetNumCantBuildOn, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetCantBuildOnIndex, NULL}, /* CantBuildOn (array) */
    { &TerrainImprovementRecord::GetNumGovernmentsModified, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetGovernmentsModifiedIndex, NULL}, /* GovernmentsModified (array) */
    { &TerrainImprovementRecord::GetNumCultureOnly, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetCultureOnlyIndex, NULL}, /* CultureOnly (array) */
    { &TerrainImprovementRecord::GetNumGovernmentType, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetGovernmentTypeIndex, NULL}, /* GovernmentType (array) */
    { &TerrainImprovementRecord::GetNumIsRestrictedToGood, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetIsRestrictedToGoodIndex, NULL}, /* IsRestrictedToGood (array) */
    { &TerrainImprovementRecord::GetNumEnablesGood, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetEnablesGoodIndex, NULL}, /* EnablesGood (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Effect */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Effect */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TerrainEffect */
    { NULL, &TerrainImprovementRecord::GetDeniedToEnemy, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetCanExportTileValue, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetCanExportGood, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetCanExportTileValueRadius, NULL, NULL, NULL, NULL, NULL },
    { &TerrainImprovementRecord::GetNumPrerequisiteTileImp, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetPrerequisiteTileImpIndex, NULL}, /* PrerequisiteTileImp (array) */
    { NULL, &TerrainImprovementRecord::GetIsCanal, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetOnlySpecialBuild, NULL, NULL, NULL, NULL, NULL },
    { &TerrainImprovementRecord::GetIconIndex, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Tooltip */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Statusbar */
    { &TerrainImprovementRecord::GetLevel, NULL, NULL, NULL, NULL, NULL, NULL },
    { &TerrainImprovementRecord::GetNumConstructionTiles, NULL, NULL, NULL, NULL, &TerrainImprovementRecord::GetConstructionTiles, NULL}, /* ConstructionTiles (array) */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TerraformTerrain */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* TerraformTerrain */
    { NULL, NULL, NULL, &TerrainImprovementRecord::GetColumn, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* Column */
    { NULL, NULL, NULL, &TerrainImprovementRecord::GetIntBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* IntBorderRadius */
    { NULL, NULL, NULL, &TerrainImprovementRecord::GetSquaredBorderRadius, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* SquaredBorderRadius */
    { NULL, NULL, NULL, &TerrainImprovementRecord::GetMoveBonus, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL }, /* MoveBonus */
    { NULL, &TerrainImprovementRecord::GetColony, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetGLHidden, NULL, NULL, NULL, NULL, NULL },
    { &TerrainImprovementRecord::GetDisplayLevel, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetCantPillage, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetSpawnsBarbarians, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetCanBuildAlly, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetCanBuildWasteland, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetCanUpgrade, NULL, NULL, NULL, NULL, NULL },
    { NULL, &TerrainImprovementRecord::GetIsCityRuin, NULL, NULL, NULL, NULL, NULL },
    { &TerrainImprovementRecord::GetEnergyHunger, NULL, NULL, NULL, NULL, NULL, NULL },
    { &TerrainImprovementRecord::GetProducesEnergy, NULL, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_TerrainImprovement_Class         ((k_Token_Custom_Base) + 0)
#define k_Token_TerrainImprovement_Excludes      ((k_Token_Custom_Base) + 1)
#define k_Token_TerrainImprovement_CanSee        ((k_Token_Custom_Base) + 2)
#define k_Token_TerrainImprovement_Sound         ((k_Token_Custom_Base) + 3)
#define k_Token_TerrainImprovement_CantBuildOn   ((k_Token_Custom_Base) + 4)
#define k_Token_TerrainImprovement_GovernmentsModified ((k_Token_Custom_Base) + 5)
#define k_Token_TerrainImprovement_CultureOnly   ((k_Token_Custom_Base) + 6)
#define k_Token_TerrainImprovement_GovernmentType ((k_Token_Custom_Base) + 7)
#define k_Token_TerrainImprovement_IsRestrictedToGood ((k_Token_Custom_Base) + 8)
#define k_Token_TerrainImprovement_EnablesGood   ((k_Token_Custom_Base) + 9)
#define k_Token_TerrainImprovement_Effect        ((k_Token_Custom_Base) + 10)
#define k_Token_TerrainImprovement_Effect_Value  ((k_Token_Custom_Base) + 11)
#define k_Token_TerrainImprovement_TerrainEffect ((k_Token_Custom_Base) + 12)
#define k_Token_TerrainImprovement_DeniedToEnemy ((k_Token_Custom_Base) + 13)
#define k_Token_TerrainImprovement_CanExportTileValue ((k_Token_Custom_Base) + 14)
#define k_Token_TerrainImprovement_CanExportGood ((k_Token_Custom_Base) + 15)
#define k_Token_TerrainImprovement_CanExportTileValueRadius ((k_Token_Custom_Base) + 16)
#define k_Token_TerrainImprovement_PrerequisiteTileImp ((k_Token_Custom_Base) + 17)
#define k_Token_TerrainImprovement_IsCanal       ((k_Token_Custom_Base) + 18)
#define k_Token_TerrainImprovement_OnlySpecialBuild ((k_Token_Custom_Base) + 19)
#define k_Token_TerrainImprovement_Icon          ((k_Token_Custom_Base) + 20)
#define k_Token_TerrainImprovement_Tooltip       ((k_Token_Custom_Base) + 21)
#define k_Token_TerrainImprovement_Statusbar     ((k_Token_Custom_Base) + 22)
#define k_Token_TerrainImprovement_Level         ((k_Token_Custom_Base) + 23)
#define k_Token_TerrainImprovement_ConstructionTiles ((k_Token_Custom_Base) + 24)
#define k_Token_TerrainImprovement_TerraformTerrain ((k_Token_Custom_Base) + 25)
#define k_Token_TerrainImprovement_TerraformTerrain_Value ((k_Token_Custom_Base) + 26)
#define k_Token_TerrainImprovement_Column        ((k_Token_Custom_Base) + 27)
#define k_Token_TerrainImprovement_Column_Value  ((k_Token_Custom_Base) + 28)
#define k_Token_TerrainImprovement_IntBorderRadius ((k_Token_Custom_Base) + 29)
#define k_Token_TerrainImprovement_IntBorderRadius_Value ((k_Token_Custom_Base) + 30)
#define k_Token_TerrainImprovement_SquaredBorderRadius ((k_Token_Custom_Base) + 31)
#define k_Token_TerrainImprovement_SquaredBorderRadius_Value ((k_Token_Custom_Base) + 32)
#define k_Token_TerrainImprovement_MoveBonus     ((k_Token_Custom_Base) + 33)
#define k_Token_TerrainImprovement_MoveBonus_Value ((k_Token_Custom_Base) + 34)
#define k_Token_TerrainImprovement_Colony        ((k_Token_Custom_Base) + 35)
#define k_Token_TerrainImprovement_GLHidden      ((k_Token_Custom_Base) + 36)
#define k_Token_TerrainImprovement_DisplayLevel  ((k_Token_Custom_Base) + 37)
#define k_Token_TerrainImprovement_CantPillage   ((k_Token_Custom_Base) + 38)
#define k_Token_TerrainImprovement_SpawnsBarbarians ((k_Token_Custom_Base) + 39)
#define k_Token_TerrainImprovement_CanBuildAlly  ((k_Token_Custom_Base) + 40)
#define k_Token_TerrainImprovement_CanBuildWasteland ((k_Token_Custom_Base) + 41)
#define k_Token_TerrainImprovement_CanUpgrade    ((k_Token_Custom_Base) + 42)
#define k_Token_TerrainImprovement_IsCityRuin    ((k_Token_Custom_Base) + 43)
#define k_Token_TerrainImprovement_EnergyHunger  ((k_Token_Custom_Base) + 44)
#define k_Token_TerrainImprovement_ProducesEnergy ((k_Token_Custom_Base) + 45)
#define k_Token_TerrainImprovement_Max           ((k_Token_Custom_Base) + 46)


static BitArray s_ParsedTokens(46);
void TerrainImprovementRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_TerrainImprovement_Tooltip - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Tooltip missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_TerrainImprovement_Statusbar - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Statusbar missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_TerrainImprovement_Level - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Level missing"));
    }
}

sint32 TerrainImprovementRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_TerrainImprovement_Tokens, k_Token_TerrainImprovement_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "TERRAINIMPROVEMENT_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }

    // Start of GovMod Specific lexical analysis
    if(tok == k_Token_Modified) {
        do {
            tok = lex->PeekAhead();
            if(tok != k_Token_Name) {
                DBERROR(("Modified record invalid- must be Government identifier or description.  No quotes, No spaces."));
                return 0;
            }
            g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified);
            tok = lex->GetToken();
        } while (tok == k_Token_ModifiedDelimiter);
    }
    // End of GovMod Specific lexical analysis

    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_TerrainImprovement_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_TerrainImprovement_Class:
                if(!ParseClassBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Excludes:
                if(!ParseExcludesBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_CanSee:
                if(!ParseCanSeeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Sound:
                if (!g_theSoundDB->GetRecordFromLexer(lex, m_Sound)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_CantBuildOn:
                if(!g_theTerrainDB->ParseRecordInArray(lex, (sint32 **)&m_CantBuildOn, &m_numCantBuildOn))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_GovernmentsModified:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentsModified, &m_numGovernmentsModified))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, (sint32 **)&m_CultureOnly, &m_numCultureOnly))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_IsRestrictedToGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_IsRestrictedToGood, &m_numIsRestrictedToGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_EnablesGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, (sint32 **)&m_EnablesGood, &m_numEnablesGood))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect:
                m_flags0 |= k_TerrainImprovement_Effect_Bit;
                if(!m_EffectValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_TerrainEffect:
                if(!TerrainImprovementRecord::Effect::ParseInArray(lex, &m_TerrainEffect, &m_numTerrainEffect))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_DeniedToEnemy:
                m_flags0 |= k_TerrainImprovement_DeniedToEnemy_Bit;
                break;
            case k_Token_TerrainImprovement_CanExportTileValue:
                m_flags0 |= k_TerrainImprovement_CanExportTileValue_Bit;
                break;
            case k_Token_TerrainImprovement_CanExportGood:
                m_flags0 |= k_TerrainImprovement_CanExportGood_Bit;
                break;
            case k_Token_TerrainImprovement_CanExportTileValueRadius:
                m_flags0 |= k_TerrainImprovement_CanExportTileValueRadius_Bit;
                break;
            case k_Token_TerrainImprovement_PrerequisiteTileImp:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, (sint32 **)&m_PrerequisiteTileImp, &m_numPrerequisiteTileImp))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_IsCanal:
                m_flags0 |= k_TerrainImprovement_IsCanal_Bit;
                break;
            case k_Token_TerrainImprovement_OnlySpecialBuild:
                m_flags0 |= k_TerrainImprovement_OnlySpecialBuild_Bit;
                break;
            case k_Token_TerrainImprovement_Icon:
                if (!g_theIconDB->GetRecordFromLexer(lex, m_Icon)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Tooltip:
                if(!lex->GetStringIdAssignment(m_Tooltip)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Statusbar:
                if(!lex->GetStringIdAssignment(m_Statusbar)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Level:
                if(!lex->GetIntAssignment(m_Level)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_ConstructionTiles:
                if(!CTPRecord::ParseIntInArray(lex, &m_ConstructionTiles, &m_numConstructionTiles))
                {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_TerraformTerrain:
                m_flags0 |= k_TerrainImprovement_TerraformTerrain_Bit;
                if(!g_theTerrainDB->GetRecordFromLexer(lex, m_TerraformTerrainValue)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Column:
                m_flags0 |= k_TerrainImprovement_Column_Bit;
                if(!lex->GetIntAssignment(m_ColumnValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_IntBorderRadius:
                m_flags0 |= k_TerrainImprovement_IntBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_IntBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_SquaredBorderRadius:
                m_flags0 |= k_TerrainImprovement_SquaredBorderRadius_Bit;
                if(!lex->GetIntAssignment(m_SquaredBorderRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_MoveBonus:
                m_flags0 |= k_TerrainImprovement_MoveBonus_Bit;
                if(!lex->GetIntAssignment(m_MoveBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Colony:
                m_flags0 |= k_TerrainImprovement_Colony_Bit;
                break;
            case k_Token_TerrainImprovement_GLHidden:
                m_flags0 |= k_TerrainImprovement_GLHidden_Bit;
                break;
            case k_Token_TerrainImprovement_DisplayLevel:
                if(!lex->GetIntAssignment(m_DisplayLevel)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_CantPillage:
                m_flags0 |= k_TerrainImprovement_CantPillage_Bit;
                break;
            case k_Token_TerrainImprovement_SpawnsBarbarians:
                m_flags0 |= k_TerrainImprovement_SpawnsBarbarians_Bit;
                break;
            case k_Token_TerrainImprovement_CanBuildAlly:
                m_flags0 |= k_TerrainImprovement_CanBuildAlly_Bit;
                break;
            case k_Token_TerrainImprovement_CanBuildWasteland:
                m_flags0 |= k_TerrainImprovement_CanBuildWasteland_Bit;
                break;
            case k_Token_TerrainImprovement_CanUpgrade:
                m_flags0 |= k_TerrainImprovement_CanUpgrade_Bit;
                break;
            case k_Token_TerrainImprovement_IsCityRuin:
                m_flags0 |= k_TerrainImprovement_IsCityRuin_Bit;
                break;
            case k_Token_TerrainImprovement_EnergyHunger:
                if(!lex->GetIntAssignment(m_EnergyHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_ProducesEnergy:
                if(!lex->GetIntAssignment(m_ProducesEnergy)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!ParseClassBit(lex)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void TerrainImprovementRecord::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numCantBuildOn; i++) {
            if(m_CantBuildOn[i] & 0x80000000) {
                sint32 id = m_CantBuildOn[i] & 0x7fffffff;
                if(!g_theTerrainDB->GetNamedItem(id, m_CantBuildOn[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Terrain database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CantBuildOn[i] == 0x7fffffff){
                m_CantBuildOn[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentsModified; i++) {
            if(m_GovernmentsModified[i] & 0x80000000) {
                sint32 id = m_GovernmentsModified[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentsModified[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentsModified[i] == 0x7fffffff){
                m_GovernmentsModified[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numIsRestrictedToGood; i++) {
            if(m_IsRestrictedToGood[i] & 0x80000000) {
                sint32 id = m_IsRestrictedToGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_IsRestrictedToGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_IsRestrictedToGood[i] == 0x7fffffff){
                m_IsRestrictedToGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numEnablesGood; i++) {
            if(m_EnablesGood[i] & 0x80000000) {
                sint32 id = m_EnablesGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_EnablesGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_EnablesGood[i] == 0x7fffffff){
                m_EnablesGood[i] = -1;
            }
        }
    }
    m_EffectValue.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numTerrainEffect; i++) {
            m_TerrainEffect[i].ResolveDBReferences();
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisiteTileImp; i++) {
            if(m_PrerequisiteTileImp[i] & 0x80000000) {
                sint32 id = m_PrerequisiteTileImp[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_PrerequisiteTileImp[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_PrerequisiteTileImp[i] == 0x7fffffff){
                m_PrerequisiteTileImp[i] = -1;
            }
        }
    }
    if(m_Icon & 0x80000000) {
        sint32 id = m_Icon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_Icon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Icon == 0x7fffffff) {
        m_Icon = -1;
    }
    if(m_TerraformTerrainValue & 0x80000000) {
        sint32 id = m_TerraformTerrainValue & 0x7fffffff;
        if(!g_theTerrainDB->GetNamedItem(id, m_TerraformTerrainValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Terrain database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_TerraformTerrainValue == 0x7fffffff) {
        m_TerraformTerrainValue = -1;
    }
}

TerrainImprovementRecord::Effect::Effect()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_Terrain = NULL;
    m_numTerrain = 0;
    m_BonusFoodValue = 0;
    m_BonusProductionValue = 0;
    m_BonusGoldValue = 0;
    m_MoveCostValue = 0;
    m_FreightValue = 0;
    m_BonusFoodExportValue = 0;
    m_BonusProductionExportValue = 0;
    m_BonusGoldExportValue = 0;
    m_FranchiseProductionValue = 0;
    m_MinefieldValue = 0.000000;
    m_GrowsToImprovement = NULL;
    m_numGrowsToImprovement = 0;
    m_TurnsToGrowthValue = 0;
    m_VisionRangeValue = 0;
    m_RadarRangeValue = 0;
    m_DefenseBonusValue = 0.000000;
    m_CultureOnly = NULL;
    m_numCultureOnly = 0;
    m_EnableAdvance = 0x7fffffff;
    m_ObsoleteAdvance = NULL;
    m_numObsoleteAdvance = 0;
    m_ProductionCost = 0;
    m_EnablesGood = NULL;
    m_numEnablesGood = 0;
    m_GoldHungerValue = 0;
    m_GoldCostValue = 0;
    m_BonusScience = 0;
    m_HappyInc = 0;
    m_ProductionTime = 0;
    m_TilesetIndex = 0;
    m_EnergyHunger = 0;
    m_ProducesEnergy = 0;
    m_IsWonder = NULL;
    m_numIsWonder = 0;
    m_HealRateValue = 0.000000;
}

TerrainImprovementRecord::Effect::~Effect()
{
    delete [] m_Terrain;
    delete [] m_GrowsToImprovement;
    delete [] m_CultureOnly;
    delete [] m_ObsoleteAdvance;
    delete [] m_EnablesGood;
    delete [] m_IsWonder;
}

TerrainImprovementRecord::Effect const & TerrainImprovementRecord::Effect::operator = (Effect const & rval)
{
    if (this != &rval)
    {
        m_flags0 = rval.m_flags0;
        m_flags1 = rval.m_flags1;

        delete [] m_Terrain;
        m_Terrain = NULL;
        if (rval.m_numTerrain > 0)
        {
            m_Terrain = new sint32 [rval.m_numTerrain];
            std::copy(rval.m_Terrain, rval.m_Terrain + rval.m_numTerrain, m_Terrain);
        }
        m_numTerrain = rval.m_numTerrain;

        m_BonusFoodValue = rval.m_BonusFoodValue;

        m_BonusProductionValue = rval.m_BonusProductionValue;

        m_BonusGoldValue = rval.m_BonusGoldValue;

        m_MoveCostValue = rval.m_MoveCostValue;

        m_FreightValue = rval.m_FreightValue;

        m_BonusFoodExportValue = rval.m_BonusFoodExportValue;

        m_BonusProductionExportValue = rval.m_BonusProductionExportValue;

        m_BonusGoldExportValue = rval.m_BonusGoldExportValue;

        m_FranchiseProductionValue = rval.m_FranchiseProductionValue;

        m_MinefieldValue = rval.m_MinefieldValue;

        delete [] m_GrowsToImprovement;
        m_GrowsToImprovement = NULL;
        if (rval.m_numGrowsToImprovement > 0)
        {
            m_GrowsToImprovement = new sint32 [rval.m_numGrowsToImprovement];
            std::copy(rval.m_GrowsToImprovement, rval.m_GrowsToImprovement + rval.m_numGrowsToImprovement, m_GrowsToImprovement);
        }
        m_numGrowsToImprovement = rval.m_numGrowsToImprovement;

        m_TurnsToGrowthValue = rval.m_TurnsToGrowthValue;

        m_VisionRangeValue = rval.m_VisionRangeValue;

        m_RadarRangeValue = rval.m_RadarRangeValue;

        m_DefenseBonusValue = rval.m_DefenseBonusValue;

        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
        {
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
            std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);
        }
        m_numCultureOnly = rval.m_numCultureOnly;

        m_EnableAdvance = rval.m_EnableAdvance;

        delete [] m_ObsoleteAdvance;
        m_ObsoleteAdvance = NULL;
        if (rval.m_numObsoleteAdvance > 0)
        {
            m_ObsoleteAdvance = new sint32 [rval.m_numObsoleteAdvance];
            std::copy(rval.m_ObsoleteAdvance, rval.m_ObsoleteAdvance + rval.m_numObsoleteAdvance, m_ObsoleteAdvance);
        }
        m_numObsoleteAdvance = rval.m_numObsoleteAdvance;

        m_ProductionCost = rval.m_ProductionCost;

        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
        {
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
            std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);
        }
        m_numEnablesGood = rval.m_numEnablesGood;

        m_GoldHungerValue = rval.m_GoldHungerValue;

        m_GoldCostValue = rval.m_GoldCostValue;

        m_BonusScience = rval.m_BonusScience;

        m_HappyInc = rval.m_HappyInc;

        m_ProductionTime = rval.m_ProductionTime;

        m_TilesetIndex = rval.m_TilesetIndex;

        m_EnergyHunger = rval.m_EnergyHunger;

        m_ProducesEnergy = rval.m_ProducesEnergy;

        delete [] m_IsWonder;
        m_IsWonder = NULL;
        if (rval.m_numIsWonder > 0)
        {
            m_IsWonder = new sint32 [rval.m_numIsWonder];
            std::copy(rval.m_IsWonder, rval.m_IsWonder + rval.m_numIsWonder, m_IsWonder);
        }
        m_numIsWonder = rval.m_numIsWonder;

        m_HealRateValue = rval.m_HealRateValue;

    }

    return *this;
}

void TerrainImprovementRecord::Effect::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_flags0;
        archive << m_flags1;
        archive << m_numTerrain;
        archive.Store((uint8*)m_Terrain, m_numTerrain * sizeof(sint32));

        archive << m_BonusFoodValue;
        archive << m_BonusProductionValue;
        archive << m_BonusGoldValue;
        archive << m_MoveCostValue;
        archive << m_FreightValue;
        archive << m_BonusFoodExportValue;
        archive << m_BonusProductionExportValue;
        archive << m_BonusGoldExportValue;
        archive << m_FranchiseProductionValue;
        archive << m_MinefieldValue;
        archive << m_numGrowsToImprovement;
        archive.Store((uint8*)m_GrowsToImprovement, m_numGrowsToImprovement * sizeof(sint32));

        archive << m_TurnsToGrowthValue;
        archive << m_VisionRangeValue;
        archive << m_RadarRangeValue;
        archive << m_DefenseBonusValue;
        archive << m_numCultureOnly;
        archive.Store((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive << m_EnableAdvance;
        archive << m_numObsoleteAdvance;
        archive.Store((uint8*)m_ObsoleteAdvance, m_numObsoleteAdvance * sizeof(sint32));

        archive << m_ProductionCost;
        archive << m_numEnablesGood;
        archive.Store((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive << m_GoldHungerValue;
        archive << m_GoldCostValue;
        archive << m_BonusScience;
        archive << m_HappyInc;
        archive << m_ProductionTime;
        archive << m_TilesetIndex;
        archive << m_EnergyHunger;
        archive << m_ProducesEnergy;
        archive << m_numIsWonder;
        archive.Store((uint8*)m_IsWonder, m_numIsWonder * sizeof(sint32));

        archive << m_HealRateValue;
    } else {
        archive >> m_flags0;
        archive >> m_flags1;
        archive >> m_numTerrain;
        archive.Load((uint8*)m_Terrain, m_numTerrain * sizeof(sint32));

        archive >> m_BonusFoodValue;
        archive >> m_BonusProductionValue;
        archive >> m_BonusGoldValue;
        archive >> m_MoveCostValue;
        archive >> m_FreightValue;
        archive >> m_BonusFoodExportValue;
        archive >> m_BonusProductionExportValue;
        archive >> m_BonusGoldExportValue;
        archive >> m_FranchiseProductionValue;
        archive >> m_MinefieldValue;
        archive >> m_numGrowsToImprovement;
        archive.Load((uint8*)m_GrowsToImprovement, m_numGrowsToImprovement * sizeof(sint32));

        archive >> m_TurnsToGrowthValue;
        archive >> m_VisionRangeValue;
        archive >> m_RadarRangeValue;
        archive >> m_DefenseBonusValue;
        archive >> m_numCultureOnly;
        archive.Load((uint8*)m_CultureOnly, m_numCultureOnly * sizeof(sint32));

        archive >> m_EnableAdvance;
        archive >> m_numObsoleteAdvance;
        archive.Load((uint8*)m_ObsoleteAdvance, m_numObsoleteAdvance * sizeof(sint32));

        archive >> m_ProductionCost;
        archive >> m_numEnablesGood;
        archive.Load((uint8*)m_EnablesGood, m_numEnablesGood * sizeof(sint32));

        archive >> m_GoldHungerValue;
        archive >> m_GoldCostValue;
        archive >> m_BonusScience;
        archive >> m_HappyInc;
        archive >> m_ProductionTime;
        archive >> m_TilesetIndex;
        archive >> m_EnergyHunger;
        archive >> m_ProducesEnergy;
        archive >> m_numIsWonder;
        archive.Load((uint8*)m_IsWonder, m_numIsWonder * sizeof(sint32));

        archive >> m_HealRateValue;
    }
}

static const char *s_TerrainImprovement_Effect_Tokens[] = {
    "Terrain",
    "BonusFood",
    "BonusProduction",
    "BonusGold",
    "MoveCost",
    "Freight",
    "Radar",
    "NeedsWorker",
    "Airport",
    "Colony",
    "Fort",
    "IsUrban",
    "Slum",
    "Installation",
    "DeniedToEnemy",
    "BonusFoodExport",
    "BonusProductionExport",
    "BonusGoldExport",
    "FranchiseProduction",
    "CanBeCaptured",
    "CanUpgrade",
    "Minefield",
    "GrowsToImprovement",
    "TurnsToGrowth",
    "ListeningPost",
    "Endgame",
    "VisionRange",
    "RadarRange",
    "DefenseBonus",
    "CultureOnly",
    "EnableAdvance",
    "ObsoleteAdvance",
    "ProductionCost",
    "EnablesGood",
    "GoldHunger",
    "GoldCost",
    "BonusScience",
    "HappyInc",
    "ProductionTime",
    "TilesetIndex",
    "EnergyHunger",
    "ProducesEnergy",
    "IsWonder",
    "NeedsIrrigation",
    "IsIrrigation",
    "NextToCity",
    "RiverOnly",
    "Obstacle",
    "NextToUrban",
    "HealRate",
};
#define k_Token_TerrainImprovement_Effect_Terrain ((k_Token_Custom_Base) + 0)
#define k_Token_TerrainImprovement_Effect_BonusFood ((k_Token_Custom_Base) + 1)
#define k_Token_TerrainImprovement_Effect_BonusProduction ((k_Token_Custom_Base) + 2)
#define k_Token_TerrainImprovement_Effect_BonusGold ((k_Token_Custom_Base) + 3)
#define k_Token_TerrainImprovement_Effect_MoveCost ((k_Token_Custom_Base) + 4)
#define k_Token_TerrainImprovement_Effect_Freight ((k_Token_Custom_Base) + 5)
#define k_Token_TerrainImprovement_Effect_Radar  ((k_Token_Custom_Base) + 6)
#define k_Token_TerrainImprovement_Effect_NeedsWorker ((k_Token_Custom_Base) + 7)
#define k_Token_TerrainImprovement_Effect_Airport ((k_Token_Custom_Base) + 8)
#define k_Token_TerrainImprovement_Effect_Colony ((k_Token_Custom_Base) + 9)
#define k_Token_TerrainImprovement_Effect_Fort   ((k_Token_Custom_Base) + 10)
#define k_Token_TerrainImprovement_Effect_IsUrban ((k_Token_Custom_Base) + 11)
#define k_Token_TerrainImprovement_Effect_Slum   ((k_Token_Custom_Base) + 12)
#define k_Token_TerrainImprovement_Effect_Installation ((k_Token_Custom_Base) + 13)
#define k_Token_TerrainImprovement_Effect_DeniedToEnemy ((k_Token_Custom_Base) + 14)
#define k_Token_TerrainImprovement_Effect_BonusFoodExport ((k_Token_Custom_Base) + 15)
#define k_Token_TerrainImprovement_Effect_BonusProductionExport ((k_Token_Custom_Base) + 16)
#define k_Token_TerrainImprovement_Effect_BonusGoldExport ((k_Token_Custom_Base) + 17)
#define k_Token_TerrainImprovement_Effect_FranchiseProduction ((k_Token_Custom_Base) + 18)
#define k_Token_TerrainImprovement_Effect_CanBeCaptured ((k_Token_Custom_Base) + 19)
#define k_Token_TerrainImprovement_Effect_CanUpgrade ((k_Token_Custom_Base) + 20)
#define k_Token_TerrainImprovement_Effect_Minefield ((k_Token_Custom_Base) + 21)
#define k_Token_TerrainImprovement_Effect_GrowsToImprovement ((k_Token_Custom_Base) + 22)
#define k_Token_TerrainImprovement_Effect_TurnsToGrowth ((k_Token_Custom_Base) + 23)
#define k_Token_TerrainImprovement_Effect_ListeningPost ((k_Token_Custom_Base) + 24)
#define k_Token_TerrainImprovement_Effect_Endgame ((k_Token_Custom_Base) + 25)
#define k_Token_TerrainImprovement_Effect_VisionRange ((k_Token_Custom_Base) + 26)
#define k_Token_TerrainImprovement_Effect_RadarRange ((k_Token_Custom_Base) + 27)
#define k_Token_TerrainImprovement_Effect_DefenseBonus ((k_Token_Custom_Base) + 28)
#define k_Token_TerrainImprovement_Effect_CultureOnly ((k_Token_Custom_Base) + 29)
#define k_Token_TerrainImprovement_Effect_EnableAdvance ((k_Token_Custom_Base) + 30)
#define k_Token_TerrainImprovement_Effect_ObsoleteAdvance ((k_Token_Custom_Base) + 31)
#define k_Token_TerrainImprovement_Effect_ProductionCost ((k_Token_Custom_Base) + 32)
#define k_Token_TerrainImprovement_Effect_EnablesGood ((k_Token_Custom_Base) + 33)
#define k_Token_TerrainImprovement_Effect_GoldHunger ((k_Token_Custom_Base) + 34)
#define k_Token_TerrainImprovement_Effect_GoldCost ((k_Token_Custom_Base) + 35)
#define k_Token_TerrainImprovement_Effect_BonusScience ((k_Token_Custom_Base) + 36)
#define k_Token_TerrainImprovement_Effect_HappyInc ((k_Token_Custom_Base) + 37)
#define k_Token_TerrainImprovement_Effect_ProductionTime ((k_Token_Custom_Base) + 38)
#define k_Token_TerrainImprovement_Effect_TilesetIndex ((k_Token_Custom_Base) + 39)
#define k_Token_TerrainImprovement_Effect_EnergyHunger ((k_Token_Custom_Base) + 40)
#define k_Token_TerrainImprovement_Effect_ProducesEnergy ((k_Token_Custom_Base) + 41)
#define k_Token_TerrainImprovement_Effect_IsWonder ((k_Token_Custom_Base) + 42)
#define k_Token_TerrainImprovement_Effect_NeedsIrrigation ((k_Token_Custom_Base) + 43)
#define k_Token_TerrainImprovement_Effect_IsIrrigation ((k_Token_Custom_Base) + 44)
#define k_Token_TerrainImprovement_Effect_NextToCity ((k_Token_Custom_Base) + 45)
#define k_Token_TerrainImprovement_Effect_RiverOnly ((k_Token_Custom_Base) + 46)
#define k_Token_TerrainImprovement_Effect_Obstacle ((k_Token_Custom_Base) + 47)
#define k_Token_TerrainImprovement_Effect_NextToUrban ((k_Token_Custom_Base) + 48)
#define k_Token_TerrainImprovement_Effect_HealRate ((k_Token_Custom_Base) + 49)
#define k_Token_TerrainImprovement_Effect_Max ((k_Token_Custom_Base) + 50)
sint32 TerrainImprovementRecord::Effect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(lex->GetCurrentToken() != k_Token_OpenBrace) {
            DBERROR(("Expected open brace for Effect"));
            return 0;
        }
    }
    else {
        tok = lex->GetToken();
    }
    lex->SetTokens(s_TerrainImprovement_Effect_Tokens, k_Token_TerrainImprovement_Effect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_TerrainImprovement_Effect_Terrain:
                if(!g_theTerrainDB->ParseRecordInArray(lex, &m_Terrain, &m_numTerrain)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_BonusFood:
                m_flags0 |= k_Effect_BonusFood_Bit;
                if(!lex->GetIntAssignment(m_BonusFoodValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_BonusProduction:
                m_flags0 |= k_Effect_BonusProduction_Bit;
                if(!lex->GetIntAssignment(m_BonusProductionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_BonusGold:
                m_flags0 |= k_Effect_BonusGold_Bit;
                if(!lex->GetIntAssignment(m_BonusGoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_MoveCost:
                m_flags0 |= k_Effect_MoveCost_Bit;
                if(!lex->GetIntAssignment(m_MoveCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_Freight:
                m_flags0 |= k_Effect_Freight_Bit;
                if(!lex->GetIntAssignment(m_FreightValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_Radar:
                m_flags0 |= k_Effect_Radar_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_NeedsWorker:
                m_flags0 |= k_Effect_NeedsWorker_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Airport:
                m_flags0 |= k_Effect_Airport_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Colony:
                m_flags0 |= k_Effect_Colony_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Fort:
                m_flags0 |= k_Effect_Fort_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_IsUrban:
                m_flags0 |= k_Effect_IsUrban_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Slum:
                m_flags0 |= k_Effect_Slum_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Installation:
                m_flags0 |= k_Effect_Installation_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_DeniedToEnemy:
                m_flags0 |= k_Effect_DeniedToEnemy_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_BonusFoodExport:
                m_flags0 |= k_Effect_BonusFoodExport_Bit;
                if(!lex->GetIntAssignment(m_BonusFoodExportValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_BonusProductionExport:
                m_flags0 |= k_Effect_BonusProductionExport_Bit;
                if(!lex->GetIntAssignment(m_BonusProductionExportValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_BonusGoldExport:
                m_flags0 |= k_Effect_BonusGoldExport_Bit;
                if(!lex->GetIntAssignment(m_BonusGoldExportValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_FranchiseProduction:
                m_flags0 |= k_Effect_FranchiseProduction_Bit;
                if(!lex->GetIntAssignment(m_FranchiseProductionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_CanBeCaptured:
                m_flags0 |= k_Effect_CanBeCaptured_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_CanUpgrade:
                m_flags0 |= k_Effect_CanUpgrade_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Minefield:
                m_flags0 |= k_Effect_Minefield_Bit;
                if(!lex->GetFloatAssignment(m_MinefieldValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_GrowsToImprovement:
                if(!g_theTerrainImprovementDB->ParseRecordInArray(lex, &m_GrowsToImprovement, &m_numGrowsToImprovement)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_TurnsToGrowth:
                m_flags0 |= k_Effect_TurnsToGrowth_Bit;
                if(!lex->GetIntAssignment(m_TurnsToGrowthValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_ListeningPost:
                m_flags0 |= k_Effect_ListeningPost_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Endgame:
                m_flags0 |= k_Effect_Endgame_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_VisionRange:
                m_flags0 |= k_Effect_VisionRange_Bit;
                if(!lex->GetIntAssignment(m_VisionRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_RadarRange:
                m_flags0 |= k_Effect_RadarRange_Bit;
                if(!lex->GetIntAssignment(m_RadarRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_DefenseBonus:
                m_flags0 |= k_Effect_DefenseBonus_Bit;
                if(!lex->GetFloatAssignment(m_DefenseBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_CultureOnly:
                if(!g_theCityStyleDB->ParseRecordInArray(lex, &m_CultureOnly, &m_numCultureOnly)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_EnableAdvance:
                if (!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_ObsoleteAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, &m_ObsoleteAdvance, &m_numObsoleteAdvance)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_ProductionCost:
                if(!lex->GetIntAssignment(m_ProductionCost)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_EnablesGood:
                if(!g_theResourceDB->ParseRecordInArray(lex, &m_EnablesGood, &m_numEnablesGood)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_GoldHunger:
                m_flags0 |= k_Effect_GoldHunger_Bit;
                if(!lex->GetIntAssignment(m_GoldHungerValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_GoldCost:
                m_flags0 |= k_Effect_GoldCost_Bit;
                if(!lex->GetIntAssignment(m_GoldCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_BonusScience:
                if(!lex->GetIntAssignment(m_BonusScience)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_HappyInc:
                if(!lex->GetIntAssignment(m_HappyInc)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_ProductionTime:
                if(!lex->GetIntAssignment(m_ProductionTime)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_TilesetIndex:
                if(!lex->GetIntAssignment(m_TilesetIndex)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_EnergyHunger:
                if(!lex->GetIntAssignment(m_EnergyHunger)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_ProducesEnergy:
                if(!lex->GetIntAssignment(m_ProducesEnergy)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_IsWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, &m_IsWonder, &m_numIsWonder)) {
                    done = true; break;
                }
                break;
            case k_Token_TerrainImprovement_Effect_NeedsIrrigation:
                m_flags0 |= k_Effect_NeedsIrrigation_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_IsIrrigation:
                m_flags0 |= k_Effect_IsIrrigation_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_NextToCity:
                m_flags0 |= k_Effect_NextToCity_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_RiverOnly:
                m_flags1 |= k_Effect_RiverOnly_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_Obstacle:
                m_flags1 |= k_Effect_Obstacle_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_NextToUrban:
                m_flags1 |= k_Effect_NextToUrban_Bit;
                break;
            case k_Token_TerrainImprovement_Effect_HealRate:
                m_flags1 |= k_Effect_HealRate_Bit;
                if(!lex->GetFloatAssignment(m_HealRateValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(false)
                if(!g_theTerrainDB->ParseRecordInArray(lex, &m_Terrain, &m_numTerrain)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 TerrainImprovementRecord::Effect::ParseInArray(DBLexer *lex, Effect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        Effect *oldArray = *array;
        *array = new Effect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++)
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new Effect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

sint32 TerrainImprovementRecord::Effect::ParseInArray(DBLexer *lex, Effect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}

void TerrainImprovementRecord::Effect::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numTerrain; i++) {
            if(m_Terrain[i] & 0x80000000) {
                sint32 id = m_Terrain[i] & 0x7fffffff;
                if(!g_theTerrainDB->GetNamedItem(id, m_Terrain[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Terrain database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Terrain[i] == 0x7fffffff){
                m_Terrain[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGrowsToImprovement; i++) {
            if(m_GrowsToImprovement[i] & 0x80000000) {
                sint32 id = m_GrowsToImprovement[i] & 0x7fffffff;
                if(!g_theTerrainImprovementDB->GetNamedItem(id, m_GrowsToImprovement[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GrowsToImprovement[i] == 0x7fffffff){
                m_GrowsToImprovement[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCultureOnly; i++) {
            if(m_CultureOnly[i] & 0x80000000) {
                sint32 id = m_CultureOnly[i] & 0x7fffffff;
                if(!g_theCityStyleDB->GetNamedItem(id, m_CultureOnly[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in CityStyle database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CultureOnly[i] == 0x7fffffff){
                m_CultureOnly[i] = -1;
            }
        }
    }
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteAdvance; i++) {
            if(m_ObsoleteAdvance[i] & 0x80000000) {
                sint32 id = m_ObsoleteAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ObsoleteAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteAdvance[i] == 0x7fffffff){
                m_ObsoleteAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numEnablesGood; i++) {
            if(m_EnablesGood[i] & 0x80000000) {
                sint32 id = m_EnablesGood[i] & 0x7fffffff;
                if(!g_theResourceDB->GetNamedItem(id, m_EnablesGood[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Resource database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_EnablesGood[i] == 0x7fffffff){
                m_EnablesGood[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numIsWonder; i++) {
            if(m_IsWonder[i] & 0x80000000) {
                sint32 id = m_IsWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_IsWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_IsWonder[i] == 0x7fffffff){
                m_IsWonder[i] = -1;
            }
        }
    }
}

static const char *s_TerrainImprovement_Class_BitNames[] = {
    "Farm",
    "Road",
    "Mine",
    "ATM",
    "OceanFarm",
    "OceanMine",
    "OceanATM",
    "OceanRoad",
    "Structure1",
    "Structure2",
    "LandDetector",
    "OceanDetector",
    "Terraform",
    "Oceanform",
    "Wonder",
    "Urban",
};
#define k_TerrainImprovement_Class_Num_BitNames 16

sint32 TerrainImprovementRecord::ParseClassBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_TerrainImprovement_Class_BitNames, k_TerrainImprovement_Class_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Class", lex->GetTokenText()));
        return 0;
    }
    m_Class |= (1 << bitindex);
    return 1;
}

static const char *s_TerrainImprovement_Excludes_BitNames[] = {
    "Farm",
    "Road",
    "Mine",
    "ATM",
    "OceanFarm",
    "OceanMine",
    "OceanATM",
    "OceanRoad",
    "Structure1",
    "Structure2",
    "LandDetector",
    "OceanDetector",
    "Terraform",
    "Oceanform",
    "Wonder",
    "Urban",
};
#define k_TerrainImprovement_Excludes_Num_BitNames 16

sint32 TerrainImprovementRecord::ParseExcludesBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_TerrainImprovement_Excludes_BitNames, k_TerrainImprovement_Excludes_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Excludes", lex->GetTokenText()));
        return 0;
    }
    m_Excludes |= (1 << bitindex);
    return 1;
}

static const char *s_TerrainImprovement_CanSee_BitNames[] = {
    "Standard",
    "Underwater",
    "Stealth",
    "UnusedBit3",
    "UnusedBit4",
    "UnusedBit5",
    "UnusedBit6",
    "UnusedBit7",
    "UnusedBit8",
    "UnusedBit9",
    "UnusedBit10",
    "UnusedBit11",
    "UnusedBit12",
    "UnusedBit13",
    "UnusedBit14",
    "UnusedBit15",
};
#define k_TerrainImprovement_CanSee_Num_BitNames 16

sint32 TerrainImprovementRecord::ParseCanSeeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_TerrainImprovement_CanSee_BitNames, k_TerrainImprovement_CanSee_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanSee", lex->GetTokenText()));
        return 0;
    }
    m_CanSee |= (1 << bitindex);
    return 1;
}

void TerrainImprovementRecord::Merge(const TerrainImprovementRecord & rval){
    // only replace values that have been set
    if (rval.m_Class)
    {
        m_Class = rval.m_Class;
    }

    // only replace values that have been set
    if (rval.m_Excludes)
    {
        m_Excludes = rval.m_Excludes;
    }

    // only replace values that have been set
    if (rval.m_CanSee)
    {
        m_CanSee = rval.m_CanSee;
    }

    // resize m_CantBuildOn if necessary
    if (rval.m_numCantBuildOn > m_numCantBuildOn)
    {
        delete [] m_CantBuildOn;
        m_CantBuildOn = NULL;
        if (rval.m_numCantBuildOn > 0)
            m_CantBuildOn = new sint32 [rval.m_numCantBuildOn];
        m_numCantBuildOn = rval.m_numCantBuildOn;
    }
    if (rval.m_numCantBuildOn > 0)
        std::copy(rval.m_CantBuildOn, rval.m_CantBuildOn + rval.m_numCantBuildOn, m_CantBuildOn);

    // resize m_GovernmentsModified if necessary
    if (rval.m_numGovernmentsModified > m_numGovernmentsModified)
    {
        delete [] m_GovernmentsModified;
        m_GovernmentsModified = NULL;
        if (rval.m_numGovernmentsModified > 0)
            m_GovernmentsModified = new sint32 [rval.m_numGovernmentsModified];
        m_numGovernmentsModified = rval.m_numGovernmentsModified;
    }
    if (rval.m_numGovernmentsModified > 0)
        std::copy(rval.m_GovernmentsModified, rval.m_GovernmentsModified + rval.m_numGovernmentsModified, m_GovernmentsModified);

    // resize m_CultureOnly if necessary
    if (rval.m_numCultureOnly > m_numCultureOnly)
    {
        delete [] m_CultureOnly;
        m_CultureOnly = NULL;
        if (rval.m_numCultureOnly > 0)
            m_CultureOnly = new sint32 [rval.m_numCultureOnly];
        m_numCultureOnly = rval.m_numCultureOnly;
    }
    if (rval.m_numCultureOnly > 0)
        std::copy(rval.m_CultureOnly, rval.m_CultureOnly + rval.m_numCultureOnly, m_CultureOnly);

    // resize m_GovernmentType if necessary
    if (rval.m_numGovernmentType > m_numGovernmentType)
    {
        delete [] m_GovernmentType;
        m_GovernmentType = NULL;
        if (rval.m_numGovernmentType > 0)
            m_GovernmentType = new sint32 [rval.m_numGovernmentType];
        m_numGovernmentType = rval.m_numGovernmentType;
    }
    if (rval.m_numGovernmentType > 0)
        std::copy(rval.m_GovernmentType, rval.m_GovernmentType + rval.m_numGovernmentType, m_GovernmentType);

    // resize m_IsRestrictedToGood if necessary
    if (rval.m_numIsRestrictedToGood > m_numIsRestrictedToGood)
    {
        delete [] m_IsRestrictedToGood;
        m_IsRestrictedToGood = NULL;
        if (rval.m_numIsRestrictedToGood > 0)
            m_IsRestrictedToGood = new sint32 [rval.m_numIsRestrictedToGood];
        m_numIsRestrictedToGood = rval.m_numIsRestrictedToGood;
    }
    if (rval.m_numIsRestrictedToGood > 0)
        std::copy(rval.m_IsRestrictedToGood, rval.m_IsRestrictedToGood + rval.m_numIsRestrictedToGood, m_IsRestrictedToGood);

    // resize m_EnablesGood if necessary
    if (rval.m_numEnablesGood > m_numEnablesGood)
    {
        delete [] m_EnablesGood;
        m_EnablesGood = NULL;
        if (rval.m_numEnablesGood > 0)
            m_EnablesGood = new sint32 [rval.m_numEnablesGood];
        m_numEnablesGood = rval.m_numEnablesGood;
    }
    if (rval.m_numEnablesGood > 0)
        std::copy(rval.m_EnablesGood, rval.m_EnablesGood + rval.m_numEnablesGood, m_EnablesGood);

    // only replace values that have been set
    if (rval.m_flags0 & k_TerrainImprovement_Effect_Bit)
    {
        m_EffectValue = rval.m_EffectValue;
    }

    // replace struct elements of m_TerrainEffect
    for (sint32 index_TerrainEffect = 0; index_TerrainEffect < m_numTerrainEffect; ++index_TerrainEffect)
    {
        // find matching struct element and replace it
        for (sint32 obj_index = 0; obj_index < rval.m_numTerrainEffect; ++obj_index)
            if (m_TerrainEffect[index_TerrainEffect] == rval.m_TerrainEffect[obj_index]){
                m_TerrainEffect[index_TerrainEffect] = rval.m_TerrainEffect[obj_index];
            }
    }
    // resize m_PrerequisiteTileImp if necessary
    if (rval.m_numPrerequisiteTileImp > m_numPrerequisiteTileImp)
    {
        delete [] m_PrerequisiteTileImp;
        m_PrerequisiteTileImp = NULL;
        if (rval.m_numPrerequisiteTileImp > 0)
            m_PrerequisiteTileImp = new sint32 [rval.m_numPrerequisiteTileImp];
        m_numPrerequisiteTileImp = rval.m_numPrerequisiteTileImp;
    }
    if (rval.m_numPrerequisiteTileImp > 0)
        std::copy(rval.m_PrerequisiteTileImp, rval.m_PrerequisiteTileImp + rval.m_numPrerequisiteTileImp, m_PrerequisiteTileImp);

    // replace array m_ConstructionTiles
    if (m_numConstructionTiles != rval.m_numConstructionTiles)
    {
        delete [] m_ConstructionTiles;
        m_ConstructionTiles = new sint32 [rval.m_numConstructionTiles];
    }
    m_numConstructionTiles = rval.m_numConstructionTiles;
    std::copy(rval.m_ConstructionTiles, rval.m_ConstructionTiles + rval.m_numConstructionTiles, m_ConstructionTiles);

    // only replace values that have been set
    if (rval.m_flags0 & k_TerrainImprovement_TerraformTerrain_Bit)
    {
        m_TerraformTerrainValue = rval.m_TerraformTerrainValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_TerrainImprovement_Column_Bit)
    {
        m_ColumnValue = rval.m_ColumnValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_TerrainImprovement_IntBorderRadius_Bit)
    {
        m_IntBorderRadiusValue = rval.m_IntBorderRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_TerrainImprovement_SquaredBorderRadius_Bit)
    {
        m_SquaredBorderRadiusValue = rval.m_SquaredBorderRadiusValue;
    }

    // only replace values that have been set
    if (rval.m_flags0 & k_TerrainImprovement_MoveBonus_Bit)
    {
        m_MoveBonusValue = rval.m_MoveBonusValue;
    }

}

SoundRecord const * TerrainImprovementRecord::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

sint32 TerrainImprovementRecord::GetCantBuildOnIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCantBuildOn);
    if((index < 0) || (index >= m_numCantBuildOn)) {
        return 0;
    }
    return m_CantBuildOn[index];
}

TerrainRecord const * TerrainImprovementRecord::GetCantBuildOn(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCantBuildOn);
    if((index < 0) || (index >= m_numCantBuildOn)) {
        return 0;
    }
    return g_theTerrainDB->Get(m_CantBuildOn[index]);
}

sint32 TerrainImprovementRecord::GetGovernmentsModifiedIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return m_GovernmentsModified[index];
}

GovernmentRecord const * TerrainImprovementRecord::GetGovernmentsModified(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentsModified);
    if((index < 0) || (index >= m_numGovernmentsModified)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentsModified[index]);
}

sint32 TerrainImprovementRecord::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

CityStyleRecord const * TerrainImprovementRecord::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

sint32 TerrainImprovementRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

GovernmentRecord const * TerrainImprovementRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

sint32 TerrainImprovementRecord::GetIsRestrictedToGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numIsRestrictedToGood);
    if((index < 0) || (index >= m_numIsRestrictedToGood)) {
        return 0;
    }
    return m_IsRestrictedToGood[index];
}

ResourceRecord const * TerrainImprovementRecord::GetIsRestrictedToGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numIsRestrictedToGood);
    if((index < 0) || (index >= m_numIsRestrictedToGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_IsRestrictedToGood[index]);
}

sint32 TerrainImprovementRecord::GetEnablesGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return m_EnablesGood[index];
}

ResourceRecord const * TerrainImprovementRecord::GetEnablesGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_EnablesGood[index]);
}

TerrainImprovementRecord::Effect const * TerrainImprovementRecord::GetTerrainEffect(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numTerrainEffect);
    if((index < 0) || (index >= m_numTerrainEffect)) {
        return 0;
    }
    return &m_TerrainEffect[index];
}

sint32 TerrainImprovementRecord::GetPrerequisiteTileImpIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteTileImp);
    if((index < 0) || (index >= m_numPrerequisiteTileImp)) {
        return 0;
    }
    return m_PrerequisiteTileImp[index];
}

TerrainImprovementRecord const * TerrainImprovementRecord::GetPrerequisiteTileImp(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisiteTileImp);
    if((index < 0) || (index >= m_numPrerequisiteTileImp)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_PrerequisiteTileImp[index]);
}

IconRecord const * TerrainImprovementRecord::GetIcon() const
{
    return g_theIconDB->Get(m_Icon);
}

sint32 TerrainImprovementRecord::GetConstructionTiles(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numConstructionTiles);
    if((index < 0) || (index >= m_numConstructionTiles)) {
        return 0;
    }
    return m_ConstructionTiles[index];
}

TerrainRecord const * TerrainImprovementRecord::GetTerraformTerrainPtr() const
{
    return g_theTerrainDB->Get(m_TerraformTerrainValue);
}

sint32 TerrainImprovementRecord::Effect::GetTerrainIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numTerrain);
    if((index < 0) || (index >= m_numTerrain)) {
        return 0;
    }
    return m_Terrain[index];
}

const TerrainRecord * TerrainImprovementRecord::Effect::GetTerrain(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numTerrain);
    if((index < 0) || (index >= m_numTerrain)) {
        return 0;
    }
    return g_theTerrainDB->Get(m_Terrain[index]);
}

sint32 TerrainImprovementRecord::Effect::GetGrowsToImprovementIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGrowsToImprovement);
    if((index < 0) || (index >= m_numGrowsToImprovement)) {
        return 0;
    }
    return m_GrowsToImprovement[index];
}

const TerrainImprovementRecord * TerrainImprovementRecord::Effect::GetGrowsToImprovement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGrowsToImprovement);
    if((index < 0) || (index >= m_numGrowsToImprovement)) {
        return 0;
    }
    return g_theTerrainImprovementDB->Get(m_GrowsToImprovement[index]);
}

sint32 TerrainImprovementRecord::Effect::GetCultureOnlyIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return m_CultureOnly[index];
}

const CityStyleRecord * TerrainImprovementRecord::Effect::GetCultureOnly(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCultureOnly);
    if((index < 0) || (index >= m_numCultureOnly)) {
        return 0;
    }
    return g_theCityStyleDB->Get(m_CultureOnly[index]);
}

const AdvanceRecord *TerrainImprovementRecord::Effect::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 TerrainImprovementRecord::Effect::GetObsoleteAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return m_ObsoleteAdvance[index];
}

const AdvanceRecord * TerrainImprovementRecord::Effect::GetObsoleteAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ObsoleteAdvance[index]);
}

sint32 TerrainImprovementRecord::Effect::GetEnablesGoodIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return m_EnablesGood[index];
}

const ResourceRecord * TerrainImprovementRecord::Effect::GetEnablesGood(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numEnablesGood);
    if((index < 0) || (index >= m_numEnablesGood)) {
        return 0;
    }
    return g_theResourceDB->Get(m_EnablesGood[index]);
}

sint32 TerrainImprovementRecord::Effect::GetIsWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numIsWonder);
    if((index < 0) || (index >= m_numIsWonder)) {
        return 0;
    }
    return m_IsWonder[index];
}

const WonderRecord * TerrainImprovementRecord::Effect::GetIsWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numIsWonder);
    if((index < 0) || (index >= m_numIsWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_IsWonder[index]);
}

