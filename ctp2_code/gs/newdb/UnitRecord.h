
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */

#if defined(HAVE_PRAGMA_ONCE)
#pragma once
#endif

#ifndef UNIT_RECORD_H__
#define UNIT_RECORD_H__

class UnitRecord;

#include "CTPDatabase.h"
#include "CTPRecord.h"
class CivArchive;
class AdvanceRecord;
class BuildingRecord;
class CityStyleRecord;
class CivilisationRecord;
class FeatRecord;
class GovernmentRecord;
class IconRecord;
class MapIconRecord;
class ResourceRecord;
class SoundRecord;
class SpecialAttackInfoRecord;
class SpriteRecord;
class TerrainRecord;
class TerrainImprovementRecord;
class WonderRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SpecialEffectRecord;

#define k_Num_UnitRecord_Tokens 425

//
// m_flags0: Unit
#define k_Unit_MoveBonus_Bit                     0x00000001
#define k_Unit_PWMoveCost_Bit                    0x00000002
#define k_Unit_MerchantGold_Bit                  0x00000004
#define k_Unit_IsGreatBuilder_Bit                0x00000008
#define k_Unit_IsGreatArtist_Bit                 0x00000010
#define k_Unit_NonLethalBombard_Bit              0x00000020
#define k_Unit_CanBombardTiles_Bit               0x00000040
#define k_Unit_CollateralTileDamage_Bit          0x00000080
#define k_Unit_PrecisionStrike_Bit               0x00000100
#define k_Unit_TargetsCivilians_Bit              0x00000200
#define k_Unit_ImmuneToHostileTerrain_Bit        0x00000400
#define k_Unit_CanRebase_Bit                     0x00000800
#define k_Unit_MultipleAttacks_Bit               0x00001000
#define k_Unit_CanBeGifted_Bit                   0x00002000
#define k_Unit_UpgradeAnywhere_Bit               0x00004000
#define k_Unit_UpgradeDoesNotHeal_Bit            0x00008000
#define k_Unit_LossMoveToDmgNone_Bit             0x00010000
#define k_Unit_LossMoveToDmgTwo_Bit              0x00020000
#define k_Unit_NoFuelThenCrash_Bit               0x00040000
#define k_Unit_TransformPartial_Bit              0x00080000
#define k_Unit_IgnoreZOC_Bit                     0x00100000
#define k_Unit_NoZoc_Bit                         0x00200000
#define k_Unit_CanCounterBombard_Bit             0x00400000
#define k_Unit_CanLiftOff_Bit                    0x00800000
#define k_Unit_SpaceLaunch_Bit                   0x01000000
#define k_Unit_SpaceLand_Bit                     0x02000000
#define k_Unit_CantCaptureCity_Bit               0x04000000
#define k_Unit_HasPopAndCanBuild_Bit             0x08000000
#define k_Unit_IsTrader_Bit                      0x10000000
#define k_Unit_ExertsMartialLaw_Bit              0x20000000
#define k_Unit_CanEntrench_Bit                   0x40000000
#define k_Unit_CanPatrol_Bit                     0x80000000
//
// m_flags1: Unit
#define k_Unit_NeedsNoSupport_Bit                0x00000001
#define k_Unit_CanExpelPop_Bit                   0x00000002
#define k_Unit_IsFlanker_Bit                     0x00000004
#define k_Unit_CanBeachAssault_Bit               0x00000008
#define k_Unit_DefendAgainstSpies_Bit            0x00000010
#define k_Unit_CanBeExpelled_Bit                 0x00000020
#define k_Unit_CanBeSued_Bit                     0x00000040
#define k_Unit_AttackFromSpaceship_Bit           0x00000080
#define k_Unit_CantBeAttacked_Bit                0x00000100
#define k_Unit_CargoPod_Bit                      0x00000200
#define k_Unit_IsFoot_Bit                        0x00000400
#define k_Unit_IsMelee_Bit                       0x00000800
#define k_Unit_IsMounted_Bit                     0x00001000
#define k_Unit_IsSiege_Bit                       0x00002000
#define k_Unit_IsWheeled_Bit                     0x00004000
#define k_Unit_IsMechanized_Bit                  0x00008000
#define k_Unit_IsHelicopter_Bit                  0x00010000
#define k_Unit_IsSubmarine_Bit                   0x00020000
#define k_Unit_IsSurfaceShip_Bit                 0x00040000
#define k_Unit_WoodenShip_Bit                    0x00080000
#define k_Unit_NoLandAttack_Bit                  0x00100000
#define k_Unit_NoSeaAttack_Bit                   0x00200000
#define k_Unit_NoAirAttack_Bit                   0x00400000
#define k_Unit_NoSpaceAttack_Bit                 0x00800000
#define k_Unit_NoUnderwaterAttack_Bit            0x01000000
#define k_Unit_NoMountainAttack_Bit              0x02000000
#define k_Unit_NoShallowWaterAttack_Bit          0x04000000
#define k_Unit_SingleUse_Bit                     0x08000000
#define k_Unit_Paratrooper_Bit                   0x10000000
#define k_Unit_AssistedDrops_Bit                 0x20000000
#define k_Unit_DefendAirBonus_Bit                0x40000000
#define k_Unit_DefendCityBonus_Bit               0x80000000
//
// m_flags2: Unit
#define k_Unit_DefendSubmarineBonus_Bit          0x00000001
#define k_Unit_DefendFootBonus_Bit               0x00000002
#define k_Unit_DefendMeleeBonus_Bit              0x00000004
#define k_Unit_DefendSiegeBonus_Bit              0x00000008
#define k_Unit_DefendWheeledBonus_Bit            0x00000010
#define k_Unit_DefendMechanizedBonus_Bit         0x00000020
#define k_Unit_DefendHelicopterBonus_Bit         0x00000040
#define k_Unit_DefendSpecialForcesBonus_Bit      0x00000080
#define k_Unit_DefendCivilianBonus_Bit           0x00000100
#define k_Unit_DefendGuerrillaBonus_Bit          0x00000200
#define k_Unit_DefendMountedBonus_Bit            0x00000400
#define k_Unit_DefendWoodenShipBonus_Bit         0x00000800
#define k_Unit_DefendSurfaceShipBonus_Bit        0x00001000
#define k_Unit_NoDefenseBonuses_Bit              0x00002000
#define k_Unit_AttackAirBonus_Bit                0x00004000
#define k_Unit_AttackCityBonus_Bit               0x00008000
#define k_Unit_AttackSubmarineBonus_Bit          0x00010000
#define k_Unit_AttackFootBonus_Bit               0x00020000
#define k_Unit_AttackMeleeBonus_Bit              0x00040000
#define k_Unit_AttackSiegeBonus_Bit              0x00080000
#define k_Unit_AttackWheeledBonus_Bit            0x00100000
#define k_Unit_AttackMechanizedBonus_Bit         0x00200000
#define k_Unit_AttackHelicopterBonus_Bit         0x00400000
#define k_Unit_AttackSpecialForcesBonus_Bit      0x00800000
#define k_Unit_AttackCivilianBonus_Bit           0x01000000
#define k_Unit_AttackGuerrillaBonus_Bit          0x02000000
#define k_Unit_AttackMountedBonus_Bit            0x04000000
#define k_Unit_AttackWoodenShipBonusNew_Bit      0x08000000
#define k_Unit_AttackSurfaceShipBonus_Bit        0x10000000
#define k_Unit_RangedAirBonus_Bit                0x20000000
#define k_Unit_RangedAttackCityBonus_Bit         0x40000000
#define k_Unit_RangedDefendCityBonus_Bit         0x80000000
//
// m_flags3: Unit
#define k_Unit_RangedSubmarineBonus_Bit          0x00000001
#define k_Unit_RangedFootBonus_Bit               0x00000002
#define k_Unit_RangedMeleeBonus_Bit              0x00000004
#define k_Unit_RangedSiegeBonus_Bit              0x00000008
#define k_Unit_RangedWheeledBonus_Bit            0x00000010
#define k_Unit_RangedMechanizedBonus_Bit         0x00000020
#define k_Unit_RangedHelicopterBonus_Bit         0x00000040
#define k_Unit_RangedSpecialForcesBonus_Bit      0x00000080
#define k_Unit_RangedCivilianBonus_Bit           0x00000100
#define k_Unit_RangedGuerrillaBonus_Bit          0x00000200
#define k_Unit_RangedMountedBonus_Bit            0x00000400
#define k_Unit_RangedWoodenShipBonus_Bit         0x00000800
#define k_Unit_RangedSurfaceShipBonus_Bit        0x00001000
#define k_Unit_IgnoreCityWalls_Bit               0x00002000
#define k_Unit_AlwaysHeal_Bit                    0x00004000
#define k_Unit_AttackWoodenShipBonus_Bit         0x00008000
#define k_Unit_WoodenShipBonus_Bit               0x00010000
#define k_Unit_BonusAgainstMounted_Bit           0x00020000
#define k_Unit_MountedBonus_Bit                  0x00040000
#define k_Unit_BonusAirDefense_Bit               0x00080000
#define k_Unit_AirBonus_Bit                      0x00100000
#define k_Unit_ReplaceWithCargoModule_Bit        0x00200000
#define k_Unit_VisibileAttacking_Bit             0x00400000
#define k_Unit_NuclearAttack_Bit                 0x00800000
#define k_Unit_CanSue_Bit                        0x01000000
#define k_Unit_IsStealthy_Bit                    0x02000000
#define k_Unit_SeeSurfaceFromSpace_Bit           0x04000000
#define k_Unit_EstablishEmbassy_Bit              0x08000000
#define k_Unit_ThrowParty_Bit                    0x10000000
#define k_Unit_HearGossip_Bit                    0x20000000
#define k_Unit_StealTechnology_Bit               0x40000000
#define k_Unit_InciteRevolution_Bit              0x80000000
//
// m_flags4: Unit
#define k_Unit_AssasinateRuler_Bit               0x00000001
#define k_Unit_InvestigateReadiness_Bit          0x00000002
#define k_Unit_NullifyCityWalls_Bit              0x00000004
#define k_Unit_CreateFranchise_Bit               0x00000008
#define k_Unit_CauseUnhappiness_Bit              0x00000010
#define k_Unit_ConductHits_Bit                   0x00000020
#define k_Unit_BioTerror_Bit                     0x00000040
#define k_Unit_NanoTerror_Bit                    0x00000080
#define k_Unit_Plague_Bit                        0x00000100
#define k_Unit_SlaveRaids_Bit                    0x00000200
#define k_Unit_SettlerSlaveRaids_Bit             0x00000400
#define k_Unit_SlaveUprising_Bit                 0x00000800
#define k_Unit_UndergroundRailway_Bit            0x00001000
#define k_Unit_VictoryEnslavement_Bit            0x00002000
#define k_Unit_VictoryEnslavementChance_Bit      0x00004000
#define k_Unit_VictoryEnslavementStacks_Bit      0x00008000
#define k_Unit_DefuseLandMines_Bit               0x00010000
#define k_Unit_DefuseSeaMines_Bit                0x00020000
#define k_Unit_DefuseXrayMines_Bit               0x00040000
#define k_Unit_IndulgenceSales_Bit               0x00080000
#define k_Unit_ConvertCities_Bit                 0x00100000
#define k_Unit_BuildXrayMines_Bit                0x00200000
#define k_Unit_BuildWonder_Bit                   0x00400000
#define k_Unit_NoSlaves_Bit                      0x00800000
#define k_Unit_CreateRift_Bit                    0x01000000
#define k_Unit_CanCloak_Bit                      0x02000000
#define k_Unit_HiddenNationality_Bit             0x04000000
#define k_Unit_SneakAttack_Bit                   0x08000000
#define k_Unit_SneakPillage_Bit                  0x10000000
#define k_Unit_SneakBombard_Bit                  0x20000000
#define k_Unit_ParatrooperTransport_Bit          0x40000000
#define k_Unit_CantBuild_Bit                     0x80000000
//
// m_flags5: Unit
#define k_Unit_PlantNuke_Bit                     0x00000001
#define k_Unit_IsTelevangelist_Bit               0x00000002
#define k_Unit_CanSoothsay_Bit                   0x00000004
#define k_Unit_CanBeRustled_Bit                  0x00000008
#define k_Unit_CreateParks_Bit                   0x00000010
#define k_Unit_CanInjoin_Bit                     0x00000020
#define k_Unit_WormholeProbe_Bit                 0x00000040
#define k_Unit_HasBonusFood_Bit                  0x00000080
#define k_Unit_LandCityCanBuild_Bit              0x00000100
#define k_Unit_SeaCityCanBuild_Bit               0x00000200
#define k_Unit_SpaceCityCanBuild_Bit             0x00000400
#define k_Unit_IsSpecialForces_Bit               0x00000800
#define k_Unit_IsPeaceKeeper_Bit                 0x00001000
#define k_Unit_IsGuerrilla_Bit                   0x00002000
#define k_Unit_IsWorker_Bit                      0x00004000
#define k_Unit_NotAffectedByLandMines_Bit        0x00008000
#define k_Unit_InternalReserved_Bit              0x00010000
#define k_Unit_DeathEffectsHappy_Bit             0x00020000
#define k_Unit_EnableCarrierDefenses_Bit         0x00040000
#define k_Unit_ActiveDefenseOnlyWhenCarryingEnablers_Bit 0x00080000
#define k_Unit_BuildingRemovesAPop_Bit           0x00100000
#define k_Unit_PopCostsToBuild_Bit               0x00200000
#define k_Unit_Explodes_Bit                      0x00400000
#define k_Unit_Advertise_Bit                     0x00800000
#define k_Unit_CanRustle_Bit                     0x01000000
#define k_Unit_OnlyBuildOne_Bit                  0x02000000
#define k_Unit_CanExpel_Bit                      0x04000000
#define k_Unit_CanReform_Bit                     0x08000000
#define k_Unit_CanPillage_Bit                    0x10000000
#define k_Unit_CanPirate_Bit                     0x20000000
#define k_Unit_CanCaptureTile_Bit                0x40000000
#define k_Unit_CargoData_Bit                     0x80000000
//
// m_flags6: Unit
#define k_Unit_BRange_Bit                        0x00000001
#define k_Unit_BRadius_Bit                       0x00000002
#define k_Unit_ElectronicCombatFactor_Bit        0x00000004
#define k_Unit_TransType_Bit                     0x00000008
#define k_Unit_ProbOfBombHit_Bit                 0x00000010
#define k_Unit_BombRounds_Bit                    0x00000020
#define k_Unit_LaunchPollution_Bit               0x00000040
#define k_Unit_DeathPollution_Bit                0x00000080
#define k_Unit_CargoModule_Bit                   0x00000100
#define k_Unit_SpyVsSpy_Bit                      0x00000200
#define k_Unit_InvestigateCity_Bit               0x00000400
#define k_Unit_BonusFood_Bit                     0x00000800
#define k_Unit_BombardRange_Bit                  0x00001000
#define k_Unit_Revolution_Bit                    0x00002000
#define k_Unit_CityGrowthCoefficient_Bit         0x00004000
#define k_Unit_NoIndex_Bit                       0x00008000
#define k_Unit_CheatIndex_Bit                    0x00010000
#define k_Unit_Advice_Bit                        0x00020000
#define k_Unit_GLHidden_Bit                      0x00040000
#define k_Unit_CantMove_Bit                      0x00080000
#define k_Unit_Civilian_Bit                      0x00100000
#define k_Unit_InvisibleForGlobeSat_Bit          0x00200000
#define k_Unit_NoBarbarian_Bit                   0x00400000
#define k_Unit_GoodyHutExcluded_Bit              0x00800000
#define k_Unit_CanHarvest_Bit                    0x01000000
#define k_Unit_CantGroup_Bit                     0x02000000
#define k_Unit_SpawnsBarbarians_Bit              0x04000000
#define k_Unit_CanSinkInSea_Bit                  0x08000000
#define k_Unit_Leader_Bit                        0x10000000
#define k_Unit_ArmyMountedBonus_Bit              0x20000000
#define k_Unit_ArmyAirBonus_Bit                  0x40000000
#define k_Unit_ArmyWoodenShipBonus_Bit           0x80000000
//
// m_flags7: Unit
#define k_Unit_ArmyAttackCityBonus_Bit           0x00000001
#define k_Unit_ArmyAttackBonusSubmarine_Bit      0x00000002
#define k_Unit_ArmyFootBonus_Bit                 0x00000004
#define k_Unit_ArmyMeleeBonus_Bit                0x00000008
#define k_Unit_ArmySiegeBonus_Bit                0x00000010
#define k_Unit_ArmyWheeledBonus_Bit              0x00000020
#define k_Unit_ArmyMechanizedBonus_Bit           0x00000040
#define k_Unit_ArmyHelicopterBonus_Bit           0x00000080
#define k_Unit_ArmySpecialForcesBonus_Bit        0x00000100
#define k_Unit_ArmyCivilianBonus_Bit             0x00000200
#define k_Unit_ArmyGuerrillaBonus_Bit            0x00000400
#define k_Unit_ArmyAgainstMountedBonus_Bit       0x00000800
#define k_Unit_ArmyAirDefenseBonus_Bit           0x00001000
#define k_Unit_HasReligionIcon_Bit               0x00002000
//
// m_MovementType bit group
#define k_Unit_MovementType_Land_Bit             0x00000001
#define k_Unit_MovementType_Sea_Bit              0x00000002
#define k_Unit_MovementType_Air_Bit              0x00000004
#define k_Unit_MovementType_Mountain_Bit         0x00000008
#define k_Unit_MovementType_Trade_Bit            0x00000010
#define k_Unit_MovementType_ShallowWater_Bit     0x00000020
#define k_Unit_MovementType_Space_Bit            0x00000040
//
// m_CanCarry bit group
#define k_Unit_CanCarry_SmallLand_Bit            0x00000001
#define k_Unit_CanCarry_MedLand_Bit              0x00000002
#define k_Unit_CanCarry_LargeLand_Bit            0x00000004
#define k_Unit_CanCarry_SmallAir_Bit             0x00000008
#define k_Unit_CanCarry_MedAir_Bit               0x00000010
#define k_Unit_CanCarry_LargeAir_Bit             0x00000020
#define k_Unit_CanCarry_SmallWater_Bit           0x00000040
#define k_Unit_CanCarry_MedWater_Bit             0x00000080
#define k_Unit_CanCarry_LargeWater_Bit           0x00000100
#define k_Unit_CanCarry_SmallSpace_Bit           0x00000200
#define k_Unit_CanCarry_MedSpace_Bit             0x00000400
#define k_Unit_CanCarry_LargeSpace_Bit           0x00000800
//
// m_Size bit group
#define k_Unit_Size_Small_Bit                    0x00000001
#define k_Unit_Size_Medium_Bit                   0x00000002
#define k_Unit_Size_Large_Bit                    0x00000004
//
// m_CanBombard bit group
#define k_Unit_CanBombard_Land_Bit               0x00000001
#define k_Unit_CanBombard_Air_Bit                0x00000002
#define k_Unit_CanBombard_Water_Bit              0x00000004
#define k_Unit_CanBombard_Space_Bit              0x00000008
#define k_Unit_CanBombard_Mountain_Bit           0x00000010
//
// m_Settle bit group
#define k_Unit_Settle_Land_Bit                   0x00000001
#define k_Unit_Settle_Water_Bit                  0x00000002
#define k_Unit_Settle_Mountain_Bit               0x00000004
#define k_Unit_Settle_Space_Bit                  0x00000008
//
// m_Defend bit group
#define k_Unit_Defend_Land_Bit                   0x00000001
#define k_Unit_Defend_Air_Bit                    0x00000002
#define k_Unit_Defend_Water_Bit                  0x00000004
#define k_Unit_Defend_Space_Bit                  0x00000008
#define k_Unit_Defend_Mountain_Bit               0x00000010
//
// m_VisionClass bit group
#define k_Unit_VisionClass_Standard_Bit          0x00000001
#define k_Unit_VisionClass_Underwater_Bit        0x00000002
#define k_Unit_VisionClass_Stealth_Bit           0x00000004
#define k_Unit_VisionClass_UnusedBit3_Bit        0x00000008
#define k_Unit_VisionClass_UnusedBit4_Bit        0x00000010
#define k_Unit_VisionClass_UnusedBit5_Bit        0x00000020
#define k_Unit_VisionClass_UnusedBit6_Bit        0x00000040
#define k_Unit_VisionClass_UnusedBit7_Bit        0x00000080
#define k_Unit_VisionClass_UnusedBit8_Bit        0x00000100
#define k_Unit_VisionClass_UnusedBit9_Bit        0x00000200
#define k_Unit_VisionClass_UnusedBit10_Bit       0x00000400
#define k_Unit_VisionClass_UnusedBit11_Bit       0x00000800
#define k_Unit_VisionClass_UnusedBit12_Bit       0x00001000
#define k_Unit_VisionClass_UnusedBit13_Bit       0x00002000
#define k_Unit_VisionClass_UnusedBit14_Bit       0x00004000
#define k_Unit_VisionClass_UnusedBit15_Bit       0x00008000
//
// m_CanSee bit group
#define k_Unit_CanSee_Standard_Bit               0x00000001
#define k_Unit_CanSee_Underwater_Bit             0x00000002
#define k_Unit_CanSee_Stealth_Bit                0x00000004
#define k_Unit_CanSee_UnusedBit3_Bit             0x00000008
#define k_Unit_CanSee_UnusedBit4_Bit             0x00000010
#define k_Unit_CanSee_UnusedBit5_Bit             0x00000020
#define k_Unit_CanSee_UnusedBit6_Bit             0x00000040
#define k_Unit_CanSee_UnusedBit7_Bit             0x00000080
#define k_Unit_CanSee_UnusedBit8_Bit             0x00000100
#define k_Unit_CanSee_UnusedBit9_Bit             0x00000200
#define k_Unit_CanSee_UnusedBit10_Bit            0x00000400
#define k_Unit_CanSee_UnusedBit11_Bit            0x00000800
#define k_Unit_CanSee_UnusedBit12_Bit            0x00001000
#define k_Unit_CanSee_UnusedBit13_Bit            0x00002000
#define k_Unit_CanSee_UnusedBit14_Bit            0x00004000
#define k_Unit_CanSee_UnusedBit15_Bit            0x00008000
//
// m_CanAttack bit group
#define k_Unit_CanAttack_Land_Bit                0x00000001
#define k_Unit_CanAttack_Sea_Bit                 0x00000002
#define k_Unit_CanAttack_Air_Bit                 0x00000004
#define k_Unit_CanAttack_Mountain_Bit            0x00000008
#define k_Unit_CanAttack_Trade_Bit               0x00000010
#define k_Unit_CanAttack_ShallowWater_Bit        0x00000020
#define k_Unit_CanAttack_Space_Bit               0x00000040
#define k_Unit_CanAttack_Underwater_Bit          0x00000080
//
// m_UserFlags bit group
#define k_Unit_UserFlags_UF1_Bit                 0x00000001
#define k_Unit_UserFlags_UF2_Bit                 0x00000002
#define k_Unit_UserFlags_UF3_Bit                 0x00000004
#define k_Unit_UserFlags_UF4_Bit                 0x00000008
#define k_Unit_UserFlags_UF5_Bit                 0x00000010
#define k_Unit_UserFlags_UF6_Bit                 0x00000020
#define k_Unit_UserFlags_UF7_Bit                 0x00000040
#define k_Unit_UserFlags_UF8_Bit                 0x00000080
#define k_Unit_UserFlags_UF9_Bit                 0x00000100
#define k_Unit_UserFlags_UF10_Bit                0x00000200
#define k_Unit_UserFlags_UF11_Bit                0x00000400
#define k_Unit_UserFlags_UF12_Bit                0x00000800
#define k_Unit_UserFlags_UF13_Bit                0x00001000
#define k_Unit_UserFlags_UF14_Bit                0x00002000
#define k_Unit_UserFlags_UF15_Bit                0x00004000
#define k_Unit_UserFlags_UF16_Bit                0x00008000
#define k_Unit_UserFlags_UF17_Bit                0x00010000
#define k_Unit_UserFlags_UF18_Bit                0x00020000
#define k_Unit_UserFlags_UF19_Bit                0x00040000
#define k_Unit_UserFlags_UF20_Bit                0x00080000
#define k_Unit_UserFlags_UF21_Bit                0x00100000
#define k_Unit_UserFlags_UF22_Bit                0x00200000
#define k_Unit_UserFlags_UF23_Bit                0x00400000
#define k_Unit_UserFlags_UF24_Bit                0x00800000
#define k_Unit_UserFlags_UF25_Bit                0x01000000
#define k_Unit_UserFlags_UF26_Bit                0x02000000
#define k_Unit_UserFlags_UF27_Bit                0x04000000
#define k_Unit_UserFlags_UF28_Bit                0x08000000
#define k_Unit_UserFlags_UF29_Bit                0x10000000
#define k_Unit_UserFlags_UF30_Bit                0x20000000
#define k_Unit_UserFlags_UF31_Bit                0x40000000
#define k_MAX_ObsoleteAdvance                5
#define k_MAX_SpecialAttacks                 8

class UnitRecord : public CTPRecord
{
public:
    typedef sint32 (UnitRecord::*IntAccessor)() const;
    typedef bool   (UnitRecord::*BoolAccessor)() const;
    typedef double (UnitRecord::*FloatAccessor)() const ;
    typedef bool   (UnitRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool   (UnitRecord::*BitFloatAccessor)(double &val) const;
    typedef sint32 (UnitRecord::*IntArrayAccessor)(sint32 index) const;
    typedef double (UnitRecord::*FloatArrayAccessor)(sint32 index) const;

    class SuccessDeath {
    private:
        double            m_Chance;
        double            m_DeathChance;

    public:
        SuccessDeath();
        SuccessDeath(CivArchive & archive){ Serialize(archive); };
        ~SuccessDeath();
        SuccessDeath const & operator = (SuccessDeath const & rval);
        bool operator == (SuccessDeath const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeath **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, SuccessDeath **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetDeathChance() const { return m_DeathChance; }

    }; /* class SuccessDeath */

    class SuccessDeathEffect {
    private:
        double            m_Chance;
        double            m_DeathChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        SuccessDeathEffect();
        SuccessDeathEffect(CivArchive & archive){ Serialize(archive); };
        ~SuccessDeathEffect();
        SuccessDeathEffect const & operator = (SuccessDeathEffect const & rval);
        bool operator == (SuccessDeathEffect const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetDeathChance() const { return m_DeathChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class SuccessDeathEffect */

    class StealTechnologyData {
    private:
        double            m_RandomChance;
        double            m_SpecificChance;
        double            m_DeathChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        StealTechnologyData();
        StealTechnologyData(CivArchive & archive){ Serialize(archive); };
        ~StealTechnologyData();
        StealTechnologyData const & operator = (StealTechnologyData const & rval);
        bool operator == (StealTechnologyData const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, StealTechnologyData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, StealTechnologyData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetRandomChance() const { return m_RandomChance; }
        double GetSpecificChance() const { return m_SpecificChance; }
        double GetDeathChance() const { return m_DeathChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class StealTechnologyData */

    class InciteRevolutionData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        InciteRevolutionData();
        InciteRevolutionData(CivArchive & archive){ Serialize(archive); };
        ~InciteRevolutionData();
        InciteRevolutionData const & operator = (InciteRevolutionData const & rval);
        bool operator == (InciteRevolutionData const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetEliteChance() const { return m_EliteChance; }
        double GetDeathChance() const { return m_DeathChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class InciteRevolutionData */

    class AssasinateRulerData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;

    public:
        AssasinateRulerData();
        AssasinateRulerData(CivArchive & archive){ Serialize(archive); };
        ~AssasinateRulerData();
        AssasinateRulerData const & operator = (AssasinateRulerData const & rval);
        bool operator == (AssasinateRulerData const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetEliteChance() const { return m_EliteChance; }
        double GetDeathChance() const { return m_DeathChance; }

    }; /* class AssasinateRulerData */

    class InvestigateReadinessData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;

    public:
        InvestigateReadinessData();
        InvestigateReadinessData(CivArchive & archive){ Serialize(archive); };
        ~InvestigateReadinessData();
        InvestigateReadinessData const & operator = (InvestigateReadinessData const & rval);
        bool operator == (InvestigateReadinessData const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetEliteChance() const { return m_EliteChance; }
        double GetDeathChance() const { return m_DeathChance; }

    }; /* class InvestigateReadinessData */

    class ChanceEffect {
    private:
        double            m_Chance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        ChanceEffect();
        ChanceEffect(CivArchive & archive){ Serialize(archive); };
        ~ChanceEffect();
        ChanceEffect const & operator = (ChanceEffect const & rval);
        bool operator == (ChanceEffect const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, ChanceEffect **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, ChanceEffect **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class ChanceEffect */

    class CauseUnhappinessData {
    private:
        double            m_Chance;
        sint32            m_Timer;
        sint32            m_Amount;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        CauseUnhappinessData();
        CauseUnhappinessData(CivArchive & archive){ Serialize(archive); };
        ~CauseUnhappinessData();
        CauseUnhappinessData const & operator = (CauseUnhappinessData const & rval);
        bool operator == (CauseUnhappinessData const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        sint32 GetTimer() const { return m_Timer; }
        sint32 GetAmount() const { return m_Amount; }
        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class CauseUnhappinessData */

    class SlaveRaidsData {
    private:
        double            m_Chance;
        double            m_DeathChance;
        sint32            m_Timer;
        sint32            m_Amount;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        SlaveRaidsData();
        SlaveRaidsData(CivArchive & archive){ Serialize(archive); };
        ~SlaveRaidsData();
        SlaveRaidsData const & operator = (SlaveRaidsData const & rval);
        bool operator == (SlaveRaidsData const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetDeathChance() const { return m_DeathChance; }
        sint32 GetTimer() const { return m_Timer; }
        sint32 GetAmount() const { return m_Amount; }
        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class SlaveRaidsData */

    class SoundAndEffect {
    private:
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        SoundAndEffect();
        SoundAndEffect(CivArchive & archive){ Serialize(archive); };
        ~SoundAndEffect();
        SoundAndEffect const & operator = (SoundAndEffect const & rval);
        bool operator == (SoundAndEffect const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SoundAndEffect **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, SoundAndEffect **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class SoundAndEffect */

    class PlantNukeData {
    private:
        double            m_Chance;
        double            m_EscapeChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        PlantNukeData();
        PlantNukeData(CivArchive & archive){ Serialize(archive); };
        ~PlantNukeData();
        PlantNukeData const & operator = (PlantNukeData const & rval);
        bool operator == (PlantNukeData const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, PlantNukeData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, PlantNukeData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetEscapeChance() const { return m_EscapeChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class PlantNukeData */

    class CargoData {
    private:
        sint32            m_MaxCargo;
        sint32            m_Load; // Index into Sound database
        sint32            m_Unload; // Index into Sound database

    public:
        CargoData();
        CargoData(CivArchive & archive){ Serialize(archive); };
        ~CargoData();
        CargoData const & operator = (CargoData const & rval);
        bool operator == (CargoData const & rval) {
          if (m_Load != rval.m_Load)
             return false;
          if (m_Unload != rval.m_Unload)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, CargoData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, CargoData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        sint32 GetMaxCargo() const { return m_MaxCargo; }
        sint32           GetLoadIndex() const { return m_Load; }
        SoundRecord const * GetLoad() const;
        sint32           GetUnloadIndex() const { return m_Unload; }
        SoundRecord const * GetUnload() const;

    }; /* class CargoData */

    class InvestigateCityData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;

    public:
        InvestigateCityData();
        InvestigateCityData(CivArchive & archive){ Serialize(archive); };
        ~InvestigateCityData();
        InvestigateCityData const & operator = (InvestigateCityData const & rval);
        bool operator == (InvestigateCityData const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, InvestigateCityData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, InvestigateCityData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetChance() const { return m_Chance; }
        double GetEliteChance() const { return m_EliteChance; }
        double GetDeathChance() const { return m_DeathChance; }

    }; /* class InvestigateCityData */

    class RevolutionData {
    private:
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database

    public:
        RevolutionData();
        RevolutionData(CivArchive & archive){ Serialize(archive); };
        ~RevolutionData();
        RevolutionData const & operator = (RevolutionData const & rval);
        bool operator == (RevolutionData const & rval) {
          if (m_Sound != rval.m_Sound)
             return false;
          if (m_Effect != rval.m_Effect)
             return false;
          return true;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, RevolutionData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, RevolutionData **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        sint32           GetSoundIndex() const { return m_Sound; }
        SoundRecord const * GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
        SpecialEffectRecord const * GetEffect() const;

    }; /* class RevolutionData */

private:
    uint32 m_flags0;
    uint32 m_flags1;
    uint32 m_flags2;
    uint32 m_flags3;
    uint32 m_flags4;
    uint32 m_flags5;
    uint32 m_flags6;
    uint32 m_flags7;
    uint32            m_MovementType;
    uint32            m_CanCarry;
    sint32            m_EnableAdvance; // Index into Advance database
    sint32            m_ObsoleteAdvance[k_MAX_ObsoleteAdvance]; // Index into Advance database
    sint32            m_numObsoleteAdvance;
    sint32          * m_PrerequisiteBuilding; // Index into Building database
    sint32            m_numPrerequisiteBuilding;
    sint32          * m_ExcludedByBuilding; // Index into Building database
    sint32            m_numExcludedByBuilding;
    sint32          * m_GovernmentsModified; // Index into Government database
    sint32            m_numGovernmentsModified;
    sint32          * m_CanSettleOn; // Index into Terrain database
    sint32            m_numCanSettleOn;
    sint32          * m_UpgradeTo; // Index into Unit database
    sint32            m_numUpgradeTo;
    sint32          * m_ObsoleteUnit; // Index into Unit database
    sint32            m_numObsoleteUnit;
    sint32          * m_CultureOnly; // Index into CityStyle database
    sint32            m_numCultureOnly;
    sint32          * m_CityStyleOnly; // Index into CityStyle database
    sint32            m_numCityStyleOnly;
    sint32          * m_CivilisationOnly; // Index into Civilisation database
    sint32            m_numCivilisationOnly;
    sint32          * m_GovernmentOnly; // Index into Government database
    sint32            m_numGovernmentOnly;
    sint32          * m_SettleImprovement; // Index into TerrainImprovement database
    sint32            m_numSettleImprovement;
    sint32          * m_NeedsCityGood; // Index into Resource database
    sint32            m_numNeedsCityGood;
    sint32          * m_NeedsCityGoodAll; // Index into Resource database
    sint32            m_numNeedsCityGoodAll;
    sint32          * m_NeedsCityGoodCapitol; // Index into Resource database
    sint32            m_numNeedsCityGoodCapitol;
    sint32          * m_NeedsCityGoodAnyCity; // Index into Resource database
    sint32            m_numNeedsCityGoodAnyCity;
    sint32          * m_NeedsFeatToBuild; // Index into Feat database
    sint32            m_numNeedsFeatToBuild;
    sint32          * m_NeedsAnyPlayerFeatToBuild; // Index into Feat database
    sint32            m_numNeedsAnyPlayerFeatToBuild;
    sint32          * m_PrerequisiteWonder; // Index into Wonder database
    sint32            m_numPrerequisiteWonder;
    sint32          * m_ExcludedByWonder; // Index into Wonder database
    sint32            m_numExcludedByWonder;
    sint32            m_MoveBonusValue;
    sint32            m_PWMoveCostValue;
    sint32            m_MerchantGoldValue;
    sint32          * m_AllTerrainAsImprovement; // Index into TerrainImprovement database
    sint32            m_numAllTerrainAsImprovement;
    sint32          * m_ObsoleteByUnit; // Index into Unit database
    sint32            m_numObsoleteByUnit;
    uint32            m_Size;
    uint32            m_CanBombard;
    uint32            m_Settle;
    sint32            m_SettleCityType; // Index into Unit database
    sint32            m_SettleSize;
    sint32          * m_SettleBuilding; // Index into Building database
    sint32            m_numSettleBuilding;
    sint32          * m_EstablishBuilding; // Index into Building database
    sint32            m_numEstablishBuilding;
    sint32            m_SpaceLaunchValue;
    uint32            m_Defend;
    double            m_DefendAgainstSpiesValue;
    double            m_DefendAirBonusValue;
    double            m_DefendCityBonusValue;
    double            m_DefendSubmarineBonusValue;
    double            m_DefendFootBonusValue;
    double            m_DefendMeleeBonusValue;
    double            m_DefendSiegeBonusValue;
    double            m_DefendWheeledBonusValue;
    double            m_DefendMechanizedBonusValue;
    double            m_DefendHelicopterBonusValue;
    double            m_DefendSpecialForcesBonusValue;
    double            m_DefendCivilianBonusValue;
    double            m_DefendGuerrillaBonusValue;
    double            m_DefendMountedBonusValue;
    double            m_DefendWoodenShipBonusValue;
    double            m_DefendSurfaceShipBonusValue;
    double            m_AttackAirBonusValue;
    double            m_AttackCityBonusValue;
    double            m_AttackSubmarineBonusValue;
    double            m_AttackFootBonusValue;
    double            m_AttackMeleeBonusValue;
    double            m_AttackSiegeBonusValue;
    double            m_AttackWheeledBonusValue;
    double            m_AttackMechanizedBonusValue;
    double            m_AttackHelicopterBonusValue;
    double            m_AttackSpecialForcesBonusValue;
    double            m_AttackCivilianBonusValue;
    double            m_AttackGuerrillaBonusValue;
    double            m_AttackMountedBonusValue;
    double            m_AttackWoodenShipBonusNewValue;
    double            m_AttackSurfaceShipBonusValue;
    double            m_RangedAirBonusValue;
    double            m_RangedAttackCityBonusValue;
    double            m_RangedDefendCityBonusValue;
    double            m_RangedSubmarineBonusValue;
    double            m_RangedFootBonusValue;
    double            m_RangedMeleeBonusValue;
    double            m_RangedSiegeBonusValue;
    double            m_RangedWheeledBonusValue;
    double            m_RangedMechanizedBonusValue;
    double            m_RangedHelicopterBonusValue;
    double            m_RangedSpecialForcesBonusValue;
    double            m_RangedCivilianBonusValue;
    double            m_RangedGuerrillaBonusValue;
    double            m_RangedMountedBonusValue;
    double            m_RangedWoodenShipBonusValue;
    double            m_RangedSurfaceShipBonusValue;
    double            m_WoodenShipBonusValue;
    double            m_MountedBonusValue;
    double            m_AirBonusValue;
    sint32            m_ReplaceWithCargoModuleValue;
    SoundAndEffect    m_NuclearAttackValue;
    StealTechnologyData   m_StealTechnologyValue;
    InciteRevolutionData   m_InciteRevolutionValue;
    AssasinateRulerData   m_AssasinateRulerValue;
    InvestigateReadinessData   m_InvestigateReadinessValue;
    ChanceEffect      m_CreateFranchiseValue;
    CauseUnhappinessData   m_CauseUnhappinessValue;
    SoundAndEffect    m_ConductHitsValue;
    ChanceEffect      m_BioTerrorValue;
    ChanceEffect      m_NanoTerrorValue;
    ChanceEffect      m_PlagueValue;
    SlaveRaidsData    m_SlaveRaidsValue;
    SoundAndEffect    m_SettlerSlaveRaidsValue;
    SoundAndEffect    m_SlaveUprisingValue;
    SuccessDeathEffect   m_UndergroundRailwayValue;
    double            m_VictoryEnslavementChanceValue;
    SoundAndEffect    m_IndulgenceSalesValue;
    SuccessDeathEffect   m_ConvertCitiesValue;
    sint32          * m_GovernmentType; // Index into Government database
    sint32            m_numGovernmentType;
    PlantNukeData     m_PlantNukeValue;
    SoundAndEffect    m_CanSoothsayValue;
    SoundAndEffect    m_CreateParksValue;
    SoundAndEffect    m_CanInjoinValue;
    sint32            m_PopCostsToBuildValue;
    SoundAndEffect    m_CanReformValue;
    sint32            m_ReducesDefensesBonus;
    uint32            m_VisionClass;
    uint32            m_CanSee;
    uint32            m_CanAttack;
    CargoData         m_CargoDataValue;
    sint32            m_ShieldCost;
    sint32            m_PowerPoints;
    sint32            m_MaxHP;
    double            m_MaxHPr;
    double            m_Attack;
    double            m_Defense;
    sint32            m_Firepower;
    sint32            m_ZBRangeAttack;
    double            m_Armor;
    sint32            m_BRangeValue;
    sint32            m_BRadiusValue;
    sint32            m_VisionRange;
    sint32            m_ActiveDefenseRange;
    sint32            m_ElectronicCombatFactorValue;
    double            m_MaxMovePoints;
    sint32            m_MaxFuel;
    sint32            m_TransTypeValue;
    sint32            m_ProbOfBombHitValue;
    sint32            m_BombRoundsValue;
    sint32            m_ShieldHunger;
    sint32            m_FoodHunger;
    sint32            m_GoldHunger;
    sint32            m_DefaultSprite; // Index into Sprite database
    sint32            m_LaunchPollutionValue;
    sint32            m_DeathPollutionValue;
    sint32            m_CargoModuleValue;
    double            m_SpyVsSpyValue;
    InvestigateCityData   m_InvestigateCityValue;
    sint32            m_BonusFoodValue;
    sint32            m_BombardRangeValue;
    RevolutionData    m_RevolutionValue;
    sint32            m_SoundSelect1; // Index into Sound database
    sint32            m_SoundSelect2; // Index into Sound database
    sint32            m_SoundMove; // Index into Sound database
    sint32            m_SoundAcknowledge; // Index into Sound database
    sint32            m_SoundCantMove; // Index into Sound database
    sint32            m_SoundAttack; // Index into Sound database
    sint32            m_SoundWork; // Index into Sound database
    sint32            m_SoundVictory; // Index into Sound database
    sint32            m_SoundDeath; // Index into Sound database
    sint32            m_SoundLoad; // Index into Sound database
    sint32            m_SoundUnload; // Index into Sound database
    sint32            m_SpecialAttacks[k_MAX_SpecialAttacks]; // Index into SpecialAttackInfo database
    sint32            m_numSpecialAttacks;
    double            m_CityGrowthCoefficientValue;
    uint32            m_UserFlags;
    sint32            m_DefaultIcon; // Index into Icon database
    sint32            m_CheatIndexValue;
    sint32            m_Description;
    sint32            m_AdviceValue;
    sint32            m_Category;
    double            m_ArmyMountedBonusValue;
    double            m_ArmyAirBonusValue;
    double            m_ArmyWoodenShipBonusValue;
    double            m_ArmyAttackCityBonusValue;
    double            m_ArmyAttackBonusSubmarineValue;
    double            m_ArmyFootBonusValue;
    double            m_ArmyMeleeBonusValue;
    double            m_ArmySiegeBonusValue;
    double            m_ArmyWheeledBonusValue;
    double            m_ArmyMechanizedBonusValue;
    double            m_ArmyHelicopterBonusValue;
    double            m_ArmySpecialForcesBonusValue;
    double            m_ArmyCivilianBonusValue;
    double            m_ArmyGuerrillaBonusValue;
    double            m_ArmyAgainstMountedBonusValue;
    double            m_ArmyAirDefenseBonusValue;
    sint32            m_EnergyHunger;
    sint32            m_ProducesEnergy;
    sint32            m_HasReligionIconValue; // Index into MapIcon database
    bool m_hasGovernmentsModified; // GovMod specific flag

public:
    UnitRecord() { Init(); };
    UnitRecord(CivArchive &archive) { Serialize(archive); };
    UnitRecord(UnitRecord const & rval) { Init(); *this = rval; }
    ~UnitRecord();
    UnitRecord const & operator = (UnitRecord const & rval);

    void Init();
    void Serialize(CivArchive &archive);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex, sint32 numRecords);

    void ResolveDBReferences();
    void Merge(const UnitRecord & rval);
    sint32 ParseMovementTypeBit(DBLexer *lex);
    sint32 ParseCanCarryBit(DBLexer *lex);
    sint32 ParseSizeBit(DBLexer *lex);
    sint32 ParseCanBombardBit(DBLexer *lex);
    sint32 ParseSettleBit(DBLexer *lex);
    sint32 ParseDefendBit(DBLexer *lex);
    sint32 ParseVisionClassBit(DBLexer *lex);
    sint32 ParseCanSeeBit(DBLexer *lex);
    sint32 ParseCanAttackBit(DBLexer *lex);
    sint32 ParseUserFlagsBit(DBLexer *lex);

    uint32           GetMovementType() const { return m_MovementType; }
    bool             GetMovementTypeLand() const { return (m_MovementType & k_Unit_MovementType_Land_Bit) != 0; }
    bool             GetMovementTypeSea() const { return (m_MovementType & k_Unit_MovementType_Sea_Bit) != 0; }
    bool             GetMovementTypeAir() const { return (m_MovementType & k_Unit_MovementType_Air_Bit) != 0; }
    bool             GetMovementTypeMountain() const { return (m_MovementType & k_Unit_MovementType_Mountain_Bit) != 0; }
    bool             GetMovementTypeTrade() const { return (m_MovementType & k_Unit_MovementType_Trade_Bit) != 0; }
    bool             GetMovementTypeShallowWater() const { return (m_MovementType & k_Unit_MovementType_ShallowWater_Bit) != 0; }
    bool             GetMovementTypeSpace() const { return (m_MovementType & k_Unit_MovementType_Space_Bit) != 0; }
    uint32           GetCanCarry() const { return m_CanCarry; }
    bool             GetCanCarrySmallLand() const { return (m_CanCarry & k_Unit_CanCarry_SmallLand_Bit) != 0; }
    bool             GetCanCarryMedLand() const { return (m_CanCarry & k_Unit_CanCarry_MedLand_Bit) != 0; }
    bool             GetCanCarryLargeLand() const { return (m_CanCarry & k_Unit_CanCarry_LargeLand_Bit) != 0; }
    bool             GetCanCarrySmallAir() const { return (m_CanCarry & k_Unit_CanCarry_SmallAir_Bit) != 0; }
    bool             GetCanCarryMedAir() const { return (m_CanCarry & k_Unit_CanCarry_MedAir_Bit) != 0; }
    bool             GetCanCarryLargeAir() const { return (m_CanCarry & k_Unit_CanCarry_LargeAir_Bit) != 0; }
    bool             GetCanCarrySmallWater() const { return (m_CanCarry & k_Unit_CanCarry_SmallWater_Bit) != 0; }
    bool             GetCanCarryMedWater() const { return (m_CanCarry & k_Unit_CanCarry_MedWater_Bit) != 0; }
    bool             GetCanCarryLargeWater() const { return (m_CanCarry & k_Unit_CanCarry_LargeWater_Bit) != 0; }
    bool             GetCanCarrySmallSpace() const { return (m_CanCarry & k_Unit_CanCarry_SmallSpace_Bit) != 0; }
    bool             GetCanCarryMedSpace() const { return (m_CanCarry & k_Unit_CanCarry_MedSpace_Bit) != 0; }
    bool             GetCanCarryLargeSpace() const { return (m_CanCarry & k_Unit_CanCarry_LargeSpace_Bit) != 0; }
    sint32           GetEnableAdvanceIndex() const { return m_EnableAdvance; }
    AdvanceRecord const * GetEnableAdvance() const;
    sint32 GetObsoleteAdvanceIndex(sint32 index) const;
    const AdvanceRecord * GetObsoleteAdvance(sint32 index) const;
    sint32 GetNumObsoleteAdvance() const { return m_numObsoleteAdvance;}
    sint32 GetPrerequisiteBuildingIndex(sint32 index) const;
    const BuildingRecord * GetPrerequisiteBuilding(sint32 index) const;
    sint32 GetNumPrerequisiteBuilding() const { return m_numPrerequisiteBuilding;}
    sint32 GetExcludedByBuildingIndex(sint32 index) const;
    const BuildingRecord * GetExcludedByBuilding(sint32 index) const;
    sint32 GetNumExcludedByBuilding() const { return m_numExcludedByBuilding;}
    sint32 GetGovernmentsModifiedIndex(sint32 index) const;
    const GovernmentRecord * GetGovernmentsModified(sint32 index) const;
    sint32 GetNumGovernmentsModified() const { return m_numGovernmentsModified;}
    sint32 GetCanSettleOnIndex(sint32 index) const;
    const TerrainRecord * GetCanSettleOn(sint32 index) const;
    sint32 GetNumCanSettleOn() const { return m_numCanSettleOn;}
    sint32 GetUpgradeToIndex(sint32 index) const;
    const UnitRecord * GetUpgradeTo(sint32 index) const;
    sint32 GetNumUpgradeTo() const { return m_numUpgradeTo;}
    sint32 GetObsoleteUnitIndex(sint32 index) const;
    const UnitRecord * GetObsoleteUnit(sint32 index) const;
    sint32 GetNumObsoleteUnit() const { return m_numObsoleteUnit;}
    sint32 GetCultureOnlyIndex(sint32 index) const;
    const CityStyleRecord * GetCultureOnly(sint32 index) const;
    sint32 GetNumCultureOnly() const { return m_numCultureOnly;}
    sint32 GetCityStyleOnlyIndex(sint32 index) const;
    const CityStyleRecord * GetCityStyleOnly(sint32 index) const;
    sint32 GetNumCityStyleOnly() const { return m_numCityStyleOnly;}
    sint32 GetCivilisationOnlyIndex(sint32 index) const;
    const CivilisationRecord * GetCivilisationOnly(sint32 index) const;
    sint32 GetNumCivilisationOnly() const { return m_numCivilisationOnly;}
    sint32 GetGovernmentOnlyIndex(sint32 index) const;
    const GovernmentRecord * GetGovernmentOnly(sint32 index) const;
    sint32 GetNumGovernmentOnly() const { return m_numGovernmentOnly;}
    sint32 GetSettleImprovementIndex(sint32 index) const;
    const TerrainImprovementRecord * GetSettleImprovement(sint32 index) const;
    sint32 GetNumSettleImprovement() const { return m_numSettleImprovement;}
    sint32 GetNeedsCityGoodIndex(sint32 index) const;
    const ResourceRecord * GetNeedsCityGood(sint32 index) const;
    sint32 GetNumNeedsCityGood() const { return m_numNeedsCityGood;}
    sint32 GetNeedsCityGoodAllIndex(sint32 index) const;
    const ResourceRecord * GetNeedsCityGoodAll(sint32 index) const;
    sint32 GetNumNeedsCityGoodAll() const { return m_numNeedsCityGoodAll;}
    sint32 GetNeedsCityGoodCapitolIndex(sint32 index) const;
    const ResourceRecord * GetNeedsCityGoodCapitol(sint32 index) const;
    sint32 GetNumNeedsCityGoodCapitol() const { return m_numNeedsCityGoodCapitol;}
    sint32 GetNeedsCityGoodAnyCityIndex(sint32 index) const;
    const ResourceRecord * GetNeedsCityGoodAnyCity(sint32 index) const;
    sint32 GetNumNeedsCityGoodAnyCity() const { return m_numNeedsCityGoodAnyCity;}
    sint32 GetNeedsFeatToBuildIndex(sint32 index) const;
    const FeatRecord * GetNeedsFeatToBuild(sint32 index) const;
    sint32 GetNumNeedsFeatToBuild() const { return m_numNeedsFeatToBuild;}
    sint32 GetNeedsAnyPlayerFeatToBuildIndex(sint32 index) const;
    const FeatRecord * GetNeedsAnyPlayerFeatToBuild(sint32 index) const;
    sint32 GetNumNeedsAnyPlayerFeatToBuild() const { return m_numNeedsAnyPlayerFeatToBuild;}
    sint32 GetPrerequisiteWonderIndex(sint32 index) const;
    const WonderRecord * GetPrerequisiteWonder(sint32 index) const;
    sint32 GetNumPrerequisiteWonder() const { return m_numPrerequisiteWonder;}
    sint32 GetExcludedByWonderIndex(sint32 index) const;
    const WonderRecord * GetExcludedByWonder(sint32 index) const;
    sint32 GetNumExcludedByWonder() const { return m_numExcludedByWonder;}
    bool HasMoveBonus() const { return (m_flags0 & k_Unit_MoveBonus_Bit) != 0; }
    bool GetMoveBonus(sint32 & value) const
    {
        if (m_flags0 & k_Unit_MoveBonus_Bit)
        {
            value = m_MoveBonusValue;
        }
        return (m_flags0 & k_Unit_MoveBonus_Bit) != 0;
    }
    bool HasPWMoveCost() const { return (m_flags0 & k_Unit_PWMoveCost_Bit) != 0; }
    bool GetPWMoveCost(sint32 & value) const
    {
        if (m_flags0 & k_Unit_PWMoveCost_Bit)
        {
            value = m_PWMoveCostValue;
        }
        return (m_flags0 & k_Unit_PWMoveCost_Bit) != 0;
    }
    bool HasMerchantGold() const { return (m_flags0 & k_Unit_MerchantGold_Bit) != 0; }
    bool GetMerchantGold(sint32 & value) const
    {
        if (m_flags0 & k_Unit_MerchantGold_Bit)
        {
            value = m_MerchantGoldValue;
        }
        return (m_flags0 & k_Unit_MerchantGold_Bit) != 0;
    }
    bool GetIsGreatBuilder() const { return (m_flags0 & k_Unit_IsGreatBuilder_Bit) != 0; }
    bool GetIsGreatArtist() const { return (m_flags0 & k_Unit_IsGreatArtist_Bit) != 0; }
    sint32 GetAllTerrainAsImprovementIndex(sint32 index) const;
    const TerrainImprovementRecord * GetAllTerrainAsImprovement(sint32 index) const;
    sint32 GetNumAllTerrainAsImprovement() const { return m_numAllTerrainAsImprovement;}
    sint32 GetObsoleteByUnitIndex(sint32 index) const;
    const UnitRecord * GetObsoleteByUnit(sint32 index) const;
    sint32 GetNumObsoleteByUnit() const { return m_numObsoleteByUnit;}
    bool GetNonLethalBombard() const { return (m_flags0 & k_Unit_NonLethalBombard_Bit) != 0; }
    bool GetCanBombardTiles() const { return (m_flags0 & k_Unit_CanBombardTiles_Bit) != 0; }
    bool GetCollateralTileDamage() const { return (m_flags0 & k_Unit_CollateralTileDamage_Bit) != 0; }
    bool GetPrecisionStrike() const { return (m_flags0 & k_Unit_PrecisionStrike_Bit) != 0; }
    bool GetTargetsCivilians() const { return (m_flags0 & k_Unit_TargetsCivilians_Bit) != 0; }
    bool GetImmuneToHostileTerrain() const { return (m_flags0 & k_Unit_ImmuneToHostileTerrain_Bit) != 0; }
    bool GetCanRebase() const { return (m_flags0 & k_Unit_CanRebase_Bit) != 0; }
    bool GetMultipleAttacks() const { return (m_flags0 & k_Unit_MultipleAttacks_Bit) != 0; }
    bool GetCanBeGifted() const { return (m_flags0 & k_Unit_CanBeGifted_Bit) != 0; }
    bool GetUpgradeAnywhere() const { return (m_flags0 & k_Unit_UpgradeAnywhere_Bit) != 0; }
    bool GetUpgradeDoesNotHeal() const { return (m_flags0 & k_Unit_UpgradeDoesNotHeal_Bit) != 0; }
    uint32           GetSize() const { return m_Size; }
    bool             GetSizeSmall() const { return (m_Size & k_Unit_Size_Small_Bit) != 0; }
    bool             GetSizeMedium() const { return (m_Size & k_Unit_Size_Medium_Bit) != 0; }
    bool             GetSizeLarge() const { return (m_Size & k_Unit_Size_Large_Bit) != 0; }
    bool GetLossMoveToDmgNone() const { return (m_flags0 & k_Unit_LossMoveToDmgNone_Bit) != 0; }
    bool GetLossMoveToDmgTwo() const { return (m_flags0 & k_Unit_LossMoveToDmgTwo_Bit) != 0; }
    bool GetNoFuelThenCrash() const { return (m_flags0 & k_Unit_NoFuelThenCrash_Bit) != 0; }
    bool GetTransformPartial() const { return (m_flags0 & k_Unit_TransformPartial_Bit) != 0; }
    bool GetIgnoreZOC() const { return (m_flags0 & k_Unit_IgnoreZOC_Bit) != 0; }
    bool GetNoZoc() const { return (m_flags0 & k_Unit_NoZoc_Bit) != 0; }
    uint32           GetCanBombard() const { return m_CanBombard; }
    bool             GetCanBombardLand() const { return (m_CanBombard & k_Unit_CanBombard_Land_Bit) != 0; }
    bool             GetCanBombardAir() const { return (m_CanBombard & k_Unit_CanBombard_Air_Bit) != 0; }
    bool             GetCanBombardWater() const { return (m_CanBombard & k_Unit_CanBombard_Water_Bit) != 0; }
    bool             GetCanBombardSpace() const { return (m_CanBombard & k_Unit_CanBombard_Space_Bit) != 0; }
    bool             GetCanBombardMountain() const { return (m_CanBombard & k_Unit_CanBombard_Mountain_Bit) != 0; }
    bool GetCanCounterBombard() const { return (m_flags0 & k_Unit_CanCounterBombard_Bit) != 0; }
    bool GetCanLiftOff() const { return (m_flags0 & k_Unit_CanLiftOff_Bit) != 0; }
    uint32           GetSettle() const { return m_Settle; }
    bool             GetSettleLand() const { return (m_Settle & k_Unit_Settle_Land_Bit) != 0; }
    bool             GetSettleWater() const { return (m_Settle & k_Unit_Settle_Water_Bit) != 0; }
    bool             GetSettleMountain() const { return (m_Settle & k_Unit_Settle_Mountain_Bit) != 0; }
    bool             GetSettleSpace() const { return (m_Settle & k_Unit_Settle_Space_Bit) != 0; }
    sint32           GetSettleCityTypeIndex() const { return m_SettleCityType; }
    UnitRecord const * GetSettleCityType() const;
    sint32 GetSettleSize() const { return m_SettleSize; }
    sint32 GetSettleBuildingIndex(sint32 index) const;
    const BuildingRecord * GetSettleBuilding(sint32 index) const;
    sint32 GetNumSettleBuilding() const { return m_numSettleBuilding;}
    sint32 GetEstablishBuildingIndex(sint32 index) const;
    const BuildingRecord * GetEstablishBuilding(sint32 index) const;
    sint32 GetNumEstablishBuilding() const { return m_numEstablishBuilding;}
    bool HasSpaceLaunch() const { return (m_flags0 & k_Unit_SpaceLaunch_Bit) != 0; }
    bool GetSpaceLaunch(sint32 & value) const
    {
        if (m_flags0 & k_Unit_SpaceLaunch_Bit)
        {
            value = m_SpaceLaunchValue;
        }
        return (m_flags0 & k_Unit_SpaceLaunch_Bit) != 0;
    }
    bool GetSpaceLand() const { return (m_flags0 & k_Unit_SpaceLand_Bit) != 0; }
    bool GetCantCaptureCity() const { return (m_flags0 & k_Unit_CantCaptureCity_Bit) != 0; }
    bool GetHasPopAndCanBuild() const { return (m_flags0 & k_Unit_HasPopAndCanBuild_Bit) != 0; }
    bool GetIsTrader() const { return (m_flags0 & k_Unit_IsTrader_Bit) != 0; }
    bool GetExertsMartialLaw() const { return (m_flags0 & k_Unit_ExertsMartialLaw_Bit) != 0; }
    bool GetCanEntrench() const { return (m_flags0 & k_Unit_CanEntrench_Bit) != 0; }
    bool GetCanPatrol() const { return (m_flags0 & k_Unit_CanPatrol_Bit) != 0; }
    bool GetNeedsNoSupport() const { return (m_flags1 & k_Unit_NeedsNoSupport_Bit) != 0; }
    bool GetCanExpelPop() const { return (m_flags1 & k_Unit_CanExpelPop_Bit) != 0; }
    bool GetIsFlanker() const { return (m_flags1 & k_Unit_IsFlanker_Bit) != 0; }
    bool GetCanBeachAssault() const { return (m_flags1 & k_Unit_CanBeachAssault_Bit) != 0; }
    uint32           GetDefend() const { return m_Defend; }
    bool             GetDefendLand() const { return (m_Defend & k_Unit_Defend_Land_Bit) != 0; }
    bool             GetDefendAir() const { return (m_Defend & k_Unit_Defend_Air_Bit) != 0; }
    bool             GetDefendWater() const { return (m_Defend & k_Unit_Defend_Water_Bit) != 0; }
    bool             GetDefendSpace() const { return (m_Defend & k_Unit_Defend_Space_Bit) != 0; }
    bool             GetDefendMountain() const { return (m_Defend & k_Unit_Defend_Mountain_Bit) != 0; }
    bool HasDefendAgainstSpies() const { return (m_flags1 & k_Unit_DefendAgainstSpies_Bit) != 0; }
    bool GetDefendAgainstSpies(double & value) const
    {
        if (m_flags1 & k_Unit_DefendAgainstSpies_Bit)
        {
            value = m_DefendAgainstSpiesValue;
        }
        return (m_flags1 & k_Unit_DefendAgainstSpies_Bit) != 0;
    }
    bool GetCanBeExpelled() const { return (m_flags1 & k_Unit_CanBeExpelled_Bit) != 0; }
    bool GetCanBeSued() const { return (m_flags1 & k_Unit_CanBeSued_Bit) != 0; }
    bool GetAttackFromSpaceship() const { return (m_flags1 & k_Unit_AttackFromSpaceship_Bit) != 0; }
    bool GetCantBeAttacked() const { return (m_flags1 & k_Unit_CantBeAttacked_Bit) != 0; }
    bool GetCargoPod() const { return (m_flags1 & k_Unit_CargoPod_Bit) != 0; }
    bool GetIsFoot() const { return (m_flags1 & k_Unit_IsFoot_Bit) != 0; }
    bool GetIsMelee() const { return (m_flags1 & k_Unit_IsMelee_Bit) != 0; }
    bool GetIsMounted() const { return (m_flags1 & k_Unit_IsMounted_Bit) != 0; }
    bool GetIsSiege() const { return (m_flags1 & k_Unit_IsSiege_Bit) != 0; }
    bool GetIsWheeled() const { return (m_flags1 & k_Unit_IsWheeled_Bit) != 0; }
    bool GetIsMechanized() const { return (m_flags1 & k_Unit_IsMechanized_Bit) != 0; }
    bool GetIsHelicopter() const { return (m_flags1 & k_Unit_IsHelicopter_Bit) != 0; }
    bool GetIsSubmarine() const { return (m_flags1 & k_Unit_IsSubmarine_Bit) != 0; }
    bool GetIsSurfaceShip() const { return (m_flags1 & k_Unit_IsSurfaceShip_Bit) != 0; }
    bool GetWoodenShip() const { return (m_flags1 & k_Unit_WoodenShip_Bit) != 0; }
    bool GetNoLandAttack() const { return (m_flags1 & k_Unit_NoLandAttack_Bit) != 0; }
    bool GetNoSeaAttack() const { return (m_flags1 & k_Unit_NoSeaAttack_Bit) != 0; }
    bool GetNoAirAttack() const { return (m_flags1 & k_Unit_NoAirAttack_Bit) != 0; }
    bool GetNoSpaceAttack() const { return (m_flags1 & k_Unit_NoSpaceAttack_Bit) != 0; }
    bool GetNoUnderwaterAttack() const { return (m_flags1 & k_Unit_NoUnderwaterAttack_Bit) != 0; }
    bool GetNoMountainAttack() const { return (m_flags1 & k_Unit_NoMountainAttack_Bit) != 0; }
    bool GetNoShallowWaterAttack() const { return (m_flags1 & k_Unit_NoShallowWaterAttack_Bit) != 0; }
    bool GetSingleUse() const { return (m_flags1 & k_Unit_SingleUse_Bit) != 0; }
    bool GetParatrooper() const { return (m_flags1 & k_Unit_Paratrooper_Bit) != 0; }
    bool GetAssistedDrops() const { return (m_flags1 & k_Unit_AssistedDrops_Bit) != 0; }
    bool HasDefendAirBonus() const { return (m_flags1 & k_Unit_DefendAirBonus_Bit) != 0; }
    bool GetDefendAirBonus(double & value) const
    {
        if (m_flags1 & k_Unit_DefendAirBonus_Bit)
        {
            value = m_DefendAirBonusValue;
        }
        return (m_flags1 & k_Unit_DefendAirBonus_Bit) != 0;
    }
    bool HasDefendCityBonus() const { return (m_flags1 & k_Unit_DefendCityBonus_Bit) != 0; }
    bool GetDefendCityBonus(double & value) const
    {
        if (m_flags1 & k_Unit_DefendCityBonus_Bit)
        {
            value = m_DefendCityBonusValue;
        }
        return (m_flags1 & k_Unit_DefendCityBonus_Bit) != 0;
    }
    bool HasDefendSubmarineBonus() const { return (m_flags2 & k_Unit_DefendSubmarineBonus_Bit) != 0; }
    bool GetDefendSubmarineBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendSubmarineBonus_Bit)
        {
            value = m_DefendSubmarineBonusValue;
        }
        return (m_flags2 & k_Unit_DefendSubmarineBonus_Bit) != 0;
    }
    bool HasDefendFootBonus() const { return (m_flags2 & k_Unit_DefendFootBonus_Bit) != 0; }
    bool GetDefendFootBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendFootBonus_Bit)
        {
            value = m_DefendFootBonusValue;
        }
        return (m_flags2 & k_Unit_DefendFootBonus_Bit) != 0;
    }
    bool HasDefendMeleeBonus() const { return (m_flags2 & k_Unit_DefendMeleeBonus_Bit) != 0; }
    bool GetDefendMeleeBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendMeleeBonus_Bit)
        {
            value = m_DefendMeleeBonusValue;
        }
        return (m_flags2 & k_Unit_DefendMeleeBonus_Bit) != 0;
    }
    bool HasDefendSiegeBonus() const { return (m_flags2 & k_Unit_DefendSiegeBonus_Bit) != 0; }
    bool GetDefendSiegeBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendSiegeBonus_Bit)
        {
            value = m_DefendSiegeBonusValue;
        }
        return (m_flags2 & k_Unit_DefendSiegeBonus_Bit) != 0;
    }
    bool HasDefendWheeledBonus() const { return (m_flags2 & k_Unit_DefendWheeledBonus_Bit) != 0; }
    bool GetDefendWheeledBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendWheeledBonus_Bit)
        {
            value = m_DefendWheeledBonusValue;
        }
        return (m_flags2 & k_Unit_DefendWheeledBonus_Bit) != 0;
    }
    bool HasDefendMechanizedBonus() const { return (m_flags2 & k_Unit_DefendMechanizedBonus_Bit) != 0; }
    bool GetDefendMechanizedBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendMechanizedBonus_Bit)
        {
            value = m_DefendMechanizedBonusValue;
        }
        return (m_flags2 & k_Unit_DefendMechanizedBonus_Bit) != 0;
    }
    bool HasDefendHelicopterBonus() const { return (m_flags2 & k_Unit_DefendHelicopterBonus_Bit) != 0; }
    bool GetDefendHelicopterBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendHelicopterBonus_Bit)
        {
            value = m_DefendHelicopterBonusValue;
        }
        return (m_flags2 & k_Unit_DefendHelicopterBonus_Bit) != 0;
    }
    bool HasDefendSpecialForcesBonus() const { return (m_flags2 & k_Unit_DefendSpecialForcesBonus_Bit) != 0; }
    bool GetDefendSpecialForcesBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendSpecialForcesBonus_Bit)
        {
            value = m_DefendSpecialForcesBonusValue;
        }
        return (m_flags2 & k_Unit_DefendSpecialForcesBonus_Bit) != 0;
    }
    bool HasDefendCivilianBonus() const { return (m_flags2 & k_Unit_DefendCivilianBonus_Bit) != 0; }
    bool GetDefendCivilianBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendCivilianBonus_Bit)
        {
            value = m_DefendCivilianBonusValue;
        }
        return (m_flags2 & k_Unit_DefendCivilianBonus_Bit) != 0;
    }
    bool HasDefendGuerrillaBonus() const { return (m_flags2 & k_Unit_DefendGuerrillaBonus_Bit) != 0; }
    bool GetDefendGuerrillaBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendGuerrillaBonus_Bit)
        {
            value = m_DefendGuerrillaBonusValue;
        }
        return (m_flags2 & k_Unit_DefendGuerrillaBonus_Bit) != 0;
    }
    bool HasDefendMountedBonus() const { return (m_flags2 & k_Unit_DefendMountedBonus_Bit) != 0; }
    bool GetDefendMountedBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendMountedBonus_Bit)
        {
            value = m_DefendMountedBonusValue;
        }
        return (m_flags2 & k_Unit_DefendMountedBonus_Bit) != 0;
    }
    bool HasDefendWoodenShipBonus() const { return (m_flags2 & k_Unit_DefendWoodenShipBonus_Bit) != 0; }
    bool GetDefendWoodenShipBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendWoodenShipBonus_Bit)
        {
            value = m_DefendWoodenShipBonusValue;
        }
        return (m_flags2 & k_Unit_DefendWoodenShipBonus_Bit) != 0;
    }
    bool HasDefendSurfaceShipBonus() const { return (m_flags2 & k_Unit_DefendSurfaceShipBonus_Bit) != 0; }
    bool GetDefendSurfaceShipBonus(double & value) const
    {
        if (m_flags2 & k_Unit_DefendSurfaceShipBonus_Bit)
        {
            value = m_DefendSurfaceShipBonusValue;
        }
        return (m_flags2 & k_Unit_DefendSurfaceShipBonus_Bit) != 0;
    }
    bool GetNoDefenseBonuses() const { return (m_flags2 & k_Unit_NoDefenseBonuses_Bit) != 0; }
    bool HasAttackAirBonus() const { return (m_flags2 & k_Unit_AttackAirBonus_Bit) != 0; }
    bool GetAttackAirBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackAirBonus_Bit)
        {
            value = m_AttackAirBonusValue;
        }
        return (m_flags2 & k_Unit_AttackAirBonus_Bit) != 0;
    }
    bool HasAttackCityBonus() const { return (m_flags2 & k_Unit_AttackCityBonus_Bit) != 0; }
    bool GetAttackCityBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackCityBonus_Bit)
        {
            value = m_AttackCityBonusValue;
        }
        return (m_flags2 & k_Unit_AttackCityBonus_Bit) != 0;
    }
    bool HasAttackSubmarineBonus() const { return (m_flags2 & k_Unit_AttackSubmarineBonus_Bit) != 0; }
    bool GetAttackSubmarineBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackSubmarineBonus_Bit)
        {
            value = m_AttackSubmarineBonusValue;
        }
        return (m_flags2 & k_Unit_AttackSubmarineBonus_Bit) != 0;
    }
    bool HasAttackFootBonus() const { return (m_flags2 & k_Unit_AttackFootBonus_Bit) != 0; }
    bool GetAttackFootBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackFootBonus_Bit)
        {
            value = m_AttackFootBonusValue;
        }
        return (m_flags2 & k_Unit_AttackFootBonus_Bit) != 0;
    }
    bool HasAttackMeleeBonus() const { return (m_flags2 & k_Unit_AttackMeleeBonus_Bit) != 0; }
    bool GetAttackMeleeBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackMeleeBonus_Bit)
        {
            value = m_AttackMeleeBonusValue;
        }
        return (m_flags2 & k_Unit_AttackMeleeBonus_Bit) != 0;
    }
    bool HasAttackSiegeBonus() const { return (m_flags2 & k_Unit_AttackSiegeBonus_Bit) != 0; }
    bool GetAttackSiegeBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackSiegeBonus_Bit)
        {
            value = m_AttackSiegeBonusValue;
        }
        return (m_flags2 & k_Unit_AttackSiegeBonus_Bit) != 0;
    }
    bool HasAttackWheeledBonus() const { return (m_flags2 & k_Unit_AttackWheeledBonus_Bit) != 0; }
    bool GetAttackWheeledBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackWheeledBonus_Bit)
        {
            value = m_AttackWheeledBonusValue;
        }
        return (m_flags2 & k_Unit_AttackWheeledBonus_Bit) != 0;
    }
    bool HasAttackMechanizedBonus() const { return (m_flags2 & k_Unit_AttackMechanizedBonus_Bit) != 0; }
    bool GetAttackMechanizedBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackMechanizedBonus_Bit)
        {
            value = m_AttackMechanizedBonusValue;
        }
        return (m_flags2 & k_Unit_AttackMechanizedBonus_Bit) != 0;
    }
    bool HasAttackHelicopterBonus() const { return (m_flags2 & k_Unit_AttackHelicopterBonus_Bit) != 0; }
    bool GetAttackHelicopterBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackHelicopterBonus_Bit)
        {
            value = m_AttackHelicopterBonusValue;
        }
        return (m_flags2 & k_Unit_AttackHelicopterBonus_Bit) != 0;
    }
    bool HasAttackSpecialForcesBonus() const { return (m_flags2 & k_Unit_AttackSpecialForcesBonus_Bit) != 0; }
    bool GetAttackSpecialForcesBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackSpecialForcesBonus_Bit)
        {
            value = m_AttackSpecialForcesBonusValue;
        }
        return (m_flags2 & k_Unit_AttackSpecialForcesBonus_Bit) != 0;
    }
    bool HasAttackCivilianBonus() const { return (m_flags2 & k_Unit_AttackCivilianBonus_Bit) != 0; }
    bool GetAttackCivilianBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackCivilianBonus_Bit)
        {
            value = m_AttackCivilianBonusValue;
        }
        return (m_flags2 & k_Unit_AttackCivilianBonus_Bit) != 0;
    }
    bool HasAttackGuerrillaBonus() const { return (m_flags2 & k_Unit_AttackGuerrillaBonus_Bit) != 0; }
    bool GetAttackGuerrillaBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackGuerrillaBonus_Bit)
        {
            value = m_AttackGuerrillaBonusValue;
        }
        return (m_flags2 & k_Unit_AttackGuerrillaBonus_Bit) != 0;
    }
    bool HasAttackMountedBonus() const { return (m_flags2 & k_Unit_AttackMountedBonus_Bit) != 0; }
    bool GetAttackMountedBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackMountedBonus_Bit)
        {
            value = m_AttackMountedBonusValue;
        }
        return (m_flags2 & k_Unit_AttackMountedBonus_Bit) != 0;
    }
    bool HasAttackWoodenShipBonusNew() const { return (m_flags2 & k_Unit_AttackWoodenShipBonusNew_Bit) != 0; }
    bool GetAttackWoodenShipBonusNew(double & value) const
    {
        if (m_flags2 & k_Unit_AttackWoodenShipBonusNew_Bit)
        {
            value = m_AttackWoodenShipBonusNewValue;
        }
        return (m_flags2 & k_Unit_AttackWoodenShipBonusNew_Bit) != 0;
    }
    bool HasAttackSurfaceShipBonus() const { return (m_flags2 & k_Unit_AttackSurfaceShipBonus_Bit) != 0; }
    bool GetAttackSurfaceShipBonus(double & value) const
    {
        if (m_flags2 & k_Unit_AttackSurfaceShipBonus_Bit)
        {
            value = m_AttackSurfaceShipBonusValue;
        }
        return (m_flags2 & k_Unit_AttackSurfaceShipBonus_Bit) != 0;
    }
    bool HasRangedAirBonus() const { return (m_flags2 & k_Unit_RangedAirBonus_Bit) != 0; }
    bool GetRangedAirBonus(double & value) const
    {
        if (m_flags2 & k_Unit_RangedAirBonus_Bit)
        {
            value = m_RangedAirBonusValue;
        }
        return (m_flags2 & k_Unit_RangedAirBonus_Bit) != 0;
    }
    bool HasRangedAttackCityBonus() const { return (m_flags2 & k_Unit_RangedAttackCityBonus_Bit) != 0; }
    bool GetRangedAttackCityBonus(double & value) const
    {
        if (m_flags2 & k_Unit_RangedAttackCityBonus_Bit)
        {
            value = m_RangedAttackCityBonusValue;
        }
        return (m_flags2 & k_Unit_RangedAttackCityBonus_Bit) != 0;
    }
    bool HasRangedDefendCityBonus() const { return (m_flags2 & k_Unit_RangedDefendCityBonus_Bit) != 0; }
    bool GetRangedDefendCityBonus(double & value) const
    {
        if (m_flags2 & k_Unit_RangedDefendCityBonus_Bit)
        {
            value = m_RangedDefendCityBonusValue;
        }
        return (m_flags2 & k_Unit_RangedDefendCityBonus_Bit) != 0;
    }
    bool HasRangedSubmarineBonus() const { return (m_flags3 & k_Unit_RangedSubmarineBonus_Bit) != 0; }
    bool GetRangedSubmarineBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedSubmarineBonus_Bit)
        {
            value = m_RangedSubmarineBonusValue;
        }
        return (m_flags3 & k_Unit_RangedSubmarineBonus_Bit) != 0;
    }
    bool HasRangedFootBonus() const { return (m_flags3 & k_Unit_RangedFootBonus_Bit) != 0; }
    bool GetRangedFootBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedFootBonus_Bit)
        {
            value = m_RangedFootBonusValue;
        }
        return (m_flags3 & k_Unit_RangedFootBonus_Bit) != 0;
    }
    bool HasRangedMeleeBonus() const { return (m_flags3 & k_Unit_RangedMeleeBonus_Bit) != 0; }
    bool GetRangedMeleeBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedMeleeBonus_Bit)
        {
            value = m_RangedMeleeBonusValue;
        }
        return (m_flags3 & k_Unit_RangedMeleeBonus_Bit) != 0;
    }
    bool HasRangedSiegeBonus() const { return (m_flags3 & k_Unit_RangedSiegeBonus_Bit) != 0; }
    bool GetRangedSiegeBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedSiegeBonus_Bit)
        {
            value = m_RangedSiegeBonusValue;
        }
        return (m_flags3 & k_Unit_RangedSiegeBonus_Bit) != 0;
    }
    bool HasRangedWheeledBonus() const { return (m_flags3 & k_Unit_RangedWheeledBonus_Bit) != 0; }
    bool GetRangedWheeledBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedWheeledBonus_Bit)
        {
            value = m_RangedWheeledBonusValue;
        }
        return (m_flags3 & k_Unit_RangedWheeledBonus_Bit) != 0;
    }
    bool HasRangedMechanizedBonus() const { return (m_flags3 & k_Unit_RangedMechanizedBonus_Bit) != 0; }
    bool GetRangedMechanizedBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedMechanizedBonus_Bit)
        {
            value = m_RangedMechanizedBonusValue;
        }
        return (m_flags3 & k_Unit_RangedMechanizedBonus_Bit) != 0;
    }
    bool HasRangedHelicopterBonus() const { return (m_flags3 & k_Unit_RangedHelicopterBonus_Bit) != 0; }
    bool GetRangedHelicopterBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedHelicopterBonus_Bit)
        {
            value = m_RangedHelicopterBonusValue;
        }
        return (m_flags3 & k_Unit_RangedHelicopterBonus_Bit) != 0;
    }
    bool HasRangedSpecialForcesBonus() const { return (m_flags3 & k_Unit_RangedSpecialForcesBonus_Bit) != 0; }
    bool GetRangedSpecialForcesBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedSpecialForcesBonus_Bit)
        {
            value = m_RangedSpecialForcesBonusValue;
        }
        return (m_flags3 & k_Unit_RangedSpecialForcesBonus_Bit) != 0;
    }
    bool HasRangedCivilianBonus() const { return (m_flags3 & k_Unit_RangedCivilianBonus_Bit) != 0; }
    bool GetRangedCivilianBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedCivilianBonus_Bit)
        {
            value = m_RangedCivilianBonusValue;
        }
        return (m_flags3 & k_Unit_RangedCivilianBonus_Bit) != 0;
    }
    bool HasRangedGuerrillaBonus() const { return (m_flags3 & k_Unit_RangedGuerrillaBonus_Bit) != 0; }
    bool GetRangedGuerrillaBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedGuerrillaBonus_Bit)
        {
            value = m_RangedGuerrillaBonusValue;
        }
        return (m_flags3 & k_Unit_RangedGuerrillaBonus_Bit) != 0;
    }
    bool HasRangedMountedBonus() const { return (m_flags3 & k_Unit_RangedMountedBonus_Bit) != 0; }
    bool GetRangedMountedBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedMountedBonus_Bit)
        {
            value = m_RangedMountedBonusValue;
        }
        return (m_flags3 & k_Unit_RangedMountedBonus_Bit) != 0;
    }
    bool HasRangedWoodenShipBonus() const { return (m_flags3 & k_Unit_RangedWoodenShipBonus_Bit) != 0; }
    bool GetRangedWoodenShipBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedWoodenShipBonus_Bit)
        {
            value = m_RangedWoodenShipBonusValue;
        }
        return (m_flags3 & k_Unit_RangedWoodenShipBonus_Bit) != 0;
    }
    bool HasRangedSurfaceShipBonus() const { return (m_flags3 & k_Unit_RangedSurfaceShipBonus_Bit) != 0; }
    bool GetRangedSurfaceShipBonus(double & value) const
    {
        if (m_flags3 & k_Unit_RangedSurfaceShipBonus_Bit)
        {
            value = m_RangedSurfaceShipBonusValue;
        }
        return (m_flags3 & k_Unit_RangedSurfaceShipBonus_Bit) != 0;
    }
    bool GetIgnoreCityWalls() const { return (m_flags3 & k_Unit_IgnoreCityWalls_Bit) != 0; }
    bool GetAlwaysHeal() const { return (m_flags3 & k_Unit_AlwaysHeal_Bit) != 0; }
    bool GetAttackWoodenShipBonus() const { return (m_flags3 & k_Unit_AttackWoodenShipBonus_Bit) != 0; }
    bool HasWoodenShipBonus() const { return (m_flags3 & k_Unit_WoodenShipBonus_Bit) != 0; }
    bool GetWoodenShipBonus(double & value) const
    {
        if (m_flags3 & k_Unit_WoodenShipBonus_Bit)
        {
            value = m_WoodenShipBonusValue;
        }
        return (m_flags3 & k_Unit_WoodenShipBonus_Bit) != 0;
    }
    bool GetBonusAgainstMounted() const { return (m_flags3 & k_Unit_BonusAgainstMounted_Bit) != 0; }
    bool HasMountedBonus() const { return (m_flags3 & k_Unit_MountedBonus_Bit) != 0; }
    bool GetMountedBonus(double & value) const
    {
        if (m_flags3 & k_Unit_MountedBonus_Bit)
        {
            value = m_MountedBonusValue;
        }
        return (m_flags3 & k_Unit_MountedBonus_Bit) != 0;
    }
    bool GetBonusAirDefense() const { return (m_flags3 & k_Unit_BonusAirDefense_Bit) != 0; }
    bool HasAirBonus() const { return (m_flags3 & k_Unit_AirBonus_Bit) != 0; }
    bool GetAirBonus(double & value) const
    {
        if (m_flags3 & k_Unit_AirBonus_Bit)
        {
            value = m_AirBonusValue;
        }
        return (m_flags3 & k_Unit_AirBonus_Bit) != 0;
    }
    bool HasReplaceWithCargoModule() const { return (m_flags3 & k_Unit_ReplaceWithCargoModule_Bit) != 0; }
    bool GetReplaceWithCargoModule(sint32 & value) const
    {
        if (m_flags3 & k_Unit_ReplaceWithCargoModule_Bit)
        {
            value = m_ReplaceWithCargoModuleValue;
        }
        return (m_flags3 & k_Unit_ReplaceWithCargoModule_Bit) != 0;
    }
    bool GetVisibileAttacking() const { return (m_flags3 & k_Unit_VisibileAttacking_Bit) != 0; }
    bool HasNuclearAttack() const { return (m_flags3 & k_Unit_NuclearAttack_Bit) != 0; }
    bool GetNuclearAttack(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags3 & k_Unit_NuclearAttack_Bit) ? &m_NuclearAttackValue : NULL;
        return (m_flags3 & k_Unit_NuclearAttack_Bit) != 0;
    }
    const SoundAndEffect * GetNuclearAttackPtr() const
    {
        return (m_flags3 & k_Unit_NuclearAttack_Bit) ? &m_NuclearAttackValue : NULL;
    }
    bool GetCanSue() const { return (m_flags3 & k_Unit_CanSue_Bit) != 0; }
    bool GetIsStealthy() const { return (m_flags3 & k_Unit_IsStealthy_Bit) != 0; }
    bool GetSeeSurfaceFromSpace() const { return (m_flags3 & k_Unit_SeeSurfaceFromSpace_Bit) != 0; }
    bool GetEstablishEmbassy() const { return (m_flags3 & k_Unit_EstablishEmbassy_Bit) != 0; }
    bool GetThrowParty() const { return (m_flags3 & k_Unit_ThrowParty_Bit) != 0; }
    bool GetHearGossip() const { return (m_flags3 & k_Unit_HearGossip_Bit) != 0; }
    bool HasStealTechnology() const { return (m_flags3 & k_Unit_StealTechnology_Bit) != 0; }
    bool GetStealTechnology(const StealTechnologyData *&ptr) const
    {
        ptr = (m_flags3 & k_Unit_StealTechnology_Bit) ? &m_StealTechnologyValue : NULL;
        return (m_flags3 & k_Unit_StealTechnology_Bit) != 0;
    }
    const StealTechnologyData * GetStealTechnologyPtr() const
    {
        return (m_flags3 & k_Unit_StealTechnology_Bit) ? &m_StealTechnologyValue : NULL;
    }
    bool HasInciteRevolution() const { return (m_flags3 & k_Unit_InciteRevolution_Bit) != 0; }
    bool GetInciteRevolution(const InciteRevolutionData *&ptr) const
    {
        ptr = (m_flags3 & k_Unit_InciteRevolution_Bit) ? &m_InciteRevolutionValue : NULL;
        return (m_flags3 & k_Unit_InciteRevolution_Bit) != 0;
    }
    const InciteRevolutionData * GetInciteRevolutionPtr() const
    {
        return (m_flags3 & k_Unit_InciteRevolution_Bit) ? &m_InciteRevolutionValue : NULL;
    }
    bool HasAssasinateRuler() const { return (m_flags4 & k_Unit_AssasinateRuler_Bit) != 0; }
    bool GetAssasinateRuler(const AssasinateRulerData *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_AssasinateRuler_Bit) ? &m_AssasinateRulerValue : NULL;
        return (m_flags4 & k_Unit_AssasinateRuler_Bit) != 0;
    }
    const AssasinateRulerData * GetAssasinateRulerPtr() const
    {
        return (m_flags4 & k_Unit_AssasinateRuler_Bit) ? &m_AssasinateRulerValue : NULL;
    }
    bool HasInvestigateReadiness() const { return (m_flags4 & k_Unit_InvestigateReadiness_Bit) != 0; }
    bool GetInvestigateReadiness(const InvestigateReadinessData *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_InvestigateReadiness_Bit) ? &m_InvestigateReadinessValue : NULL;
        return (m_flags4 & k_Unit_InvestigateReadiness_Bit) != 0;
    }
    const InvestigateReadinessData * GetInvestigateReadinessPtr() const
    {
        return (m_flags4 & k_Unit_InvestigateReadiness_Bit) ? &m_InvestigateReadinessValue : NULL;
    }
    bool GetNullifyCityWalls() const { return (m_flags4 & k_Unit_NullifyCityWalls_Bit) != 0; }
    bool HasCreateFranchise() const { return (m_flags4 & k_Unit_CreateFranchise_Bit) != 0; }
    bool GetCreateFranchise(const ChanceEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_CreateFranchise_Bit) ? &m_CreateFranchiseValue : NULL;
        return (m_flags4 & k_Unit_CreateFranchise_Bit) != 0;
    }
    const ChanceEffect * GetCreateFranchisePtr() const
    {
        return (m_flags4 & k_Unit_CreateFranchise_Bit) ? &m_CreateFranchiseValue : NULL;
    }
    bool HasCauseUnhappiness() const { return (m_flags4 & k_Unit_CauseUnhappiness_Bit) != 0; }
    bool GetCauseUnhappiness(const CauseUnhappinessData *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_CauseUnhappiness_Bit) ? &m_CauseUnhappinessValue : NULL;
        return (m_flags4 & k_Unit_CauseUnhappiness_Bit) != 0;
    }
    const CauseUnhappinessData * GetCauseUnhappinessPtr() const
    {
        return (m_flags4 & k_Unit_CauseUnhappiness_Bit) ? &m_CauseUnhappinessValue : NULL;
    }
    bool HasConductHits() const { return (m_flags4 & k_Unit_ConductHits_Bit) != 0; }
    bool GetConductHits(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_ConductHits_Bit) ? &m_ConductHitsValue : NULL;
        return (m_flags4 & k_Unit_ConductHits_Bit) != 0;
    }
    const SoundAndEffect * GetConductHitsPtr() const
    {
        return (m_flags4 & k_Unit_ConductHits_Bit) ? &m_ConductHitsValue : NULL;
    }
    bool HasBioTerror() const { return (m_flags4 & k_Unit_BioTerror_Bit) != 0; }
    bool GetBioTerror(const ChanceEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_BioTerror_Bit) ? &m_BioTerrorValue : NULL;
        return (m_flags4 & k_Unit_BioTerror_Bit) != 0;
    }
    const ChanceEffect * GetBioTerrorPtr() const
    {
        return (m_flags4 & k_Unit_BioTerror_Bit) ? &m_BioTerrorValue : NULL;
    }
    bool HasNanoTerror() const { return (m_flags4 & k_Unit_NanoTerror_Bit) != 0; }
    bool GetNanoTerror(const ChanceEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_NanoTerror_Bit) ? &m_NanoTerrorValue : NULL;
        return (m_flags4 & k_Unit_NanoTerror_Bit) != 0;
    }
    const ChanceEffect * GetNanoTerrorPtr() const
    {
        return (m_flags4 & k_Unit_NanoTerror_Bit) ? &m_NanoTerrorValue : NULL;
    }
    bool HasPlague() const { return (m_flags4 & k_Unit_Plague_Bit) != 0; }
    bool GetPlague(const ChanceEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_Plague_Bit) ? &m_PlagueValue : NULL;
        return (m_flags4 & k_Unit_Plague_Bit) != 0;
    }
    const ChanceEffect * GetPlaguePtr() const
    {
        return (m_flags4 & k_Unit_Plague_Bit) ? &m_PlagueValue : NULL;
    }
    bool HasSlaveRaids() const { return (m_flags4 & k_Unit_SlaveRaids_Bit) != 0; }
    bool GetSlaveRaids(const SlaveRaidsData *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_SlaveRaids_Bit) ? &m_SlaveRaidsValue : NULL;
        return (m_flags4 & k_Unit_SlaveRaids_Bit) != 0;
    }
    const SlaveRaidsData * GetSlaveRaidsPtr() const
    {
        return (m_flags4 & k_Unit_SlaveRaids_Bit) ? &m_SlaveRaidsValue : NULL;
    }
    bool HasSettlerSlaveRaids() const { return (m_flags4 & k_Unit_SettlerSlaveRaids_Bit) != 0; }
    bool GetSettlerSlaveRaids(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_SettlerSlaveRaids_Bit) ? &m_SettlerSlaveRaidsValue : NULL;
        return (m_flags4 & k_Unit_SettlerSlaveRaids_Bit) != 0;
    }
    const SoundAndEffect * GetSettlerSlaveRaidsPtr() const
    {
        return (m_flags4 & k_Unit_SettlerSlaveRaids_Bit) ? &m_SettlerSlaveRaidsValue : NULL;
    }
    bool HasSlaveUprising() const { return (m_flags4 & k_Unit_SlaveUprising_Bit) != 0; }
    bool GetSlaveUprising(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_SlaveUprising_Bit) ? &m_SlaveUprisingValue : NULL;
        return (m_flags4 & k_Unit_SlaveUprising_Bit) != 0;
    }
    const SoundAndEffect * GetSlaveUprisingPtr() const
    {
        return (m_flags4 & k_Unit_SlaveUprising_Bit) ? &m_SlaveUprisingValue : NULL;
    }
    bool HasUndergroundRailway() const { return (m_flags4 & k_Unit_UndergroundRailway_Bit) != 0; }
    bool GetUndergroundRailway(const SuccessDeathEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_UndergroundRailway_Bit) ? &m_UndergroundRailwayValue : NULL;
        return (m_flags4 & k_Unit_UndergroundRailway_Bit) != 0;
    }
    const SuccessDeathEffect * GetUndergroundRailwayPtr() const
    {
        return (m_flags4 & k_Unit_UndergroundRailway_Bit) ? &m_UndergroundRailwayValue : NULL;
    }
    bool GetVictoryEnslavement() const { return (m_flags4 & k_Unit_VictoryEnslavement_Bit) != 0; }
    bool HasVictoryEnslavementChance() const { return (m_flags4 & k_Unit_VictoryEnslavementChance_Bit) != 0; }
    bool GetVictoryEnslavementChance(double & value) const
    {
        if (m_flags4 & k_Unit_VictoryEnslavementChance_Bit)
        {
            value = m_VictoryEnslavementChanceValue;
        }
        return (m_flags4 & k_Unit_VictoryEnslavementChance_Bit) != 0;
    }
    bool GetVictoryEnslavementStacks() const { return (m_flags4 & k_Unit_VictoryEnslavementStacks_Bit) != 0; }
    bool GetDefuseLandMines() const { return (m_flags4 & k_Unit_DefuseLandMines_Bit) != 0; }
    bool GetDefuseSeaMines() const { return (m_flags4 & k_Unit_DefuseSeaMines_Bit) != 0; }
    bool GetDefuseXrayMines() const { return (m_flags4 & k_Unit_DefuseXrayMines_Bit) != 0; }
    bool HasIndulgenceSales() const { return (m_flags4 & k_Unit_IndulgenceSales_Bit) != 0; }
    bool GetIndulgenceSales(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_IndulgenceSales_Bit) ? &m_IndulgenceSalesValue : NULL;
        return (m_flags4 & k_Unit_IndulgenceSales_Bit) != 0;
    }
    const SoundAndEffect * GetIndulgenceSalesPtr() const
    {
        return (m_flags4 & k_Unit_IndulgenceSales_Bit) ? &m_IndulgenceSalesValue : NULL;
    }
    bool HasConvertCities() const { return (m_flags4 & k_Unit_ConvertCities_Bit) != 0; }
    bool GetConvertCities(const SuccessDeathEffect *&ptr) const
    {
        ptr = (m_flags4 & k_Unit_ConvertCities_Bit) ? &m_ConvertCitiesValue : NULL;
        return (m_flags4 & k_Unit_ConvertCities_Bit) != 0;
    }
    const SuccessDeathEffect * GetConvertCitiesPtr() const
    {
        return (m_flags4 & k_Unit_ConvertCities_Bit) ? &m_ConvertCitiesValue : NULL;
    }
    bool GetBuildXrayMines() const { return (m_flags4 & k_Unit_BuildXrayMines_Bit) != 0; }
    bool GetBuildWonder() const { return (m_flags4 & k_Unit_BuildWonder_Bit) != 0; }
    sint32 GetGovernmentTypeIndex(sint32 index) const;
    const GovernmentRecord * GetGovernmentType(sint32 index) const;
    sint32 GetNumGovernmentType() const { return m_numGovernmentType;}
    bool GetNoSlaves() const { return (m_flags4 & k_Unit_NoSlaves_Bit) != 0; }
    bool GetCreateRift() const { return (m_flags4 & k_Unit_CreateRift_Bit) != 0; }
    bool GetCanCloak() const { return (m_flags4 & k_Unit_CanCloak_Bit) != 0; }
    bool GetHiddenNationality() const { return (m_flags4 & k_Unit_HiddenNationality_Bit) != 0; }
    bool GetSneakAttack() const { return (m_flags4 & k_Unit_SneakAttack_Bit) != 0; }
    bool GetSneakPillage() const { return (m_flags4 & k_Unit_SneakPillage_Bit) != 0; }
    bool GetSneakBombard() const { return (m_flags4 & k_Unit_SneakBombard_Bit) != 0; }
    bool GetParatrooperTransport() const { return (m_flags4 & k_Unit_ParatrooperTransport_Bit) != 0; }
    bool GetCantBuild() const { return (m_flags4 & k_Unit_CantBuild_Bit) != 0; }
    bool HasPlantNuke() const { return (m_flags5 & k_Unit_PlantNuke_Bit) != 0; }
    bool GetPlantNuke(const PlantNukeData *&ptr) const
    {
        ptr = (m_flags5 & k_Unit_PlantNuke_Bit) ? &m_PlantNukeValue : NULL;
        return (m_flags5 & k_Unit_PlantNuke_Bit) != 0;
    }
    const PlantNukeData * GetPlantNukePtr() const
    {
        return (m_flags5 & k_Unit_PlantNuke_Bit) ? &m_PlantNukeValue : NULL;
    }
    bool GetIsTelevangelist() const { return (m_flags5 & k_Unit_IsTelevangelist_Bit) != 0; }
    bool HasCanSoothsay() const { return (m_flags5 & k_Unit_CanSoothsay_Bit) != 0; }
    bool GetCanSoothsay(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags5 & k_Unit_CanSoothsay_Bit) ? &m_CanSoothsayValue : NULL;
        return (m_flags5 & k_Unit_CanSoothsay_Bit) != 0;
    }
    const SoundAndEffect * GetCanSoothsayPtr() const
    {
        return (m_flags5 & k_Unit_CanSoothsay_Bit) ? &m_CanSoothsayValue : NULL;
    }
    bool GetCanBeRustled() const { return (m_flags5 & k_Unit_CanBeRustled_Bit) != 0; }
    bool HasCreateParks() const { return (m_flags5 & k_Unit_CreateParks_Bit) != 0; }
    bool GetCreateParks(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags5 & k_Unit_CreateParks_Bit) ? &m_CreateParksValue : NULL;
        return (m_flags5 & k_Unit_CreateParks_Bit) != 0;
    }
    const SoundAndEffect * GetCreateParksPtr() const
    {
        return (m_flags5 & k_Unit_CreateParks_Bit) ? &m_CreateParksValue : NULL;
    }
    bool HasCanInjoin() const { return (m_flags5 & k_Unit_CanInjoin_Bit) != 0; }
    bool GetCanInjoin(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags5 & k_Unit_CanInjoin_Bit) ? &m_CanInjoinValue : NULL;
        return (m_flags5 & k_Unit_CanInjoin_Bit) != 0;
    }
    const SoundAndEffect * GetCanInjoinPtr() const
    {
        return (m_flags5 & k_Unit_CanInjoin_Bit) ? &m_CanInjoinValue : NULL;
    }
    bool GetWormholeProbe() const { return (m_flags5 & k_Unit_WormholeProbe_Bit) != 0; }
    bool GetHasBonusFood() const { return (m_flags5 & k_Unit_HasBonusFood_Bit) != 0; }
    bool GetLandCityCanBuild() const { return (m_flags5 & k_Unit_LandCityCanBuild_Bit) != 0; }
    bool GetSeaCityCanBuild() const { return (m_flags5 & k_Unit_SeaCityCanBuild_Bit) != 0; }
    bool GetSpaceCityCanBuild() const { return (m_flags5 & k_Unit_SpaceCityCanBuild_Bit) != 0; }
    bool GetIsSpecialForces() const { return (m_flags5 & k_Unit_IsSpecialForces_Bit) != 0; }
    bool GetIsPeaceKeeper() const { return (m_flags5 & k_Unit_IsPeaceKeeper_Bit) != 0; }
    bool GetIsGuerrilla() const { return (m_flags5 & k_Unit_IsGuerrilla_Bit) != 0; }
    bool GetIsWorker() const { return (m_flags5 & k_Unit_IsWorker_Bit) != 0; }
    bool GetNotAffectedByLandMines() const { return (m_flags5 & k_Unit_NotAffectedByLandMines_Bit) != 0; }
    bool GetInternalReserved() const { return (m_flags5 & k_Unit_InternalReserved_Bit) != 0; }
    bool GetDeathEffectsHappy() const { return (m_flags5 & k_Unit_DeathEffectsHappy_Bit) != 0; }
    bool GetEnableCarrierDefenses() const { return (m_flags5 & k_Unit_EnableCarrierDefenses_Bit) != 0; }
    bool GetActiveDefenseOnlyWhenCarryingEnablers() const { return (m_flags5 & k_Unit_ActiveDefenseOnlyWhenCarryingEnablers_Bit) != 0; }
    bool GetBuildingRemovesAPop() const { return (m_flags5 & k_Unit_BuildingRemovesAPop_Bit) != 0; }
    bool HasPopCostsToBuild() const { return (m_flags5 & k_Unit_PopCostsToBuild_Bit) != 0; }
    bool GetPopCostsToBuild(sint32 & value) const
    {
        if (m_flags5 & k_Unit_PopCostsToBuild_Bit)
        {
            value = m_PopCostsToBuildValue;
        }
        return (m_flags5 & k_Unit_PopCostsToBuild_Bit) != 0;
    }
    bool GetExplodes() const { return (m_flags5 & k_Unit_Explodes_Bit) != 0; }
    bool GetAdvertise() const { return (m_flags5 & k_Unit_Advertise_Bit) != 0; }
    bool GetCanRustle() const { return (m_flags5 & k_Unit_CanRustle_Bit) != 0; }
    bool GetOnlyBuildOne() const { return (m_flags5 & k_Unit_OnlyBuildOne_Bit) != 0; }
    bool GetCanExpel() const { return (m_flags5 & k_Unit_CanExpel_Bit) != 0; }
    bool HasCanReform() const { return (m_flags5 & k_Unit_CanReform_Bit) != 0; }
    bool GetCanReform(const SoundAndEffect *&ptr) const
    {
        ptr = (m_flags5 & k_Unit_CanReform_Bit) ? &m_CanReformValue : NULL;
        return (m_flags5 & k_Unit_CanReform_Bit) != 0;
    }
    const SoundAndEffect * GetCanReformPtr() const
    {
        return (m_flags5 & k_Unit_CanReform_Bit) ? &m_CanReformValue : NULL;
    }
    bool GetCanPillage() const { return (m_flags5 & k_Unit_CanPillage_Bit) != 0; }
    bool GetCanPirate() const { return (m_flags5 & k_Unit_CanPirate_Bit) != 0; }
    bool GetCanCaptureTile() const { return (m_flags5 & k_Unit_CanCaptureTile_Bit) != 0; }
    sint32 GetReducesDefensesBonus() const { return m_ReducesDefensesBonus; }
    uint32           GetVisionClass() const { return m_VisionClass; }
    bool             GetVisionClassStandard() const { return (m_VisionClass & k_Unit_VisionClass_Standard_Bit) != 0; }
    bool             GetVisionClassUnderwater() const { return (m_VisionClass & k_Unit_VisionClass_Underwater_Bit) != 0; }
    bool             GetVisionClassStealth() const { return (m_VisionClass & k_Unit_VisionClass_Stealth_Bit) != 0; }
    bool             GetVisionClassUnusedBit3() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit3_Bit) != 0; }
    bool             GetVisionClassUnusedBit4() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit4_Bit) != 0; }
    bool             GetVisionClassUnusedBit5() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit5_Bit) != 0; }
    bool             GetVisionClassUnusedBit6() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit6_Bit) != 0; }
    bool             GetVisionClassUnusedBit7() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit7_Bit) != 0; }
    bool             GetVisionClassUnusedBit8() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit8_Bit) != 0; }
    bool             GetVisionClassUnusedBit9() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit9_Bit) != 0; }
    bool             GetVisionClassUnusedBit10() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit10_Bit) != 0; }
    bool             GetVisionClassUnusedBit11() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit11_Bit) != 0; }
    bool             GetVisionClassUnusedBit12() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit12_Bit) != 0; }
    bool             GetVisionClassUnusedBit13() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit13_Bit) != 0; }
    bool             GetVisionClassUnusedBit14() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit14_Bit) != 0; }
    bool             GetVisionClassUnusedBit15() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit15_Bit) != 0; }
    uint32           GetCanSee() const { return m_CanSee; }
    bool             GetCanSeeStandard() const { return (m_CanSee & k_Unit_CanSee_Standard_Bit) != 0; }
    bool             GetCanSeeUnderwater() const { return (m_CanSee & k_Unit_CanSee_Underwater_Bit) != 0; }
    bool             GetCanSeeStealth() const { return (m_CanSee & k_Unit_CanSee_Stealth_Bit) != 0; }
    bool             GetCanSeeUnusedBit3() const { return (m_CanSee & k_Unit_CanSee_UnusedBit3_Bit) != 0; }
    bool             GetCanSeeUnusedBit4() const { return (m_CanSee & k_Unit_CanSee_UnusedBit4_Bit) != 0; }
    bool             GetCanSeeUnusedBit5() const { return (m_CanSee & k_Unit_CanSee_UnusedBit5_Bit) != 0; }
    bool             GetCanSeeUnusedBit6() const { return (m_CanSee & k_Unit_CanSee_UnusedBit6_Bit) != 0; }
    bool             GetCanSeeUnusedBit7() const { return (m_CanSee & k_Unit_CanSee_UnusedBit7_Bit) != 0; }
    bool             GetCanSeeUnusedBit8() const { return (m_CanSee & k_Unit_CanSee_UnusedBit8_Bit) != 0; }
    bool             GetCanSeeUnusedBit9() const { return (m_CanSee & k_Unit_CanSee_UnusedBit9_Bit) != 0; }
    bool             GetCanSeeUnusedBit10() const { return (m_CanSee & k_Unit_CanSee_UnusedBit10_Bit) != 0; }
    bool             GetCanSeeUnusedBit11() const { return (m_CanSee & k_Unit_CanSee_UnusedBit11_Bit) != 0; }
    bool             GetCanSeeUnusedBit12() const { return (m_CanSee & k_Unit_CanSee_UnusedBit12_Bit) != 0; }
    bool             GetCanSeeUnusedBit13() const { return (m_CanSee & k_Unit_CanSee_UnusedBit13_Bit) != 0; }
    bool             GetCanSeeUnusedBit14() const { return (m_CanSee & k_Unit_CanSee_UnusedBit14_Bit) != 0; }
    bool             GetCanSeeUnusedBit15() const { return (m_CanSee & k_Unit_CanSee_UnusedBit15_Bit) != 0; }
    uint32           GetCanAttack() const { return m_CanAttack; }
    bool             GetCanAttackLand() const { return (m_CanAttack & k_Unit_CanAttack_Land_Bit) != 0; }
    bool             GetCanAttackSea() const { return (m_CanAttack & k_Unit_CanAttack_Sea_Bit) != 0; }
    bool             GetCanAttackAir() const { return (m_CanAttack & k_Unit_CanAttack_Air_Bit) != 0; }
    bool             GetCanAttackMountain() const { return (m_CanAttack & k_Unit_CanAttack_Mountain_Bit) != 0; }
    bool             GetCanAttackTrade() const { return (m_CanAttack & k_Unit_CanAttack_Trade_Bit) != 0; }
    bool             GetCanAttackShallowWater() const { return (m_CanAttack & k_Unit_CanAttack_ShallowWater_Bit) != 0; }
    bool             GetCanAttackSpace() const { return (m_CanAttack & k_Unit_CanAttack_Space_Bit) != 0; }
    bool             GetCanAttackUnderwater() const { return (m_CanAttack & k_Unit_CanAttack_Underwater_Bit) != 0; }
    bool HasCargoData() const { return (m_flags5 & k_Unit_CargoData_Bit) != 0; }
    bool GetCargoData(const CargoData *&ptr) const
    {
        ptr = (m_flags5 & k_Unit_CargoData_Bit) ? &m_CargoDataValue : NULL;
        return (m_flags5 & k_Unit_CargoData_Bit) != 0;
    }
    const CargoData * GetCargoDataPtr() const
    {
        return (m_flags5 & k_Unit_CargoData_Bit) ? &m_CargoDataValue : NULL;
    }
    sint32 GetShieldCost() const { return m_ShieldCost; }
    sint32 GetPowerPoints() const { return m_PowerPoints; }
    sint32 GetMaxHP() const { return m_MaxHP; }
    double GetMaxHPr() const { return m_MaxHPr; }
    double GetAttack() const { return m_Attack; }
    double GetDefense() const { return m_Defense; }
    sint32 GetFirepower() const { return m_Firepower; }
    sint32 GetZBRangeAttack() const { return m_ZBRangeAttack; }
    double GetArmor() const { return m_Armor; }
    bool HasBRange() const { return (m_flags6 & k_Unit_BRange_Bit) != 0; }
    bool GetBRange(sint32 & value) const
    {
        if (m_flags6 & k_Unit_BRange_Bit)
        {
            value = m_BRangeValue;
        }
        return (m_flags6 & k_Unit_BRange_Bit) != 0;
    }
    bool HasBRadius() const { return (m_flags6 & k_Unit_BRadius_Bit) != 0; }
    bool GetBRadius(sint32 & value) const
    {
        if (m_flags6 & k_Unit_BRadius_Bit)
        {
            value = m_BRadiusValue;
        }
        return (m_flags6 & k_Unit_BRadius_Bit) != 0;
    }
    sint32 GetVisionRange() const { return m_VisionRange; }
    sint32 GetActiveDefenseRange() const { return m_ActiveDefenseRange; }
    bool HasElectronicCombatFactor() const { return (m_flags6 & k_Unit_ElectronicCombatFactor_Bit) != 0; }
    bool GetElectronicCombatFactor(sint32 & value) const
    {
        if (m_flags6 & k_Unit_ElectronicCombatFactor_Bit)
        {
            value = m_ElectronicCombatFactorValue;
        }
        return (m_flags6 & k_Unit_ElectronicCombatFactor_Bit) != 0;
    }
    double GetMaxMovePoints() const { return m_MaxMovePoints; }
    sint32 GetMaxFuel() const { return m_MaxFuel; }
    bool HasTransType() const { return (m_flags6 & k_Unit_TransType_Bit) != 0; }
    bool GetTransType(sint32 & value) const
    {
        if (m_flags6 & k_Unit_TransType_Bit)
        {
            value = m_TransTypeValue;
        }
        return (m_flags6 & k_Unit_TransType_Bit) != 0;
    }
    bool HasProbOfBombHit() const { return (m_flags6 & k_Unit_ProbOfBombHit_Bit) != 0; }
    bool GetProbOfBombHit(sint32 & value) const
    {
        if (m_flags6 & k_Unit_ProbOfBombHit_Bit)
        {
            value = m_ProbOfBombHitValue;
        }
        return (m_flags6 & k_Unit_ProbOfBombHit_Bit) != 0;
    }
    bool HasBombRounds() const { return (m_flags6 & k_Unit_BombRounds_Bit) != 0; }
    bool GetBombRounds(sint32 & value) const
    {
        if (m_flags6 & k_Unit_BombRounds_Bit)
        {
            value = m_BombRoundsValue;
        }
        return (m_flags6 & k_Unit_BombRounds_Bit) != 0;
    }
    sint32 GetShieldHunger() const { return m_ShieldHunger; }
    sint32 GetFoodHunger() const { return m_FoodHunger; }
    sint32 GetGoldHunger() const { return m_GoldHunger; }
    sint32           GetDefaultSpriteIndex() const { return m_DefaultSprite; }
    SpriteRecord const * GetDefaultSprite() const;
    bool HasLaunchPollution() const { return (m_flags6 & k_Unit_LaunchPollution_Bit) != 0; }
    bool GetLaunchPollution(sint32 & value) const
    {
        if (m_flags6 & k_Unit_LaunchPollution_Bit)
        {
            value = m_LaunchPollutionValue;
        }
        return (m_flags6 & k_Unit_LaunchPollution_Bit) != 0;
    }
    bool HasDeathPollution() const { return (m_flags6 & k_Unit_DeathPollution_Bit) != 0; }
    bool GetDeathPollution(sint32 & value) const
    {
        if (m_flags6 & k_Unit_DeathPollution_Bit)
        {
            value = m_DeathPollutionValue;
        }
        return (m_flags6 & k_Unit_DeathPollution_Bit) != 0;
    }
    bool HasCargoModule() const { return (m_flags6 & k_Unit_CargoModule_Bit) != 0; }
    bool GetCargoModule(sint32 & value) const
    {
        if (m_flags6 & k_Unit_CargoModule_Bit)
        {
            value = m_CargoModuleValue;
        }
        return (m_flags6 & k_Unit_CargoModule_Bit) != 0;
    }
    bool HasSpyVsSpy() const { return (m_flags6 & k_Unit_SpyVsSpy_Bit) != 0; }
    bool GetSpyVsSpy(double & value) const
    {
        if (m_flags6 & k_Unit_SpyVsSpy_Bit)
        {
            value = m_SpyVsSpyValue;
        }
        return (m_flags6 & k_Unit_SpyVsSpy_Bit) != 0;
    }
    bool HasInvestigateCity() const { return (m_flags6 & k_Unit_InvestigateCity_Bit) != 0; }
    bool GetInvestigateCity(const InvestigateCityData *&ptr) const
    {
        ptr = (m_flags6 & k_Unit_InvestigateCity_Bit) ? &m_InvestigateCityValue : NULL;
        return (m_flags6 & k_Unit_InvestigateCity_Bit) != 0;
    }
    const InvestigateCityData * GetInvestigateCityPtr() const
    {
        return (m_flags6 & k_Unit_InvestigateCity_Bit) ? &m_InvestigateCityValue : NULL;
    }
    bool HasBonusFood() const { return (m_flags6 & k_Unit_BonusFood_Bit) != 0; }
    bool GetBonusFood(sint32 & value) const
    {
        if (m_flags6 & k_Unit_BonusFood_Bit)
        {
            value = m_BonusFoodValue;
        }
        return (m_flags6 & k_Unit_BonusFood_Bit) != 0;
    }
    bool HasBombardRange() const { return (m_flags6 & k_Unit_BombardRange_Bit) != 0; }
    bool GetBombardRange(sint32 & value) const
    {
        if (m_flags6 & k_Unit_BombardRange_Bit)
        {
            value = m_BombardRangeValue;
        }
        return (m_flags6 & k_Unit_BombardRange_Bit) != 0;
    }
    bool HasRevolution() const { return (m_flags6 & k_Unit_Revolution_Bit) != 0; }
    bool GetRevolution(const RevolutionData *&ptr) const
    {
        ptr = (m_flags6 & k_Unit_Revolution_Bit) ? &m_RevolutionValue : NULL;
        return (m_flags6 & k_Unit_Revolution_Bit) != 0;
    }
    const RevolutionData * GetRevolutionPtr() const
    {
        return (m_flags6 & k_Unit_Revolution_Bit) ? &m_RevolutionValue : NULL;
    }
    sint32           GetSoundSelect1Index() const { return m_SoundSelect1; }
    SoundRecord const * GetSoundSelect1() const;
    sint32           GetSoundSelect2Index() const { return m_SoundSelect2; }
    SoundRecord const * GetSoundSelect2() const;
    sint32           GetSoundMoveIndex() const { return m_SoundMove; }
    SoundRecord const * GetSoundMove() const;
    sint32           GetSoundAcknowledgeIndex() const { return m_SoundAcknowledge; }
    SoundRecord const * GetSoundAcknowledge() const;
    sint32           GetSoundCantMoveIndex() const { return m_SoundCantMove; }
    SoundRecord const * GetSoundCantMove() const;
    sint32           GetSoundAttackIndex() const { return m_SoundAttack; }
    SoundRecord const * GetSoundAttack() const;
    sint32           GetSoundWorkIndex() const { return m_SoundWork; }
    SoundRecord const * GetSoundWork() const;
    sint32           GetSoundVictoryIndex() const { return m_SoundVictory; }
    SoundRecord const * GetSoundVictory() const;
    sint32           GetSoundDeathIndex() const { return m_SoundDeath; }
    SoundRecord const * GetSoundDeath() const;
    sint32           GetSoundLoadIndex() const { return m_SoundLoad; }
    SoundRecord const * GetSoundLoad() const;
    sint32           GetSoundUnloadIndex() const { return m_SoundUnload; }
    SoundRecord const * GetSoundUnload() const;
    sint32 GetSpecialAttacksIndex(sint32 index) const;
    const SpecialAttackInfoRecord * GetSpecialAttacks(sint32 index) const;
    sint32 GetNumSpecialAttacks() const { return m_numSpecialAttacks;}
    bool HasCityGrowthCoefficient() const { return (m_flags6 & k_Unit_CityGrowthCoefficient_Bit) != 0; }
    bool GetCityGrowthCoefficient(double & value) const
    {
        if (m_flags6 & k_Unit_CityGrowthCoefficient_Bit)
        {
            value = m_CityGrowthCoefficientValue;
        }
        return (m_flags6 & k_Unit_CityGrowthCoefficient_Bit) != 0;
    }
    uint32           GetUserFlags() const { return m_UserFlags; }
    bool             GetUserFlagsUF1() const { return (m_UserFlags & k_Unit_UserFlags_UF1_Bit) != 0; }
    bool             GetUserFlagsUF2() const { return (m_UserFlags & k_Unit_UserFlags_UF2_Bit) != 0; }
    bool             GetUserFlagsUF3() const { return (m_UserFlags & k_Unit_UserFlags_UF3_Bit) != 0; }
    bool             GetUserFlagsUF4() const { return (m_UserFlags & k_Unit_UserFlags_UF4_Bit) != 0; }
    bool             GetUserFlagsUF5() const { return (m_UserFlags & k_Unit_UserFlags_UF5_Bit) != 0; }
    bool             GetUserFlagsUF6() const { return (m_UserFlags & k_Unit_UserFlags_UF6_Bit) != 0; }
    bool             GetUserFlagsUF7() const { return (m_UserFlags & k_Unit_UserFlags_UF7_Bit) != 0; }
    bool             GetUserFlagsUF8() const { return (m_UserFlags & k_Unit_UserFlags_UF8_Bit) != 0; }
    bool             GetUserFlagsUF9() const { return (m_UserFlags & k_Unit_UserFlags_UF9_Bit) != 0; }
    bool             GetUserFlagsUF10() const { return (m_UserFlags & k_Unit_UserFlags_UF10_Bit) != 0; }
    bool             GetUserFlagsUF11() const { return (m_UserFlags & k_Unit_UserFlags_UF11_Bit) != 0; }
    bool             GetUserFlagsUF12() const { return (m_UserFlags & k_Unit_UserFlags_UF12_Bit) != 0; }
    bool             GetUserFlagsUF13() const { return (m_UserFlags & k_Unit_UserFlags_UF13_Bit) != 0; }
    bool             GetUserFlagsUF14() const { return (m_UserFlags & k_Unit_UserFlags_UF14_Bit) != 0; }
    bool             GetUserFlagsUF15() const { return (m_UserFlags & k_Unit_UserFlags_UF15_Bit) != 0; }
    bool             GetUserFlagsUF16() const { return (m_UserFlags & k_Unit_UserFlags_UF16_Bit) != 0; }
    bool             GetUserFlagsUF17() const { return (m_UserFlags & k_Unit_UserFlags_UF17_Bit) != 0; }
    bool             GetUserFlagsUF18() const { return (m_UserFlags & k_Unit_UserFlags_UF18_Bit) != 0; }
    bool             GetUserFlagsUF19() const { return (m_UserFlags & k_Unit_UserFlags_UF19_Bit) != 0; }
    bool             GetUserFlagsUF20() const { return (m_UserFlags & k_Unit_UserFlags_UF20_Bit) != 0; }
    bool             GetUserFlagsUF21() const { return (m_UserFlags & k_Unit_UserFlags_UF21_Bit) != 0; }
    bool             GetUserFlagsUF22() const { return (m_UserFlags & k_Unit_UserFlags_UF22_Bit) != 0; }
    bool             GetUserFlagsUF23() const { return (m_UserFlags & k_Unit_UserFlags_UF23_Bit) != 0; }
    bool             GetUserFlagsUF24() const { return (m_UserFlags & k_Unit_UserFlags_UF24_Bit) != 0; }
    bool             GetUserFlagsUF25() const { return (m_UserFlags & k_Unit_UserFlags_UF25_Bit) != 0; }
    bool             GetUserFlagsUF26() const { return (m_UserFlags & k_Unit_UserFlags_UF26_Bit) != 0; }
    bool             GetUserFlagsUF27() const { return (m_UserFlags & k_Unit_UserFlags_UF27_Bit) != 0; }
    bool             GetUserFlagsUF28() const { return (m_UserFlags & k_Unit_UserFlags_UF28_Bit) != 0; }
    bool             GetUserFlagsUF29() const { return (m_UserFlags & k_Unit_UserFlags_UF29_Bit) != 0; }
    bool             GetUserFlagsUF30() const { return (m_UserFlags & k_Unit_UserFlags_UF30_Bit) != 0; }
    bool             GetUserFlagsUF31() const { return (m_UserFlags & k_Unit_UserFlags_UF31_Bit) != 0; }
    sint32           GetDefaultIconIndex() const { return m_DefaultIcon; }
    IconRecord const * GetDefaultIcon() const;
    bool GetNoIndex() const { return (m_flags6 & k_Unit_NoIndex_Bit) != 0; }
    bool HasCheatIndex() const { return (m_flags6 & k_Unit_CheatIndex_Bit) != 0; }
    bool GetCheatIndex(sint32 & value) const
    {
        if (m_flags6 & k_Unit_CheatIndex_Bit)
        {
            value = m_CheatIndexValue;
        }
        return (m_flags6 & k_Unit_CheatIndex_Bit) != 0;
    }
    sint32 GetDescription() const { return m_Description; }
    bool HasAdvice() const { return (m_flags6 & k_Unit_Advice_Bit) != 0; }
    bool GetAdvice(sint32 & value) const
    {
        if (m_flags6 & k_Unit_Advice_Bit)
        {
            value = m_AdviceValue;
        }
        return (m_flags6 & k_Unit_Advice_Bit) != 0;
    }
    sint32 GetCategory() const { return m_Category; }
    bool GetGLHidden() const { return (m_flags6 & k_Unit_GLHidden_Bit) != 0; }
    bool GetCantMove() const { return (m_flags6 & k_Unit_CantMove_Bit) != 0; }
    bool GetCivilian() const { return (m_flags6 & k_Unit_Civilian_Bit) != 0; }
    bool GetInvisibleForGlobeSat() const { return (m_flags6 & k_Unit_InvisibleForGlobeSat_Bit) != 0; }
    bool GetNoBarbarian() const { return (m_flags6 & k_Unit_NoBarbarian_Bit) != 0; }
    bool GetGoodyHutExcluded() const { return (m_flags6 & k_Unit_GoodyHutExcluded_Bit) != 0; }
    bool GetCanHarvest() const { return (m_flags6 & k_Unit_CanHarvest_Bit) != 0; }
    bool GetCantGroup() const { return (m_flags6 & k_Unit_CantGroup_Bit) != 0; }
    bool GetSpawnsBarbarians() const { return (m_flags6 & k_Unit_SpawnsBarbarians_Bit) != 0; }
    bool GetCanSinkInSea() const { return (m_flags6 & k_Unit_CanSinkInSea_Bit) != 0; }
    bool GetLeader() const { return (m_flags6 & k_Unit_Leader_Bit) != 0; }
    bool HasArmyMountedBonus() const { return (m_flags6 & k_Unit_ArmyMountedBonus_Bit) != 0; }
    bool GetArmyMountedBonus(double & value) const
    {
        if (m_flags6 & k_Unit_ArmyMountedBonus_Bit)
        {
            value = m_ArmyMountedBonusValue;
        }
        return (m_flags6 & k_Unit_ArmyMountedBonus_Bit) != 0;
    }
    bool HasArmyAirBonus() const { return (m_flags6 & k_Unit_ArmyAirBonus_Bit) != 0; }
    bool GetArmyAirBonus(double & value) const
    {
        if (m_flags6 & k_Unit_ArmyAirBonus_Bit)
        {
            value = m_ArmyAirBonusValue;
        }
        return (m_flags6 & k_Unit_ArmyAirBonus_Bit) != 0;
    }
    bool HasArmyWoodenShipBonus() const { return (m_flags6 & k_Unit_ArmyWoodenShipBonus_Bit) != 0; }
    bool GetArmyWoodenShipBonus(double & value) const
    {
        if (m_flags6 & k_Unit_ArmyWoodenShipBonus_Bit)
        {
            value = m_ArmyWoodenShipBonusValue;
        }
        return (m_flags6 & k_Unit_ArmyWoodenShipBonus_Bit) != 0;
    }
    bool HasArmyAttackCityBonus() const { return (m_flags7 & k_Unit_ArmyAttackCityBonus_Bit) != 0; }
    bool GetArmyAttackCityBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyAttackCityBonus_Bit)
        {
            value = m_ArmyAttackCityBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyAttackCityBonus_Bit) != 0;
    }
    bool HasArmyAttackBonusSubmarine() const { return (m_flags7 & k_Unit_ArmyAttackBonusSubmarine_Bit) != 0; }
    bool GetArmyAttackBonusSubmarine(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyAttackBonusSubmarine_Bit)
        {
            value = m_ArmyAttackBonusSubmarineValue;
        }
        return (m_flags7 & k_Unit_ArmyAttackBonusSubmarine_Bit) != 0;
    }
    bool HasArmyFootBonus() const { return (m_flags7 & k_Unit_ArmyFootBonus_Bit) != 0; }
    bool GetArmyFootBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyFootBonus_Bit)
        {
            value = m_ArmyFootBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyFootBonus_Bit) != 0;
    }
    bool HasArmyMeleeBonus() const { return (m_flags7 & k_Unit_ArmyMeleeBonus_Bit) != 0; }
    bool GetArmyMeleeBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyMeleeBonus_Bit)
        {
            value = m_ArmyMeleeBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyMeleeBonus_Bit) != 0;
    }
    bool HasArmySiegeBonus() const { return (m_flags7 & k_Unit_ArmySiegeBonus_Bit) != 0; }
    bool GetArmySiegeBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmySiegeBonus_Bit)
        {
            value = m_ArmySiegeBonusValue;
        }
        return (m_flags7 & k_Unit_ArmySiegeBonus_Bit) != 0;
    }
    bool HasArmyWheeledBonus() const { return (m_flags7 & k_Unit_ArmyWheeledBonus_Bit) != 0; }
    bool GetArmyWheeledBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyWheeledBonus_Bit)
        {
            value = m_ArmyWheeledBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyWheeledBonus_Bit) != 0;
    }
    bool HasArmyMechanizedBonus() const { return (m_flags7 & k_Unit_ArmyMechanizedBonus_Bit) != 0; }
    bool GetArmyMechanizedBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyMechanizedBonus_Bit)
        {
            value = m_ArmyMechanizedBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyMechanizedBonus_Bit) != 0;
    }
    bool HasArmyHelicopterBonus() const { return (m_flags7 & k_Unit_ArmyHelicopterBonus_Bit) != 0; }
    bool GetArmyHelicopterBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyHelicopterBonus_Bit)
        {
            value = m_ArmyHelicopterBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyHelicopterBonus_Bit) != 0;
    }
    bool HasArmySpecialForcesBonus() const { return (m_flags7 & k_Unit_ArmySpecialForcesBonus_Bit) != 0; }
    bool GetArmySpecialForcesBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmySpecialForcesBonus_Bit)
        {
            value = m_ArmySpecialForcesBonusValue;
        }
        return (m_flags7 & k_Unit_ArmySpecialForcesBonus_Bit) != 0;
    }
    bool HasArmyCivilianBonus() const { return (m_flags7 & k_Unit_ArmyCivilianBonus_Bit) != 0; }
    bool GetArmyCivilianBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyCivilianBonus_Bit)
        {
            value = m_ArmyCivilianBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyCivilianBonus_Bit) != 0;
    }
    bool HasArmyGuerrillaBonus() const { return (m_flags7 & k_Unit_ArmyGuerrillaBonus_Bit) != 0; }
    bool GetArmyGuerrillaBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyGuerrillaBonus_Bit)
        {
            value = m_ArmyGuerrillaBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyGuerrillaBonus_Bit) != 0;
    }
    bool HasArmyAgainstMountedBonus() const { return (m_flags7 & k_Unit_ArmyAgainstMountedBonus_Bit) != 0; }
    bool GetArmyAgainstMountedBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyAgainstMountedBonus_Bit)
        {
            value = m_ArmyAgainstMountedBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyAgainstMountedBonus_Bit) != 0;
    }
    bool HasArmyAirDefenseBonus() const { return (m_flags7 & k_Unit_ArmyAirDefenseBonus_Bit) != 0; }
    bool GetArmyAirDefenseBonus(double & value) const
    {
        if (m_flags7 & k_Unit_ArmyAirDefenseBonus_Bit)
        {
            value = m_ArmyAirDefenseBonusValue;
        }
        return (m_flags7 & k_Unit_ArmyAirDefenseBonus_Bit) != 0;
    }
    sint32 GetEnergyHunger() const { return m_EnergyHunger; }
    sint32 GetProducesEnergy() const { return m_ProducesEnergy; }
    bool HasHasReligionIcon() const { return (m_flags7 & k_Unit_HasReligionIcon_Bit) != 0; }
    bool GetHasReligionIconIndex(sint32 & index) const
    {
        index = (m_flags7 & k_Unit_HasReligionIcon_Bit) ? m_HasReligionIconValue : -1;
        return (m_flags7 & k_Unit_HasReligionIcon_Bit) != 0;
    }
    bool GetHasReligionIcon(const MapIconRecord * & rec) const;
    const MapIconRecord * GetHasReligionIconPtr() const;
    bool GetHasGovernmentsModified() const { return m_hasGovernmentsModified; }
    sint32 GenericGetNumGovernmentsModified() const { return m_numGovernmentsModified; }
    sint32 GenericGetGovernmentsModifiedIndex(sint32 index) const { return GetGovernmentsModifiedIndex(index); }

}; /* UnitRecord */

struct UnitRecordAccessorInfo
{
    UnitRecord::IntAccessor        m_intAccessor;
    UnitRecord::BoolAccessor       m_boolAccessor;
    UnitRecord::FloatAccessor      m_floatAccessor;
    UnitRecord::BitIntAccessor     m_bitIntAccessor;
    UnitRecord::BitFloatAccessor   m_bitFloatAccessor;
    UnitRecord::IntArrayAccessor   m_intArrayAccessor;
    UnitRecord::FloatArrayAccessor m_floatArrayAccessor;
};

extern UnitRecordAccessorInfo      g_UnitRecord_Accessors[];
extern CTPDatabase<UnitRecord> *   g_theUnitDB;

extern const char * g_Unit_Tokens[];

#endif
