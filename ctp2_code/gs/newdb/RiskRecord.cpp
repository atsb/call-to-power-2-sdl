
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "RiskRecord.h"

#include <algorithm>
#include "BitArray.h"
#include "c3errors.h"
#include "CTPDatabase.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "StrDB.h"


CTPDatabase<RiskRecord> *g_theRiskDB = NULL;

void RiskRecord::Init()
{
    m_HutChanceBarbarian = 0.000000;
    m_HutChanceAdvance = 0.000000;
    m_HutChanceUnit = 0.000000;
    m_HutChanceCity = 0.000000;
    m_HutChanceSettler = 0.000000;
    m_HutChanceGold = 0.000000;
    m_HutMaxBarbarians = 0;
    m_HutMaxAdvancePrerequisites = 0;
    m_HutMaxUnitPrerequisites = 0;
    m_HutMaxGold = 0;
    m_HutMinGold = 0;
    m_BarbarianChance = 0.000000;
    m_BarbarianUnitRankMax = 0;
    m_BarbarianUnitRankMin = 0;
    m_MaxSpontaniousBarbarians = 0;
    m_BarbarianFirstTurn = 0;
    m_BarbarianLastTurn = 0;
    m_BarbarianMinimumDistance = 0;
    //GovMod Specific flag initialization
    m_hasGovernmentsModified = false;
}

void RiskRecord::Serialize(CivArchive &archive)
{
    if(archive.IsStoring()) {
        archive << m_index;
        if(m_name >= 0){
            archive << GetIDText();
        }
        else{
            archive << static_cast<MBCHAR*>(NULL);
        }
        archive << m_HutChanceBarbarian;
        archive << m_HutChanceAdvance;
        archive << m_HutChanceUnit;
        archive << m_HutChanceCity;
        archive << m_HutChanceSettler;
        archive << m_HutChanceGold;
        archive << m_HutMaxBarbarians;
        archive << m_HutMaxAdvancePrerequisites;
        archive << m_HutMaxUnitPrerequisites;
        archive << m_HutMaxGold;
        archive << m_HutMinGold;
        archive << m_BarbarianChance;
        archive << m_BarbarianUnitRankMax;
        archive << m_BarbarianUnitRankMin;
        archive << m_MaxSpontaniousBarbarians;
        archive << m_BarbarianFirstTurn;
        archive << m_BarbarianLastTurn;
        archive << m_BarbarianMinimumDistance;
    } else {
        //GovMod Specific flag initialization
        m_hasGovernmentsModified = false;

        archive >> m_index;
        {
            MBCHAR* tmpStr = NULL;
            archive >> tmpStr;
            g_theStringDB->GetStringID(tmpStr, m_name);
            SetTextName(g_theStringDB->GetNameStr(m_name));
        }
        archive >> m_HutChanceBarbarian;
        archive >> m_HutChanceAdvance;
        archive >> m_HutChanceUnit;
        archive >> m_HutChanceCity;
        archive >> m_HutChanceSettler;
        archive >> m_HutChanceGold;
        archive >> m_HutMaxBarbarians;
        archive >> m_HutMaxAdvancePrerequisites;
        archive >> m_HutMaxUnitPrerequisites;
        archive >> m_HutMaxGold;
        archive >> m_HutMinGold;
        archive >> m_BarbarianChance;
        archive >> m_BarbarianUnitRankMax;
        archive >> m_BarbarianUnitRankMin;
        archive >> m_MaxSpontaniousBarbarians;
        archive >> m_BarbarianFirstTurn;
        archive >> m_BarbarianLastTurn;
        archive >> m_BarbarianMinimumDistance;
    }
}

RiskRecord::~RiskRecord()
{
}

RiskRecord const & RiskRecord::operator = (RiskRecord const & rval)
{
    if (this != &rval)
    {
        m_index = rval.m_index;
        m_hasGovernmentsModified = rval.m_hasGovernmentsModified;

        m_HutChanceBarbarian = rval.m_HutChanceBarbarian;

        m_HutChanceAdvance = rval.m_HutChanceAdvance;

        m_HutChanceUnit = rval.m_HutChanceUnit;

        m_HutChanceCity = rval.m_HutChanceCity;

        m_HutChanceSettler = rval.m_HutChanceSettler;

        m_HutChanceGold = rval.m_HutChanceGold;

        m_HutMaxBarbarians = rval.m_HutMaxBarbarians;

        m_HutMaxAdvancePrerequisites = rval.m_HutMaxAdvancePrerequisites;

        m_HutMaxUnitPrerequisites = rval.m_HutMaxUnitPrerequisites;

        m_HutMaxGold = rval.m_HutMaxGold;

        m_HutMinGold = rval.m_HutMinGold;

        m_BarbarianChance = rval.m_BarbarianChance;

        m_BarbarianUnitRankMax = rval.m_BarbarianUnitRankMax;

        m_BarbarianUnitRankMin = rval.m_BarbarianUnitRankMin;

        m_MaxSpontaniousBarbarians = rval.m_MaxSpontaniousBarbarians;

        m_BarbarianFirstTurn = rval.m_BarbarianFirstTurn;

        m_BarbarianLastTurn = rval.m_BarbarianLastTurn;

        m_BarbarianMinimumDistance = rval.m_BarbarianMinimumDistance;

    }

    return *this;
}

const char *g_Risk_Tokens[] =
{
    "HutChanceBarbarian",
    "HutChanceAdvance",
    "HutChanceUnit",
    "HutChanceCity",
    "HutChanceSettler",
    "HutChanceGold",
    "HutMaxBarbarians",
    "HutMaxAdvancePrerequisites",
    "HutMaxUnitPrerequisites",
    "HutMaxGold",
    "HutMinGold",
    "BarbarianChance",
    "BarbarianUnitRankMax",
    "BarbarianUnitRankMin",
    "MaxSpontaniousBarbarians",
    "BarbarianFirstTurn",
    "BarbarianLastTurn",
    "BarbarianMinimumDistance",
    "BARBARIAN_HUT_CHANCE",
    "ADVANCE_HUT_CHANCE",
    "UNIT_HUT_CHANCE",
    "CITY_HUT_CHANCE",
    "SETTLER_HUT_CHANCE",
    "GOLD_HUT_CHANCE",
    "MAX_HUT_BARBARIANS",
    "MAX_HUT_ADVANCE_PREREQUISITES",
    "MAX_UNIT_PREREQUISITES",
    "MAX_HUT_GOLD",
    "MIN_HUT_GOLD",
    "BARBARIAN_CHANCE",
    "BARBARIAN_RANK_MAX",
    "BARBARIAN_RANK_MIN",
    "MAX_SPONTANEOUS_BARBARIANS",
    "FIRST_BARBARIAN_TURN",
    "LAST_BARBARIAN_TURN",
    "MINIMUM_BARBARIAN_DISTANCE",
};

RiskRecordAccessorInfo g_RiskRecord_Accessors[] =
{
    { NULL, NULL, &RiskRecord::GetHutChanceBarbarian, NULL, NULL, NULL, NULL },
    { NULL, NULL, &RiskRecord::GetHutChanceAdvance, NULL, NULL, NULL, NULL },
    { NULL, NULL, &RiskRecord::GetHutChanceUnit, NULL, NULL, NULL, NULL },
    { NULL, NULL, &RiskRecord::GetHutChanceCity, NULL, NULL, NULL, NULL },
    { NULL, NULL, &RiskRecord::GetHutChanceSettler, NULL, NULL, NULL, NULL },
    { NULL, NULL, &RiskRecord::GetHutChanceGold, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetHutMaxBarbarians, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetHutMaxAdvancePrerequisites, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetHutMaxUnitPrerequisites, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetHutMaxGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetHutMinGold, NULL, NULL, NULL, NULL, NULL, NULL },
    { NULL, NULL, &RiskRecord::GetBarbarianChance, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetBarbarianUnitRankMax, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetBarbarianUnitRankMin, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetMaxSpontaniousBarbarians, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetBarbarianFirstTurn, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetBarbarianLastTurn, NULL, NULL, NULL, NULL, NULL, NULL },
    { &RiskRecord::GetBarbarianMinimumDistance, NULL, NULL, NULL, NULL, NULL, NULL },
};

#define k_Token_Risk_HutChanceBarbarian          ((k_Token_Custom_Base) + 0)
#define k_Token_Risk_HutChanceAdvance            ((k_Token_Custom_Base) + 1)
#define k_Token_Risk_HutChanceUnit               ((k_Token_Custom_Base) + 2)
#define k_Token_Risk_HutChanceCity               ((k_Token_Custom_Base) + 3)
#define k_Token_Risk_HutChanceSettler            ((k_Token_Custom_Base) + 4)
#define k_Token_Risk_HutChanceGold               ((k_Token_Custom_Base) + 5)
#define k_Token_Risk_HutMaxBarbarians            ((k_Token_Custom_Base) + 6)
#define k_Token_Risk_HutMaxAdvancePrerequisites  ((k_Token_Custom_Base) + 7)
#define k_Token_Risk_HutMaxUnitPrerequisites     ((k_Token_Custom_Base) + 8)
#define k_Token_Risk_HutMaxGold                  ((k_Token_Custom_Base) + 9)
#define k_Token_Risk_HutMinGold                  ((k_Token_Custom_Base) + 10)
#define k_Token_Risk_BarbarianChance             ((k_Token_Custom_Base) + 11)
#define k_Token_Risk_BarbarianUnitRankMax        ((k_Token_Custom_Base) + 12)
#define k_Token_Risk_BarbarianUnitRankMin        ((k_Token_Custom_Base) + 13)
#define k_Token_Risk_MaxSpontaniousBarbarians    ((k_Token_Custom_Base) + 14)
#define k_Token_Risk_BarbarianFirstTurn          ((k_Token_Custom_Base) + 15)
#define k_Token_Risk_BarbarianLastTurn           ((k_Token_Custom_Base) + 16)
#define k_Token_Risk_BarbarianMinimumDistance    ((k_Token_Custom_Base) + 17)
#define k_Token_Risk_BARBARIAN_HUT_CHANCE        ((k_Token_Custom_Base) + 18)
#define k_Token_Risk_ADVANCE_HUT_CHANCE          ((k_Token_Custom_Base) + 19)
#define k_Token_Risk_UNIT_HUT_CHANCE             ((k_Token_Custom_Base) + 20)
#define k_Token_Risk_CITY_HUT_CHANCE             ((k_Token_Custom_Base) + 21)
#define k_Token_Risk_SETTLER_HUT_CHANCE          ((k_Token_Custom_Base) + 22)
#define k_Token_Risk_GOLD_HUT_CHANCE             ((k_Token_Custom_Base) + 23)
#define k_Token_Risk_MAX_HUT_BARBARIANS          ((k_Token_Custom_Base) + 24)
#define k_Token_Risk_MAX_HUT_ADVANCE_PREREQUISITES ((k_Token_Custom_Base) + 25)
#define k_Token_Risk_MAX_UNIT_PREREQUISITES      ((k_Token_Custom_Base) + 26)
#define k_Token_Risk_MAX_HUT_GOLD                ((k_Token_Custom_Base) + 27)
#define k_Token_Risk_MIN_HUT_GOLD                ((k_Token_Custom_Base) + 28)
#define k_Token_Risk_BARBARIAN_CHANCE            ((k_Token_Custom_Base) + 29)
#define k_Token_Risk_BARBARIAN_RANK_MAX          ((k_Token_Custom_Base) + 30)
#define k_Token_Risk_BARBARIAN_RANK_MIN          ((k_Token_Custom_Base) + 31)
#define k_Token_Risk_MAX_SPONTANEOUS_BARBARIANS  ((k_Token_Custom_Base) + 32)
#define k_Token_Risk_FIRST_BARBARIAN_TURN        ((k_Token_Custom_Base) + 33)
#define k_Token_Risk_LAST_BARBARIAN_TURN         ((k_Token_Custom_Base) + 34)
#define k_Token_Risk_MINIMUM_BARBARIAN_DISTANCE  ((k_Token_Custom_Base) + 35)
#define k_Token_Risk_Max                         ((k_Token_Custom_Base) + 36)


static BitArray s_ParsedTokens(36);
void RiskRecord::CheckRequiredFields(DBLexer *lex)
{
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutChanceBarbarian - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_BARBARIAN_HUT_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutChanceBarbarian missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutChanceAdvance - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_ADVANCE_HUT_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutChanceAdvance missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutChanceUnit - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_UNIT_HUT_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutChanceUnit missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutChanceCity - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_CITY_HUT_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutChanceCity missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutChanceSettler - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_SETTLER_HUT_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutChanceSettler missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutChanceGold - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_GOLD_HUT_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutChanceGold missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutMaxBarbarians - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_MAX_HUT_BARBARIANS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutMaxBarbarians missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutMaxAdvancePrerequisites - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_MAX_HUT_ADVANCE_PREREQUISITES - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutMaxAdvancePrerequisites missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutMaxUnitPrerequisites - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_MAX_UNIT_PREREQUISITES - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutMaxUnitPrerequisites missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutMaxGold - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_MAX_HUT_GOLD - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutMaxGold missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_HutMinGold - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_MIN_HUT_GOLD - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field HutMinGold missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_BarbarianChance - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_BARBARIAN_CHANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BarbarianChance missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_BarbarianUnitRankMax - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_BARBARIAN_RANK_MAX - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BarbarianUnitRankMax missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_BarbarianUnitRankMin - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_BARBARIAN_RANK_MIN - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BarbarianUnitRankMin missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_MaxSpontaniousBarbarians - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_MAX_SPONTANEOUS_BARBARIANS - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field MaxSpontaniousBarbarians missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_BarbarianFirstTurn - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_FIRST_BARBARIAN_TURN - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BarbarianFirstTurn missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_BarbarianLastTurn - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_LAST_BARBARIAN_TURN - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BarbarianLastTurn missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Risk_BarbarianMinimumDistance - k_Token_Custom_Base)
    && !s_ParsedTokens.Bit(k_Token_Risk_MINIMUM_BARBARIAN_DISTANCE - k_Token_Custom_Base)
    ){
        DBERROR(("Warning: required field BarbarianMinimumDistance missing"));
    }
}

sint32 RiskRecord::Parse(DBLexer *lex, sint32 numRecords)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Risk_Tokens, k_Token_Risk_Max);
    tok = lex->GetToken();
    if(tok == k_Token_Int) {
        tok = lex->GetToken(); // Accept number to make new db compatible with the old database format
    }
    if(tok != k_Token_Name) {
        char newName[256];
        sprintf(newName, "RISK_%i", numRecords);
        if(!g_theStringDB->GetStringID(newName, m_name)) {
            g_theStringDB->InsertStr(newName, newName);
            if(!g_theStringDB->GetStringID(newName, m_name))
                SetTextName(newName);
        }
    }
    else{
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
            g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
            if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
                SetTextName(lex->GetTokenText());
        }
        tok = lex->GetToken();
    }


    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Risk_Max) {
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Risk_HutChanceBarbarian:
            case k_Token_Risk_BARBARIAN_HUT_CHANCE:
                if(!lex->GetFloatAssignment(m_HutChanceBarbarian)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutChanceAdvance:
            case k_Token_Risk_ADVANCE_HUT_CHANCE:
                if(!lex->GetFloatAssignment(m_HutChanceAdvance)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutChanceUnit:
            case k_Token_Risk_UNIT_HUT_CHANCE:
                if(!lex->GetFloatAssignment(m_HutChanceUnit)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutChanceCity:
            case k_Token_Risk_CITY_HUT_CHANCE:
                if(!lex->GetFloatAssignment(m_HutChanceCity)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutChanceSettler:
            case k_Token_Risk_SETTLER_HUT_CHANCE:
                if(!lex->GetFloatAssignment(m_HutChanceSettler)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutChanceGold:
            case k_Token_Risk_GOLD_HUT_CHANCE:
                if(!lex->GetFloatAssignment(m_HutChanceGold)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutMaxBarbarians:
            case k_Token_Risk_MAX_HUT_BARBARIANS:
                if(!lex->GetIntAssignment(m_HutMaxBarbarians)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutMaxAdvancePrerequisites:
            case k_Token_Risk_MAX_HUT_ADVANCE_PREREQUISITES:
                if(!lex->GetIntAssignment(m_HutMaxAdvancePrerequisites)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutMaxUnitPrerequisites:
            case k_Token_Risk_MAX_UNIT_PREREQUISITES:
                if(!lex->GetIntAssignment(m_HutMaxUnitPrerequisites)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutMaxGold:
            case k_Token_Risk_MAX_HUT_GOLD:
                if(!lex->GetIntAssignment(m_HutMaxGold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_HutMinGold:
            case k_Token_Risk_MIN_HUT_GOLD:
                if(!lex->GetIntAssignment(m_HutMinGold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_BarbarianChance:
            case k_Token_Risk_BARBARIAN_CHANCE:
                if(!lex->GetFloatAssignment(m_BarbarianChance)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_BarbarianUnitRankMax:
            case k_Token_Risk_BARBARIAN_RANK_MAX:
                if(!lex->GetIntAssignment(m_BarbarianUnitRankMax)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_BarbarianUnitRankMin:
            case k_Token_Risk_BARBARIAN_RANK_MIN:
                if(!lex->GetIntAssignment(m_BarbarianUnitRankMin)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_MaxSpontaniousBarbarians:
            case k_Token_Risk_MAX_SPONTANEOUS_BARBARIANS:
                if(!lex->GetIntAssignment(m_MaxSpontaniousBarbarians)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_BarbarianFirstTurn:
            case k_Token_Risk_FIRST_BARBARIAN_TURN:
                if(!lex->GetIntAssignment(m_BarbarianFirstTurn)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_BarbarianLastTurn:
            case k_Token_Risk_LAST_BARBARIAN_TURN:
                if(!lex->GetIntAssignment(m_BarbarianLastTurn)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Risk_BarbarianMinimumDistance:
            case k_Token_Risk_MINIMUM_BARBARIAN_DISTANCE:
                if(!lex->GetIntAssignment(m_BarbarianMinimumDistance)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                if(!lex->GetFloat(m_HutChanceBarbarian)) {
                    DBERROR(("Unknown token"));
                    done = true; break;
                }
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void RiskRecord::ResolveDBReferences()
{
}

void RiskRecord::Merge(const RiskRecord & rval){
}

