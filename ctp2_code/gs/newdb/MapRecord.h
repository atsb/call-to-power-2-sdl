
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */

#if defined(HAVE_PRAGMA_ONCE)
#pragma once
#endif

#ifndef MAP_RECORD_H__
#define MAP_RECORD_H__

class MapRecord;

#include "CTPDatabase.h"
#include "CTPRecord.h"
class CivArchive;

#define k_Num_MapRecord_Tokens 4


class MapRecord : public CTPRecord
{
public:
    typedef sint32 (MapRecord::*IntAccessor)() const;
    typedef bool   (MapRecord::*BoolAccessor)() const;
    typedef double (MapRecord::*FloatAccessor)() const ;
    typedef bool   (MapRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool   (MapRecord::*BitFloatAccessor)(double &val) const;
    typedef sint32 (MapRecord::*IntArrayAccessor)(sint32 index) const;
    typedef double (MapRecord::*FloatArrayAccessor)(sint32 index) const;

    class Settings {
    private:
        double            m_NumContinents;
        double            m_MinWidth;
        double            m_MinHeight;
        double            m_MaxWidth;
        double            m_MaxHeight;
        double            m_BumpSize;
        double            m_MinSubcontinents;
        double            m_MaxSubcontinents;
        double            m_SubcontinentSize;
        double            m_SubcontinentHeight;
        double            m_BorderSize;
        double            m_FaultLines;
        double            m_FaultLength;
        double            m_NSBorderSize;

    public:
        Settings();
        Settings(CivArchive & archive){ Serialize(archive); };
        ~Settings();
        Settings const & operator = (Settings const & rval);
        bool operator == (Settings const & rval) {
          return false;
        }

        void Serialize(CivArchive &archive);
        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        sint32 ParseFullySequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, Settings **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, Settings *array, sint32 *numElements, sint32 maxSize);
        static sint32 ParseInArraySequential(DBLexer *lex, Settings **array, sint32 *numElements);
        static sint32 ParseInArraySequential(DBLexer *lex, Settings *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();

        double GetNumContinents() const { return m_NumContinents; }
        double GetMinWidth() const { return m_MinWidth; }
        double GetMinHeight() const { return m_MinHeight; }
        double GetMaxWidth() const { return m_MaxWidth; }
        double GetMaxHeight() const { return m_MaxHeight; }
        double GetBumpSize() const { return m_BumpSize; }
        double GetMinSubcontinents() const { return m_MinSubcontinents; }
        double GetMaxSubcontinents() const { return m_MaxSubcontinents; }
        double GetSubcontinentSize() const { return m_SubcontinentSize; }
        double GetSubcontinentHeight() const { return m_SubcontinentHeight; }
        double GetBorderSize() const { return m_BorderSize; }
        double GetFaultLines() const { return m_FaultLines; }
        double GetFaultLength() const { return m_FaultLength; }
        double GetNSBorderSize() const { return m_NSBorderSize; }

    }; /* class Settings */

private:
    Settings        * m_Settings;
    sint32            m_numSettings;
    sint32            m_Width;
    sint32            m_Height;
    double            m_CityLimitModifyer;
    bool m_hasGovernmentsModified; // GovMod specific flag

public:
    MapRecord() { Init(); };
    MapRecord(CivArchive &archive) { Serialize(archive); };
    MapRecord(MapRecord const & rval) { Init(); *this = rval; }
    ~MapRecord();
    MapRecord const & operator = (MapRecord const & rval);

    void Init();
    void Serialize(CivArchive &archive);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex, sint32 numRecords);

    void ResolveDBReferences();
    void Merge(const MapRecord & rval);

    const Settings * GetSettings(sint32 index) const;
    sint32 GetNumSettings() const { return m_numSettings;}
    sint32 GetWidth() const { return m_Width; }
    sint32 GetHeight() const { return m_Height; }
    double GetCityLimitModifyer() const { return m_CityLimitModifyer; }
    bool GetHasGovernmentsModified() const { return m_hasGovernmentsModified; }
    sint32 GenericGetNumGovernmentsModified() const { return 0; }
    sint32 GenericGetGovernmentsModifiedIndex(sint32 index) const { return -1; }

}; /* MapRecord */

struct MapRecordAccessorInfo
{
    MapRecord::IntAccessor        m_intAccessor;
    MapRecord::BoolAccessor       m_boolAccessor;
    MapRecord::FloatAccessor      m_floatAccessor;
    MapRecord::BitIntAccessor     m_bitIntAccessor;
    MapRecord::BitFloatAccessor   m_bitFloatAccessor;
    MapRecord::IntArrayAccessor   m_intArrayAccessor;
    MapRecord::FloatArrayAccessor m_floatArrayAccessor;
};

extern MapRecordAccessorInfo      g_MapRecord_Accessors[];
extern CTPDatabase<MapRecord> *   g_theMapDB;

extern const char * g_Map_Tokens[];

#endif
